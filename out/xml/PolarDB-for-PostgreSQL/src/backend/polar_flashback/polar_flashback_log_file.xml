<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/polar_flashback/polar_flashback_log_file.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_flashback_log_file.c
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2021, Alibaba Group Holding limited
 *
 * IDENTIFICATION
 *    src/backend/polar_flashback/polar_flashback_log_file.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOG_TMP_FNAME</name></cpp:macro> <cpp:value>"flogtmp."</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>flog_dir_full_path</name><parameter_list>(<parameter><type><name>ctl</name></type></parameter>, <parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>polar_make_file_path_level2(path, polar_get_flog_dir(ctl))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>flog_file_full_path</name><parameter_list>(<parameter><type><name>ctl</name></type></parameter>, <parameter><type><name>path</name></type></parameter>, <parameter><type><name>file_name</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>polar_make_file_path_level3(path, polar_get_flog_dir(ctl), file_name)</cpp:value></cpp:define>

<comment type="block">/* GUCs */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_flashback_log_keep_segments</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_file_exist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Get flashback log file path. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flog_file_path_from_seg</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>seg_no</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segsz_bytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>seg_file_name</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>seg_file_name</name></expr></argument>, <argument><expr><name>seg_no</name></expr></argument>, <argument><expr><name>segsz_bytes</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_make_file_path_level3</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>seg_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Install a new flashback log file as a current or future segment.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>install_flog_seg</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>segno</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tmppath</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>find_free</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>max_segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>lock</name> <init>= <expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>init_lock</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>flog_file_path_from_seg</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>polar_get_flog_dir</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>segno</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We want to be sure that only one process does this at a time.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>find_free</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Force installation: get rid of any pre-existing segment file */</comment>
		<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Find a free slot to put it in */</comment>
		<while>while <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>segno</name><operator>)</operator> <operator>&gt;=</operator> <name>max_segno</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Failed to find a free slot within specified range */</comment>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>segno</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>flog_file_path_from_seg</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>polar_get_flog_dir</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>segno</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Perform the rename using link if available, paranoidly trying to avoid
	 * overwriting an existing file (there shouldn't be one).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>durable_link_or_rename</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* durable_link_or_rename already emitted log message */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recycle or remove a log file that's no longer needed.
 *
 * endptr is current (or recent) end of flashback log. It is used to determine
 * whether we want to recycle rather than delete no-longer-wanted log files.
 * If lastredoptr is not known, pass invalid, and the function will recycle,
 * somewhat arbitrarily, 10 future segments.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_old_flog_file</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>segname</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>endptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>  <name>endlogSegNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>  <name>recycleSegNo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize info about where to try to recycle to.
	 */</comment>
	<expr_stmt><expr><name>endlogSegNo</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: Just reuse polar_flashback_log_keep_segments segments */</comment>
	<expr_stmt><expr><name>recycleSegNo</name> <operator>=</operator> <name>endlogSegNo</name> <operator>+</operator> <name>polar_flashback_log_keep_segments</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>flog_file_full_path</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before deleting the file, see if it can be recycled as a future log
	 * segment. Only recycle normal files.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>endlogSegNo</name> <operator>&lt;=</operator> <name>recycleSegNo</name> <operator>&amp;&amp;</operator>
			<call><name>polar_lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>install_flog_seg</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endlogSegNo</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>recycleSegNo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* POLAR: force log */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recycled flashback log file \"%s\""</literal></expr></argument>,
						<argument><expr><name>segname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>endlogSegNo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No need for any more future segments... */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing flashback log file \"%s\""</literal></expr></argument>,
						<argument><expr><name>segname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Message already logged by durable_unlink() */</comment>
		<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>keep_flog_seg</name><parameter_list>(<parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* compute limit for polar_flashback_log_keep_segments */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_flashback_log_keep_segments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* avoid underflow, don't go below 1 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>segno</name> <operator>&lt;=</operator> <name>polar_flashback_log_keep_segments</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>segno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>segno</name> <operator>=</operator> <operator>*</operator><name>segno</name> <operator>-</operator> <name>polar_flashback_log_keep_segments</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recycle or remove all log files older or equal to passed segno.
 *
 * endptr is current (or recent) end of flashback log used to determine
 * whether we want to recycle rather than delete no-longer-wanted log files.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>truncate_flog_files</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>endptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>        <modifier>*</modifier></type><name>xldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>xlde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>lastoff</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>polar_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>flog_dir_full_path</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>polar_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct a filename of the last segment to be kept. The timeline ID
	 * doesn't matter, we ignore that in the comparison. (During recovery,
	 * ThisTimeLineID isn't set, so we can't use that.)
	 */</comment>
	<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>lastoff</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"attempting to remove flashback log segments older than log file %s"</literal></expr></argument>,
		 <argument><expr><name>lastoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>xldir</name> <operator>=</operator> <call><name>polar_allocate_dir</name><argument_list>(<argument><expr><name>polar_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>xlde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>, <argument><expr><name>polar_path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore files that are not flashback log segments */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_flashback_log_file</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>lastoff</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>remove_old_flog_file</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name><name>xlde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>xldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Truncate the flashback log files before the checkpoint ptr.
 */</comment>
<function><type><name>void</name></type>
<name>polar_truncate_flog_before</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>seg_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>recptr</name></decl>;</decl_stmt>

	<comment type="block">/* Get the current flashback log write result (end of flashback log in disk) */</comment>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>polar_get_flog_write_result</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seg_no</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There is only one file, just return */</comment>
	<if_stmt><if>if <condition>(<expr><name>seg_no</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>keep_flog_seg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seg_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>seg_no</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>truncate_flog_files</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>seg_no</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read 'count' bytes from flashback log into 'buf',
 * starting at location 'startptr'.
 *
 * Will open, and keep open, one segment stored in the static file
 * descriptor 'sendFile'. This means if polar_flashback_log_read is
 * used once, there will always be one descriptor left open until
 * the process ends, but never more than one.
 *
 */</comment>
<function><type><name>void</name></type>
<name>polar_flog_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segsize</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>startptr</name></decl></parameter>,
				<parameter><decl><type><name>Size</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>        <name>nbytes</name></decl>;</decl_stmt>
	<comment type="block">/* state maintained across calls */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>  <name>open_file</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>open_segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segsize</name> <operator>==</operator> <name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recptr</name> <operator>=</operator> <name>startptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>startoff</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>segbytes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>readbytes</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>startoff</name> <operator>=</operator> <call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do we need to switch to a different xlog segment? */</comment>
		<if_stmt><if>if <condition>(<expr><name>open_file</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>ptr_in_flog_seg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>open_segno</name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>open_file</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>open_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>open_segno</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>recptr</name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>flog_file_path_from_seg</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>open_segno</name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>open_file</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>open_file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*no cover begin*/</comment>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested flashback log segment %s has already been removed"</literal></expr></argument>,
									<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/*no cover end*/</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* How many bytes are within this segment? */</comment>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;</operator> <operator>(</operator><name>segsize</name> <operator>-</operator> <name>startoff</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>segsize</name> <operator>-</operator> <name>startoff</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>segbytes</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>readbytes</name> <operator>=</operator> <call><name>polar_pread</name><argument_list>(<argument><expr><name>open_file</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>segbytes</name></expr></argument>, <argument><expr><name>startoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>readbytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>         <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>flog_file_path_from_seg</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>open_segno</name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
			<comment type="block">/*no cover line*/</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from log segment %s, offset %u, length %lu: %m"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>, <argument><expr><name>startoff</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>segbytes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update state for read */</comment>
		<expr_stmt><expr><name>recptr</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>-=</operator> <name>readbytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>readbytes</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Converts a "usable byte position" to polar_flog_rec_ptr. A usable byte position
 * is the position starting from the beginning of flashback log, excluding all flashback log
 * page headers.
 */</comment>
<function><type><name>polar_flog_rec_ptr</name></type>
<name>polar_flog_pos2ptr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bytepos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>fullsegs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>fullpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>bytesleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>seg_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fullsegs</name> <operator>=</operator> <name>bytepos</name> <operator>/</operator> <name>USABLE_BYTES_IN_SEG</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytesleft</name> <operator>=</operator> <name>bytepos</name> <operator>%</operator> <name>USABLE_BYTES_IN_SEG</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>bytesleft</name> <operator>&lt;</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fits on first page of segment */</comment>
		<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <name>bytesleft</name> <operator>+</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* account for the first page on segment with long header */</comment>
		<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesleft</name> <operator>-=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>fullpages</name> <operator>=</operator> <name>bytesleft</name> <operator>/</operator> <name>USABLE_BYTES_IN_PAGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesleft</name> <operator>=</operator> <name>bytesleft</name> <operator>%</operator> <name>USABLE_BYTES_IN_PAGE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>seg_offset</name> <operator>+=</operator> <name>fullpages</name> <operator>*</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>+</operator> <name>bytesleft</name> <operator>+</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>flog_seg_offset_to_ptr</name><argument_list>(<argument><expr><name>fullsegs</name></expr></argument>, <argument><expr><name>seg_offset</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like polar_flog_pos2ptr, but if the position is at a page boundary,
 * returns a pointer to the beginning of the page (ie. before page header),
 * not to where the first flashbck log record on that page would go to. This is used
 * when converting a pointer to the end of a record.
 */</comment>
<function><type><name>polar_flog_rec_ptr</name></type>
<name>polar_flog_pos2endptr</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>bytepos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>fullsegs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>fullpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>bytesleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>seg_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fullsegs</name> <operator>=</operator> <name>bytepos</name> <operator>/</operator> <name>USABLE_BYTES_IN_SEG</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytesleft</name> <operator>=</operator> <name>bytepos</name> <operator>%</operator> <name>USABLE_BYTES_IN_SEG</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>bytesleft</name> <operator>&lt;</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fits on first page of segment */</comment>
		<if_stmt><if>if <condition>(<expr><name>bytesleft</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <name>bytesleft</name> <operator>+</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* account for the first page on segment with long header */</comment>
		<expr_stmt><expr><name>seg_offset</name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesleft</name> <operator>-=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>fullpages</name> <operator>=</operator> <name>bytesleft</name> <operator>/</operator> <name>USABLE_BYTES_IN_PAGE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesleft</name> <operator>=</operator> <name>bytesleft</name> <operator>%</operator> <name>USABLE_BYTES_IN_PAGE</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>bytesleft</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>seg_offset</name> <operator>+=</operator> <name>fullpages</name> <operator>*</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>+</operator> <name>bytesleft</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>seg_offset</name> <operator>+=</operator> <name>fullpages</name> <operator>*</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>+</operator> <name>bytesleft</name> <operator>+</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>flog_seg_offset_to_ptr</name><argument_list>(<argument><expr><name>fullsegs</name></expr></argument>, <argument><expr><name>seg_offset</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an flashback log ptr to a "usable byte position".
 */</comment>
<function><type><name>uint64</name></type>
<name>polar_flog_ptr2pos</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>fullsegs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>fullpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fullsegs</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fullpages</name> <operator>=</operator> <operator>(</operator><call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fullpages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>fullsegs</name> <operator>*</operator> <name>USABLE_BYTES_IN_SEG</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <name>FLOG_LONG_PHD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>offset</name> <operator>-</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>fullsegs</name> <operator>*</operator> <name>USABLE_BYTES_IN_SEG</name> <operator>+</operator>
				 <operator>(</operator><name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>FLOG_LONG_PHD_SIZE</name><operator>)</operator> <operator>+</operator> <comment type="block">/* account for first page */</comment>
				 <operator>(</operator><name>fullpages</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>USABLE_BYTES_IN_PAGE</name></expr>;</expr_stmt>    <comment type="block">/* full pages */</comment>

		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>offset</name> <operator>-</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read flashback log control file and return false when there is
 * no control file data. otherwise, return true.
 *
 * NB: We don't mark the control file non-exist a error but waring and return
 * false.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_read_flog_ctl_file</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>flog_ctl_file_data_t</name> <modifier>*</modifier></type><name>ctl_file_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>ctl_file_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>read_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>   <name>crc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>flog_file_full_path</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>ctl_file_path</name></expr></argument>, <argument><expr><name>FLOG_CTL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The control file may be non-exist */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_file_exist</name><argument_list>(<argument><expr><name>ctl_file_path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Can't find %s"</literal></expr></argument>, <argument><expr><name>ctl_file_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>ctl_file_path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>ctl_file_path</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Read data */</comment>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_CTL_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>read_len</name> <operator>=</operator> <call><name>polar_read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ctl_file_data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_ctl_file_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>read_len</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>flog_ctl_file_data_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>ctl_file_path</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>ctl_file_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Verify CRC */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ctl_file_data</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>flog_ctl_file_data_t</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EQ_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name><name>ctl_file_data</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"calculated CRC checksum does not match value stored in file \"%s\""</literal></expr></argument>,
						<argument><expr><name>ctl_file_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: write flashback log control file by checkpoint.
 * Caller must hold the ctl_file_lock.
 */</comment>
<function><type><name>void</name></type>
<name>polar_write_flog_ctl_file</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_ctl_file_data_t</name></type> <name>flashback_log_ctl_file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>            <name><name>ctl_file_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>             <name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>flashback_log_ctl_file</name><operator>.</operator><name>version_no</name></name> <operator>=</operator> <name>FLOG_CTL_FILE_VERSION</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>buf_state</name></name> <operator>==</operator> <name>FLOG_BUF_SHUTDOWNED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>flashback_log_ctl_file</name><operator>.</operator><name>version_no</name></name> <operator>|=</operator> <name>FLOG_SHUTDOWNED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name></name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>fbpoint_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>flashback_log_ctl_file</name><operator>.</operator><name>max_seg_no</name></name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>max_seg_no</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>flashback_log_ctl_file</name><operator>.</operator><name>tli</name></name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>tli</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name><name>flashback_log_ctl_file</name><operator>.</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>flashback_log_ctl_file</name><operator>.</operator><name>crc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flashback_log_ctl_file</name></expr></argument>,
				<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>flog_ctl_file_data_t</name></expr></argument>, <argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>flashback_log_ctl_file</name><operator>.</operator><name>crc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>flog_file_full_path</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>ctl_file_path</name></expr></argument>, <argument><expr><name>FLOG_CTL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>ctl_file_path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>ctl_file_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_CTL_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flashback_log_ctl_file</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_ctl_file_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>flog_ctl_file_data_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>ctl_file_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_CTL_FILE_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not sync file \"%s\": %m"</literal></expr></argument>,
						 <argument><expr><name>ctl_file_path</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>ctl_file_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_flashback_log_debug</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>ckpttime_str</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>time_t</name></type>		<name>time_tmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strftime_fmt</name> <init>= <expr><literal type="string">"%c"</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>time_tmp</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator> <name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_time</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>ckpttime_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ckpttime_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>strftime_fmt</name></expr></argument>,
				 <argument><expr><call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time_tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The flashback log control info now is: "</literal>
			 <literal type="string">"next flashback log point in the last flashback point begining: %X/%X, "</literal>
			 <literal type="string">"next flashback log point in the last flashback point end: %X/%X, "</literal>
			 <literal type="string">"previous flashback log point of the last flashback point end: %X/%X, "</literal>
			 <literal type="string">"max segment no: %lu, "</literal>
			 <literal type="string">"current flashback point WAL lsn: %X/%X, "</literal>
			 <literal type="string">"previous flashback point WAL lsn: %X/%X, "</literal>
			 <literal type="string">"current flashback point time: %s"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>flog_start_ptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>flog_start_ptr</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr_prev</name></name></expr></argument>,
			 <argument><expr><name><name>flashback_log_ctl_file</name><operator>.</operator><name>max_seg_no</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>prior_fbpoint_lsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>flashback_log_ctl_file</name><operator>.</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>prior_fbpoint_lsn</name></name></expr></argument>,
			 <argument><expr><name>ckpttime_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: update the flashback log checkpoint information and write the flashback log
 * control file to disk.
 *
 * This is only called by checkpointer process.
 */</comment>
<function><type><name>void</name></type>
<name>polar_flush_fbpoint_info</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>,
						  <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>flashback_log_ptr_ckp_start</name></decl></parameter>,
						  <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>flashback_log_ptr_ckp_end</name></decl></parameter>,
						  <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>flashback_log_ptr_ckp_end_prev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_start_ptr</name></name> <operator>=</operator> <name>flashback_log_ptr_ckp_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr</name></name> <operator>=</operator> <name>flashback_log_ptr_ckp_end</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr_prev</name></name> <operator>=</operator> <name>flashback_log_ptr_ckp_end_prev</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name></name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>wal_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_write_flog_ctl_file</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_flush_flog_max_seg_no</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>seg_no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>max_seg_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_seg_no</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>max_seg_no</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>max_seg_no</name> <operator>==</operator> <name>POLAR_INVALID_FLOG_SEGNO</name>
			<operator>||</operator> <name>max_seg_no</name> <operator>&lt;</operator> <name>seg_no</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>max_seg_no</name></name> <operator>=</operator> <name>seg_no</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_write_flog_ctl_file</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR: Validate the flashback log dir */</comment>
<function><type><name>void</name></type>
<name>polar_validate_flog_dir</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>flog_dir_full_path</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_validate_dir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Open a pre-existing logfile segment for writing.
 */</comment>
<function><type><name>int</name></type>
<name>polar_flog_file_open</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>segno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>flog_file_path_from_seg</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open flashback log file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Create a new flashback log file segment, or open a pre-existing one.
 *
 * logsegno: identify segment to be created/opened.
 *
 * *use_existent: if true, OK to use a pre-existing file (else, any
 * pre-existing file will be deleted).  On return, true if a pre-existing
 * file was used.
 *
 * Returns FD of opened file.
 *
 * Note: errors here are ERROR not PANIC because we might or might not be
 * inside a critical section (eg, during checkpoint there is no reason to
 * take down the system on failure).  They will promote to PANIC if we are
 * in a critical section.
 */</comment>
<function><type><name>int</name></type>
<name>polar_flog_file_init</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>logsegno</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>use_existent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>tmppath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>  <name>installed_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>  <name>max_segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>tmpfile_name</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>flog_file_path_from_seg</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>polar_get_flog_dir</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>logsegno</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to use existent file (polar worker may have created it already)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>use_existent</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*no cover begin*/</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>fd</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize an empty (all zeroes) segment.  NOTE: it is possible that
	 * another process is doing the same thing.  If so, we will end up
	 * pre-creating an extra log segment.  That seems OK, and better than
	 * holding the lock throughout this lengthy process.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"creating and filling new flashback log file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpfile_name</name></expr></argument>, <argument><expr><name>FLOG_MAX_FNAME_LEN</name></expr></argument>, <argument><expr><name>FLOG_TMP_FNAME</name> <literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>flog_file_full_path</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>tmpfile_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Zero-fill the file.  We have to do this the hard way to ensure that all
	 * the file space has really been allocated --- on platforms that allow
	 * "holes" in files, just seeking to the end doesn't allocate intermediate
	 * space.  This way, we know that we have all the space and (after the
	 * fsync below) that all the indirect blocks are down on disk.  Therefore,
	 * fdatasync(2) or O_DSYNC will be sufficient to sync future writes to the
	 * log file.
	 */</comment>

	<expr_stmt><expr><call><name>polar_fill_segment_file_zero</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>,
								 <argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_INIT_WRITE</name></expr></argument>, <argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_INIT_SYNC</name></expr></argument>, <argument><expr><literal type="string">"flashback log"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now move the segment into place with its final name.
	 *
	 * If caller didn't want to use a pre-existing file, get rid of any
	 * pre-existing file.  Otherwise, cope with possibility that someone else
	 * has created the file while we were filling ours: if so, use ours to
	 * pre-create a future log segment.
	 */</comment>
	<expr_stmt><expr><name>installed_segno</name> <operator>=</operator> <name>logsegno</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>max_segno</name> <operator>=</operator> <name>logsegno</name> <operator>+</operator> <name>polar_flashback_log_keep_segments</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>install_flog_seg</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>installed_segno</name></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>,
						  <argument><expr><operator>*</operator><name>use_existent</name></expr></argument>, <argument><expr><name>max_segno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No need for any more future segments, or polar_install_flashback_log_seg()
		 * failed to rename the file into place. If the rename failed, opening
		 * the file below will fail.
		 */</comment>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Set flag to tell caller there was no existent file */</comment>
	<expr_stmt><expr><operator>*</operator><name>use_existent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Now open original target segment (might not be file I just made) */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_flashback_log_debug</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"done creating and filling new flashback log file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Preallocate flashback log files beyond last endpoint.
 */</comment>
<function><type><name>void</name></type>
<name>polar_prealloc_flog_files</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>request_ptr</name> <init>= <expr><call><name>polar_get_flog_write_request</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>   <name>_log_seg_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>lf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>use_existent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>_log_seg_no</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>request_ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>num</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>use_existent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>lf</name> <operator>=</operator> <call><name>polar_flog_file_init</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>_log_seg_no</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_existent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>lf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>_log_seg_no</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* POLAR: Check the flashback log of the segment no exists */</comment>
<function><type><name>bool</name></type>
<name>polar_is_flog_file_exist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>segno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>segno</name> <operator>=</operator> <call><name>flog_ptr_to_seg</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>flog_file_path_from_seg</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_file_exist</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*no cover begin*/</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The flashback log file %s is not found"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
	<comment type="block">/*no cover end*/</comment>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_flog_clean_dir_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>dir_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>rmtree</name><argument_list>(<argument><expr><name>dir_path</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Remove the directory %s while the polar_enable_flashback_log is off."</literal></expr></argument>, <argument><expr><name>dir_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR: Remove all the flashback log files and keep the flashback log dir. */</comment>
<function><type><name>void</name></type>
<name>polar_flog_remove_all</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>flog_dir_full_path</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_flog_clean_dir_internal</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR: Write a new line contain flashback log switch pointer info to the history file */</comment>
<function><type><name>void</name></type>
<name>polar_write_flog_history_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>TimeLineID</name></type> <name>tli</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>switch_ptr</name></decl></parameter>,
							  <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>next_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_INFO_LEN</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>tmp_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>tmp_fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>ptr_info</name><index>[<expr><name>MAX_INFO_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>buffer</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_make_file_path_level3</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>FLOG_HISTORY_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_make_file_path_level3</name><argument_list>(<argument><expr><name>tmp_path</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>FLOG_TMP_HISTORY_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>tmp_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create new tmp history file */</comment>
	<expr_stmt><expr><name>tmp_fd</name> <operator>=</operator> <call><name>polar_open_transient_file</name><argument_list>(<argument><expr><name>tmp_path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tmp_fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmp_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_file_exist</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/*no cover line*/</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_HISTORY_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>polar_read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_TIMELINE_HISTORY_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>polar_write</name><argument_list>(<argument><expr><name>tmp_fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nbytes</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>         <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If we fail to make the file, delete it to release disk
				 * space
				 */</comment>
				<expr_stmt><expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>tmp_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * if write didn't set errno, assume problem is no disk space
				 */</comment>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>tmp_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>ptr_info</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ptr_info</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"%s%u\t%08X/%08X\t%08X/%08X\n"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>found</name></expr> ?</condition><then> <expr><literal type="string">"\n"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>tli</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>switch_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>switch_ptr</name><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>next_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>next_ptr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ptr_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_HISTORY_FILE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_write</name><argument_list>(<argument><expr><name>tmp_fd</name></expr></argument>, <argument><expr><name>ptr_info</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nbytes</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>tmp_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_close</name><argument_list>(<argument><expr><name>tmp_fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * As the rename is atomic operation, if any problem occurs after this
	 * at worst it can lose the new switch ptr and next ptr.
	 */</comment>
	<expr_stmt><expr><call><name>polar_durable_rename</name><argument_list>(<argument><expr><name>tmp_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Try to read a flashback log history file.
 * Return the list of switch ptr flog_history_entry.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>polar_read_flog_history_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>fline</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>switch_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>last_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>next_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>history_file_fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_make_file_path_level3</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>FLOG_HISTORY_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_file_exist</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>history_file_fd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>history_file_fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_HISTORY_FILE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>polar_read_line</name><argument_list>(<argument><expr><name>history_file_fd</name></expr></argument>, <argument><expr><name>fline</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fline</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>switchpoint_hi</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>switchpoint_lo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>nextpoint_hi</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>      <name>nextpoint_lo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimeLineID</name></type>  <name>tli</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>nfields</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>flog_history_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<comment type="block">/* skip leading whitespace and check for # comment */</comment>
		<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>fline</name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>nfields</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>fline</name></expr></argument>, <argument><expr><literal type="string">"%u\t%08X/%08X\t%08X/%08X"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tli</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>switchpoint_hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>switchpoint_lo</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>nextpoint_hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextpoint_lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <name>HISTORY_FILE_FIELDS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*no cover line*/</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"syntax error in flashback log history file: %s"</literal></expr></argument>, <argument><expr><name>fline</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Expected a flashback log switch point and next point location."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>switch_ptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>polar_flog_rec_ptr</name><operator>)</operator><operator>(</operator><name>switchpoint_hi</name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator>
					 <operator>(</operator><name>polar_flog_rec_ptr</name><operator>)</operator> <name>switchpoint_lo</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>next_ptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>polar_flog_rec_ptr</name><operator>)</operator><operator>(</operator><name>nextpoint_hi</name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator>
				   <operator>(</operator><name>polar_flog_rec_ptr</name><operator>)</operator> <name>nextpoint_lo</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FLOG_REC_PTR_IS_INVAILD</name><argument_list>(<argument><expr><name>next_ptr</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<name>switch_ptr</name> <operator>&gt;</operator> <name>next_ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/*no cover line*/</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid data in flashback log history file: %s"</literal></expr></argument>, <argument><expr><name>fline</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"switch point and next point must be valid and next point"</literal>
									<literal type="string">" is larger than or equal to switch point."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>last_ptr</name> <operator>&amp;&amp;</operator> <name>last_ptr</name> <operator>&gt;</operator> <name>switch_ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/*no cover line*/</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid data in flashback log history file: %s"</literal></expr></argument>, <argument><expr><name>fline</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"switch point location must be in increasing sequence."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>flog_history_entry</name> <operator>*</operator><operator>)</operator> <call><name>polar_palloc_in_crit</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_history_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tli</name></name> <operator>=</operator> <name>tli</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>switch_ptr</name></name> <operator>=</operator> <name>switch_ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next_ptr</name></name> <operator>=</operator> <name>next_ptr</name></expr>;</expr_stmt>
		<comment type="block">/* Build list with newest item first */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>last_ptr</name> <operator>=</operator> <name>switch_ptr</name></expr>;</expr_stmt>
		<comment type="block">/* we ignore the remainder of each line */</comment>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Make the page ptr to first record ptr in flashback log */</comment>
<function><type><name>polar_flog_rec_ptr</name></type>
<name>convert_to_first_valid_ptr</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>page_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>valid_ptr</name> <init>= <expr><name>page_ptr</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>valid_ptr</name> <operator>%</operator> <name>POLAR_FLOG_SEG_SIZE</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>valid_ptr</name> <operator>+=</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>valid_ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>valid_ptr</name> <operator>+=</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>valid_ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR: Get the next valid flashback log pointer */</comment>
<function><type><name>polar_flog_rec_ptr</name></type>
<name>polar_get_next_flog_ptr</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>log_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>next_ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>pos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>log_len</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>polar_flog_ptr2pos</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>log_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_ptr</name> <operator>=</operator> <call><name>polar_flog_pos2ptr</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_flashback_log_debug</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The flashback log point after %X/%X is %X/%X"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>next_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>next_ptr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>next_ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR: Remove all the temporary flashback log in the startup */</comment>
<function><type><name>void</name></type>
<name>polar_remove_tmp_flog_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>       <modifier>*</modifier></type><name>flashback_log_dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>flashback_log_de</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flashback_log_dir</name> <operator>=</operator> <call><name>polar_allocate_dir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*no cover begin*/</comment>
	<if_stmt><if>if <condition>(<expr><name>flashback_log_dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*no cover end*/</comment>

	<while>while <condition>(<expr><operator>(</operator><name>flashback_log_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>flashback_log_dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>        <name><name>file_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>flashback_log_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>FLOG_TMP_FNAME</name></expr></argument>,
					<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>FLOG_TMP_FNAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*no cover begin*/</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>file_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>flashback_log_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Remove the temporary flashback log %s"</literal></expr></argument>, <argument><expr><name><name>flashback_log_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>durable_unlink</name><argument_list>(<argument><expr><name>file_path</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*no cover end*/</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>flashback_log_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
