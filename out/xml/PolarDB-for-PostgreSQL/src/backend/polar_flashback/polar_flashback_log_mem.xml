<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/polar_flashback/polar_flashback_log_mem.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * polar_flashback_log_mem.c
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2021, Alibaba Group Holding limited
 *
 * IDENTIFICATION
 *    src/backend/polar_flashback/polar_flashback_log_mem.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_file.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log_mem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_point.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/startup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<comment type="block">/* Name suffix */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_NAME_SUFFIX</name></cpp:macro> <cpp:value>" Ctl"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_LOCKS_NAME_SUFFIX</name></cpp:macro> <cpp:value>"_insert"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF_MAPPING_LOCK_NAME_SUFFIX</name></cpp:macro> <cpp:value>"_buf_mapping"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_LOCK_NAME_SUFFIX</name></cpp:macro> <cpp:value>"_write"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_LOCK_NAME_SUFFIX</name></cpp:macro> <cpp:value>"_init"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_FILE_LOCK_NAME_SUFFIX</name></cpp:macro> <cpp:value>"_control_file"</cpp:value></cpp:define>

<comment type="block">/* local var */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>  <name>my_lock_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/* possibly out-of-date copy of shared write_result. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type> <name>write_result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>flog_insert_lock_padded</name> <modifier>*</modifier></type><name>flog_insert_locks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>LWLock</name> <modifier>*</modifier></type><name>flog_buf_mapping_lock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>LWLock</name> <modifier>*</modifier></type><name>flog_write_lock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Macro to advance to next buffer index. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOG_NEXT_BUF_IDX</name><parameter_list>(<parameter><type><name>idx</name></type></parameter>, <parameter><type><name>ctl</name></type></parameter>)</parameter_list></cpp:macro>     \
	<cpp:value>(((idx) == ctl-&gt;cache_blck) ? 0 : ((idx) + 1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT_FREESPACE</name><parameter_list>(<parameter><type><name>endptr</name></type></parameter>)</parameter_list></cpp:macro>    \
	<cpp:value>(((endptr) % POLAR_FLOG_BLCKSZ == 0) ? 0 : (POLAR_FLOG_BLCKSZ - (endptr) % POLAR_FLOG_BLCKSZ))</cpp:value></cpp:define>

<comment type="block">/* Local file operate */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>  <name>open_log_file</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>open_log_segno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Acquire a flashback log insertion lock, for inserting to flashback log.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flog_insert_lock_acquire</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>        <name>immed</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * It doesn't matter which of the flashback log insertion locks we acquire, so try
	 * the one we used last time.  If the system isn't particularly busy, it's
	 * a good bet that it's still available, and it's good to have some
	 * affinity to a particular lock so that you don't unnecessarily bounce
	 * cache lines between processes when there's no contention.
	 *
	 * If this is the first time through in this backend, pick a lock
	 * (semi-)randomly.  This allows the locks to be used evenly if you have a
	 * lot of very short connections.
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>  <name>lock_to_try</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lock_to_try</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lock_to_try</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name> <operator>%</operator> <name><name>ctl</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>insert_locks_num</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>my_lock_no</name> <operator>=</operator> <name>lock_to_try</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The inserting_at value is initially set to 0, as we don't know our
	 * insert location yet.
	 */</comment>
	<expr_stmt><expr><name>immed</name> <operator>=</operator> <call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>flog_insert_locks</name><index>[<expr><name>my_lock_no</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>immed</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we couldn't get the lock immediately, try another lock next
		 * time.  On a system with more insertion locks than concurrent
		 * inserters, this causes all the inserters to eventually migrate to a
		 * lock that no-one else is using.  On a system with more inserters
		 * than locks, it still helps to distribute the inserters evenly
		 * across the locks.
		 */</comment>
		<expr_stmt><expr><name>lock_to_try</name> <operator>=</operator> <operator>(</operator><name>lock_to_try</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>ctl</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>insert_locks_num</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>flog_insert_lock_release</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

	<expr_stmt><expr><call><name>LWLockReleaseClearVar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>flog_insert_locks</name><index>[<expr><name>my_lock_no</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>flog_insert_locks</name><index>[<expr><name>my_lock_no</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>inserting_at</name></name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update our insertingAt value, to let others know that we've finished
 * inserting up to that point.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>insertlock_update_insert_at</name><parameter_list>(<parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>insertingAt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockUpdateVar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>flog_insert_locks</name><index>[<expr><name>my_lock_no</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>flog_insert_locks</name><index>[<expr><name>my_lock_no</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>inserting_at</name></name></expr></argument>,
					<argument><expr><name>insertingAt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reserves the right amount of space for a record of given size from the flashback log.
 * *start_ptr is set to the beginning of the reserved section, *end_ptr to
 * its end+1.
 *
 * That must be serialized across backends. The rest can happen mostly in parallel. Try to keep this
 * section as short as possible, insertpos_lck can be heavily contended on a
 * busy system.
 *
 * NB: The space calculation here must match the code in polar_copy_flashback_log_rec2buf,
 * where we actually copy the record to the reserved space.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reserve_flog_insert_location</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>buf_ctl</name></decl></parameter>, <parameter><decl><type><name>flog_index_queue_ctl_t</name></type> <name>queue_ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name> <modifier>*</modifier></type><name>start_ptr</name></decl></parameter>,
							 <parameter><decl><type><name>polar_flog_rec_ptr</name> <modifier>*</modifier></type><name>end_ptr</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name> <modifier>*</modifier></type><name>prev_ptr</name></decl></parameter>,
							 <parameter><decl><type><name>uint32</name></type> <name>queue_data_size</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>queue_pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_ctl_insert</name> <modifier>*</modifier></type><name>insert</name> <init>= <expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>insert</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>start_bytepos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>end_bytepos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>prev_bytepos</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* All records should contain data. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;=</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The duration the spinlock needs to be held is minimized by minimizing
	 * the calculations that have to be done while holding the lock. The
	 * current tip of reserved flashback log is kept in curr_pos, as a byte position
	 * that only counts "usable" bytes in flashback log, that is, it excludes all
	 * page headers. The mapping between "usable" byte positions and physical
	 * positions (polar_flog_rec_ptr) can be done outside the locked region, and
	 * because the usable byte position doesn't include any headers, reserving
	 * X bytes from flashback log is almost as simple as "curr_pos += X".
	 */</comment>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reserve the flashback logindex queue size */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>queue_ctl</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_flog_index_queue_free</name><argument_list>(<argument><expr><name>queue_ctl</name></expr></argument>, <argument><expr><name>queue_data_size</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>polar_flog_index_queue_free_up</name><argument_list>(<argument><expr><name>queue_ctl</name></expr></argument>, <argument><expr><name>queue_data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>queue_pos</name> <operator>=</operator> <call><name>polar_flog_index_queue_reserve</name><argument_list>(<argument><expr><name>queue_ctl</name></expr></argument>, <argument><expr><name>queue_data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>start_bytepos</name> <operator>=</operator> <name><name>insert</name><operator>-&gt;</operator><name>curr_pos</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_bytepos</name> <operator>=</operator> <name><name>insert</name><operator>-&gt;</operator><name>prev_pos</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>end_bytepos</name> <operator>=</operator> <name>start_bytepos</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>insert</name><operator>-&gt;</operator><name>curr_pos</name></name> <operator>=</operator> <name>end_bytepos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>insert</name><operator>-&gt;</operator><name>prev_pos</name></name> <operator>=</operator> <name>start_bytepos</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></for>

	<comment type="block">/* Set packet length */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>queue_ctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_flog_index_queue_set_pkt_len</name><argument_list>(<argument><expr><name>queue_ctl</name></expr></argument>, <argument><expr><operator>*</operator><name>queue_pos</name></expr></argument>, <argument><expr><name>queue_data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>start_ptr</name> <operator>=</operator> <call><name>polar_flog_pos2ptr</name><argument_list>(<argument><expr><name>start_bytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>end_ptr</name> <operator>=</operator> <call><name>polar_flog_pos2endptr</name><argument_list>(<argument><expr><name>end_bytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* When we met the first flashback log record, set prev ptr to zero */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>start_ptr</name> <operator>==</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>prev_ptr</name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>prev_ptr</name> <operator>=</operator> <call><name>polar_flog_pos2ptr</name><argument_list>(<argument><expr><name>prev_bytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* When we met a crash recovery, set prev ptr to zero */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>prev_ptr</name> <operator>==</operator> <name>FLOG_LONG_PHD_SIZE</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>*</operator><name>start_ptr</name> <operator>%</operator> <name>POLAR_FLOG_SEG_SIZE</name> <operator>==</operator> <name>FLOG_LONG_PHD_SIZE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>prev_ptr</name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the conversions between "usable byte positions" and
	 * polar_flog_rec_ptr work consistently in both directions.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_flog_ptr2pos</name><argument_list>(<argument><expr><operator>*</operator><name>start_ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>start_bytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_flog_ptr2pos</name><argument_list>(<argument><expr><operator>*</operator><name>end_ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>end_bytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>polar_flog_ptr2pos</name><argument_list>(<argument><expr><operator>*</operator><name>prev_ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>prev_bytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for any flashback log insertions &lt; upto to finish.
 *
 * Returns the location of the oldest insertion that is still in-progress.
 * Any flashback log prior to that point has been fully copied into flashback log buffers, and
 * can be flushed out to disk. Because this waits for any insertions older
 * than 'upto' to finish, the return value is always &gt;= 'upto'.
 *
 * Note: When you are about to write out flashback log, you must call this function
 * *before* acquiring flog_write_lock, to avoid deadlocks. This function might
 * need to wait for an insertion to finish (or at least advance to next
 * uninitialized page), and the inserter might need to evict an old flashback log buffer
 * to make room for a new one, which in turn requires write lock.
 */</comment>
<function><type><specifier>static</specifier> <name>polar_flog_rec_ptr</name></type>
<name>wait_flog_insertions_finish</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>upto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>      <name>bytepos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>reserved_upto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>finished_upto</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_ctl_insert</name> <modifier>*</modifier></type><name>insert</name> <init>= <expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>insert</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"cannot wait without a PGPROC structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Read the current insert position */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytepos</name> <operator>=</operator> <name><name>insert</name><operator>-&gt;</operator><name>curr_pos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reserved_upto</name> <operator>=</operator> <call><name>polar_flog_pos2endptr</name><argument_list>(<argument><expr><name>bytepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No-one should request to flush a piece of flashback log that hasn't even been
	 * reserved yet. However, it can happen if there is a block with a bogus
	 * LSN on disk, for example. polar_flashback_log_flush checks for that situation and
	 * complains, but only after the flush. Here we just assume that to mean
	 * that all flashback log that has been reserved needs to be finished. In this
	 * corner-case, the return value can be smaller than 'upto' argument.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>upto</name> <operator>&gt;</operator> <name>reserved_upto</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"request to flush past end of generated flashback log; request %X/%X, currpos %X/%X"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>upto</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>upto</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>reserved_upto</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>reserved_upto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>upto</name> <operator>=</operator> <name>reserved_upto</name></expr>;</expr_stmt>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Loop through all the locks, sleeping on any in-progress insert older
	 * than 'upto'.
	 *
	 * finishedUpto is our return value, indicating the point upto which all
	 * the flashback log insertions have been finished. Initialize it to the head of
	 * reserved flashback log, and as we iterate through the insertion locks, back it
	 * out for any insertion that's still in progress.
	 */</comment>
	<expr_stmt><expr><name>finished_upto</name> <operator>=</operator> <name>reserved_upto</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctl</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>insert_locks_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>inserting_at</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>

		<do>do
		<block>{<block_content>
			<comment type="block">/*
			 * See if this insertion is in progress. LWLockWait will wait for
			 * the lock to be released, or for the 'value' to be set by a
			 * LWLockUpdateVar call.  When a lock is initially acquired, its
			 * value is 0 (POLAR_INVALID_FLOG_REC_PTR), which means that we don't know
			 * where it's inserting yet.  We will have to wait for it.  If
			 * it's a small insertion, the record will most likely fit on the
			 * same page and the inserter will release the lock without ever
			 * calling LWLockUpdateVar.  But if it has to sleep, it will
			 * advertise the insertion point with LWLockUpdateVar before
			 * sleeping.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>LWLockWaitForVar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>flog_insert_locks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>flog_insert_locks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>inserting_at</name></name></expr></argument>,
								 <argument><expr><name>inserting_at</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inserting_at</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* the lock was free, so no insertion in progress */</comment>
				<expr_stmt><expr><name>inserting_at</name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * This insertion is still in progress. Have to wait, unless the
			 * inserter has proceeded past 'upto'.
			 */</comment>
		</block_content>}</block>
		while <condition>(<expr><name>inserting_at</name> <operator>&lt;</operator> <name>upto</name></expr>)</condition>;</do>

		<if_stmt><if>if <condition>(<expr><name>inserting_at</name> <operator>!=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name> <operator>&amp;&amp;</operator> <name>inserting_at</name> <operator>&lt;</operator> <name>finished_upto</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>finished_upto</name> <operator>=</operator> <name>inserting_at</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>finished_upto</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close the current logfile segment for writing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flog_file_close</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>open_log_file</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_close</name><argument_list>(<argument><expr><name>open_log_file</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>open_log_segno</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close log file %s: %m"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>open_log_file</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write and fsync the log at least as far as write_request indicates.
 *
 * If flexible == true, we don't have to write as far as write_request, but
 * may stop at any convenient boundary (such as a cache or logfile boundary).
 * This option allows us to avoid uselessly issuing multiple writes when a
 * single one would do.
 *
 * Must be called with write_lock held. wait_flashback_log_insertions2finish(write_request)
 * must be called before grabbing the lock, to make sure the data is ready to
 * write.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>flog_write</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>write_request</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>flexible</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>        <name>is_partial_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>last_iteration</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>finishing_seg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>use_existent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>curridx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>npages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>startidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>startoffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>pages_written</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>segs_added</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>total_usecs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>        <name>total_secs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>start_t</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>end_t</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Update local write_result (caller probably did this already, but...)
	 */</comment>
	<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>

	<comment type="block">/* Log before the write. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_flashback_log_debug</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The flashback log write result is %X/%X, the write request is %X/%X"</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>write_result</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>write_result</name></expr></argument>,
				<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>write_request</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>write_request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Since successive pages in the flashback cache are consecutively allocated,
	 * we can usually gather multiple pages together and issue just one
	 * write() call. npages is the number of pages we have determined can be
	 * written together; startidx is the cache block index of the first one,
	 * and startoffset is the file offset at which it should go. The latter
	 * two variables are only valid when npages &gt; 0, but we must initialize
	 * all of them to keep the compiler quiet.
	 */</comment>
	<expr_stmt><expr><name>npages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>startidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>startoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Reset the stat */</comment>
	<expr_stmt><expr><name>pages_written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>segs_added</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_t</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * Within the loop, curridx is the cache block index of the page to
	 * consider writing.  Begin at the buffer containing the next unwritten
	 * page, or last partially written page.
	 */</comment>
	<expr_stmt><expr><name>curridx</name> <operator>=</operator> <call><name>FLOG_PTR2BUF_IDX</name><argument_list>(<argument><expr><name>write_result</name></expr></argument>, <argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>write_result</name> <operator>&lt;</operator> <name>write_request</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure we're not ahead of the insert process. This could happen
		 * if we're passed a bogus write_request that is past the end of the
		 * last page that's been initialized by advance_insert_buffer.
		 */</comment>
		<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>EndPtr</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>curridx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>write_result</name> <operator>&gt;=</operator> <name>EndPtr</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/*no cover line*/</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"flashback log write request %X/%X is past end of log %X/%X"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>write_result</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>write_result</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>EndPtr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>EndPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Advance write_result to end of current buffer page */</comment>
		<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name>EndPtr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_partial_page</name> <operator>=</operator> <name>write_request</name> <operator>&lt;</operator> <name>write_result</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ptr_prev_in_flog_seg</name><argument_list>(<argument><expr><name>write_result</name></expr></argument>, <argument><expr><name>open_log_segno</name></expr></argument>,
								  <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Switch to new logfile segment.  We cannot have any pending
			 * pages here (since we dump what we have at segment end).
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npages</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>open_log_file</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>flog_file_close</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>open_log_segno</name> <operator>=</operator> <call><name>flog_ptr_prev_to_seg</name><argument_list>(<argument><expr><name>write_result</name></expr></argument>,
												  <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* create/use new log file */</comment>
			<expr_stmt><expr><name>use_existent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>open_log_file</name> <operator>=</operator> <call><name>polar_flog_file_init</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>open_log_segno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_existent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_existent</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>segs_added</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>polar_flush_flog_max_seg_no</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>open_log_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Make sure we have the current logfile open */</comment>
		<if_stmt><if>if <condition>(<expr><name>open_log_file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>open_log_segno</name> <operator>=</operator> <call><name>flog_ptr_prev_to_seg</name><argument_list>(<argument><expr><name>write_result</name></expr></argument>,
												  <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* create/use new log file */</comment>
			<expr_stmt><expr><name>use_existent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>open_log_file</name> <operator>=</operator> <call><name>polar_flog_file_init</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>open_log_segno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>use_existent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_existent</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>segs_added</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>polar_flush_flog_max_seg_no</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>open_log_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Add current page to the set of pending pages-to-dump */</comment>
		<if_stmt><if>if <condition>(<expr><name>npages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* first of group */</comment>
			<expr_stmt><expr><name>startidx</name> <operator>=</operator> <name>curridx</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>startoffset</name> <operator>=</operator> <call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>write_result</name> <operator>-</operator> <name>POLAR_FLOG_BLCKSZ</name></expr></argument>,
											  <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>npages</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Dump the set if this will be the last loop iteration, or if we are
		 * at the last page of the cache area (since the next page won't be
		 * contiguous in memory), or if we are at the end of the logfile
		 * segment.
		 */</comment>
		<expr_stmt><expr><name>last_iteration</name> <operator>=</operator> <operator>(</operator><name>write_request</name> <operator>&lt;=</operator> <name>write_result</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>finishing_seg</name> <operator>=</operator> <operator>!</operator><name>is_partial_page</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><name>startoffset</name> <operator>+</operator> <name>npages</name> <operator>*</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator> <operator>&gt;=</operator> <name>POLAR_FLOG_SEG_SIZE</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>last_iteration</name> <operator>||</operator>
				<name>curridx</name> <operator>==</operator> <name><name>ctl</name><operator>-&gt;</operator><name>cache_blck</name></name> <operator>||</operator>
				<name>finishing_seg</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>        <name>nbytes</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>        <name>nleft</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>         <name>written</name></decl>;</decl_stmt>

			<comment type="block">/* OK to write the page(s) */</comment>
			<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>pages</name></name> <operator>+</operator> <name>startidx</name> <operator>*</operator> <operator>(</operator><name>Size</name><operator>)</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>npages</name> <operator>*</operator> <operator>(</operator><name>Size</name><operator>)</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nleft</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pages_written</name> <operator>+=</operator> <name>npages</name></expr>;</expr_stmt>

			<do>do
			<block>{<block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>polar_pwrite</name><argument_list>(<argument><expr><name>open_log_file</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>nleft</name></expr></argument>, <argument><expr><name>startoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>written</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*no cover begin*/</comment>
					<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>open_log_segno</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to flashback log file %s "</literal>
									<literal type="string">"at offset %u, length %zu: %m"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>,
									<argument><expr><name>startoffset</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/*no cover end*/</comment>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>nleft</name> <operator>-=</operator> <name>written</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>from</name> <operator>+=</operator> <name>written</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>startoffset</name> <operator>+=</operator> <name>written</name></expr>;</expr_stmt>
			</block_content>}</block>
			while <condition>(<expr><name>nleft</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

			<comment type="block">/* Update state for write */</comment>
			<expr_stmt><expr><name>npages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we just wrote the whole last page of a logfile segment,
			 * fsync the segment immediately.  This avoids having to go back
			 * and re-open prior segments when an fsync request comes along
			 * later. Doing it here ensures that one and only one backend will
			 * perform this fsync.
			 *
			 * NB: before fsync, add max segment no, so when crash, we can
			 * swtich a new semgent.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>finishing_seg</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>polar_fsync</name><argument_list>(<argument><expr><name>open_log_file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*no cover begin*/</comment>
					<decl_stmt><decl><type><name>int</name></type>         <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>FLOG_MAX_FNAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>get_flog_fname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>open_log_segno</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>, <argument><expr><name>FLOG_DEFAULT_TIMELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>polar_close</name><argument_list>(<argument><expr><name>open_log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/*no cover end*/</comment>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_partial_page</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Only asked to write a partial page */</comment>
			<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name>write_request</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>curridx</name> <operator>=</operator> <call><name>FLOG_NEXT_BUF_IDX</name><argument_list>(<argument><expr><name>curridx</name></expr></argument>, <argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If flexible, break out of loop as soon as we wrote something */</comment>
		<if_stmt><if>if <condition>(<expr><name>flexible</name> <operator>&amp;&amp;</operator> <name>npages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npages</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>end_t</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>start_t</name></expr></argument>, <argument><expr><name>end_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* To avoid the log too noisy. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_flashback_log_debug</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Flashback log write in %s process: wrote %d flashback log buffers (%.1f%%); "</literal>
			 <literal type="string">"%d flashback log file(s) added; "</literal>
			 <literal type="string">"cost %ld.%03d s; "</literal>
			 <literal type="string">"the write result is %X/%X"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>flexible</name></expr> ?</condition><then> <expr><literal type="string">"background"</literal></expr> </then><else>: <expr><literal type="string">"normal"</literal></expr></else></ternary></expr></argument>,
			 <argument><expr><name>pages_written</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>pages_written</name> <operator>*</operator> <literal type="number">100</literal> <operator>/</operator> <operator>(</operator><name><name>ctl</name><operator>-&gt;</operator><name>cache_blck</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
			 <argument><expr><name>segs_added</name></expr></argument>, <argument><expr><name>total_secs</name></expr></argument>, <argument><expr><name>total_usecs</name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>write_result</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>write_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Update shared-memory status
	 *
	 * We make sure that the shared 'request' values do not fall behind the
	 * 'result' values.  This is not absolutely essential, but it saves some
	 * code in a couple of places.
	 */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>write_result</name></name> <operator>=</operator> <name>write_result</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>write_request</name></name> <operator>&lt;</operator> <name>write_request</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>write_request</name></name> <operator>=</operator> <name>write_request</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Update the statistics */</comment>
	<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>write_total_num</name></name></expr></argument>, <argument><expr><name>pages_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>segs_added_total_num</name></name></expr></argument>, <argument><expr><name>segs_added</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>flexible</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>bg_write_num</name></name> <operator>+=</operator> <name>pages_written</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>pages_written</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize flashback log buffers, writing out old buffers if they still contain
 * unwritten data, upto the page containing 'upto'. Or if 'opportunistic' is
 * true, initialize as many pages as we can without having to write out
 * unwritten data. Any new pages are initialized to zeros, with pages headers
 * initialized properly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>advance_insert_buffer</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>upto</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>opportunistic</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>nextidx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>old_page_reqst_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>write_rqst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>new_page_endptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>new_page_beginptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_page_header</name></type> <name>new_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>npages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>flog_buf_mapping_lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that we have the lock, check if someone initialized the page
	 * already.
	 */</comment>
	<while>while <condition>(<expr><name>upto</name> <operator>&gt;=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>initalized_upto</name></name> <operator>||</operator> <name>opportunistic</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nextidx</name> <operator>=</operator> <call><name>FLOG_PTR2BUF_IDX</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>initalized_upto</name></name></expr></argument>, <argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get ending-offset of the buffer page we need to replace (this may
		 * be zero if the buffer hasn't been used yet).  Fall through if it's
		 * already written out.
		 */</comment>
		<expr_stmt><expr><name>old_page_reqst_ptr</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>nextidx</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>write_result</name> <operator>&lt;</operator> <name>old_page_reqst_ptr</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Nope, got work to do. If we just want to pre-initialize as much
			 * as we can without flushing, give up now.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>opportunistic</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* Before waiting, get info_lck and update write_result */</comment>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>write_request</name></name> <operator>&lt;</operator> <name>old_page_reqst_ptr</name></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/*no cover line*/</comment>
				<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>write_request</name></name> <operator>=</operator> <name>old_page_reqst_ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now that we have an up-to-date write_result value, see if we
			 * still need to write it or if someone else already did.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>write_result</name> <operator>&lt;</operator> <name>old_page_reqst_ptr</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Must acquire write lock. Release flashback_log_buf_mapping_lock first,
				 * to make sure that all insertions that we need to wait for
				 * can finish (up to this same position). Otherwise we risk
				 * deadlock.
				 */</comment>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>flog_buf_mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>wait_flog_insertions_finish</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>old_page_reqst_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>flog_write_lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>write_result</name> <operator>&gt;=</operator> <name>old_page_reqst_ptr</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* OK, someone wrote it already */</comment>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>flog_write_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Have to write it ourselves */</comment>
					<expr_stmt><expr><name>write_rqst</name> <operator>=</operator> <name>old_page_reqst_ptr</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>flog_write</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>write_rqst</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>flog_write_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* Re-acquire flog_buf_mapping_lock and retry */</comment>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>flog_buf_mapping_lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now the next buffer slot is free and we can set it up to be the
		 * next output page.
		 */</comment>
		<expr_stmt><expr><name>new_page_beginptr</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>initalized_upto</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_page_endptr</name> <operator>=</operator> <name>new_page_beginptr</name> <operator>+</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>FLOG_PTR2BUF_IDX</name><argument_list>(<argument><expr><name>new_page_beginptr</name></expr></argument>, <argument><expr><name>ctl</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nextidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_page</name> <operator>=</operator> <operator>(</operator><name>flog_page_header</name><operator>)</operator><operator>(</operator><name><name>ctl</name><operator>-&gt;</operator><name>pages</name></name> <operator>+</operator> <name>nextidx</name> <operator>*</operator> <operator>(</operator><name>Size</name><operator>)</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Be sure to re-zero the buffer so that bytes beyond what we've
		 * written will look like zeroes and not valid flashback log records...
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>new_page</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fill the new page's header
		 */</comment>
		<expr_stmt><expr><name><name>new_page</name><operator>-&gt;</operator><name>xlp_magic</name></name> <operator>=</operator> <name>FLOG_PAGE_MAGIC</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_page</name><operator>-&gt;</operator><name>xlp_version</name></name> <operator>=</operator> <name>FLOG_PAGE_VERSION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_page</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name> <operator>=</operator> <name>new_page_beginptr</name></expr>;</expr_stmt>

		<comment type="block">/* Log the buffer init */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_flashback_log_debug</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Init flashback log buffer at %X/%X"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>new_page_beginptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>new_page_beginptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If first page of an flashback log segment file, make it a long header.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name><name>new_page</name><operator>-&gt;</operator><name>xlp_pageaddr</name></name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>polar_long_page_header</name></type> <name>NewLongPage</name> <init>= <expr><operator>(</operator><name>polar_long_page_header</name><operator>)</operator> <name>new_page</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>NewLongPage</name><operator>-&gt;</operator><name>xlp_sysid</name></name> <operator>=</operator> <call><name>GetSystemIdentifier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>NewLongPage</name><operator>-&gt;</operator><name>xlp_seg_size</name></name> <operator>=</operator> <name>POLAR_FLOG_SEG_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>NewLongPage</name><operator>-&gt;</operator><name>xlp_blcksz</name></name> <operator>=</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_page</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>|=</operator> <name>FLOG_LONG_PAGE_HEADER</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Make sure the initialization of the page becomes visible to others
		 * before the blocks update. polar_get_flog_buf() reads blocks without
		 * holding a lock.
		 */</comment>
		<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>volatile</specifier> <name>polar_flog_rec_ptr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>nextidx</name></expr>]</index></name><operator>)</operator> <operator>=</operator> <name>new_page_endptr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>initalized_upto</name></name> <operator>=</operator> <name>new_page_endptr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>npages</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>flog_buf_mapping_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get a pointer to the right location in the flashback log buffer containing the
 * given polar_flog_rec_ptr.
 *
 * If the page is not initialized yet, it is initialized. That might require
 * evicting an old dirty buffer from the buffer cache, which means I/O.
 *
 * The caller must ensure that the page containing the requested location
 * isn't evicted yet, and won't be evicted. The way to ensure that is to
 * hold onto a flashback log insertion lock with the insertingAt position set to
 * something &lt;= ptr. polar_get_flog_buf() will update inserting_at
 * if it needs to evict an old page from the buffer. (This means that once you call
 * polar_get_flog_buf() with a given 'ptr', you must not access anything before
 * that point anymore, and must not call polar_get_flog_buf() with an older 'ptr'
 * later, because older buffers might be recycled already)
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>polar_get_flog_buf</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>         <name>idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>cached_page</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>cached_pos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>expected_endptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fast path for the common case that we need to access again the same
	 * page as last time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cached_pos</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>/</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>==</operator> <name>cached_page</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name>cached_pos</name><operator>)</operator><operator>-&gt;</operator><name>xlp_magic</name> <operator>==</operator> <name>FLOG_PAGE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name>cached_pos</name><operator>)</operator><operator>-&gt;</operator><name>xlp_pageaddr</name> <operator>==</operator> <name>ptr</name> <operator>-</operator> <operator>(</operator><name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>cached_pos</name> <operator>+</operator> <name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The flashback log buffer cache is organized so that a page is always loaded to a
	 * particular buffer.  That way we can easily calculate the buffer a given
	 * page must be loaded into, from the polar_flog_rec_ptr alone.
	 */</comment>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>FLOG_PTR2BUF_IDX</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See what page is loaded in the buffer at the moment. It could be the
	 * page we're looking for, or something older. It can't be anything newer
	 * - that would imply the page we're looking for has already been written
	 * out to disk and evicted, and the caller is responsible for making sure
	 * that doesn't happen.
	 *
	 * However, we don't hold a lock while we read the value. If someone has
	 * just initialized the page, it's possible that we get a "torn read" of
	 * the polar_flog_rec_ptr if 64-bit fetches are not atomic on this platform.
	 * In that case we will see a bogus value. That's ok, we'll grab the mapping
	 * lock (in advance_insert_buffer) and retry if we see anything else than
	 * the page we're looking for. But it means that when we do this unlocked
	 * read, we might see a value that appears to be ahead of the page we're
	 * looking for. Don't PANIC on that, until we've verified the value while
	 * holding the lock.
	 */</comment>
	<expr_stmt><expr><name>expected_endptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>expected_endptr</name> <operator>+=</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>-</operator> <name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>expected_endptr</name> <operator>!=</operator> <name>endptr</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>initialized_upto</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Before calling advance_insert_buffer(), which can block, let others
		 * know how far we're finished with inserting the record.
		 *
		 * NB: If 'ptr' points to just after the page header, advertise a
		 * position at the beginning of the page rather than 'ptr' itself. If
		 * there are no other insertions running, someone might try to flush
		 * up to our advertised location. If we advertised a position after
		 * the page header, someone might try to flush the page header, even
		 * though page might actually not be initialized yet. As the first
		 * inserter on the page, we are effectively responsible for making
		 * sure that it's initialized, before we let insertingAt to move past
		 * the page header.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>==</operator> <name>FLOG_SHORT_PHD_SIZE</name> <operator>&amp;&amp;</operator>
				<call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>initialized_upto</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>==</operator> <name>FLOG_LONG_PHD_SIZE</name> <operator>&amp;&amp;</operator>
				 <call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>initialized_upto</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>initialized_upto</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>insertlock_update_insert_at</name><argument_list>(<argument><expr><name>initialized_upto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>advance_insert_buffer</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>blocks</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>expected_endptr</name> <operator>!=</operator> <name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/*no cover line*/</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"could not find flashback log buffer for %X/%X"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure the initialization of the page is visible to us, and
		 * won't arrive later to overwrite the flashback log data we write on the page.
		 */</comment>
		<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Found the buffer holding this page. Return a pointer to the right
	 * offset within the page.
	 */</comment>
	<expr_stmt><expr><name>cached_page</name> <operator>=</operator> <name>ptr</name> <operator>/</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cached_pos</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>pages</name></name> <operator>+</operator> <name>idx</name> <operator>*</operator> <operator>(</operator><name>Size</name><operator>)</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name>cached_pos</name><operator>)</operator><operator>-&gt;</operator><name>xlp_magic</name> <operator>==</operator> <name>FLOG_PAGE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>flog_page_header</name><operator>)</operator> <name>cached_pos</name><operator>)</operator><operator>-&gt;</operator><name>xlp_pageaddr</name> <operator>==</operator> <name>ptr</name> <operator>-</operator> <operator>(</operator><name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cached_pos</name> <operator>+</operator> <name>ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine of polar_flog_insert_record.
 * Copies a flashback log record to an already-reserved
 * area in the flashback log.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_copy_flog_rec2buf</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>rdata</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>start_ptr</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>currpos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>freespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>written</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type>  <name>curr_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flog_page_header</name></type> <name>pagehdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>rdata_data</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>rdata</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>write_len</name> <init>= <expr><name><name>rdata</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>rdata_len</name> <init>= <expr><name><name>rdata</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get a pointer to the right place in the right flashback log buffer to start
	 * inserting to.
	 */</comment>
	<expr_stmt><expr><name>curr_ptr</name> <operator>=</operator> <name>start_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currpos</name> <operator>=</operator> <call><name>polar_get_flog_buf</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>curr_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>INSERT_FREESPACE</name><argument_list>(<argument><expr><name>curr_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * there should be enough space for at least the first field (xl_tot_len)
	 * on this page.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>freespace</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy record data */</comment>
	<expr_stmt><expr><name>written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>rdata_len</name> <operator>&gt;</operator> <name>freespace</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Write what fits on this page, and continue on the next page.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>curr_ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>&gt;=</operator> <name>FLOG_SHORT_PHD_SIZE</name> <operator>||</operator> <name>freespace</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>currpos</name></expr></argument>, <argument><expr><name>rdata_data</name></expr></argument>, <argument><expr><name>freespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rdata_data</name> <operator>+=</operator> <name>freespace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rdata_len</name> <operator>-=</operator> <name>freespace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>freespace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>curr_ptr</name> <operator>+=</operator> <name>freespace</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get pointer to beginning of next page, and set the xlp_rem_len
		 * in the page header. Set FLASHBACK_LOG_FIRST_IS_CONTRECORD.
		 *
		 * It's safe to set the contrecord flag and xlp_rem_len without a
		 * lock on the page. All the other flags were already set when the
		 * page was initialized, in advance_insert_buffer, and we're the
		 * only backend that needs to set the contrecord flag.
		 */</comment>
		<expr_stmt><expr><name>currpos</name> <operator>=</operator> <call><name>polar_get_flog_buf</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>curr_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pagehdr</name> <operator>=</operator> <operator>(</operator><name>flog_page_header</name><operator>)</operator> <name>currpos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pagehdr</name><operator>-&gt;</operator><name>xlp_rem_len</name></name> <operator>=</operator> <name>write_len</name> <operator>-</operator> <name>written</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pagehdr</name><operator>-&gt;</operator><name>xlp_info</name></name> <operator>|=</operator> <name>FLOG_FIRST_IS_CONTRECORD</name></expr>;</expr_stmt>

		<comment type="block">/* Log the contrecord */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_flashback_log_debug</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Flashback log at %X/%X is a contrecord"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name>start_ptr</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>start_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* skip over the page header */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>FLOG_SEGMENT_OFFSET</name><argument_list>(<argument><expr><name>curr_ptr</name></expr></argument>, <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>curr_ptr</name> <operator>+=</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>currpos</name> <operator>+=</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>curr_ptr</name> <operator>+=</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>currpos</name> <operator>+=</operator> <name>FLOG_SHORT_PHD_SIZE</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>INSERT_FREESPACE</name><argument_list>(<argument><expr><name>curr_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>curr_ptr</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>&gt;=</operator> <name>FLOG_SHORT_PHD_SIZE</name> <operator>||</operator> <name>rdata_len</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>currpos</name></expr></argument>, <argument><expr><name>rdata_data</name></expr></argument>, <argument><expr><name>rdata_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>currpos</name> <operator>+=</operator> <name>rdata_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>curr_ptr</name> <operator>+=</operator> <name>rdata_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>freespace</name> <operator>-=</operator> <name>rdata_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>rdata_len</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>written</name> <operator>==</operator> <name>write_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Align the end position, so that the next record starts aligned */</comment>
	<expr_stmt><expr><name>curr_ptr</name> <operator>=</operator> <call><name>MAXALIGN64</name><argument_list>(<argument><expr><name>curr_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>curr_ptr</name> <operator>!=</operator> <name>end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"space reserved for flashback log record does not match what was written, "</literal>
			 <literal type="string">"the current pointer is %ld and end pointer expected is %ld"</literal></expr></argument>,
			 <argument><expr><name>curr_ptr</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*no cover end*/</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Set the flashback log checkpoint information.
 *
 * This is only called by startup flog init.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_set_fbpoint_info</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>flog_ctl_file_data_t</name> <modifier>*</modifier></type><name>ctl_file_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_buf_state</name></type> <name>buf_state</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctl_file_data</name><operator>-&gt;</operator><name>version_no</name></name> <operator>&amp;</operator> <name>FLOG_SHUTDOWNED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <name>FLOG_BUF_SHUTDOWN_RECOVERY</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf_state</name> <operator>=</operator> <name>FLOG_BUF_CRASH_RECOVERY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>fbpoint_info</name></name> <operator>=</operator> <name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>max_seg_no</name></name> <operator>=</operator> <name><name>ctl_file_data</name><operator>-&gt;</operator><name>max_seg_no</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>wal_info</name></name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>buf_state</name></name> <operator>=</operator> <name>buf_state</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_flashback_log_debug</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Startup the flashback log buffer: "</literal>
			 <literal type="string">"the next point in the flashback log at the last flashback point begining: %X/%X, "</literal>
			 <literal type="string">"the next point in the flashback log at the last flashback point end: %X/%X, "</literal>
			 <literal type="string">"the previous point of the flashback log at the last flashback point end: %X/%X, "</literal>
			 <literal type="string">"the max flashback log segment no: %lu, "</literal>
			 <literal type="string">"the current flashback point WAL lsn is %X/%X, "</literal>
			 <literal type="string">"the prevoius flashback point WAL lsn is %X/%X"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_start_ptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_start_ptr</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr_prev</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>flog_end_ptr_prev</name></name></expr></argument>,
			 <argument><expr><name><name>ctl_file_data</name><operator>-&gt;</operator><name>max_seg_no</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>fbpoint_lsn</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><operator>(</operator><name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>prior_fbpoint_lsn</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>ctl_file_data</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name><operator>.</operator><name>prior_fbpoint_lsn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get the size of shared memory for flashback log
 */</comment>
<function><type><name>Size</name></type>
<name>polar_flog_buf_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>insert_locks_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_buffers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>        <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* flashback log control data */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>flog_buf_ctl_data_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<comment type="block">/* flashback log insertion locks, plus alignment */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_insert_lock_padded</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								   <argument><expr><name>insert_locks_num</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* blocks array */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_flog_rec_ptr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>log_buffers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* extra alignment padding for flashback log I/O buffers */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* and the buffers themselves */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>, <argument><expr><name>log_buffers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Init the flashback log buffer.
 * And do basic initialization of flog_ctl shared data.
 * polar_startup_flog_buf will fill in additional info.
 */</comment>
<function><type><name>void</name></type>
<name>polar_flog_buf_init_data</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>insert_locks_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_buffers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>allocptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>  <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buf_mapping_lock_name</name><index>[<expr><name>FL_OBJ_MAX_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>write_lock_name</name><index>[<expr><name>FL_OBJ_MAX_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>init_lock_name</name><index>[<expr><name>FL_OBJ_MAX_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>insert_locks_name</name><index>[<expr><name>FL_OBJ_MAX_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>ctl_file_lock_name</name><index>[<expr><name>FL_OBJ_MAX_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FLOG_GET_OBJ_NAME</name><argument_list>(<argument><expr><name>insert_locks_name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>INSERT_LOCKS_NAME_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FLOG_GET_OBJ_NAME</name><argument_list>(<argument><expr><name>buf_mapping_lock_name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>BUF_MAPPING_LOCK_NAME_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FLOG_GET_OBJ_NAME</name><argument_list>(<argument><expr><name>write_lock_name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>WRITE_LOCK_NAME_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FLOG_GET_OBJ_NAME</name><argument_list>(<argument><expr><name>init_lock_name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>INIT_LOCK_NAME_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FLOG_GET_OBJ_NAME</name><argument_list>(<argument><expr><name>ctl_file_lock_name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>CTL_FILE_LOCK_NAME_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flog_buf_ctl_data_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>write_total_num</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>segs_added_total_num</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_POLAR_FLASHBACK_LOG_BUFFER_MAPPING</name></expr></argument>, <argument><expr><name>buf_mapping_lock_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>buf_mapping_lock</name></name></expr></argument>,
					 <argument><expr><name>LWTRANCHE_POLAR_FLASHBACK_LOG_BUFFER_MAPPING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_POLAR_FLASHBACK_LOG_WRITE</name></expr></argument>, <argument><expr><name>write_lock_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>write_lock</name></name></expr></argument>,
					 <argument><expr><name>LWTRANCHE_POLAR_FLASHBACK_LOG_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_POLAR_FLASHBACK_LOG_INIT</name></expr></argument>, <argument><expr><name>init_lock_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>init_lock</name></name></expr></argument>,
					 <argument><expr><name>LWTRANCHE_POLAR_FLASHBACK_LOG_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_POLAR_FLASHBACK_LOG_CTL_FILE</name></expr></argument>, <argument><expr><name>ctl_file_lock_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>ctl_file_lock</name></name></expr></argument>,
					<argument><expr><name>LWTRANCHE_POLAR_FLASHBACK_LOG_CTL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>allocptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ctl</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>flog_buf_ctl_data_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>blocks</name></name> <operator>=</operator> <operator>(</operator><name>polar_flog_rec_ptr</name> <operator>*</operator><operator>)</operator> <name>allocptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>blocks</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_flog_rec_ptr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>log_buffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>allocptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>polar_flog_rec_ptr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>log_buffers</name></expr>;</expr_stmt>

	<comment type="block">/* flashback log insertion locks. Ensure they're aligned to the full padded size */</comment>
	<expr_stmt><expr><name>allocptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>flog_insert_lock_padded</name></expr></argument>)</argument_list></sizeof> <operator>-</operator>
				<operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>allocptr</name><operator>)</operator> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>flog_insert_lock_padded</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>flog_insert_locks</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>insert_locks</name></name> <operator>=</operator>
							<operator>(</operator><name>flog_insert_lock_padded</name> <operator>*</operator><operator>)</operator> <name>allocptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>allocptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>flog_insert_lock_padded</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>insert_locks_num</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_POLAR_FLASHBACK_LOG_INSERT</name></expr></argument>, <argument><expr><name>insert_locks_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>insert_locks_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>flog_insert_locks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LWTRANCHE_POLAR_FLASHBACK_LOG_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>flog_insert_locks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>l</name><operator>.</operator><name>inserting_at</name></name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Align the start of the page buffers to a full flashback log block size boundary.
	 * This simplifies some calculations in flashback log insertion. It is also
	 * required for O_DIRECT.
	 */</comment>
	<expr_stmt><expr><name>allocptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>TYPEALIGN</name><argument_list>(<argument><expr><name>POLAR_FLOG_BLCKSZ</name></expr></argument>, <argument><expr><name>allocptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name>allocptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>*</operator> <name>log_buffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do basic initialization of ctl shared data. (polar_startup_flog_buf will fill
	 * in additional info.)
	 */</comment>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>cache_blck</name></name> <operator>=</operator> <name>log_buffers</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>write_result</name></name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>write_request</name></name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>max_seg_no</name></name> <operator>=</operator> <name>POLAR_INVALID_FLOG_SEGNO</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>FL_INS_MAX_NAME_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>insert_locks_num</name></name> <operator>=</operator> <name>insert_locks_num</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>tli</name></name> <operator>=</operator> <name>FLOG_DEFAULT_TIMELINE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>buf_state</name></name> <operator>=</operator> <name>FLOG_BUF_INIT</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* init the local var */</comment>
	<expr_stmt><expr><name>flog_insert_locks</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>insert_locks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>flog_buf_mapping_lock</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>buf_mapping_lock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>flog_write_lock</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>write_lock</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialization of shared memory for flashback log buffers
 */</comment>
<function><type><name>flog_buf_ctl_t</name></type>
<name>polar_flog_buf_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>insert_locks_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_buffers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_buf_ctl_t</name></type> <name>buf_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>ctl_name</name><index>[<expr><name>FL_OBJ_MAX_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>insert_locks_name</name><index>[<expr><name>FL_OBJ_MAX_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FLOG_GET_OBJ_NAME</name><argument_list>(<argument><expr><name>ctl_name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>CTL_NAME_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FLOG_GET_OBJ_NAME</name><argument_list>(<argument><expr><name>insert_locks_name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>INSERT_LOCKS_NAME_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_ctl</name> <operator>=</operator> <operator>(</operator><name>flog_buf_ctl_t</name><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>ctl_name</name></expr></argument>,
											  <argument><expr><call><name>polar_flog_buf_size</name><argument_list>(<argument><expr><name>insert_locks_num</name></expr></argument>, <argument><expr><name>log_buffers</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Do basic initialization of buffer control shared data.
		 * polar_startup_flog_buf will fill in additional info.
		 */</comment>
		<expr_stmt><expr><call><name>polar_flog_buf_init_data</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>insert_locks_num</name></expr></argument>, <argument><expr><name>log_buffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* init the local var */</comment>
		<expr_stmt><expr><name>flog_insert_locks</name> <operator>=</operator> <name><name>buf_ctl</name><operator>-&gt;</operator><name>insert</name><operator>.</operator><name>insert_locks</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_POLAR_FLASHBACK_LOG_INSERT</name></expr></argument>, <argument><expr><name>insert_locks_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>flog_buf_mapping_lock</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>buf_mapping_lock</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>flog_write_lock</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>write_lock</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>buf_ctl</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>buf_ctl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Fill the flashback log control info */</comment>
<function><type><name>void</name></type>
<name>polar_startup_flog_buf</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>CheckPoint</name> <modifier>*</modifier></type><name>checkpoint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_ctl_file_data_t</name></type> <name>ctl_file_data</name></decl>;</decl_stmt>

	<comment type="block">/* Read the flashback log control file */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_read_flog_ctl_file</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_file_data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_set_fbpoint_info</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl_file_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_set_fbpoint_wal_info</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name><name>checkpoint</name><operator>-&gt;</operator><name>redo</name></name></expr></argument>, <argument><expr><name><name>checkpoint</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name>InvalidXLogRecPtr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>fbpoint_info</name><operator>.</operator><name>wal_info</name></name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>wal_info</name></name></expr>;</expr_stmt>
		<comment type="block">/* There no flashback, so just set buffer ready */</comment>
		<expr_stmt><expr><call><name>polar_set_flog_buf_state</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>FLOG_BUF_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>flog_buf_state</name></type>
<name>polar_get_flog_buf_state</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>ctl</name><operator>-&gt;</operator><name>buf_state</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_set_flog_buf_state</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>flog_buf_state</name></type> <name>buf_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>buf_state</name></name> <operator>=</operator> <name>buf_state</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>polar_flog_rec_ptr</name></type>
<name>polar_get_flog_min_recover_lsn</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>ctl</name><operator>-&gt;</operator><name>min_recover_lsn</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_set_flog_min_recover_lsn</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>min_recover_lsn</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR: Track and log flashback log service state. */</comment>
<function><type><name>void</name></type>
<name>polar_log_flog_buf_state</name><parameter_list>(<parameter><decl><type><name>flog_buf_state</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*no cover begin*/</comment>
	<switch>switch <condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FLOG_BUF_INIT</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The state of flashback log buffer is init."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FLOG_BUF_CRASH_RECOVERY</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The state of flashback log buffer is crash recovery."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FLOG_BUF_SHUTDOWN_RECOVERY</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The state of flashback log buffer is shutdown recovery."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FLOG_BUF_READY</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The state of flashback log buffer is ready."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FLOG_BUF_SHUTDOWNED</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The state of flashback log buffer is shutdowned."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<comment type="block">/*no cover begin*/</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"The state of flashback log buffer is in unknown state."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Insert an flashback log record represented by an already-constructed record data.
 *
 * Returns the flashback log pointer to end of record.
 *
 * This can be used as LSN for buffer affected by the logged action.
 * (LSN is the flashback log point up to which the flashback log must be flushed to disk
 * before the buffer can be written out. This implements the basic
 * flashback log rule "write the origin data before the new data".)
 *
 */</comment>
<function><type><name>polar_flog_rec_ptr</name></type>
<name>polar_flog_rec_insert</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>buf_ctl</name></decl></parameter>, <parameter><decl><type><name>flog_index_queue_ctl_t</name></type> <name>queue_ctl</name></decl></parameter>, <parameter><decl><type><name>flog_record</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name> <modifier>*</modifier></type><name>start_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>   <name>rdata_crc</name></decl>;</decl_stmt>
	<comment type="block">/* The reserved start point from flashback logindex queue */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>      <name>queue_pos</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<comment type="block">/* The size for flashback logindex queue data */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>queue_data_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>queue_data_size</name> <operator>=</operator> <name>FLOG_INDEX_QUEUE_DATA_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>&gt;=</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_FLASHBACK_LOG_BUF_READY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check the flashback log shared buffer ready */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_is_flog_buf_ready</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*no cover line*/</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"The flashback log buffer must be ready before insert flashback log record."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*----------
	 *
	 * We have now done all the preparatory work we can without holding a
	 * lock or modifying shared state. From here on, inserting the new flashback log
	 * record to the shared flashback log buffer cache is a two-step process:
	 *
	 * 1. Reserve the right amount of space from the flashback log. The current head of
	 *    reserved space is kept in insert-&gt;curr_pos, and is protected by
	 *    insertpos_lck.
	 *
	 * 2. Copy the record to the reserved flashback log space. This involves finding the
	 *    correct flashback log buffer containing the reserved space, and copying the
	 *    record in place. This can be done concurrently in multiple processes.
	 *
	 * To keep track of which insertions are still in-progress, each concurrent
	 * inserter acquires an insertion lock. In addition to just indicating that
	 * an insertion is in progress, the lock tells others how far the inserter
	 * has progressed. There is a small fixed number of insertion locks,
	 * determined by polar_flashback_log_buf_insert_locks. When an inserter crosses a page
	 * boundary, it updates the value stored in the lock to the how far it has
	 * inserted, to allow the previous buffer to be flushed.
	 *
	 * Holding onto an insertion lock also protects log_rec_ptr from changing
	 * until the insertion is finished.
	 *
	 * Step 2 can usually be done completely in parallel. If the required flashback log
	 * page is not initialized yet, you have to grab flog_write_lock to
	 * initialize it, but the flashback log writer tries to do that ahead of insertions
	 * to avoid that from happening in the critical path.
	 *
	 *----------
	 */</comment>
	<expr_stmt><expr><call><name>flog_insert_lock_acquire</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reserve space for the record in the flashback log.
	 */</comment>
	<expr_stmt><expr><call><name>reserve_flog_insert_location</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>, <argument><expr><name>queue_ctl</name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>, <argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_ptr</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>rec</name><operator>-&gt;</operator><name>xl_prev</name></name></expr></argument>, <argument><expr><name>queue_data_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queue_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that xl_prev has been filled in, calculate CRC of the record
	 * header.
	 */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>rdata_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>&gt;</operator> <name>FLOG_REC_HEADER_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>rdata_crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>rec</name> <operator>+</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>,
					<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_tot_len</name></name> <operator>-</operator> <name>FLOG_REC_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>rdata_crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>rec</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>flog_record</name></expr></argument>, <argument><expr><name>xl_crc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>rdata_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_crc</name></name> <operator>=</operator> <name>rdata_crc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be inside CRIT_SECTION.
	 * Hold off signal to avoid mess up memory data contain
	 * flashback log buffer and flashback logindex queue data.
	 */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * All the record data, including the header, is now ready to be
	 * inserted. Copy the record in the space reserved.
	 */</comment>
	<expr_stmt><expr><call><name>polar_copy_flog_rec2buf</name><argument_list>(<argument><expr><name>buf_ctl</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><operator>*</operator><name>start_ptr</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Done! Let others know that we're finished.
	 */</comment>
	<expr_stmt><expr><call><name>flog_insert_lock_release</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be inside CRIT_SECTION.
	 * Hold off signal to avoid mess up queue data.
	 * Copy the content to flashback logindex queue buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>queue_ctl</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Don't need a error report while the polar_flashback_logindex_queue_push catch it. */</comment>
		<expr_stmt><expr><call><name>polar_flog_index_queue_push</name><argument_list>(<argument><expr><name>queue_ctl</name></expr></argument>, <argument><expr><name>queue_pos</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>queue_data_size</name></expr></argument>,
									<argument><expr><operator>*</operator><name>start_ptr</name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>xl_tot_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update shared write_request, if we crossed page boundary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>start_ptr</name> <operator>/</operator> <name>POLAR_FLOG_BLCKSZ</name> <operator>!=</operator> <name>end_ptr</name> <operator>/</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* advance global request to include new block(s) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>write_request</name></name> <operator>&lt;</operator> <name>end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>buf_ctl</name><operator>-&gt;</operator><name>write_request</name></name> <operator>=</operator> <name>end_ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* update local result copy while I have the chance */</comment>
		<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>buf_ctl</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>end_ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the flashback log record write pointer and
 * update the local write result.
 *
 * NB: It may be a callback, so we don't use the flog_buf_ctl_t as a parameter.
 */</comment>
<function><type><name>polar_flog_rec_ptr</name></type>
<name>polar_get_flog_write_result</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>buf_ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>buf_ctl</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf_ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the flashback log record request pointer */</comment>
<function><type><name>polar_flog_rec_ptr</name></type>
<name>polar_get_flog_write_request</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name> <init>= <expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>write_request</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the flashback log record current end pointer */</comment>
<function><type><name>polar_flog_rec_ptr</name></type>
<name>polar_get_curr_flog_ptr</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name> <modifier>*</modifier></type><name>prev_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>flog_ctl_insert</name> <modifier>*</modifier></type><name>insert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>curr_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>prev_pos</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>insert</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>insert</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curr_pos</name> <operator>=</operator> <name><name>insert</name><operator>-&gt;</operator><name>curr_pos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_pos</name> <operator>=</operator> <name><name>insert</name><operator>-&gt;</operator><name>prev_pos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>insert</name><operator>-&gt;</operator><name>insertpos_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The point may be a end of flashback log blocks */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>polar_flog_pos2endptr</name><argument_list>(<argument><expr><name>curr_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>prev_ptr</name> <operator>=</operator> <call><name>polar_flog_pos2ptr</name><argument_list>(<argument><expr><name>prev_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FLOG_REC_PTR_IS_INVAILD</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>*</operator><name>prev_ptr</name> <operator>==</operator> <name>FLOG_LONG_PHD_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>prev_ptr</name> <operator>=</operator> <name>POLAR_INVALID_FLOG_REC_PTR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*no cover begin*/</comment>
<function><type><name>uint64</name></type>
<name>polar_get_flog_max_seg_no</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>max_seg_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_seg_no</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>max_seg_no</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>max_seg_no</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*no cover end*/</comment>

<comment type="block">/*
 * POLAR: Write &amp; flush flashback log, but without specifying exactly where to.
 * We will write complete blocks only.
 * This routine is invoked periodically by the background process.
 *
 * Return the flush result.
 */</comment>
<function><type><name>polar_flog_rec_ptr</name></type>
<name>polar_flog_flush_bg</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>write_reqst</name></decl>;</decl_stmt>

	<comment type="block">/* read write result and update local state */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>write_reqst</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>write_request</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>write_reqst</name> <operator>-</operator> <name>write_result</name> <operator>&gt;=</operator> <name>polar_flashback_log_flush_max_size</name> <operator>*</operator> <literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>write_reqst</name> <operator>=</operator>  <name>write_result</name> <operator>+</operator> <name>polar_flashback_log_flush_max_size</name> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* back off to last completed page boundary */</comment>
	<expr_stmt><expr><name>write_reqst</name> <operator>-=</operator> <name>write_reqst</name> <operator>%</operator> <name>POLAR_FLOG_BLCKSZ</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If already known flushed, we're done. Just need to check if we are
	 * holding an open file handle to a logfile that's no longer in use,
	 * preventing the file from being deleted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>write_reqst</name> <operator>&lt;=</operator> <name>write_result</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>open_log_file</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ptr_prev_in_flog_seg</name><argument_list>(<argument><expr><name>write_result</name></expr></argument>, <argument><expr><name>open_log_segno</name></expr></argument>,
									  <argument><expr><name>POLAR_FLOG_SEG_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>flog_file_close</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>write_result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* now wait for any in-progress insertions to finish and get write lock */</comment>
	<expr_stmt><expr><call><name>wait_flog_insertions_finish</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>write_reqst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>flog_write_lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>write_result</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>write_result</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>write_reqst</name> <operator>&gt;</operator> <name>write_result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>flog_write</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>write_reqst</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>flog_write_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Great, done. To take some work off the critical path, try to initialize
	 * as many of the no-longer-needed WAL buffers for future use as we can.
	 */</comment>
	<expr_stmt><expr><call><name>advance_insert_buffer</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>POLAR_INVALID_FLOG_REC_PTR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we determined that we need to write data, but somebody else
	 * wrote/flushed already, it should be considered as being active, to
	 * avoid hibernating too early.
	 */</comment>
	<return>return <expr><name>write_result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_get_flog_write_stat</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>write_total_num</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>bg_write_num</name></decl></parameter>,
						  <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>segs_added_total_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>write_total_num</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>write_total_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>bg_write_num</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>bg_write_num</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>segs_added_total_num</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>segs_added_total_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>polar_flog_rec_ptr</name></type>
<name>polar_get_flog_buf_initalized_upto</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_flog_rec_ptr</name></type> <name>initalized_upto</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>initalized_upto</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>initalized_upto</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctl</name><operator>-&gt;</operator><name>info_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>initalized_upto</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR: flush the flashback log to end_ptr */</comment>
<function><type><name>void</name></type>
<name>polar_flog_flush</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>polar_flog_rec_ptr</name></type> <name>end_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Larger than the local write result */</comment>
	<if_stmt><if>if <condition>(<expr><name>end_ptr</name> <operator>&gt;</operator> <name>write_result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>wait_flog_insertions_finish</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>flog_write_lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>flog_write</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>flog_write_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_flog_get_keep_wal_lsn</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>XLogRecPtr</name> <modifier>*</modifier></type><name>keep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>fl_keep_wal_lsn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fl_keep_wal_lsn</name> <operator>=</operator> <name><name>ctl</name><operator>-&gt;</operator><name>keep_wal_lsn</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fl_keep_wal_lsn</name> <operator>==</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>keep</name> <operator>!=</operator> <name>InvalidXLogRecPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>keep</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><operator>*</operator><name>keep</name></expr></argument>, <argument><expr><name>fl_keep_wal_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>keep</name> <operator>=</operator> <name>fl_keep_wal_lsn</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>polar_get_flog_dir</name><parameter_list>(<parameter><decl><type><name>flog_buf_ctl_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ctl</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>ctl</name><operator>-&gt;</operator><name>dir</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>POLAR_FL_DEFAULT_DIR</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
