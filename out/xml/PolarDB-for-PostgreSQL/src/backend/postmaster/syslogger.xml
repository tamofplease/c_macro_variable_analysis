<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/postmaster/syslogger.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * syslogger.c
 *
 * The system logger (syslogger) appeared in Postgres 8.0. It catches all
 * stderr output from the postmaster, backends, and other subprocesses
 * by redirecting to a pipe, and writes it to a set of logfiles.
 * It's possible to have size and age limits for the logfile configured
 * in postgresql.conf. If these limits are reached or passed, the
 * current logfile is closed and a new one is created (rotated).
 * The logfiles are stored in a subdirectory (configurable in
 * postgresql.conf), using a user-selectable naming scheme.
 *
 * Author: Andreas Pflug &lt;pgadmin@pse-consulting.de&gt;
 *
 * Copyright (c) 2004-2018, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/postmaster/syslogger.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fork_process.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/syslogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<comment type="block">/*
 * We read() into a temp buffer twice as big as a chunk, so that any fragment
 * left after processing can be moved down to the front and we'll still have
 * room to read a full chunk.
 */</comment>
<comment type="block">/* POLAR: enlarge this */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BUF_SIZE</name></cpp:macro> <cpp:value>(200 * PIPE_CHUNK_SIZE)</cpp:value></cpp:define>


<comment type="block">/*
 * GUC parameters.  Logging_collector cannot be changed after postmaster
 * start, but the rest can change at SIGHUP.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>Logging_collector</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Log_RotationAge</name> <init>= <expr><name>HOURS_PER_DAY</name> <operator>*</operator> <name>MINS_PER_HOUR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Log_RotationSize</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>Log_directory</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>Log_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Log_truncate_on_rotation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Log_file_mode</name> <init>= <expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Globally visible state (used by elog.c)
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>am_syslogger</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR: public */</comment>
<decl_stmt><decl><type><name>int</name></type> 		<name>MyLoggerIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>        <name>polar_enable_multi_syslogger</name> <init>= <expr><name>DEFAULT_MULTI_SYSLOGGER_FLAG</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 		<name>polar_enable_syslog_pipe_buffer</name>	<init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 		<name>polar_enable_syslog_file_buffer</name>	<init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_enable_error_to_audit_log</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_num_of_sysloggers</name> <init>= <expr><name>DEFAULT_SYSLOGGER_NUM</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_LOG_CHANNEL_FD_WITH_INDEX</name><parameter_list>(<parameter><type><name>index</name></type></parameter>, <parameter><type><name>end</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>index ? syslogChannels[index][end] : syslogPipe[end]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_LOG_CHANNEL_FD</name><parameter_list>(<parameter><type><name>end</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>GET_LOG_CHANNEL_FD_WITH_INDEX(MyLoggerIndex, end)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_LOG_CHANNEL_FD_WITH_INDEX</name><parameter_list>(<parameter><type><name>index</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro>  	\
	<cpp:value>do {												\
		if (index == 0)									\
			syslogPipe[end] = fd;						\
		else											\
			syslogChannels[index][end] = fd;	\
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_LOG_CHANNEL_FD</name><parameter_list>(<parameter><type><name>end</name></type></parameter>, <parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro> 	\
	<cpp:value>SET_LOG_CHANNEL_FD_WITH_INDEX(MyLoggerIndex, end, fd)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_BUF_MODE</name><parameter_list>(<parameter><type><name>file_type</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((file_type == LOG_DESTINATION_POLAR_AUDITLOG &amp;&amp; polar_enable_syslog_file_buffer) ? PG_IOFBF : PG_IOLBF)</cpp:value></cpp:define>
<comment type="block">/* POLAR end */</comment>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>redirection_done</name></decl>;</decl_stmt>

<comment type="block">/*
 * Private state
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pg_time_t</name></type> <name>next_rotation_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>pipe_eof_seen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>rotation_disabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>syslogFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>csvlogFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NON_EXEC_STATIC</name> <name>pg_time_t</name></type> <name>first_syslogger_file_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>last_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>last_csv_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR: private */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>auditlogFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>polar_last_audit_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>slowlogFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>polar_last_slowlog_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 * Buffers for saving partial messages from different backends.
 *
 * Keep NBUFFER_LISTS lists of these, with the entry for a given source pid
 * being in the list numbered (pid % NBUFFER_LISTS), so as to cut down on
 * the number of entries we have to examine for any one incoming message.
 * There must never be more than one entry for the same source pid.
 *
 * An inactive buffer is not removed from its list, just held for re-use.
 * An inactive buffer has pid == 0 and undefined contents of data.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int32</name></type>		<name>pid</name></decl>;</decl_stmt>			<comment type="block">/* PID of source process */</comment>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>data</name></decl>;</decl_stmt>		<comment type="block">/* accumulated data, as a StringInfo */</comment>
}</block></struct></type> <name>save_buffer</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBUFFER_LISTS</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name><name>buffer_lists</name><index>[<expr><name>NBUFFER_LISTS</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* These must be exported for EXEC_BACKEND case ... annoying */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><name>int</name></type>			<name><name>syslogPipe</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>HANDLE</name></type>		<name><name>syslogPipe</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* POLAR */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><name>bool</name></type>        <name>polar_syslog_channel_is_inited</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>         <name><name>syslogChannels</name><index>[<expr><name>MAX_SYSLOGGER_NUM</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>HANDLE</name></type>      <name><name>syslogChannels</name><index>[<expr><name>MAX_SYSLOGGER_NUM</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* POLAR end */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>threadHandle</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>CRITICAL_SECTION</name></type> <name>sysloggerSection</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Flags set by interrupt handlers for later service in the main loop.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>rotation_requested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* Local subroutines */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>syslogger_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>syslogger_parseArgs</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>NON_EXEC_STATIC</name> <name>void</name></type> <name>SysLoggerMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_pipe_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>logbuffer</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bytes_in_logbuffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flush_pipe_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>logbuffer</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bytes_in_logbuffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>logfile_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>, 
						<parameter><decl><type><name>bool</name></type> <name>allow_errors</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name> <name>__stdcall</name></type> <name>pipeThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>logfile_rotate</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>time_based_rotation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size_rotation_for</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>logfile_getname</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_next_rotation_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_remove_old_syslog_files</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_remove_log_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_metainfo_datafile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR */</comment>
<function_decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>logfile_open_with_buffer_mode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>allow_errors</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buffer_mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_dest_from_flag</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>flag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>get_logfile_from_dest</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>destination</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 * Main entry point for syslogger process
 * argc/argv parameters are valid only in EXEC_BACKEND case.
 */</comment>
<function><type><name>NON_EXEC_STATIC</name> <name>void</name></type>
<name>SysLoggerMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<comment type="block">/* POLAR: allocate it on heap because we enlarge the READ_BUF_SIZE */</comment>
	<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>logbuffer</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>READ_BUF_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytes_in_logbuffer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>currentLogDir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>currentLogFilename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>currentLogRotationAge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>now</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR */</comment>
	<decl_stmt><decl><type><name>int</name></type> 		<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>     	<name>channel_fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>wait_event_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEvent</name></type>   <name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>loggerIndexStr</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><name>MyLoggerIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>MyLoggerIndex</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>argv</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_ltoa</name><argument_list>(<argument><expr><name>MyLoggerIndex</name></expr></argument>, <argument><expr><name>loggerIndexStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <name>MyStartTime</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<comment type="line">// TODO(wormhole.gl): argv</comment>
	<expr_stmt><expr><call><name>syslogger_parseArgs</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>

	<expr_stmt><expr><name>am_syslogger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><literal type="string">"logger"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>loggerIndexStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we restarted, our stderr is already redirected into our own input
	 * pipe.  This is of course pretty useless, not to mention that it
	 * interferes with detecting pipe EOF.  Point stderr to /dev/null. This
	 * assumes that all interesting messages generated in the syslogger will
	 * come through elog.c and will be sent to write_syslogger_file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>redirection_done</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>DEVNULL</name></expr></argument>, <argument><expr><name>O_WRONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The closes might look redundant, but they are not: we want to be
		 * darn sure the pipe gets closed even if the open failed.  We can
		 * survive running with stderr pointing nowhere, but we can't afford
		 * to have extra pipe input descriptors hanging around.
		 *
		 * As we're just trying to reset these to go to DEVNULL, there's not
		 * much point in checking for failure from the close/dup2 calls here,
		 * if they fail then presumably the file descriptors are closed and
		 * any writes will go into the bitbucket anyway.
		 */</comment>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dup2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dup2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * Syslogger's own stderr can't be the syslogPipe, so set it back to text
	 * mode if we didn't just close it. (It was set to binary in
	 * SubPostmasterMain).
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Also close our copy of the write end of the pipe.  This is needed to
	 * ensure we can detect pipe EOF correctly.  (But note that in the restart
	 * case, the postmaster already did this.)
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>channel_fd</name> <operator>=</operator> <call><name>GET_LOG_CHANNEL_FD</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>channel_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>channel_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SET_LOG_CHANNEL_FD</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: here we close all other syslogger fds that do not need,
	 * because we need catch file EOF when normal exit.
	 *
	 * If two processes have this socket open,
	 * one can close it but the socket isn't considered closed by
	 * the operating system because the other still has it open.
	 * Until the other process closes the socket,
	 * the process reading from the socket won't get an end-of-file.
	 * This can lead to confusion and deadlock.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>polar_num_of_sysloggers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>MyLoggerIndex</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>channel_fd</name> <operator>=</operator> <call><name>GET_LOG_CHANNEL_FD_WITH_INDEX</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>channel_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>channel_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>SET_LOG_CHANNEL_FD_WITH_INDEX</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>channel_fd</name> <operator>=</operator> <call><name>GET_LOG_CHANNEL_FD_WITH_INDEX</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>channel_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>channel_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>SET_LOG_CHANNEL_FD_WITH_INDEX</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>channel_fd</name> <operator>=</operator> <call><name>GET_LOG_CHANNEL_FD</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>channel_fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>channel_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SET_LOG_CHANNEL_FD</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Properly accept or ignore signals the postmaster might send us
	 *
	 * Note: we ignore all termination signals, and instead exit only when all
	 * upstream processes are gone, to ensure we don't miss any dying gasps of
	 * broken backends...
	 */</comment>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>sigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* set flag to read config file */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>sigUsr1Handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* request log rotation */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset some signals that are accepted by postmaster but not here
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTIN</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTTOU</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCONT</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGWINCH</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* Fire up separate data transfer thread */</comment>
	<expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>threadHandle</name> <operator>=</operator> <operator>(</operator><name>HANDLE</name><operator>)</operator> <call><name>_beginthreadex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pipeThread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>threadHandle</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not create syslogger data transfer thread: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

	<comment type="block">/*
	 * Remember active logfiles' name(s).  We recompute 'em from the reference
	 * time because passing down just the pg_time_t is a lot cheaper than
	 * passing a whole file path in the EXEC_BACKEND case.
	 */</comment>
	<expr_stmt><expr><name>last_file_name</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><name>SYSLOG_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_csv_file_name</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><literal type="string">".csv"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR */</comment>
	<if_stmt><if>if <condition>(<expr><name>auditlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>polar_last_audit_file_name</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><name>AUDITLOG_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>slowlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>polar_last_slowlog_file_name</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><name>SLOWLOG_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/* remember active logfile parameters */</comment>
	<expr_stmt><expr><name>currentLogDir</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentLogFilename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>Log_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentLogRotationAge</name> <operator>=</operator> <name>Log_RotationAge</name></expr>;</expr_stmt>
	<comment type="block">/* set next planned rotation time */</comment>
	<expr_stmt><expr><call><name>set_next_rotation_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_metainfo_datafile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset whereToSendOutput, as the postmaster will do (but hasn't yet, at
	 * the point where we forked).  This prevents duplicate output of messages
	 * from syslogger itself.
	 */</comment>
	<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>

	<comment type="block">/* POLAR: move create wait event out of loop begin */</comment>
	<expr_stmt><expr><name>set</name> <operator>=</operator> <call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>,
						<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>wait_event_id</name> <operator>=</operator> <call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>WL_SOCKET_READABLE</name></expr></argument>, 
								<argument><expr><call><name>GET_LOG_CHANNEL_FD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/* main worker loop */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>time_based_rotation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>size_rotation_for</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>cur_timeout</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cur_flags</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>ret</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Clear any already-pending wakeups */</comment>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Process any requests or signals received recently.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check if the log directory or filename pattern changed in
			 * postgresql.conf. If so, force rotation to make sure we're
			 * writing the logfiles in the right place.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>currentLogDir</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>currentLogDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>currentLogDir</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Also, create new directory if not present; ignore errors
				 */</comment>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>MakePGDirectory</name><argument_list>(<argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>Log_filename</name></expr></argument>, <argument><expr><name>currentLogFilename</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>currentLogFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>currentLogFilename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>Log_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Force a rotation if CSVLOG output was just turned on or off and
			 * we need to open or close csvlogFile accordingly.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>!=</operator>
				<operator>(</operator><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			
			<comment type="block">/* POLAR */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_AUDITLOG</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>!=</operator>
				<operator>(</operator><name>auditlogFile</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>!=</operator> 
				<operator>(</operator><name>slowlogFile</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* POLAR end */</comment>

			<comment type="block">/*
			 * If rotation time parameter changed, reset next rotation time,
			 * but don't immediately force a rotation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>currentLogRotationAge</name> <operator>!=</operator> <name>Log_RotationAge</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>currentLogRotationAge</name> <operator>=</operator> <name>Log_RotationAge</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>set_next_rotation_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we had a rotation-disabling failure, re-enable rotation
			 * attempts after SIGHUP, and force one immediately.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>rotation_disabled</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rotation_disabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Force rewriting last log filename when reloading configuration.
			 * Even if rotation_requested is false, log_destination may have
			 * been changed and we don't want to wait the next file rotation.
			 */</comment>
			<expr_stmt><expr><call><name>update_metainfo_datafile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>Log_RotationAge</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>rotation_disabled</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Do a logfile rotation if it's time */</comment>
			<expr_stmt><expr><name>now</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>next_rotation_time</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>time_based_rotation</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rotation_requested</name> <operator>&amp;&amp;</operator> <name>Log_RotationSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>rotation_disabled</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Do a rotation if file is too big */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ftell</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>Log_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>size_rotation_for</name> <operator>|=</operator> <name>LOG_DESTINATION_STDERR</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<call><name>ftell</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>Log_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>size_rotation_for</name> <operator>|=</operator> <name>LOG_DESTINATION_CSVLOG</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* POLAR */</comment>
			<if_stmt><if>if <condition>(<expr><name>auditlogFile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<call><name>ftell</name><argument_list>(<argument><expr><name>auditlogFile</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>Log_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>size_rotation_for</name> <operator>|=</operator> <name>LOG_DESTINATION_POLAR_AUDITLOG</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>slowlogFile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<call><name>ftell</name><argument_list>(<argument><expr><name>slowlogFile</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>Log_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>size_rotation_for</name> <operator>|=</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* POLAR end */</comment>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rotation_requested</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// TODO(wormhole.gl): need to choose the proper logger carefully to do these works</comment>
			<comment type="block">/* POLAR: remove oldest log file, now every syslogger will do this work */</comment>
			<expr_stmt><expr><call><name>polar_remove_old_syslog_files</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* POLAR end */</comment>

			<comment type="block">/*
			 * Force rotation when both values are zero. It means the request
			 * was sent by pg_rotate_logfile.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>time_based_rotation</name> <operator>&amp;&amp;</operator> <name>size_rotation_for</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>size_rotation_for</name> <operator>=</operator> <name>LOG_DESTINATION_STDERR</name> <operator>|</operator> <name>LOG_DESTINATION_CSVLOG</name> <operator>|</operator>
									<name>LOG_DESTINATION_POLAR_AUDITLOG</name> <operator>|</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>logfile_rotate</name><argument_list>(<argument><expr><name>time_based_rotation</name></expr></argument>, <argument><expr><name>size_rotation_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Calculate time till next time-based rotation, so that we don't
		 * sleep longer than that.  We assume the value of "now" obtained
		 * above is still close enough.  Note we can't make this calculation
		 * until after calling logfile_rotate(), since it will advance
		 * next_rotation_time.
		 *
		 * Also note that we need to beware of overflow in calculation of the
		 * timeout: with large settings of Log_RotationAge, next_rotation_time
		 * could be more than INT_MAX msec in the future.  In that case we'll
		 * wait no more than INT_MAX msec, and try again.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>Log_RotationAge</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>rotation_disabled</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>delay</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>delay</name> <operator>=</operator> <name>next_rotation_time</name> <operator>-</operator> <name>now</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>delay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>delay</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>delay</name> <operator>=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <name>delay</name> <operator>*</operator> <literal type="number">1000L</literal></expr>;</expr_stmt>	<comment type="block">/* msec */</comment>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>cur_flags</name> <operator>=</operator> <name>WL_TIMEOUT</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* POLAR optimized */</comment>
		<expr_stmt><expr><call><name>ModifyWaitEvent</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>wait_event_id</name></expr></argument>, <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>cur_flags</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sleep until there's something to do
		 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>cur_timeout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>event</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_SYSLOGGER_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>WL_TIMEOUT</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>event</name><operator>.</operator><name>events</name></name> <operator>&amp;</operator> <operator>(</operator><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_SOCKET_MASK</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>bytesRead</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>bytesRead</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><call><name>GET_LOG_CHANNEL_FD</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>logbuffer</name> <operator>+</operator> <name>bytes_in_logbuffer</name></expr></argument>,
							 <argument><expr><name>READ_BUF_SIZE</name> <operator>-</operator> <name>bytes_in_logbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>bytesRead</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from logger pipe: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>bytesRead</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>bytes_in_logbuffer</name> <operator>+=</operator> <name>bytesRead</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>process_pipe_input</name><argument_list>(<argument><expr><name>logbuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_in_logbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Zero bytes read when select() is saying read-ready means
				 * EOF on the pipe: that is, there are no longer any processes
				 * with the pipe write end open.  Therefore, the postmaster
				 * and all backends are shut down, and we are done.
				 */</comment>
				<expr_stmt><expr><name>pipe_eof_seen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* if there's any data left then force it out now */</comment>
				<expr_stmt><expr><call><name>flush_pipe_input</name><argument_list>(<argument><expr><name>logbuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_in_logbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_TIMEOUT</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* if there's any data left then force it out now */</comment>
			<expr_stmt><expr><call><name>flush_syslogger_file</name><argument_list>(<argument><expr><name>LOG_DESTINATION_POLAR_AUDITLOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* POLAR end */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
		<comment type="line">// TODO(wormhole.gl): WIN32</comment>

		<comment type="block">/*
		 * On Windows we leave it to a separate thread to transfer data and
		 * detect pipe EOF.  The main thread just wakes up to handle SIGHUP
		 * and rotation conditions.
		 *
		 * Server code isn't generally thread-safe, so we ensure that only one
		 * of the threads is active at a time by entering the critical section
		 * whenever we're not sleeping.
		 */</comment>
		<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
						 <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>cur_flags</name></expr></argument>,
						 <argument><expr><name>cur_timeout</name></expr></argument>,
						 <argument><expr><name>WAIT_EVENT_SYSLOGGER_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

		<if_stmt><if>if <condition>(<expr><name>pipe_eof_seen</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * seeing this message on the real stderr is annoying - so we make
			 * it DEBUG1 to suppress in normal use.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logger shutting down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Normal exit from the syslogger is here.  Note that we
			 * deliberately do not close syslogFile before exiting; this is to
			 * allow for the possibility of elog messages being generated
			 * inside proc_exit.  Regular exit() will take care of flushing
			 * and closing stdio channels.
			 */</comment>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Postmaster subroutine to start a syslogger subprocess.
 */</comment>
<function><type><name>int</name></type>
<name>SysLogger_Start</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>loggerIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>sysloggerPid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Logging_collector</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If first time through, create the pipe which will receive stderr
	 * output.
	 *
	 * If the syslogger crashes and needs to be restarted, we continue to use
	 * the same pipe (indeed must do so, since extant backends will be writing
	 * into that pipe).
	 *
	 * This means the postmaster must continue to hold the read end of the
	 * pipe open, so we can pass it down to the reincarnated syslogger. This
	 * is a bit klugy but we have little choice.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_syslog_channel_is_inited</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>syslogChannels</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>MAX_SYSLOGGER_NUM</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>polar_syslog_channel_is_inited</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>loggerIndex</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>syslogPipe</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="line">// if (socketpair(AF_UNIX, SOCK_STREAM, 0, syslogPipe) &lt; 0)</comment>
	    		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
	    				<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
	    				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create pipe for syslog: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    </block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>syslogChannels</name><index>[<expr><name>loggerIndex</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>socketpair</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>syslogChannels</name><index>[<expr><name>loggerIndex</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create channels for syslog: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="line">// TODO(wormhole.gl): for WIN32</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SECURITY_ATTRIBUTES</name></type> <name>sa</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>nLength</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>bInheritHandle</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreatePipe</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">32768</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create pipe for syslog: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Create log directory if not present; ignore errors
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>MakePGDirectory</name><argument_list>(<argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The initial logfile is created right in the postmaster, to verify that
	 * the Log_directory is writable.  We save the reference time so that the
	 * syslogger child process can recompute this file name.
	 *
	 * It might look a bit strange to re-do this during a syslogger restart,
	 * but we must do so since the postmaster closed syslogFile after the
	 * previous fork (and remembering that old file wouldn't be right anyway).
	 * Note we always append here, we won't overwrite any existing file.  This
	 * is consistent with the normal rules, because by definition this is not
	 * a time-based rotation.
	 */</comment>
	<expr_stmt><expr><name>first_syslogger_file_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><name>SYSLOG_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>syslogFile</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Likewise for the initial CSV log file, if that's enabled.  (Note that
	 * we open syslogFile even when only CSV output is nominally enabled,
	 * since some code paths will write to syslogFile anyway.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><literal type="string">".csv"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>csvlogFile</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* POLAR */</comment>
	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_AUDITLOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><name>AUDITLOG_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>auditlogFile</name> <operator>=</operator> <call><name>logfile_open_with_buffer_mode</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, 
													 <argument><expr><call><name>FILE_BUF_MODE</name><argument_list>(<argument><expr><name>LOG_DESTINATION_POLAR_AUDITLOG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><name>SLOWLOG_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>slowlogFile</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<switch>switch <condition>(<expr><operator>(</operator><name>sysloggerPid</name> <operator>=</operator> <call><name>syslogger_forkexec</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<switch>switch <condition>(<expr><operator>(</operator><name>sysloggerPid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork system logger: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<comment type="block">/* in postmaster child ... */</comment>
			<expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Close the postmaster's sockets */</comment>
			<expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Drop our connection to postmaster's shared memory, as well */</comment>
			<expr_stmt><expr><call><name>dsm_detach_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PGSharedMemoryDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* do the work */</comment>
			<comment type="block">/* POLAR add one argv */</comment>
			<expr_stmt><expr><call><name>SysLoggerMain</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>loggerIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* POLAR end */</comment>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<default>default:</default>
			<comment type="block">/* success, in postmaster */</comment>

			<comment type="block">/* now we redirect stderr, if not done already */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>redirection_done</name></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
				<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<comment type="block">/*
				 * Leave a breadcrumb trail when redirecting, in case the user
				 * forgets that redirection is active and looks only at the
				 * original stderr target file.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"redirecting log output to logging collector process"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Future log output will appear in directory \"%s\"."</literal></expr></argument>,
								 <argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
				<if_stmt><if>if <condition>(<expr><name>loggerIndex</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> 
				<block>{<block_content>
					<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not redirect stdout: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not redirect stderr: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* Now we are done with the write end of the pipe. */</comment>
					<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if> 
				<else>else
				<block>{<block_content>
					<comment type="block">/* POLAR close index 1 */</comment>
					<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>syslogChannels</name><index>[<expr><name>loggerIndex</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>syslogChannels</name><index>[<expr><name>loggerIndex</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<comment type="block">/* POLAR end */</comment>
				</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

				<comment type="block">/*
				 * open the pipe in binary mode and make sure stderr is binary
				 * after it's been dup'ed into, to avoid disturbing the pipe
				 * chunking protocol.
				 */</comment>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>_open_osfhandle</name><argument_list>(<argument><expr><operator>(</operator><name>intptr_t</name><operator>)</operator> <name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name>_O_APPEND</name> <operator>|</operator> <name>_O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not redirect stderr: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Now we are done with the write end of the pipe.
				 * CloseHandle() must not be called because the preceding
				 * close() closes the underlying handle.
				 */</comment>
				<expr_stmt><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>redirection_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* postmaster will never write the file(s); close 'em */</comment>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>syslogFile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>csvlogFile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* POLAR */</comment>
			<if_stmt><if>if <condition>(<expr><name>auditlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>auditlogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>auditlogFile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>slowlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>slowlogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>slowlogFile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* POLAR end */</comment>
			<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>sysloggerPid</name></expr>;</return>
	</block_content>}</block></switch></block_content></block></switch>

	<comment type="block">/* we should never reach here */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

<comment type="block">/*
 * syslogger_forkexec() -
 *
 * Format up the arglist for, then fork and exec, a syslogger process
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>syslogger_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>filenobuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>csvfilenobuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"--forklog"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* filled in by postmaster_forkexec */</comment>

	<comment type="block">/* static variables (those not passed by write_backend_variables) */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name>syslogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filenobuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filenobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
				 <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>filenobuf</name></expr></argument>, <argument><expr><literal type="string">"-1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
	<if_stmt><if>if <condition>(<expr><name>syslogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filenobuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filenobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>_get_osfhandle</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>filenobuf</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>filenobuf</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
				 <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>, <argument><expr><literal type="string">"-1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
	<if_stmt><if>if <condition>(<expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>_get_osfhandle</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>csvfilenobuf</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>postmaster_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * syslogger_parseArgs() -
 *
 * Extract data from the arglist for exec'ed syslogger process
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>syslogger_parseArgs</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>argv</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-open the error output files that were opened by SysLogger_Start().
	 *
	 * We expect this will always succeed, which is too optimistic, but if it
	 * fails there's not a lot we can do to report the problem anyway.  As
	 * coded, we'll just crash on a null pointer dereference after failure...
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>syslogFile</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>csvlogFile</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>_open_osfhandle</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>_O_APPEND</name> <operator>|</operator> <name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>syslogFile</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>_open_osfhandle</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>_O_APPEND</name> <operator>|</operator> <name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>csvlogFile</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>


<comment type="block">/* --------------------------------
 *		pipe protocol handling
 * --------------------------------
 */</comment>

<comment type="block">/*
 * Process data received through the syslogger pipe.
 *
 * This routine interprets the log pipe protocol which sends log messages as
 * (hopefully atomic) chunks - such chunks are detected and reassembled here.
 *
 * The protocol has a header that starts with two nul bytes, then has a 16 bit
 * length, the pid of the sending process, and a flag to indicate if it is
 * the last chunk in a message. Incomplete chunks are saved until we read some
 * more, and non-final chunks are accumulated until we get the final chunk.
 *
 * All of this is to avoid 2 problems:
 * . partial messages being written to logfiles (messes rotation), and
 * . messages from different backends being interleaved (messages garbled).
 *
 * Any non-protocol messages are written out directly. These should only come
 * from non-PostgreSQL sources, however (e.g. third party libraries writing to
 * stderr).
 *
 * logbuffer is the data input buffer, and *bytes_in_logbuffer is the number
 * of bytes present.  On exit, any not-yet-eaten data is left-justified in
 * logbuffer, and *bytes_in_logbuffer is updated.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_pipe_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>logbuffer</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bytes_in_logbuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cursor</name> <init>= <expr><name>logbuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><operator>*</operator><name>bytes_in_logbuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dest</name> <init>= <expr><name>LOG_DESTINATION_STDERR</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* While we have enough for a header, process data... */</comment>
	<while>while <condition>(<expr><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name>offsetof</name><argument_list>(<argument><expr><name>PipeProtoHeader</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PipeProtoHeader</name></type> <name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>chunklen</name></decl>;</decl_stmt>

		<comment type="block">/* Do we have a valid header? */</comment>
		<comment type="block">/* POLAR: p.len is only uint16, not do any sanity check */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PipeProtoHeader</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>.</operator><name>nuls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>.</operator><name>nuls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
			<name><name>p</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>p</name><operator>.</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>||</operator> <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'f'</literal> <operator>||</operator>
			 <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'T'</literal> <operator>||</operator> <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'F'</literal> <operator>||</operator>
			 <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <name>AUDITLOG_CHUNK</name> <operator>||</operator> <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <name>AUDITLOG_LAST_CHUNK</name> <operator>||</operator>
			 <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <name>SLOWLOG_CHUNK</name> <operator>||</operator> <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <name>SLOWLOG_LAST_CHUNK</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>buffer_list</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>save_buffer</name> <modifier>*</modifier></type><name>existing_slot</name> <init>= <expr><name>NULL</name></expr></init></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>free_slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfo</name></type>	<name>str</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>chunklen</name> <operator>=</operator> <name>PIPE_HEADER_SIZE</name> <operator>+</operator> <name><name>p</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

			<comment type="block">/* Fall out of loop if we don't have the whole chunk yet */</comment>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>chunklen</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>get_dest_from_flag</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>is_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Locate any existing buffer for this source pid */</comment>
			<expr_stmt><expr><name>buffer_list</name> <operator>=</operator> <name><name>buffer_lists</name><index>[<expr><name><name>p</name><operator>.</operator><name>pid</name></name> <operator>%</operator> <name>NBUFFER_LISTS</name></expr>]</index></name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>buffer_list</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>save_buffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><name>save_buffer</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name><name>p</name><operator>.</operator><name>pid</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>existing_slot</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>free_slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>free_slot</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'f'</literal> <operator>||</operator> <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'F'</literal> <operator>||</operator>
				<name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <name>AUDITLOG_CHUNK</name> <operator>||</operator> <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <name>SLOWLOG_CHUNK</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Save a complete non-final chunk in a per-pid buffer
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>existing_slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Add chunk to data from preceding chunks */</comment>
					<expr_stmt><expr><name>str</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>existing_slot</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
										   <argument><expr><name>cursor</name> <operator>+</operator> <name>PIPE_HEADER_SIZE</name></expr></argument>,
										   <argument><expr><name><name>p</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* First chunk of message, save in a new buffer */</comment>
					<if_stmt><if>if <condition>(<expr><name>free_slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Need a free slot, but there isn't one in the list,
						 * so create a new one and extend the list with it.
						 */</comment>
						<expr_stmt><expr><name>free_slot</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>save_buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>buffer_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>buffer_list</name></expr></argument>, <argument><expr><name>free_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>buffer_lists</name><index>[<expr><name><name>p</name><operator>.</operator><name>pid</name></name> <operator>%</operator> <name>NBUFFER_LISTS</name></expr>]</index></name> <operator>=</operator> <name>buffer_list</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>free_slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>p</name><operator>.</operator><name>pid</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>str</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>free_slot</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
										   <argument><expr><name>cursor</name> <operator>+</operator> <name>PIPE_HEADER_SIZE</name></expr></argument>,
										   <argument><expr><name><name>p</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Final chunk --- add it to anything saved for that pid, and
				 * either way write the whole thing out.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>existing_slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>str</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>existing_slot</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
										   <argument><expr><name>cursor</name> <operator>+</operator> <name>PIPE_HEADER_SIZE</name></expr></argument>,
										   <argument><expr><name><name>p</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>write_syslogger_file</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Mark the buffer unused, and reclaim string storage */</comment>
					<expr_stmt><expr><name><name>existing_slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* The whole message was one chunk, evidently. */</comment>
					<expr_stmt><expr><call><name>write_syslogger_file</name><argument_list>(<argument><expr><name>cursor</name> <operator>+</operator> <name>PIPE_HEADER_SIZE</name></expr></argument>, <argument><expr><name><name>p</name><operator>.</operator><name>len</name></name></expr></argument>,
										 <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Finished processing this chunk */</comment>
			<expr_stmt><expr><name>cursor</name> <operator>+=</operator> <name>chunklen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name> <operator>-=</operator> <name>chunklen</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Process non-protocol data */</comment>

			<comment type="block">/*
			 * Look for the start of a protocol header.  If found, dump data
			 * up to there and repeat the loop.  Otherwise, dump it all and
			 * fall out of the loop.  (Note: we want to dump it all if at all
			 * possible, so as to avoid dividing non-protocol messages across
			 * logfiles.  We expect that in many scenarios, a non-protocol
			 * message will arrive all in one read(), and we want to respect
			 * the read() boundary if possible.)
			 */</comment>
			<for>for <control>(<init><expr><name>chunklen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>chunklen</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>chunklen</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>cursor</name><index>[<expr><name>chunklen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<comment type="block">/* fall back on the stderr log as the destination */</comment>
			<expr_stmt><expr><call><name>write_syslogger_file</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>chunklen</name></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cursor</name> <operator>+=</operator> <name>chunklen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name> <operator>-=</operator> <name>chunklen</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* We don't have a full chunk, so left-align what remains in the buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cursor</name> <operator>!=</operator> <name>logbuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>logbuffer</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>bytes_in_logbuffer</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Force out any buffered data
 *
 * This is currently used only at syslogger shutdown, but could perhaps be
 * useful at other times, so it is careful to leave things in a clean state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flush_pipe_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>logbuffer</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bytes_in_logbuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR audit log: notice that audit log is never larger than one chunk */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyLoggerIndex</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bytes_in_logbuffer</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_syslogger_file</name><argument_list>(<argument><expr><name>logbuffer</name></expr></argument>, <argument><expr><operator>*</operator><name>bytes_in_logbuffer</name></expr></argument>,
								 <argument><expr><name>LOG_DESTINATION_POLAR_AUDITLOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>flush_syslogger_file</name><argument_list>(<argument><expr><name>LOG_DESTINATION_POLAR_AUDITLOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>bytes_in_logbuffer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="line">// (TODO: wormhole.gl): It may write slow log into stderr...</comment>
	<comment type="block">/* Dump any incomplete protocol messages */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NBUFFER_LISTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><name><name>buffer_lists</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>save_buffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><name>save_buffer</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StringInfo</name></type>	<name>str</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>write_syslogger_file</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
									 <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Mark the buffer unused, and reclaim string storage */</comment>
				<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Force out any remaining pipe data as-is; we don't bother trying to
	 * remove any protocol headers that may exist in it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bytes_in_logbuffer</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file</name><argument_list>(<argument><expr><name>logbuffer</name></expr></argument>, <argument><expr><operator>*</operator><name>bytes_in_logbuffer</name></expr></argument>,
							 <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>flush_syslogger_file</name><argument_list>(<argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>bytes_in_logbuffer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *		logfile routines
 * --------------------------------
 */</comment>

<comment type="block">/*
 * Write text to the currently open logfile
 *
 * This is exported so that elog.c can call it when am_syslogger is true.
 * This allows the syslogger process to record elog messages of its own,
 * even though its stderr does not point at the syslog pipe.
 */</comment>
<function><type><name>void</name></type>
<name>write_syslogger_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>logfile</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're told to write to csvlogFile, but it's not open, dump the data
	 * to syslogFile (which is always open) instead.  This can happen if CSV
	 * output is enabled after postmaster start and we've been unable to open
	 * csvlogFile.  There are also race conditions during a parameter change
	 * whereby backends might send us CSV output before we open csvlogFile or
	 * after we close it.  Writing CSV-formatted output to the regular log
	 * file isn't great, but it beats dropping log output on the floor.
	 *
	 * Think not to improve this by trying to open csvlogFile on-the-fly.  Any
	 * failure in that would lead to recursion.
	 */</comment>
	<expr_stmt><expr><name>logfile</name> <operator>=</operator> <call><name>get_logfile_from_dest</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to report any failure.  We mustn't use ereport because it would
	 * just recurse right back here, but write_stderr is OK: it will write
	 * either to the postmaster's original stderr, or to /dev/null, but never
	 * to our input pipe which would result in a different sort of looping.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not write to log file: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<comment type="block">/*
 * Worker thread to transfer data from the pipe to the current logfile.
 *
 * We need this because on Windows, WaitforMultipleObjects does not work on
 * unnamed pipes: it always reports "signaled", so the blocking ReadFile won't
 * allow for SIGHUP; and select is for sockets only.
 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name> <name>__stdcall</name></type>
<name>pipeThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>logbuffer</name><index>[<expr><name>READ_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytes_in_logbuffer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DWORD</name></type>		<name>bytesRead</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BOOL</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ReadFile</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						  <argument><expr><name>logbuffer</name> <operator>+</operator> <name>bytes_in_logbuffer</name></expr></argument>,
						  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>logbuffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>bytes_in_logbuffer</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Enter critical section before doing anything that might touch
		 * global state shared by the main thread. Anything that uses
		 * palloc()/pfree() in particular are not safe outside the critical
		 * section.
		 */</comment>
		<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DWORD</name></type>		<name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <name>ERROR_HANDLE_EOF</name> <operator>||</operator>
				<name>error</name> <operator>==</operator> <name>ERROR_BROKEN_PIPE</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from logger pipe: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>bytesRead</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bytes_in_logbuffer</name> <operator>+=</operator> <name>bytesRead</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>process_pipe_input</name><argument_list>(<argument><expr><name>logbuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_in_logbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we've filled the current logfile, nudge the main thread to do a
		 * log rotation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>Log_RotationSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ftell</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>Log_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>||</operator>
				<operator>(</operator><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>Log_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We exit the above loop only upon detecting pipe EOF */</comment>
	<expr_stmt><expr><name>pipe_eof_seen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* if there's any data left then force it out now */</comment>
	<expr_stmt><expr><call><name>flush_pipe_input</name><argument_list>(<argument><expr><name>logbuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_in_logbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set the latch to waken the main thread, which will quit */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_endthread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * Open a new logfile with proper permissions and buffering options.
 *
 * If allow_errors is true, we just log any open failure and return NULL
 * (with errno still correct for the fopen failure).
 * Otherwise, errors are treated as fatal.
 */</comment>
<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>logfile_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_errors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mode_t</name></type>		<name>oumask</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note we do not let Log_file_mode disable IWUSR, since we certainly want
	 * to be able to write the files ourselves.
	 */</comment>
	<expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><operator>(</operator><name>mode_t</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>Log_file_mode</name> <operator>|</operator> <name>S_IWUSR</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>S_IRWXU</name> <operator>|</operator> <name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fh</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<comment type="block">/* use CRLF line endings on Windows */</comment>
		<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>allow_errors</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>FATAL</name></expr></else></ternary></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open log file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>fh</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * perform logfile rotation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>logfile_rotate</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>time_based_rotation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size_rotation_for</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>csvfilename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR */</comment>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>auditfilename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>slowlogfilename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR end */</comment>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>fntime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fh</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * When doing a time-based rotation, invent the new logfile name based on
	 * the planned rotation time, not current time, to avoid "slippage" in the
	 * file name when we don't do the rotation immediately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>time_based_rotation</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fntime</name> <operator>=</operator> <name>next_rotation_time</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fntime</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>fntime</name></expr></argument>, <argument><expr><name>SYSLOG_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>csvfilename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>fntime</name></expr></argument>, <argument><expr><literal type="string">".csv"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR */</comment>
	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_AUDITLOG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>auditfilename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>fntime</name></expr></argument>, <argument><expr><name>AUDITLOG_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>slowlogfilename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>fntime</name></expr></argument>, <argument><expr><name>SLOWLOG_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * Decide whether to overwrite or append.  We can overwrite if (a)
	 * Log_truncate_on_rotation is set, (b) the rotation was triggered by
	 * elapsed time and not something else, and (c) the computed file name is
	 * different from what we were previously logging into.
	 *
	 * Note: last_file_name should never be NULL here, but if it is, append.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>time_based_rotation</name> <operator>||</operator> <operator>(</operator><name>size_rotation_for</name> <operator>&amp;</operator> <name>LOG_DESTINATION_STDERR</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Log_truncate_on_rotation</name> <operator>&amp;&amp;</operator> <name>time_based_rotation</name> <operator>&amp;&amp;</operator>
			<name>last_file_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>last_file_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fh</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ENFILE/EMFILE are not too surprising on a busy system; just
			 * keep using the old file till we manage to get a new one.
			 * Otherwise, assume something's wrong with Log_directory and stop
			 * trying to create files.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENFILE</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EMFILE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling automatic rotation (use SIGHUP to re-enable)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotation_disabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>csvfilename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>csvfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>syslogFile</name> <operator>=</operator> <name>fh</name></expr>;</expr_stmt>

		<comment type="block">/* instead of pfree'ing filename, remember it for next time */</comment>
		<if_stmt><if>if <condition>(<expr><name>last_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>last_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>last_file_name</name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Same as above, but for csv file.  Note that if LOG_DESTINATION_CSVLOG
	 * was just turned on, we might have to open csvlogFile here though it was
	 * not open before.  In such a case we'll append not overwrite (since
	 * last_csv_file_name will be NULL); that is consistent with the normal
	 * rules since it's not a time-based rotation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>csvlogFile</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		 <name>time_based_rotation</name> <operator>||</operator> <operator>(</operator><name>size_rotation_for</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Log_truncate_on_rotation</name> <operator>&amp;&amp;</operator> <name>time_based_rotation</name> <operator>&amp;&amp;</operator>
			<name>last_csv_file_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>csvfilename</name></expr></argument>, <argument><expr><name>last_csv_file_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>csvfilename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>csvfilename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fh</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ENFILE/EMFILE are not too surprising on a busy system; just
			 * keep using the old file till we manage to get a new one.
			 * Otherwise, assume something's wrong with Log_directory and stop
			 * trying to create files.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENFILE</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EMFILE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling automatic rotation (use SIGHUP to re-enable)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotation_disabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>csvfilename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>csvfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>csvlogFile</name> <operator>=</operator> <name>fh</name></expr>;</expr_stmt>

		<comment type="block">/* instead of pfree'ing filename, remember it for next time */</comment>
		<if_stmt><if>if <condition>(<expr><name>last_csv_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>last_csv_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>last_csv_file_name</name> <operator>=</operator> <name>csvfilename</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>csvfilename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* CSVLOG was just turned off, so close the old file */</comment>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>csvlogFile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>last_csv_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>last_csv_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>last_csv_file_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* POLAR */</comment>
	<comment type="block">/*
	 * Same as above, but for audit file.  Note that if LOG_DESTINATION_POLAR_AUDITLOG
	 * was just turned on, we might have to open auditlogFile here though it was
	 * not open before.  In such a case we'll append not overwrite (since
	 * polar_last_audit_file_name will be NULL); that is consistent with the normal
	 * rules since it's not a time-based rotation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_AUDITLOG</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>auditlogFile</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		 <name>time_based_rotation</name> <operator>||</operator> <operator>(</operator><name>size_rotation_for</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_AUDITLOG</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Log_truncate_on_rotation</name> <operator>&amp;&amp;</operator> <name>time_based_rotation</name> <operator>&amp;&amp;</operator>
			<name>polar_last_audit_file_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>auditfilename</name></expr></argument>, <argument><expr><name>polar_last_audit_file_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>logfile_open_with_buffer_mode</name><argument_list>(<argument><expr><name>auditfilename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, 
											   <argument><expr><call><name>FILE_BUF_MODE</name><argument_list>(<argument><expr><name>LOG_DESTINATION_POLAR_AUDITLOG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>logfile_open_with_buffer_mode</name><argument_list>(<argument><expr><name>auditfilename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, 
											   <argument><expr><call><name>FILE_BUF_MODE</name><argument_list>(<argument><expr><name>LOG_DESTINATION_POLAR_AUDITLOG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fh</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ENFILE/EMFILE are not too surprising on a busy system; just
			 * keep using the old file till we manage to get a new one.
			 * Otherwise, assume something's wrong with Log_directory and stop
			 * trying to create files.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENFILE</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EMFILE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling automatic rotation (use SIGHUP to re-enable)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotation_disabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>auditfilename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>auditfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>auditlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>auditlogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>auditlogFile</name> <operator>=</operator> <name>fh</name></expr>;</expr_stmt>

		<comment type="block">/* instead of pfree'ing filename, remember it for next time */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_last_audit_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>polar_last_audit_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>polar_last_audit_file_name</name> <operator>=</operator> <name>auditfilename</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>auditfilename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_AUDITLOG</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name>auditlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* AUDITLOG was just turned off, so close the old file */</comment>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>auditlogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>auditlogFile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>polar_last_audit_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>polar_last_audit_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>polar_last_audit_file_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Same as above, but for slowlog file.  Note that if LOG_DESTINATION_POLAR_SLOWLOG
	 * was just turned on, we might have to open slowlogFile here though it was
	 * not open before.  In such a case we'll append not overwrite (since
	 * polar_last_slowlog_file_name will be NULL); that is consistent with the normal
	 * rules since it's not a time-based rotation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>slowlogFile</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		 <name>time_based_rotation</name> <operator>||</operator> <operator>(</operator><name>size_rotation_for</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Log_truncate_on_rotation</name> <operator>&amp;&amp;</operator> <name>time_based_rotation</name> <operator>&amp;&amp;</operator>
			<name>polar_last_slowlog_file_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>slowlogfilename</name></expr></argument>, <argument><expr><name>polar_last_slowlog_file_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>slowlogfilename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>slowlogfilename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fh</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ENFILE/EMFILE are not too surprising on a busy system; just
			 * keep using the old file till we manage to get a new one.
			 * Otherwise, assume something's wrong with Log_directory and stop
			 * trying to create files.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENFILE</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EMFILE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling automatic rotation (use SIGHUP to re-enable)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotation_disabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>slowlogfilename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>slowlogfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>slowlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>slowlogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>slowlogFile</name> <operator>=</operator> <name>fh</name></expr>;</expr_stmt>

		<comment type="block">/* instead of pfree'ing filename, remember it for next time */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_last_slowlog_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>polar_last_slowlog_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>polar_last_slowlog_file_name</name> <operator>=</operator> <name>slowlogfilename</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slowlogfilename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name>slowlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* SLOWLOG was just turned off, so close the old file */</comment>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>slowlogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slowlogFile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>polar_last_slowlog_file_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>polar_last_slowlog_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>polar_last_slowlog_file_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>auditfilename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>auditfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>slowlogfilename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>slowlogfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>csvfilename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>csvfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>update_metainfo_datafile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_next_rotation_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * construct logfile name using timestamp information
 *
 * If suffix isn't NULL, append it to the name, replacing any ".log"
 * that may be in the pattern.
 *
 * Result is palloc'd.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>logfile_getname</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>loggerIndexStr</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* treat Log_filename as a strftime pattern */</comment>
	<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>Log_filename</name></expr></argument>,
				<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timestamp</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>suffix</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="string">".log"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* POLAR: add log index to log file name */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>AUDITLOG_SUFFIX</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>loggerIndexStr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"_%d"</literal></expr></argument>, <argument><expr><name>MyLoggerIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>loggerIndexStr</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* POLAR END */</comment>

		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt> 

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filename</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>filename</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the next planned rotation time, and store in next_rotation_time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_next_rotation_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rotinterval</name></decl>;</decl_stmt>

	<comment type="block">/* nothing to do if time-based rotation is disabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>Log_RotationAge</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The requirements here are to choose the next time &gt; now that is a
	 * "multiple" of the log rotation interval.  "Multiple" can be interpreted
	 * fairly loosely.  In this version we align to log_timezone rather than
	 * GMT.
	 */</comment>
	<expr_stmt><expr><name>rotinterval</name> <operator>=</operator> <name>Log_RotationAge</name> <operator>*</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>	<comment type="block">/* convert to seconds */</comment>
	<expr_stmt><expr><name>now</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>now</name> <operator>+=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>now</name> <operator>-=</operator> <name>now</name> <operator>%</operator> <name>rotinterval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>now</name> <operator>+=</operator> <name>rotinterval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>now</name> <operator>-=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_rotation_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Store the name of the file(s) where the log collector, when enabled, writes
 * log messages.  Useful for finding the name(s) of the current log file(s)
 * when there is time-based logfile rotation.  Filenames are stored in a
 * temporary file and which is renamed into the final destination for
 * atomicity.  The file is opened with the same permissions as what gets
 * created in the data directory and has proper buffering options.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_metainfo_datafile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mode_t</name></type>		<name>oumask</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyLoggerIndex</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_STDERR</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_AUDITLOG</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>LOG_METAINFO_DATAFILE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>LOG_METAINFO_DATAFILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* use the same permissions as the data directory for the new file */</comment>
	<expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><name>pg_mode_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fh</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<comment type="block">/* use CRLF line endings on Windows */</comment>
		<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>last_file_name</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_STDERR</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><literal type="string">"stderr %s\n"</literal></expr></argument>, <argument><expr><name>last_file_name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>last_csv_file_name</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><literal type="string">"csvlog %s\n"</literal></expr></argument>, <argument><expr><name>last_csv_file_name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* POLAR */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_last_audit_file_name</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_AUDITLOG</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><literal type="string">"auditlog %s\n"</literal></expr></argument>, <argument><expr><name>polar_last_audit_file_name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_last_slowlog_file_name</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><literal type="string">"slowlog %s\n"</literal></expr></argument>, <argument><expr><name>polar_last_slowlog_file_name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>, <argument><expr><name>LOG_METAINFO_DATAFILE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename file \"%s\" to \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>, <argument><expr><name>LOG_METAINFO_DATAFILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		signal handler routines
 * --------------------------------
 */</comment>

<comment type="block">/* SIGHUP: set flag to reload config file */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGUSR1: set flag to rotate logfile */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: remove oldest log file
 *
 * Remove oldest log file from log directory
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_remove_old_syslog_files</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>logdir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>logde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>oldest_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> 		<name><name>oldest_auditlog_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>oldest_slowlog_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_log_files</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>num_auditlog_files</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>num_slowlog_files</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>log_prefix_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if polar_max_log_files is disabled, we should skip it */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_max_log_files</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> 
			<name>polar_max_auditlog_files</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>polar_max_slowlog_files</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>logdir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>logdir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open error log directory \"%s\": %m"</literal></expr></argument>,
					 <argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get first '%' postion in log_filename, NB:this is a single line */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>Log_filename</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name><name>Log_filename</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'%'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
	<comment type="block">/* save first '%' postion */</comment>
	<expr_stmt><expr><name>log_prefix_pos</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

	<comment type="block">/* Init our result path, mark it invalid */</comment>
	<expr_stmt><expr><name><name>oldest_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oldest_auditlog_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>oldest_slowlog_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>logde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>logdir</name></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Skip special stuff */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>logde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>logde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * skip not pg log prefix file and choose minimum log file name.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>logde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>Log_filename</name></expr></argument>, <argument><expr><name>log_prefix_pos</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* increase log file num */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>logde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>AUDITLOG_SUFFIX</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* audit log */</comment>
				<expr_stmt><expr><name>num_auditlog_files</name> <operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>oldest_auditlog_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> 
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>logde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>oldest_auditlog_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* save it */</comment>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>oldest_auditlog_path</name></expr></argument>, <argument><expr><name><name>logde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>logde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>SLOWLOG_SUFFIX</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* slow log */</comment>
				<expr_stmt><expr><name>num_slowlog_files</name> <operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>oldest_slowlog_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> 
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>logde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>oldest_slowlog_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* save it */</comment>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>oldest_slowlog_path</name></expr></argument>, <argument><expr><name><name>logde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>num_log_files</name> <operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>oldest_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>logde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>oldest_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* save it */</comment>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>oldest_path</name></expr></argument>, <argument><expr><name><name>logde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>num_auditlog_files</name> <operator>&lt;=</operator> <name>polar_max_auditlog_files</name> 
		<operator>&amp;&amp;</operator> <name>num_log_files</name> <operator>&lt;=</operator> <name>polar_max_log_files</name>
		<operator>&amp;&amp;</operator> <name>num_slowlog_files</name> <operator>&lt;=</operator> <name>polar_max_slowlog_files</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>logdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_max_auditlog_files</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>num_auditlog_files</name> <operator>&gt;</operator> <name>polar_max_auditlog_files</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>oldest_auditlog_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"attempting to remove oldest audit log file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_remove_log_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_max_slowlog_files</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>num_slowlog_files</name> <operator>&gt;</operator> <name>polar_max_slowlog_files</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>oldest_slowlog_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"attempting to remove oldest slow log file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_remove_log_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_max_log_files</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>num_log_files</name> <operator>&gt;</operator> <name>polar_max_log_files</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>oldest_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"attempting to remove oldest log file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_remove_log_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>logdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * remove file
 */</comment> 
<function><type><specifier>static</specifier> <name>void</name></type> 
<name>polar_remove_log_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name></type> <name><name>newpath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * On Windows, if another process (e.g another backend)
	 * holds the file open in FILE_SHARE_DELETE mode, unlink
	 * will succeed, but the file will still show up in
	 * directory listing until the last handle is closed. To
	 * avoid confusing the lingering deleted file for a live
	 * WAL file that needs to be archived, rename it before
	 * deleting it.
	 *
	 * If another process holds the file open without
	 * FILE_SHARE_DELETE flag, rename will fail. We'll try
	 * again at the next checkpoint.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s.deleted"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>newpath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
			<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename old error log file \"%s\": %m"</literal></expr></argument>,
				<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
			<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove old error log file \"%s\": %m"</literal></expr></argument>,
				<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/* POLAR */</comment>
<comment type="block">/*
 * flush log buffer
 */</comment>
<function><type><name>void</name></type>
<name>flush_syslogger_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>destination</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>logfile</name> <init>= <expr><call><name>get_logfile_from_dest</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Just a copy of logfile_open, add buffer_mode parameter */</comment>
<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>logfile_open_with_buffer_mode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_errors</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>buffer_mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mode_t</name></type>		<name>oumask</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note we do not let Log_file_mode disable IWUSR, since we certainly want
	 * to be able to write the files ourselves.
	 */</comment>
	<expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><operator>(</operator><name>mode_t</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>Log_file_mode</name> <operator>|</operator> <name>S_IWUSR</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>S_IRWXU</name> <operator>|</operator> <name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fh</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buffer_mode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<comment type="block">/* use CRLF line endings on Windows */</comment>
		<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>allow_errors</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>FATAL</name></expr></else></ternary></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open log file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>fh</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get log destination from chunk meta
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> 
<name>get_dest_from_flag</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>flag</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
	<switch>switch<condition>(<expr><name>flag</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'T'</literal></expr>:</case>
		<case>case <expr><literal type="char">'F'</literal></expr>:</case>
			<return>return <expr><name>LOG_DESTINATION_CSVLOG</name></expr>;</return>
		<case>case <expr><name>AUDITLOG_CHUNK</name></expr>:</case>
		<case>case <expr><name>AUDITLOG_LAST_CHUNK</name></expr>:</case>
			<return>return <expr><name>LOG_DESTINATION_POLAR_AUDITLOG</name></expr>;</return>
		<case>case <expr><name>SLOWLOG_CHUNK</name></expr>:</case>
		<case>case <expr><name>SLOWLOG_LAST_CHUNK</name></expr>:</case>
			<return>return <expr><name>LOG_DESTINATION_POLAR_SLOWLOG</name></expr>;</return>
		<case>case <expr><literal type="char">'t'</literal></expr>:</case>
		<case>case <expr><literal type="char">'f'</literal></expr>:</case>
		<default>default:</default>
			<return>return <expr><name>LOG_DESTINATION_STDERR</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * get logfile handler from destinaction
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>get_logfile_from_dest</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>destination</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>destination</name> <operator>==</operator> <name>LOG_DESTINATION_CSVLOG</name> <operator>&amp;&amp;</operator> <name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>csvlogFile</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>destination</name> <operator>==</operator> <name>LOG_DESTINATION_POLAR_AUDITLOG</name> <operator>&amp;&amp;</operator> <name>auditlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>auditlogFile</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>destination</name> <operator>==</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name> <operator>&amp;&amp;</operator> <name>slowlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>slowlogFile</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>syslogFile</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment>
</unit>
