<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/postmaster/bgworker.c"><comment type="block">/*--------------------------------------------------------------------
 * bgworker.c
 *		POSTGRES pluggable background workers implementation
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/postmaster/bgworker.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicallauncher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicalworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ascii.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/polar_coredump.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_async_ddl_lock_replay.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/polar_parallel_bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_procpool.h"</cpp:file></cpp:include>

<comment type="block">/*
 * The postmaster's list of registered background workers, in private memory.
 */</comment>
<decl_stmt><decl><type><name>slist_head</name></type>	<name>BackgroundWorkerList</name> <init>= <expr><call><name>SLIST_STATIC_INIT</name><argument_list>(<argument><expr><name>BackgroundWorkerList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RegisterBackgroundWorkerEx</name><parameter_list>(<parameter><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * BackgroundWorkerSlots exist in shared memory and can be accessed (via
 * the BackgroundWorkerArray) by both the postmaster and by regular backends.
 * However, the postmaster cannot take locks, even spinlocks, because this
 * might allow it to crash or become wedged if shared memory gets corrupted.
 * Such an outcome is intolerable.  Therefore, we need a lockless protocol
 * for coordinating access to this data.
 *
 * The 'in_use' flag is used to hand off responsibility for the slot between
 * the postmaster and the rest of the system.  When 'in_use' is false,
 * the postmaster will ignore the slot entirely, except for the 'in_use' flag
 * itself, which it may read.  In this state, regular backends may modify the
 * slot.  Once a backend sets 'in_use' to true, the slot becomes the
 * responsibility of the postmaster.  Regular backends may no longer modify it,
 * but the postmaster may examine it.  Thus, a backend initializing a slot
 * must fully initialize the slot - and insert a write memory barrier - before
 * marking it as in use.
 *
 * As an exception, however, even when the slot is in use, regular backends
 * may set the 'terminate' flag for a slot, telling the postmaster not
 * to restart it.  Once the background worker is no longer running, the slot
 * will be released for reuse.
 *
 * In addition to coordinating with the postmaster, backends modifying this
 * data structure must coordinate with each other.  Since they can take locks,
 * this is straightforward: any backend wishing to manipulate a slot must
 * take BackgroundWorkerLock in exclusive mode.  Backends wishing to read
 * data that might get concurrently modified by other backends should take
 * this lock in shared mode.  No matter what, backends reading this data
 * structure must be able to tolerate concurrent modifications by the
 * postmaster.
 */</comment>
<typedef>typedef <type><struct>struct <name>BackgroundWorkerSlot</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>in_use</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>terminate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>			<comment type="block">/* InvalidPid = not started yet; 0 = dead */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>generation</name></decl>;</decl_stmt>		<comment type="block">/* incremented when slot is recycled */</comment>
	<decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name></decl>;</decl_stmt>
}</block></struct></type> <name>BackgroundWorkerSlot</name>;</typedef>

<comment type="block">/*
 * In order to limit the total number of parallel workers (according to
 * max_parallel_workers GUC), we maintain the number of active parallel
 * workers.  Since the postmaster cannot take locks, two variables are used for
 * this purpose: the number of registered parallel workers (modified by the
 * backends, protected by BackgroundWorkerLock) and the number of terminated
 * parallel workers (modified only by the postmaster, lockless).  The active
 * number of parallel workers is the number of registered workers minus the
 * terminated ones.  These counters can of course overflow, but it's not
 * important here since the subtraction will still give the right number.
 */</comment>
<typedef>typedef <type><struct>struct <name>BackgroundWorkerArray</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>total_slots</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>parallel_register_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>parallel_terminate_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorkerSlot</name></type> <name><name>slot</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>BackgroundWorkerArray</name>;</typedef>

<struct>struct <name>BackgroundWorkerHandle</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>generation</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>BackgroundWorkerArray</name> <modifier>*</modifier></type><name>BackgroundWorkerData</name></decl>;</decl_stmt>

<comment type="block">/*
 * List of internal background worker entry points.  We need this for
 * reasons explained in LookupBackgroundWorkerFunction(), below.
 */</comment>
<struct><specifier>static</specifier> <specifier>const</specifier> struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fn_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bgworker_main_type</name></type> <name>fn_addr</name></decl>;</decl_stmt>
}</block>			<decl><name><name>InternalBGWorkers</name><index>[]</index></name> <init>=

<expr><block>{
	<expr><block>{
		<expr><literal type="string">"ParallelWorkerMain"</literal></expr>, <expr><name>ParallelWorkerMain</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"ApplyLauncherMain"</literal></expr>, <expr><name>ApplyLauncherMain</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"ApplyWorkerMain"</literal></expr>, <expr><name>ApplyWorkerMain</name></expr>
	}</block></expr>,

	<comment type="block">/* POLAR */</comment>
	<expr><block>{
		<expr><literal type="string">"polar_parallel_bgwriter_worker_main"</literal></expr>, <expr><name>polar_parallel_bgwriter_worker_main</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"polar_async_ddl_lock_replay_worker_main"</literal></expr>, <expr><name>polar_async_ddl_lock_replay_worker_main</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"polar_sub_task_main"</literal></expr>, <expr><name>polar_sub_task_main</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</struct>

<comment type="block">/* Private functions. */</comment>
<function_decl><type><specifier>static</specifier> <name>bgworker_main_type</name></type> <name>LookupBackgroundWorkerFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libraryname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Calculate shared memory needed.
 */</comment>
<function><type><name>Size</name></type>
<name>BackgroundWorkerShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* Array of workers is variably sized. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>BackgroundWorkerArray</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>max_worker_processes</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackgroundWorkerSlot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize shared memory.
 */</comment>
<function><type><name>void</name></type>
<name>BackgroundWorkerShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>BackgroundWorkerData</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Background Worker Data"</literal></expr></argument>,
										   <argument><expr><call><name>BackgroundWorkerShmemSize</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>slist_iter</name></type>	<name>siter</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>total_slots</name></name> <operator>=</operator> <name>max_worker_processes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_register_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_terminate_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Copy contents of worker list into shared memory.  Record the shared
		 * memory slot assigned to each worker.  This ensures a 1-to-1
		 * correspondence between the postmaster's private list and the array
		 * in shared memory.
		 */</comment>
		<macro><name>slist_foreach</name><argument_list>(<argument>siter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>siter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slotno</name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>terminate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>generation</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* might be reinit after crash */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackgroundWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>slotno</name></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Mark any remaining slots as not in use.
		 */</comment>
		<while>while <condition>(<expr><name>slotno</name> <operator>&lt;</operator> <name>max_worker_processes</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name>slotno</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Search the postmaster's backend-private list of RegisteredBgWorker objects
 * for the one that maps to the given slot number.
 */</comment>
<function><type><specifier>static</specifier> <name>RegisteredBgWorker</name> <modifier>*</modifier></type>
<name>FindRegisteredWorkerBySlotNumber</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>slist_iter</name></type>	<name>siter</name></decl>;</decl_stmt>

	<macro><name>slist_foreach</name><argument_list>(<argument>siter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>siter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>==</operator> <name>slotno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>rw</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Notice changes to shared memory made by other backends.  This code
 * runs in the postmaster, so we must be very careful not to assume that
 * shared memory contents are sane.  Otherwise, a rogue backend could take
 * out the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>BackgroundWorkerStateChange</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The total number of slots stored in shared memory should match our
	 * notion of max_worker_processes.  If it does not, something is very
	 * wrong.  Further down, we always refer to this value as
	 * max_worker_processes, in case shared memory gets corrupted while we're
	 * looping.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>max_worker_processes</name> <operator>!=</operator> <name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>total_slots</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"inconsistent background worker state (max_worker_processes=%d, total_slots=%d"</literal></expr></argument>,
			 <argument><expr><name>max_worker_processes</name></expr></argument>,
			 <argument><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>total_slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Iterate through slots, looking for newly-registered workers or workers
	 * who must die.
	 */</comment>
	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name>max_worker_processes</name></expr>;</condition> <incr><expr><operator>++</operator><name>slotno</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Make sure we don't see the in_use flag before the updated slot
		 * contents.
		 */</comment>
		<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* See whether we already know about this worker. */</comment>
		<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>FindRegisteredWorkerBySlotNumber</name><argument_list>(<argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rw</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In general, the worker data can't change after it's initially
			 * registered.  However, someone can set the terminate flag.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>terminate</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Report never-started, now-terminated worker as dead. */</comment>
					<expr_stmt><expr><call><name>ReportBackgroundWorkerPID</name><argument_list>(<argument><expr><name>rw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the worker is marked for termination, we don't need to add it to
		 * the registered workers list; we can just free the slot. However, if
		 * bgw_notify_pid is set, the process that registered the worker may
		 * need to know that we've processed the terminate request, so be sure
		 * to signal it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>terminate</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>notify_pid</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We need a memory barrier here to make sure that the load of
			 * bgw_notify_pid and the update of parallel_terminate_count
			 * complete before the store to in_use.
			 */</comment>
			<expr_stmt><expr><name>notify_pid</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_CLASS_PARALLEL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_terminate_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pg_memory_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>notify_pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>notify_pid</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Copy the registration data into the registered workers list.
		 */</comment>
		<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rw</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Copy strings in a paranoid way.  If shared memory is corrupted, the
		 * source data might not even be NUL-terminated.
		 */</comment>
		<expr_stmt><expr><call><name>ascii_safe_strlcpy</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>,
						   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ascii_safe_strlcpy</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_type</name></name></expr></argument>,
						   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_type</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ascii_safe_strlcpy</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>,
						   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ascii_safe_strlcpy</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>,
						   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Copy various fixed-size fields.
		 *
		 * flags, start_time, and restart_time are examined by the postmaster,
		 * but nothing too bad will happen if they are corrupted.  The
		 * remaining fields will only be examined by the child process.  It
		 * might crash, but we won't.
		 */</comment>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_flags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_start_time</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_main_arg</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_main_arg</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><name>BGW_EXTRALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Copy the PID to be notified about state changes, but only if the
		 * postmaster knows about a backend with that PID.  It isn't an error
		 * if the postmaster doesn't know about the PID, because the backend
		 * that requested the worker could have died (or been killed) just
		 * after doing so.  Nonetheless, at least until we get some experience
		 * with how this plays out in the wild, log a message at a relative
		 * high debug level.
		 */</comment>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterMarkPIDForWorkerNotify</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"worker notification PID %lu is not valid"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Initialize postmaster bookkeeping. */</comment>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_child_slot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Log it! */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"registering background worker \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>slist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BackgroundWorkerList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_lnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Forget about a background worker that's no longer needed.
 *
 * The worker must be identified by passing an slist_mutable_iter that
 * points to it.  This convention allows deletion of workers during
 * searches of the worker list, and saves having to search the list again.
 *
 * This function must be invoked only in the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>ForgetBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>slist_mutable_iter</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_CLASS_PARALLEL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_terminate_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unregistering background worker \"%s\""</literal></expr></argument>,
					<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>slist_delete_current</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>rw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report the PID of a newly-launched background worker in shared memory.
 *
 * This function should only be called from the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>ReportBackgroundWorkerPID</name><parameter_list>(<parameter><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report that the PID of a background worker is now zero because a
 * previously-running background worker has exited.
 *
 * This function should only be called from the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>ReportBackgroundWorkerExit</name><parameter_list>(<parameter><decl><type><name>slist_mutable_iter</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>notify_pid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_shmem_slot</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>notify_pid</name> <operator>=</operator> <name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this worker is slated for deregistration, do that before notifying
	 * the process which started it.  Otherwise, if that process tries to
	 * reuse the slot immediately, it might not be available yet.  In theory
	 * that could happen anyway if the process checks slot-&gt;pid at just the
	 * wrong moment, but this makes the window narrower.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name> <operator>||</operator>
		<name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>==</operator> <name>BGW_NEVER_RESTART</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ForgetBackgroundWorker</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>notify_pid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>notify_pid</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cancel SIGUSR1 notifications for a PID belonging to an exiting backend.
 *
 * This function should only be called from the postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>BackgroundWorkerStopNotifications</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>slist_iter</name></type>	<name>siter</name></decl>;</decl_stmt>

	<macro><name>slist_foreach</name><argument_list>(<argument>siter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>siter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Reset background worker crash state.
 *
 * We assume that, after a crash-and-restart cycle, background workers without
 * the never-restart flag should be restarted immediately, instead of waiting
 * for bgw_restart_time to elapse.
 */</comment>
<function><type><name>void</name></type>
<name>ResetBackgroundWorkerCrashTimes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>slist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<macro><name>slist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;BackgroundWorkerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>slist_container</name><argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>, <argument><expr><name>rw_lnode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>==</operator> <name>BGW_NEVER_RESTART</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Workers marked BGW_NVER_RESTART shouldn't get relaunched after
			 * the crash, so forget about them.  (If we wait until after the
			 * crash to forget about them, and they are parallel workers,
			 * parallel_terminate_count will get incremented after we've
			 * already zeroed parallel_register_count, which would be bad.)
			 */</comment>
			<expr_stmt><expr><call><name>ForgetBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The accounting which we do via parallel_register_count and
			 * parallel_terminate_count would get messed up if a worker marked
			 * parallel could survive a crash and restart cycle. All such
			 * workers should be marked BGW_NEVER_RESTART, and thus control
			 * should never reach this branch.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_CLASS_PARALLEL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Allow this worker to be restarted immediately after we finish
			 * resetting.
			 */</comment>
			<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<comment type="block">/*
 * In EXEC_BACKEND mode, workers use this to retrieve their details from
 * shared memory.
 */</comment>
<function><type><name>BackgroundWorker</name> <modifier>*</modifier></type>
<name>BackgroundWorkerEntry</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>BackgroundWorker</name></type> <name>myEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slotno</name> <operator>&lt;</operator> <name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>total_slots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* must copy this in case we don't intend to retain shmem access */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name>myEntry</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name>myEntry</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Complain about the BackgroundWorker definition using error level elevel.
 * Return true if it looks ok, false if not (unless elevel &gt;= ERROR, in
 * which case we won't return at all in the not-OK case).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SanityCheckBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* sanity check for flags */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_SHMEM_ACCESS</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": must attach to shared memory in order to request a database connection"</literal></expr></argument>,
							<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_start_time</name></name> <operator>==</operator> <name>BgWorkerStart_PostmasterStart</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": cannot request database access if starting at postmaster start"</literal></expr></argument>,
							<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* XXX other checks? */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_restart_time</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		 <name><name>worker</name><operator>-&gt;</operator><name>bgw_restart_time</name></name> <operator>!=</operator> <name>BGW_NEVER_RESTART</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_restart_time</name></name> <operator>&gt;</operator> <name>USECS_PER_DAY</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": invalid restart interval"</literal></expr></argument>,
						<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Parallel workers may not be configured for restart, because the
	 * parallel_register_count/parallel_terminate_count accounting can't
	 * handle parallel workers lasting through a crash-and-restart cycle.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_restart_time</name></name> <operator>!=</operator> <name>BGW_NEVER_RESTART</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_CLASS_PARALLEL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": parallel workers may not be configured for restart"</literal></expr></argument>,
						<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If bgw_type is not filled in, use bgw_name.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_type</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_type</name></name></expr></argument>, <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bgworker_quickdie</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We DO NOT want to run proc_exit() or atexit() callbacks -- we're here
	 * because shared memory may be corrupted, so we don't want to try to
	 * clean up our transaction.  Just nail the windows shut and get out of
	 * town.  The callbacks wouldn't be safe to run from a signal handler,
	 * anyway.
	 *
	 * Note we do _exit(2) not _exit(0).  This is to force the postmaster into
	 * a system reset cycle if someone sends a manual SIGQUIT to a random
	 * backend.  This is necessary precisely because we don't clean up our
	 * shared memory state.  (The "dead man switch" mechanism in pmsignal.c
	 * should ensure the postmaster sees this as a crash, too, but no harm in
	 * being doubly sure.)
	 */</comment>
	<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Standard SIGTERM handler for background workers
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bgworker_die</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating background worker \"%s\" due to administrator command"</literal></expr></argument>,
					<argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Standard SIGUSR1 handler for unconnected workers
 *
 * Here, we want to make sure an unconnected worker will at least heed
 * latch activity.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bgworker_sigusr1_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>latch_sigusr1_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start a new background worker
 *
 * This is the main entry point for background worker, to be called from
 * postmaster.
 */</comment>
<function><type><name>void</name></type>
<name>StartBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sigjmp_buf</name></type>	<name>local_sigjmp_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><name>MyBgworkerEntry</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bgworker_main_type</name></type> <name>entrypt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>worker</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"unable to find bgworker entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>IsBackgroundWorker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Identify myself via ps */</comment>
	<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're not supposed to have shared memory access, then detach from
	 * shared memory.  If we didn't request shared memory access, the
	 * postmaster won't force a cluster-wide restart if we exit unexpectedly,
	 * so we'd better make sure that we don't mess anything up that would
	 * require that sort of cleanup.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_SHMEM_ACCESS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dsm_detach_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PGSharedMemoryDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>InitProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Apply PostAuthDelay */</comment>
	<if_stmt><if>if <condition>(<expr><name>PostAuthDelay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>PostAuthDelay</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set up signal handlers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * SIGINT is used to signal canceling the current action
		 */</comment>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>procsignal_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>FloatExceptionHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* XXX Any other handlers needed here? */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>bgworker_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>bgworker_die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>bgworker_quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* establishes SIGALRM handler */</comment>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR : register for coredump print */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGILL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>, <argument><expr><name>polar_program_error_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGSEGV</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>, <argument><expr><name>polar_program_error_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGBUS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>, <argument><expr><name>polar_program_error_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* _WIN32 */</comment>
	<comment type="block">/* POLAR: end */</comment>

	<comment type="block">/*
	 * If an exception is encountered, processing resumes here.
	 *
	 * See notes in postgres.c about the design of this coding.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Since not using PG_TRY, must reset error stack by hand */</comment>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Prevent interrupts while cleaning up */</comment>
		<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Report the error to the server log */</comment>
		<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do we need more cleanup here?  For shmem-connected bgworkers, we
		 * will call InitProcess below, which will install ProcKill as exit
		 * callback.  That will take care of releasing locks, etc.
		 */</comment>

		<comment type="block">/* and go away */</comment>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We can now handle ereport(ERROR) */</comment>
	<expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the background worker request shared memory access, set that up now;
	 * else, detach all shared memory segments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_SHMEM_ACCESS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Early initialization.  Some of this could be useful even for
		 * background workers that aren't using shared memory, but they can
		 * call the individual startup routines for those subsystems if
		 * needed.
		 */</comment>
		<expr_stmt><expr><call><name>BaseInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create a per-backend PGPROC struct in shared memory, except in the
		 * EXEC_BACKEND case where this was done in SubPostmasterMain. We must
		 * do this before we can use LWLocks (and in the EXEC_BACKEND case we
		 * already had to do some stuff with LWLocks).
		 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
		<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look up the entry point function, loading its library if necessary.
	 */</comment>
	<expr_stmt><expr><name>entrypt</name> <operator>=</operator> <call><name>LookupBackgroundWorkerFunction</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_library_name</name></name></expr></argument>,
											 <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_function_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that in normal processes, we would call InitPostgres here.  For a
	 * worker, however, we don't know what database to connect to, yet; so we
	 * need to wait until the user code does it via
	 * BackgroundWorkerInitializeConnection().
	 */</comment>

	<comment type="block">/*
	 * Now invoke the user-defined worker code
	 */</comment>
	<expr_stmt><expr><call><name>entrypt</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_main_arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... and if it returns, we're done */</comment>
	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR add polar_mount_process check */</comment>
<function><type><name>void</name></type>
<name>RegisterBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RegisterBackgroundWorkerEx</name><argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Register a new static background worker.
 *
 * This can only be called directly from postmaster or in the _PG_init
 * function of a module library that's loaded by shared_preload_libraries;
 * otherwise it will have no effect.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegisterBackgroundWorkerEx</name><parameter_list>(<parameter><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RegisteredBgWorker</name> <modifier>*</modifier></type><name>rw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numworkers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"registering background worker \"%s\""</literal></expr></argument>, <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>process_shared_preload_libraries_in_progress</name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": must be registered in shared_preload_libraries"</literal></expr></argument>,
							<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SanityCheckBackgroundWorker</name><argument_list>(<argument><expr><name>worker</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_notify_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"background worker \"%s\": only dynamic background workers can request notification"</literal></expr></argument>,
						<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>bgw_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Enforce maximum number of workers.  Note this is overly restrictive: we
	 * could allow more non-shmem-connected workers, because these don't count
	 * towards the MAX_BACKENDS limit elsewhere.  For now, it doesn't seem
	 * important to relax this restriction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>++</operator><name>numworkers</name> <operator>&gt;</operator> <name>max_worker_processes</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIGURATION_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many background workers"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_plural</name><argument_list>(<argument><expr><literal type="string">"Up to %d background worker can be registered with the current settings."</literal></expr></argument>,
								  <argument><expr><literal type="string">"Up to %d background workers can be registered with the current settings."</literal></expr></argument>,
								  <argument><expr><name>max_worker_processes</name></expr></argument>,
								  <argument><expr><name>max_worker_processes</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider increasing the configuration parameter \"max_worker_processes\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Copy the registration data into the registered workers list.
	 */</comment>
	<expr_stmt><expr><name>rw</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RegisteredBgWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rw</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_worker</name></name> <operator>=</operator> <operator>*</operator><name>worker</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_backend</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_child_slot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_crashed_at</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rw</name><operator>-&gt;</operator><name>rw_terminate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>slist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BackgroundWorkerList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rw</name><operator>-&gt;</operator><name>rw_lnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a new background worker from a regular backend.
 *
 * Returns true on success and false on failure.  Failure typically indicates
 * that no background worker slots are currently available.
 *
 * If handle != NULL, we'll set *handle to a pointer that can subsequently
 * be used as an argument to GetBackgroundWorkerPid().  The caller can
 * free this pointer using pfree(), if desired.
 */</comment>
<function><type><name>bool</name></type>
<name>RegisterDynamicBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>BackgroundWorker</name> <modifier>*</modifier></type><name>worker</name></decl></parameter>,
								<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>success</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>parallel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>generation</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can't register dynamic background workers from the postmaster. If
	 * this is a standalone backend, we're the only process and can't start
	 * any more.  In a multi-process environment, it might be theoretically
	 * possible, but we don't currently support it due to locking
	 * considerations; see comments on the BackgroundWorkerSlot data
	 * structure.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SanityCheckBackgroundWorker</name><argument_list>(<argument><expr><name>worker</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>parallel</name> <operator>=</operator> <operator>(</operator><name><name>worker</name><operator>-&gt;</operator><name>bgw_flags</name></name> <operator>&amp;</operator> <name>BGWORKER_CLASS_PARALLEL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is a parallel worker, check whether there are already too many
	 * parallel workers; if so, don't register another one.  Our view of
	 * parallel_terminate_count may be slightly stale, but that doesn't really
	 * matter: we would have gotten the same result if we'd arrived here
	 * slightly earlier anyway.  There's no help for it, either, since the
	 * postmaster must not take locks; a memory barrier wouldn't guarantee
	 * anything useful.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parallel</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_register_count</name></name> <operator>-</operator>
					 <name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_terminate_count</name></name><operator>)</operator> <operator>&gt;=</operator>
		<name>max_parallel_workers</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_register_count</name></name> <operator>-</operator>
			   <name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_terminate_count</name></name> <operator>&lt;=</operator>
			   <name>MAX_PARALLEL_WORKER_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look for an unused slot.  If we find one, grab it.
	 */</comment>
	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>slotno</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><name>worker</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackgroundWorker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt> <comment type="block">/* indicates not started yet */</comment>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>generation</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>terminate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>generation</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>generation</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>parallel</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>parallel_register_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Make sure postmaster doesn't see the slot as in use before it
			 * sees the new contents.
			 */</comment>
			<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we found a slot, tell the postmaster to notice the change. */</comment>
	<if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_BACKGROUND_WORKER_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we found a slot and the user has provided a handle, initialize it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>success</name> <operator>&amp;&amp;</operator> <name>handle</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>handle</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BackgroundWorkerHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>handle</name><operator>)</operator><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>handle</name><operator>)</operator><operator>-&gt;</operator><name>generation</name></name> <operator>=</operator> <name>generation</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the PID of a dynamically-registered background worker.
 *
 * If the worker is determined to be running, the return value will be
 * BGWH_STARTED and *pidp will get the PID of the worker process.  If the
 * postmaster has not yet attempted to start the worker, the return value will
 * be BGWH_NOT_YET_STARTED.  Otherwise, the return value is BGWH_STOPPED.
 *
 * BGWH_STOPPED can indicate either that the worker is temporarily stopped
 * (because it is configured for automatic restart and exited non-zero),
 * or that the worker is permanently stopped (because it exited with exit
 * code 0, or was not configured for automatic restart), or even that the
 * worker was unregistered without ever starting (either because startup
 * failed and the worker is not configured for automatic restart, or because
 * TerminateBackgroundWorker was used before the worker was successfully
 * started).
 */</comment>
<function><type><name>BgwHandleStatus</name></type>
<name>GetBackgroundWorkerPid</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>pid_t</name> <modifier>*</modifier></type><name>pidp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>slot</name></name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>slot</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We could probably arrange to synchronize access to data using memory
	 * barriers only, but for now, let's just keep it simple and grab the
	 * lock.  It seems unlikely that there will be enough traffic here to
	 * result in meaningful contention.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The generation number can't be concurrently changed while we hold the
	 * lock.  The pid, which is updated by the postmaster, can change at any
	 * time, but we assume such changes are atomic.  So the value we read
	 * won't be garbage, but it might be out of date by the time the caller
	 * examines it (but that's unavoidable anyway).
	 *
	 * The in_use flag could be in the process of changing from true to false,
	 * but if it is already false then it can't change further.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>generation</name></name> <operator>!=</operator> <name><name>slot</name><operator>-&gt;</operator><name>generation</name></name> <operator>||</operator> <operator>!</operator><name><name>slot</name><operator>-&gt;</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>pid</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* All done. */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>BGWH_STOPPED</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>pid</name> <operator>==</operator> <name>InvalidPid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>BGWH_NOT_YET_STARTED</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>pidp</name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
	<return>return <expr><name>BGWH_STARTED</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for a background worker to start up.
 *
 * This is like GetBackgroundWorkerPid(), except that if the worker has not
 * yet started, we wait for it to do so; thus, BGWH_NOT_YET_STARTED is never
 * returned.  However, if the postmaster has died, we give up and return
 * BGWH_POSTMASTER_DIED, since it that case we know that startup will not
 * take place.
 */</comment>
<function><type><name>BgwHandleStatus</name></type>
<name>WaitForBackgroundWorkerStartup</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>pid_t</name> <modifier>*</modifier></type><name>pidp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>pidp</name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>BGWH_NOT_YET_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
					   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					   <argument><expr><name>WAIT_EVENT_BGWORKER_STARTUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <name>BGWH_POSTMASTER_DIED</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for a background worker to stop.
 *
 * If the worker hasn't yet started, or is running, we wait for it to stop
 * and then return BGWH_STOPPED.  However, if the postmaster has died, we give
 * up and return BGWH_POSTMASTER_DIED, because it's the postmaster that
 * notifies us when a worker's state changes.
 */</comment>
<function><type><name>BgwHandleStatus</name></type>
<name>WaitForBackgroundWorkerShutdown</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Polar: Wait for postmaster notify that this worker is shutdown. */</comment>
	<return>return <expr><call><name>polar_wait_bg_worker_shutdown</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Instruct the postmaster to terminate a background worker.
 *
 * Note that it's safe to do this without regard to whether the worker is
 * still running, or even if the worker may already have existed and been
 * unregistered.
 */</comment>
<function><type><name>void</name></type>
<name>TerminateBackgroundWorker</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>signal_postmaster</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>slot</name></name> <operator>&lt;</operator> <name>max_worker_processes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>slot</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Set terminate flag in shared memory, unless slot has been reused. */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>generation</name></name> <operator>==</operator> <name><name>slot</name><operator>-&gt;</operator><name>generation</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>terminate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>signal_postmaster</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure the postmaster notices the change to shared memory. */</comment>
	<if_stmt><if>if <condition>(<expr><name>signal_postmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_BACKGROUND_WORKER_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Look up (and possibly load) a bgworker entry point function.
 *
 * For functions contained in the core code, we use library name "postgres"
 * and consult the InternalBGWorkers array.  External functions are
 * looked up, and loaded if necessary, using load_external_function().
 *
 * The point of this is to pass function names as strings across process
 * boundaries.  We can't pass actual function addresses because of the
 * possibility that the function has been loaded at a different address
 * in a different process.  This is obviously a hazard for functions in
 * loadable libraries, but it can happen even for functions in the core code
 * on platforms using EXEC_BACKEND (e.g., Windows).
 *
 * At some point it might be worthwhile to get rid of InternalBGWorkers[]
 * in favor of applying load_external_function() for core functions too;
 * but that raises portability issues that are not worth addressing now.
 */</comment>
<function><type><specifier>static</specifier> <name>bgworker_main_type</name></type>
<name>LookupBackgroundWorkerFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libraryname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the function is to be loaded from postgres itself, search the
	 * InternalBGWorkers array.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>libraryname</name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>InternalBGWorkers</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>InternalBGWorkers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_name</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>InternalBGWorkers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_addr</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* We can only reach this by programming error. */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"internal function \"%s\" not found"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Otherwise load from external library. */</comment>
	<return>return <expr><operator>(</operator><name>bgworker_main_type</name><operator>)</operator>
		<call><name>load_external_function</name><argument_list>(<argument><expr><name>libraryname</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a PID, get the bgw_type of the background worker.  Returns NULL if
 * not a valid background worker.
 *
 * The return value is in static memory belonging to this function, so it has
 * to be used before calling this function again.  This is so that the caller
 * doesn't have to worry about the background worker locking protocol.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetBackgroundWorkerTypeByPid</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>result</name><index>[<expr><name>BGW_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>total_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BackgroundWorkerSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>&amp;</operator><name><name>BackgroundWorkerData</name><operator>-&gt;</operator><name>slot</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>slot</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name>pid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>bgw_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BackgroundWorkerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_set_parallel_bgwriter_handle</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>worker_handle</name></decl></parameter>,
								   <parameter><decl><type><name>ParallelBgwriterHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name><name>worker_handle</name><operator>-&gt;</operator><name>slot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>generation</name></name> <operator>=</operator> <name><name>worker_handle</name><operator>-&gt;</operator><name>generation</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for a background worker to stop.
 *
 * If the worker hasn't yet started, or is running, we wait for it to stop
 * and then return BGWH_STOPPED.  However, if the postmaster has died, we give
 * up and return BGWH_POSTMASTER_DIED, because it's the postmaster that
 * notifies us when a worker's state changes.
 *
 * POLAR: If timeout_loop is true,we will check background work's status every 100ms,
 * otherwise we will wait until postmaster send signal.
 * When postmaster receive shutdown request, it will not notify worker is shutdown.
 * If process want to check whether woker is shutdown after postmaster receive shutdown request,
 * it has to set timeout_loop to be true.
 */</comment>
<function><type><name>BgwHandleStatus</name></type>
<name>polar_wait_bg_worker_shutdown</name><parameter_list>(<parameter><decl><type><name>BackgroundWorkerHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>timeout_loop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_STOPPED</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>timeout_loop</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
						   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_TIMEOUT</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <comment type="block">/* ms */</comment>
						   <argument><expr><name>WAIT_EVENT_BGWORKER_SHUTDOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
						   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						   <argument><expr><name>WAIT_EVENT_BGWORKER_SHUTDOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <name>BGWH_POSTMASTER_DIED</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>
</unit>
