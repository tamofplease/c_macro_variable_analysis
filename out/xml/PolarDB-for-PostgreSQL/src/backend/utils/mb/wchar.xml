<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/mb/wchar.c"><comment type="block">/*
 * conversion functions between pg_wchar and multibyte streams.
 * Tatsuo Ishii
 * src/backend/utils/mb/wchar.c
 *
 */</comment>
<comment type="block">/* can be used in either frontend or backend */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FRONTEND</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>


<comment type="block">/*
 * conversion to pg_wchar is done by "table driven."
 * to add an encoding support, define mb2wchar_with_len(), mblen(), dsplen()
 * for the particular encoding. Note that if the encoding is only
 * supported in the client, you don't need to define
 * mb2wchar_with_len() function (SJIS is the case).
 *
 * These functions generally assume that their input is validly formed.
 * The "verifier" functions, further down in the file, have to be more
 * paranoid.  We expect that mblen() does not need to examine more than
 * the first byte of the character to discover the correct length.
 *
 * Note: for the display output of psql to work properly, the return values
 * of the dsplen functions must conform to the Unicode standard. In particular
 * the NUL character is zero width and control characters are generally
 * width -1. It is recommended that non-ASCII encodings refer their ASCII
 * subset to the ASCII routines to ensure consistency.
 */</comment>

<comment type="block">/*
 * SQL/ASCII
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_ascii2wchar_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_ascii_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_ascii_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>&lt;</operator> <literal type="number">0x20</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="number">0x7f</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EUC
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euc2wchar_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>from</name> <operator>==</operator> <name>SS2</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>	<comment type="block">/* JIS X 0201 (so called "1 byte
										 * KANA") */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><name>SS2</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>from</name> <operator>==</operator> <name>SS3</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>	<comment type="block">/* JIS X 0212 KANJI */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><name>SS3</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>from</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <comment type="block">/* JIS X 0208 KANJI */</comment>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else					<comment type="block">/* must be ASCII */</comment>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>to</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>pg_euc_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>SS2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>SS3</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>pg_euc_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>SS2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>SS3</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_ascii_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EUC_JP
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_eucjp2wchar_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_euc2wchar_with_len</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_eucjp_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_euc_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_eucjp_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>SS2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>SS3</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_ascii_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EUC_KR
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euckr2wchar_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_euc2wchar_with_len</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euckr_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_euc_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euckr_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_euc_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EUC_CN
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euccn2wchar_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>from</name> <operator>==</operator> <name>SS2</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>	<comment type="block">/* code set 2 (unused?) */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><name>SS2</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>from</name> <operator>==</operator> <name>SS3</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>	<comment type="block">/* code set 3 (unused ?) */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><name>SS3</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>from</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <comment type="block">/* code set 1 */</comment>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>to</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euccn_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euccn_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_ascii_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EUC_TW
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euctw2wchar_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>from</name> <operator>==</operator> <name>SS2</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition>	<comment type="block">/* code set 2 */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint32</name><operator>)</operator> <name>SS2</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>from</name> <operator>==</operator> <name>SS3</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>	<comment type="block">/* code set 3 (unused?) */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><name>SS3</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>from</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <comment type="block">/* code set 2 */</comment>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>to</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euctw_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>SS2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>SS3</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euctw_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>SS2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>SS3</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_ascii_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert pg_wchar to EUC_* encoding.
 * caller must allocate enough space for "to", including a trailing zero!
 * len: length of from.
 * "from" not necessarily null terminated.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wchar2euc_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JOHAB
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_johab_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_euc_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_johab_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_euc_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * convert UTF8 string to pg_wchar (UCS-4)
 * caller must allocate enough space for "to", including a trailing zero!
 * len: length of from.
 * "from" not necessarily null terminated.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_utf2wchar_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>c1</name></decl>,
				<decl><type ref="prev"/><name>c2</name></decl>,
				<decl><type ref="prev"/><name>c3</name></decl>,
				<decl><type ref="prev"/><name>c4</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xe0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xc0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* drop trailing incomplete char */</comment>
			<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x1f</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><name>c1</name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <name>c2</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xf0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xe0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* drop trailing incomplete char */</comment>
			<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x0f</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>c3</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><name>c1</name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>c2</name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <name>c3</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xf0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* drop trailing incomplete char */</comment>
			<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x07</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>c3</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>c4</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><name>c1</name> <operator>&lt;&lt;</operator> <literal type="number">18</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>c2</name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>c3</name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <name>c4</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* treat a bogus char as length 1; not ours to raise error */</comment>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>to</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Map a Unicode code point to UTF-8.  utf8string must have 4 bytes of
 * space allocated.
 */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>unicode_to_utf8</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>utf8string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <literal type="number">0x7F</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>utf8string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <literal type="number">0x7FF</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>utf8string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xC0</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1F</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>utf8string</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <literal type="number">0xFFFF</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>utf8string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xE0</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>utf8string</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>utf8string</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>utf8string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xF0</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">18</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>utf8string</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>utf8string</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>utf8string</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>utf8string</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Trivial conversion from pg_wchar to UTF-8.
 * caller should allocate enough space for "to"
 * len: length of from.
 * "from" not necessarily null terminated.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wchar2utf_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>char_len</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>unicode_to_utf8</name><argument_list>(<argument><expr><operator>*</operator><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>char_len</name> <operator>=</operator> <call><name>pg_utf_mblen</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <name>char_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>to</name> <operator>+=</operator> <name>char_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the byte length of a UTF8 character pointed to by s
 *
 * Note: in the current implementation we do not support UTF8 sequences
 * of more than 4 bytes; hence do NOT return a value larger than 4.
 * We return "1" for any leading byte that is either flat-out illegal or
 * indicates a length larger than we support.
 *
 * pg_utf2wchar_with_len(), utf8_to_unicode(), pg_utf8_islegal(), and perhaps
 * other places would need to be fixed to change this.
 */</comment>
<function><type><name>int</name></type>
<name>pg_utf_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>&amp;</operator> <literal type="number">0xe0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xc0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>&amp;</operator> <literal type="number">0xf0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xe0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xf0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>&amp;</operator> <literal type="number">0xfc</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xf8</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>s</name> <operator>&amp;</operator> <literal type="number">0xfe</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xfc</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This is an implementation of wcwidth() and wcswidth() as defined in
 * "The Single UNIX Specification, Version 2, The Open Group, 1997"
 * &lt;http://www.UNIX-systems.org/online.html&gt;
 *
 * Markus Kuhn -- 2001-09-08 -- public domain
 *
 * customised for PostgreSQL
 *
 * original available at : http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c
 */</comment>

<struct>struct <name>mbinterval</name>
<block>{
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>last</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* auxiliary function for binary search in interval table */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>mbbisearch</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>ucs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>mbinterval</name></name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ucs</name> <operator>&lt;</operator> <name><name>table</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first</name> <operator>||</operator> <name>ucs</name> <operator>&gt;</operator> <name><name>table</name><index>[<expr><name>max</name></expr>]</index></name><operator>.</operator><name>last</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<while>while <condition>(<expr><name>max</name> <operator>&gt;=</operator> <name>min</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>min</name> <operator>+</operator> <name>max</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ucs</name> <operator>&gt;</operator> <name><name>table</name><index>[<expr><name>mid</name></expr>]</index></name><operator>.</operator><name>last</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>min</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>ucs</name> <operator>&lt;</operator> <name><name>table</name><index>[<expr><name>mid</name></expr>]</index></name><operator>.</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>max</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* The following functions define the column width of an ISO 10646
 * character as follows:
 *
 *	  - The null character (U+0000) has a column width of 0.
 *
 *	  - Other C0/C1 control characters and DEL will lead to a return
 *		value of -1.
 *
 *	  - Non-spacing and enclosing combining characters (general
 *		category code Mn or Me in the Unicode database) have a
 *		column width of 0.
 *
 *	  - Other format characters (general category code Cf in the Unicode
 *		database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
 *
 *	  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
 *		have a column width of 0.
 *
 *	  - Spacing characters in the East Asian Wide (W) or East Asian
 *		FullWidth (F) category as defined in Unicode Technical
 *		Report #11 have a column width of 2.
 *
 *	  - All remaining characters (including all printable
 *		ISO 8859-1 and WGL4 characters, Unicode control characters,
 *		etc.) have a column width of 1.
 *
 * This implementation assumes that wchar_t characters are encoded
 * in ISO 10646.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ucs_wcwidth</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>ucs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* sorted list of non-overlapping intervals of non-spacing characters */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>mbinterval</name></name></type> <name><name>combining</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{<expr><literal type="number">0x0300</literal></expr>, <expr><literal type="number">0x034E</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0360</literal></expr>, <expr><literal type="number">0x0362</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0483</literal></expr>, <expr><literal type="number">0x0486</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0488</literal></expr>, <expr><literal type="number">0x0489</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0591</literal></expr>, <expr><literal type="number">0x05A1</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x05A3</literal></expr>, <expr><literal type="number">0x05B9</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x05BB</literal></expr>, <expr><literal type="number">0x05BD</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x05BF</literal></expr>, <expr><literal type="number">0x05BF</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x05C1</literal></expr>, <expr><literal type="number">0x05C2</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x05C4</literal></expr>, <expr><literal type="number">0x05C4</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x064B</literal></expr>, <expr><literal type="number">0x0655</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0670</literal></expr>, <expr><literal type="number">0x0670</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x06D6</literal></expr>, <expr><literal type="number">0x06E4</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x06E7</literal></expr>, <expr><literal type="number">0x06E8</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x06EA</literal></expr>, <expr><literal type="number">0x06ED</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x070F</literal></expr>, <expr><literal type="number">0x070F</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0711</literal></expr>, <expr><literal type="number">0x0711</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0730</literal></expr>, <expr><literal type="number">0x074A</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x07A6</literal></expr>, <expr><literal type="number">0x07B0</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0901</literal></expr>, <expr><literal type="number">0x0902</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x093C</literal></expr>, <expr><literal type="number">0x093C</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0941</literal></expr>, <expr><literal type="number">0x0948</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x094D</literal></expr>, <expr><literal type="number">0x094D</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0951</literal></expr>, <expr><literal type="number">0x0954</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0962</literal></expr>, <expr><literal type="number">0x0963</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0981</literal></expr>, <expr><literal type="number">0x0981</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x09BC</literal></expr>, <expr><literal type="number">0x09BC</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x09C1</literal></expr>, <expr><literal type="number">0x09C4</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x09CD</literal></expr>, <expr><literal type="number">0x09CD</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x09E2</literal></expr>, <expr><literal type="number">0x09E3</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0A02</literal></expr>, <expr><literal type="number">0x0A02</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0A3C</literal></expr>, <expr><literal type="number">0x0A3C</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0A41</literal></expr>, <expr><literal type="number">0x0A42</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0A47</literal></expr>, <expr><literal type="number">0x0A48</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0A4B</literal></expr>, <expr><literal type="number">0x0A4D</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0A70</literal></expr>, <expr><literal type="number">0x0A71</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0A81</literal></expr>, <expr><literal type="number">0x0A82</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0ABC</literal></expr>, <expr><literal type="number">0x0ABC</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0AC1</literal></expr>, <expr><literal type="number">0x0AC5</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0AC7</literal></expr>, <expr><literal type="number">0x0AC8</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0ACD</literal></expr>, <expr><literal type="number">0x0ACD</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0B01</literal></expr>, <expr><literal type="number">0x0B01</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0B3C</literal></expr>, <expr><literal type="number">0x0B3C</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0B3F</literal></expr>, <expr><literal type="number">0x0B3F</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0B41</literal></expr>, <expr><literal type="number">0x0B43</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0B4D</literal></expr>, <expr><literal type="number">0x0B4D</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0B56</literal></expr>, <expr><literal type="number">0x0B56</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0B82</literal></expr>, <expr><literal type="number">0x0B82</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0BC0</literal></expr>, <expr><literal type="number">0x0BC0</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0BCD</literal></expr>, <expr><literal type="number">0x0BCD</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0C3E</literal></expr>, <expr><literal type="number">0x0C40</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0C46</literal></expr>, <expr><literal type="number">0x0C48</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0C4A</literal></expr>, <expr><literal type="number">0x0C4D</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0C55</literal></expr>, <expr><literal type="number">0x0C56</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0CBF</literal></expr>, <expr><literal type="number">0x0CBF</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0CC6</literal></expr>, <expr><literal type="number">0x0CC6</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0CCC</literal></expr>, <expr><literal type="number">0x0CCD</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0D41</literal></expr>, <expr><literal type="number">0x0D43</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0D4D</literal></expr>, <expr><literal type="number">0x0D4D</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0DCA</literal></expr>, <expr><literal type="number">0x0DCA</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0DD2</literal></expr>, <expr><literal type="number">0x0DD4</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0DD6</literal></expr>, <expr><literal type="number">0x0DD6</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0E31</literal></expr>, <expr><literal type="number">0x0E31</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0E34</literal></expr>, <expr><literal type="number">0x0E3A</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0E47</literal></expr>, <expr><literal type="number">0x0E4E</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0EB1</literal></expr>, <expr><literal type="number">0x0EB1</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0EB4</literal></expr>, <expr><literal type="number">0x0EB9</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0EBB</literal></expr>, <expr><literal type="number">0x0EBC</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0EC8</literal></expr>, <expr><literal type="number">0x0ECD</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0F18</literal></expr>, <expr><literal type="number">0x0F19</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0F35</literal></expr>, <expr><literal type="number">0x0F35</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0F37</literal></expr>, <expr><literal type="number">0x0F37</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0F39</literal></expr>, <expr><literal type="number">0x0F39</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0F71</literal></expr>, <expr><literal type="number">0x0F7E</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0F80</literal></expr>, <expr><literal type="number">0x0F84</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0F86</literal></expr>, <expr><literal type="number">0x0F87</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0F90</literal></expr>, <expr><literal type="number">0x0F97</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x0F99</literal></expr>, <expr><literal type="number">0x0FBC</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x0FC6</literal></expr>, <expr><literal type="number">0x0FC6</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x102D</literal></expr>, <expr><literal type="number">0x1030</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x1032</literal></expr>, <expr><literal type="number">0x1032</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x1036</literal></expr>, <expr><literal type="number">0x1037</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x1039</literal></expr>, <expr><literal type="number">0x1039</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x1058</literal></expr>, <expr><literal type="number">0x1059</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x1160</literal></expr>, <expr><literal type="number">0x11FF</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x17B7</literal></expr>, <expr><literal type="number">0x17BD</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x17C6</literal></expr>, <expr><literal type="number">0x17C6</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x17C9</literal></expr>, <expr><literal type="number">0x17D3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x180B</literal></expr>, <expr><literal type="number">0x180E</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x18A9</literal></expr>, <expr><literal type="number">0x18A9</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x200B</literal></expr>, <expr><literal type="number">0x200F</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x202A</literal></expr>, <expr><literal type="number">0x202E</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x206A</literal></expr>, <expr><literal type="number">0x206F</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0x20D0</literal></expr>, <expr><literal type="number">0x20E3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x302A</literal></expr>, <expr><literal type="number">0x302F</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0x3099</literal></expr>, <expr><literal type="number">0x309A</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0xFB1E</literal></expr>, <expr><literal type="number">0xFB1E</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0xFE20</literal></expr>, <expr><literal type="number">0xFE23</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">0xFEFF</literal></expr>, <expr><literal type="number">0xFEFF</literal></expr>}</block></expr>,
		<expr><block>{<expr><literal type="number">0xFFF9</literal></expr>, <expr><literal type="number">0xFFFB</literal></expr>}</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* test for 8-bit control characters */</comment>
	<if_stmt><if>if <condition>(<expr><name>ucs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ucs</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x20</literal> <operator>||</operator> <operator>(</operator><name>ucs</name> <operator>&gt;=</operator> <literal type="number">0x7f</literal> <operator>&amp;&amp;</operator> <name>ucs</name> <operator>&lt;</operator> <literal type="number">0xa0</literal><operator>)</operator> <operator>||</operator> <name>ucs</name></expr></argument> &gt;</argument_list></name> <literal type="number">0x0010ffff</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* binary search in table of non-spacing characters */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>mbbisearch</name><argument_list>(<argument><expr><name>ucs</name></expr></argument>, <argument><expr><name>combining</name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>combining</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>mbinterval</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * if we arrive here, ucs is not a combining or C0/C1 control character
	 */</comment>

	<return>return <expr><literal type="number">1</literal> <operator>+</operator>
		<operator>(</operator><name>ucs</name> <operator>&gt;=</operator> <literal type="number">0x1100</literal> <operator>&amp;&amp;</operator>
		 <operator>(</operator><name>ucs</name> <operator>&lt;=</operator> <literal type="number">0x115f</literal> <operator>||</operator>		<comment type="block">/* Hangul Jamo init. consonants */</comment>
		  <operator>(</operator><name>ucs</name> <operator>&gt;=</operator> <literal type="number">0x2e80</literal> <operator>&amp;&amp;</operator> <name>ucs</name> <operator>&lt;=</operator> <literal type="number">0xa4cf</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>ucs</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x0011</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x300a</literal> <operator>&amp;&amp;</operator>
		   <name>ucs</name> <operator>!=</operator> <literal type="number">0x303f</literal><operator>)</operator> <operator>||</operator>	<comment type="block">/* CJK ... Yi */</comment>
		  <operator>(</operator><name>ucs</name> <operator>&gt;=</operator> <literal type="number">0xac00</literal> <operator>&amp;&amp;</operator> <name>ucs</name> <operator>&lt;=</operator> <literal type="number">0xd7a3</literal><operator>)</operator> <operator>||</operator>	<comment type="block">/* Hangul Syllables */</comment>
		  <operator>(</operator><name>ucs</name> <operator>&gt;=</operator> <literal type="number">0xf900</literal> <operator>&amp;&amp;</operator> <name>ucs</name> <operator>&lt;=</operator> <literal type="number">0xfaff</literal><operator>)</operator> <operator>||</operator>	<comment type="block">/* CJK Compatibility
												 * Ideographs */</comment>
		  <operator>(</operator><name>ucs</name> <operator>&gt;=</operator> <literal type="number">0xfe30</literal> <operator>&amp;&amp;</operator> <name>ucs</name> <operator>&lt;=</operator> <literal type="number">0xfe6f</literal><operator>)</operator> <operator>||</operator>	<comment type="block">/* CJK Compatibility Forms */</comment>
		  <operator>(</operator><name>ucs</name> <operator>&gt;=</operator> <literal type="number">0xff00</literal> <operator>&amp;&amp;</operator> <name>ucs</name> <operator>&lt;=</operator> <literal type="number">0xff5f</literal><operator>)</operator> <operator>||</operator>	<comment type="block">/* Fullwidth Forms */</comment>
		  <operator>(</operator><name>ucs</name> <operator>&gt;=</operator> <literal type="number">0xffe0</literal> <operator>&amp;&amp;</operator> <name>ucs</name> <operator>&lt;=</operator> <literal type="number">0xffe6</literal><operator>)</operator> <operator>||</operator>
		  <operator>(</operator><name>ucs</name> <operator>&gt;=</operator> <literal type="number">0x20000</literal> <operator>&amp;&amp;</operator> <name>ucs</name> <operator>&lt;=</operator> <literal type="number">0x2ffff</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a UTF-8 character to a Unicode code point.
 * This is a one-character version of pg_utf2wchar_with_len.
 *
 * No error checks here, c must point to a long-enough string.
 */</comment>
<function><type><name>pg_wchar</name></type>
<name>utf8_to_unicode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>pg_wchar</name><operator>)</operator> <name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xe0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xc0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>pg_wchar</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator>
						   <operator>(</operator><name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xf0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xe0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>pg_wchar</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x0f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>|</operator>
						   <operator>(</operator><operator>(</operator><name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator>
						   <operator>(</operator><name><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xf0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>pg_wchar</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">18</literal><operator>)</operator> <operator>|</operator>
						   <operator>(</operator><operator>(</operator><name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>|</operator>
						   <operator>(</operator><operator>(</operator><name><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator>
						   <operator>(</operator><name><name>c</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* that is an invalid code on purpose */</comment>
		<return>return <expr><literal type="number">0xffffffff</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_utf_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ucs_wcwidth</name><argument_list>(<argument><expr><call><name>utf8_to_unicode</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * convert mule internal code to pg_wchar
 * caller should allocate enough space for "to"
 * len: length of from.
 * "from" not necessarily null terminated.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_mule2wchar_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_LC1</name><argument_list>(<argument><expr><operator>*</operator><name>from</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_LCPRV1</name><argument_list>(<argument><expr><operator>*</operator><name>from</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_LC2</name><argument_list>(<argument><expr><operator>*</operator><name>from</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_LCPRV2</name><argument_list>(<argument><expr><operator>*</operator><name>from</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>						<comment type="block">/* assume ASCII */</comment>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>to</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * convert pg_wchar to mule internal code
 * caller should allocate enough space for "to"
 * len: length of from.
 * "from" not necessarily null terminated.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wchar2mule_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>lb</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lb</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IS_LC1</name><argument_list>(<argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>lb</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_LC2</name><argument_list>(<argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>lb</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_LCPRV1_A_RANGE</name><argument_list>(<argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>LCPRV1_A</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>lb</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_LCPRV1_B_RANGE</name><argument_list>(<argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>LCPRV1_B</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>lb</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_LCPRV2_A_RANGE</name><argument_list>(<argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>LCPRV2_A</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>lb</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_LCPRV2_B_RANGE</name><argument_list>(<argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>LCPRV2_B</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>lb</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pg_mule_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_LC1</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_LCPRV1</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_LC2</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_LCPRV2</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>				<comment type="block">/* assume ASCII */</comment>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_mule_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: it's not really appropriate to assume that all multibyte charsets
	 * are double-wide on screen.  But this seems an okay approximation for
	 * the MULE charsets we currently support.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>IS_LC1</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_LCPRV1</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_LC2</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_LCPRV2</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>				<comment type="block">/* assume ASCII */</comment>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ISO8859-1
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_latin12wchar_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Trivial conversion from pg_wchar to single byte encoding. Just ignores
 * high bits.
 * caller should allocate enough space for "to"
 * len: length of from.
 * "from" not necessarily null terminated.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wchar2single_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_latin1_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_latin1_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_ascii_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SJIS
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_sjis_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="number">0xa1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="number">0xdf</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* 1 byte kana? */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* kanji? */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>				<comment type="block">/* should be ASCII */</comment>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_sjis_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="number">0xa1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="number">0xdf</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* 1 byte kana? */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* kanji? */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_ascii_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* should be ASCII */</comment>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Big5
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_big5_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* kanji? */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>				<comment type="block">/* should be ASCII */</comment>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_big5_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* kanji? */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_ascii_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* should be ASCII */</comment>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: support gbk encoding
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_gbk2wchar_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* loop until the end */</comment>
	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>from</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* first case, it is a valid Chinese word with 2 bytes */</comment>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* second case, it is a ASCII code with 1 bytes */</comment>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* move forward and update cnt */</comment>
		<expr_stmt><expr><name>to</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* set the last word with zero */</comment>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: support gbk encoding
 * the fucntion is part of pg_wchar2euc_with_len 
 * when max encoding length is 2 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> 
<name>polar_wchar2gbk_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pg_wchar</name><modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* loop until the end */</comment>
	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

		<comment type="block">/* only possible for 2 bytes or 1 byte */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* set the last word with zero */</comment>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GBK
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_gbk_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* kanji? */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>				<comment type="block">/* should be ASCII */</comment>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_gbk_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* kanji? */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_ascii_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* should be ASCII */</comment>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * UHC
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_uhc_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* 2byte? */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>				<comment type="block">/* should be ASCII */</comment>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_uhc_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* 2byte? */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_ascii_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* should be ASCII */</comment>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: support gb18030 encoding
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>polar_gb18030_2_wchar_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* loop until the end */</comment>
	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>from</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>from</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>from</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0x30</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>from</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0x39</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* first case, it is a valid Chinese word with 4 bytes */</comment>
				<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>(</operator><operator>*</operator><name>from</name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>(</operator><operator>*</operator><name>from</name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* second case, it is a valid Chinese word with 2 bytes */</comment>
				<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>from</name><operator>++</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>to</name> <operator>|=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* third case, it is a ASCII code with 1 bytes */</comment>
			<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* move forward and update cnt */</comment>
		<expr_stmt><expr><name>to</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* set the last word with zero */</comment>
	<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GB18030
 *	Added by Bill Huang &lt;bhuang@redhat.com&gt;,&lt;bill_huanghb@ybb.ne.jp&gt;
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_gb18030_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* ASCII */</comment>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0x30</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0x39</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_gb18030_dsplen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_ascii_dsplen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* ASCII */</comment>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *-------------------------------------------------------------------
 * multibyte sequence validators
 *
 * These functions accept "s", a pointer to the first byte of a string,
 * and "len", the remaining length of the string.  If there is a validly
 * encoded character beginning at *s, return its length in bytes; else
 * return -1.
 *
 * The functions can assume that len &gt; 0 and that *s != '\0', but they must
 * test for and reject zeroes in any additional bytes of a multibyte character.
 *
 * Note that this definition allows the function for a single-byte
 * encoding to be just "return 1".
 *-------------------------------------------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_ascii_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_EUC_RANGE_VALID</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((c) &gt;= 0xa1 &amp;&amp; (c) &lt;= 0xfe)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_eucjp_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c1</name></decl>,
				<decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>c1</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SS2</name></expr>:</case>				<comment type="block">/* JIS X 0201 */</comment>
			<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>c2</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0xa1</literal> <operator>||</operator> <name>c2</name></expr></argument> &gt;</argument_list></name> <literal type="number">0xdf</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>SS3</name></expr>:</case>				<comment type="block">/* JIS X 0212 */</comment>
			<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_EUC_RANGE_VALID</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_EUC_RANGE_VALID</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call></expr>)</condition> <comment type="block">/* JIS X 0208? */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_EUC_RANGE_VALID</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_EUC_RANGE_VALID</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
				<comment type="block">/* must be ASCII */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>l</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euckr_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c1</name></decl>,
				<decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_EUC_RANGE_VALID</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_EUC_RANGE_VALID</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
		<comment type="block">/* must be ASCII */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>l</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* EUC-CN byte sequences are exactly same as EUC-KR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pg_euccn_verifier</name></cpp:macro>	<cpp:value>pg_euckr_verifier</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_euctw_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c1</name></decl>,
				<decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>c1</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SS2</name></expr>:</case>				<comment type="block">/* CNS 11643 Plane 1-7 */</comment>
			<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>c2</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0xa1</literal> <operator>||</operator> <name>c2</name></expr></argument> &gt;</argument_list></name> <literal type="number">0xa7</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_EUC_RANGE_VALID</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_EUC_RANGE_VALID</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>SS3</name></expr>:</case>				<comment type="block">/* unused */</comment>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call></expr>)</condition> <comment type="block">/* CNS 11643 Plane 1 */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* no further range check on c1? */</comment>
				<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_EUC_RANGE_VALID</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
				<comment type="block">/* must be ASCII */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>l</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_johab_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>,
				<decl><type ref="prev"/><name>mbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>l</name> <operator>=</operator> <name>mbl</name> <operator>=</operator> <call><name>pg_johab_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mbl</name></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>--</operator><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>s</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_EUC_RANGE_VALID</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>mbl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_mule_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>,
				<decl><type ref="prev"/><name>mbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>l</name> <operator>=</operator> <name>mbl</name> <operator>=</operator> <call><name>pg_mule_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>--</operator><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>s</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>mbl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_latin1_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_sjis_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>,
				<decl><type ref="prev"/><name>mbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c1</name></decl>,
				<decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>l</name> <operator>=</operator> <name>mbl</name> <operator>=</operator> <call><name>pg_sjis_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>					<comment type="block">/* pg_sjis_mblen already verified it */</comment>
		<return>return <expr><name>mbl</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>c2</name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISSJISHEAD</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ISSJISTAIL</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>mbl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_big5_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>,
				<decl><type ref="prev"/><name>mbl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>l</name> <operator>=</operator> <name>mbl</name> <operator>=</operator> <call><name>pg_big5_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>--</operator><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>mbl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_gbk_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>,
				<decl><type ref="prev"/><name>mbl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>l</name> <operator>=</operator> <name>mbl</name> <operator>=</operator> <call><name>pg_gbk_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>--</operator><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>mbl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_uhc_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>,
				<decl><type ref="prev"/><name>mbl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>l</name> <operator>=</operator> <name>mbl</name> <operator>=</operator> <call><name>pg_uhc_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>--</operator><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>mbl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_gb18030_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>					<comment type="block">/* ASCII */</comment>
	<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0x30</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0x39</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Should be 4-byte, validate remaining bytes */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="number">0x81</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="number">0xfe</literal> <operator>&amp;&amp;</operator>
			<operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0x81</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0xfe</literal> <operator>&amp;&amp;</operator>
			<operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0x30</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0x39</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="number">0x81</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="number">0xfe</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Should be 2-byte, validate */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0x40</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0x7e</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0xfe</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>l</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_utf8_verifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name> <init>= <expr><call><name>pg_utf_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_utf8_islegal</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>l</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check for validity of a single UTF-8 encoded character
 *
 * This directly implements the rules in RFC3629.  The bizarre-looking
 * restrictions on the second byte are meant to ensure that there isn't
 * more than one encoding of a given Unicode character point; that is,
 * you may not use a longer-than-necessary byte sequence with high order
 * zero bits to represent a character that would fit in fewer bytes.
 * To do otherwise is to create security hazards (eg, create an apparent
 * non-ASCII character that decodes to plain ASCII).
 *
 * length is assumed to have been obtained by pg_utf_mblen(), and the
 * caller must have checked that that many bytes are present in the buffer.
 */</comment>
<function><type><name>bool</name></type>
<name>pg_utf8_islegal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>a</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>length</name></expr>)</condition>
	<block>{<block_content>
		<default>default:</default>
			<comment type="block">/* reject lengths 5 and 6 for now */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>source</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>a</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x80</literal> <operator>||</operator> <name>a</name></expr></argument> &gt;</argument_list></name> <literal type="number">0xBF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>source</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>a</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x80</literal> <operator>||</operator> <name>a</name></expr></argument> &gt;</argument_list></name> <literal type="number">0xBF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>source</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><operator>*</operator><name>source</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="number">0xE0</literal></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>a</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0xA0</literal> <operator>||</operator> <name>a</name></expr></argument> &gt;</argument_list></name> <literal type="number">0xBF</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">0xED</literal></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>a</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x80</literal> <operator>||</operator> <name>a</name></expr></argument> &gt;</argument_list></name> <literal type="number">0x9F</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">0xF0</literal></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>a</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x90</literal> <operator>||</operator> <name>a</name></expr></argument> &gt;</argument_list></name> <literal type="number">0xBF</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">0xF4</literal></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>a</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x80</literal> <operator>||</operator> <name>a</name></expr></argument> &gt;</argument_list></name> <literal type="number">0x8F</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<if_stmt><if>if <condition>(<expr><name><name>a</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x80</literal> <operator>||</operator> <name>a</name></expr></argument> &gt;</argument_list></name> <literal type="number">0xBF</literal></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>*</operator><name>source</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;=</operator> <literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <name>a</name> <operator>&lt;</operator> <literal type="number">0xC2</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;</operator> <literal type="number">0xF4</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>

<comment type="block">/*
 * Generic character incrementer function.
 *
 * Not knowing anything about the properties of the encoding in use, we just
 * keep incrementing the last byte until we get a validly-encoded result,
 * or we run out of values to try.  We don't bother to try incrementing
 * higher-order bytes, so there's no growth in runtime for wider characters.
 * (If we did try to do that, we'd need to consider the likelihood that 255
 * is not a valid final byte in the encoding.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pg_generic_charinc</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>charptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lastbyte</name> <init>= <expr><name>charptr</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mbverifier</name></type>	<name>mbverify</name></decl>;</decl_stmt>

	<comment type="block">/* We can just invoke the character verifier directly. */</comment>
	<expr_stmt><expr><name>mbverify</name> <operator>=</operator> <name><name>pg_wchar_table</name><index>[<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr>]</index></name><operator>.</operator><name>mbverify</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>lastbyte</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <literal type="number">255</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>lastbyte</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>mbverify</name>) <argument_list>(<argument><expr><name>charptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * UTF-8 character incrementer function.
 *
 * For a one-byte character less than 0x7F, we just increment the byte.
 *
 * For a multibyte character, every byte but the first must fall between 0x80
 * and 0xBF; and the first byte must be between 0xC0 and 0xF4.  We increment
 * the last byte that's not already at its maximum value.  If we can't find a
 * byte that's less than the maximum allowable value, we simply fail.  We also
 * need some special-case logic to skip regions used for surrogate pair
 * handling, as those should not occur in valid UTF-8.
 *
 * Note that we don't reset lower-order bytes back to their minimums, since
 * we can't afford to make an exhaustive search (see make_greater_string).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pg_utf8_increment</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>charptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>limit</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>length</name></expr>)</condition>
	<block>{<block_content>
		<default>default:</default>
			<comment type="block">/* reject lengths 5 and 6 for now */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>charptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <literal type="number">0xBF</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>charptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>charptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <literal type="number">0xBF</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>charptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>charptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><operator>*</operator><name>charptr</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="number">0xED</literal></expr>:</case>
					<expr_stmt><expr><name>limit</name> <operator>=</operator> <literal type="number">0x9F</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="number">0xF4</literal></expr>:</case>
					<expr_stmt><expr><name>limit</name> <operator>=</operator> <literal type="number">0x8F</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>limit</name> <operator>=</operator> <literal type="number">0xBF</literal></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <name>limit</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>charptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>*</operator><name>charptr</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <literal type="number">0x7F</literal> <operator>||</operator> <name>a</name> <operator>==</operator> <literal type="number">0xDF</literal> <operator>||</operator> <name>a</name> <operator>==</operator> <literal type="number">0xEF</literal> <operator>||</operator> <name>a</name> <operator>==</operator> <literal type="number">0xF4</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>charptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EUC-JP character incrementer function.
 *
 * If the sequence starts with SS2 (0x8e), it must be a two-byte sequence
 * representing JIS X 0201 characters with the second byte ranging between
 * 0xa1 and 0xdf.  We just increment the last byte if it's less than 0xdf,
 * and otherwise rewrite the whole sequence to 0xa1 0xa1.
 *
 * If the sequence starts with SS3 (0x8f), it must be a three-byte sequence
 * in which the last two bytes range between 0xa1 and 0xfe.  The last byte
 * is incremented if possible, otherwise the second-to-last byte.
 *
 * If the sequence starts with a value other than the above and its MSB
 * is set, it must be a two-byte sequence representing JIS X 0208 characters
 * with both bytes ranging between 0xa1 and 0xfe.  The last byte is
 * incremented if possible, otherwise the second-to-last byte.
 *
 * Otherwise, the sequence is a single-byte ASCII character. It is
 * incremented up to 0x7f.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pg_eucjp_increment</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>charptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c1</name></decl>,
				<decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>*</operator><name>charptr</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>c1</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SS2</name></expr>:</case>				<comment type="block">/* JIS X 0201 */</comment>
			<if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>charptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>&gt;=</operator> <literal type="number">0xdf</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>charptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>charptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xa1</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>c2</name> <operator>&lt;</operator> <literal type="number">0xa1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>charptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xa1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>charptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>SS3</name></expr>:</case>				<comment type="block">/* JIS X 0212 */</comment>
			<if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>charptr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>&lt;</operator> <literal type="number">0xa1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>charptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xa1</literal></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>c2</name> <operator>&lt;</operator> <literal type="number">0xfe</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>charptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/* Out of 3-byte code region */</comment>
			<return>return <expr><name>false</name></expr>;</return>

		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call></expr>)</condition> <comment type="block">/* JIS X 0208? */</comment>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>charptr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>&lt;</operator> <literal type="number">0xa1</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>charptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xa1</literal></expr>;</expr_stmt>
						<return>return <expr><name>true</name></expr>;</return>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>c2</name> <operator>&lt;</operator> <literal type="number">0xfe</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>charptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
						<return>return <expr><name>true</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/* Out of 2 byte code region */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>					<comment type="block">/* ASCII, single byte */</comment>
				<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>&gt;</operator> <literal type="number">0x7e</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>charptr</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !FRONTEND */</comment>


<comment type="block">/*
 *-------------------------------------------------------------------
 * encoding info table
 * XXX must be sorted by the same order as enum pg_enc (in mb/pg_wchar.h)
 *-------------------------------------------------------------------
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>pg_wchar_tbl</name></type> <name><name>pg_wchar_table</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><name>pg_ascii2wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_ascii_mblen</name></expr>, <expr><name>pg_ascii_dsplen</name></expr>, <expr><name>pg_ascii_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_SQL_ASCII */</comment>
	<expr><block>{<expr><name>pg_eucjp2wchar_with_len</name></expr>, <expr><name>pg_wchar2euc_with_len</name></expr>, <expr><name>pg_eucjp_mblen</name></expr>, <expr><name>pg_eucjp_dsplen</name></expr>, <expr><name>pg_eucjp_verifier</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,	<comment type="block">/* PG_EUC_JP */</comment>
	<expr><block>{<expr><name>pg_euccn2wchar_with_len</name></expr>, <expr><name>pg_wchar2euc_with_len</name></expr>, <expr><name>pg_euccn_mblen</name></expr>, <expr><name>pg_euccn_dsplen</name></expr>, <expr><name>pg_euccn_verifier</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,	<comment type="block">/* PG_EUC_CN */</comment>
	<expr><block>{<expr><name>pg_euckr2wchar_with_len</name></expr>, <expr><name>pg_wchar2euc_with_len</name></expr>, <expr><name>pg_euckr_mblen</name></expr>, <expr><name>pg_euckr_dsplen</name></expr>, <expr><name>pg_euckr_verifier</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,	<comment type="block">/* PG_EUC_KR */</comment>
	<expr><block>{<expr><name>pg_euctw2wchar_with_len</name></expr>, <expr><name>pg_wchar2euc_with_len</name></expr>, <expr><name>pg_euctw_mblen</name></expr>, <expr><name>pg_euctw_dsplen</name></expr>, <expr><name>pg_euctw_verifier</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,	<comment type="block">/* PG_EUC_TW */</comment>
	<expr><block>{<expr><name>pg_eucjp2wchar_with_len</name></expr>, <expr><name>pg_wchar2euc_with_len</name></expr>, <expr><name>pg_eucjp_mblen</name></expr>, <expr><name>pg_eucjp_dsplen</name></expr>, <expr><name>pg_eucjp_verifier</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,	<comment type="block">/* PG_EUC_JIS_2004 */</comment>
	<expr><block>{<expr><name>pg_utf2wchar_with_len</name></expr>, <expr><name>pg_wchar2utf_with_len</name></expr>, <expr><name>pg_utf_mblen</name></expr>, <expr><name>pg_utf_dsplen</name></expr>, <expr><name>pg_utf8_verifier</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,	<comment type="block">/* PG_UTF8 */</comment>
	<expr><block>{<expr><name>pg_mule2wchar_with_len</name></expr>, <expr><name>pg_wchar2mule_with_len</name></expr>, <expr><name>pg_mule_mblen</name></expr>, <expr><name>pg_mule_dsplen</name></expr>, <expr><name>pg_mule_verifier</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,	<comment type="block">/* PG_MULE_INTERNAL */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_LATIN1 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_LATIN2 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_LATIN3 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_LATIN4 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_LATIN5 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_LATIN6 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_LATIN7 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_LATIN8 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_LATIN9 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_LATIN10 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_WIN1256 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_WIN1258 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_WIN866 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_WIN874 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_KOI8R */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_WIN1251 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_WIN1252 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* ISO-8859-5 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* ISO-8859-6 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* ISO-8859-7 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* ISO-8859-8 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_WIN1250 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_WIN1253 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_WIN1254 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_WIN1255 */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_WIN1257 */</comment>
	<expr><block>{<expr><name>polar_gbk2wchar_with_len</name></expr>, <expr><name>polar_wchar2gbk_with_len</name></expr>, <expr><name>pg_gbk_mblen</name></expr>, <expr><name>pg_gbk_dsplen</name></expr>, <expr><name>pg_gbk_verifier</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,	<comment type="block">/* PG_GBK (POLAR) */</comment>
	<expr><block>{<expr><name>polar_gb18030_2_wchar_with_len</name></expr>, <expr><name>pg_wchar2euc_with_len</name></expr>, <expr><name>pg_gb18030_mblen</name></expr>, <expr><name>pg_gb18030_dsplen</name></expr>, <expr><name>pg_gb18030_verifier</name></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,	<comment type="block">/* PG_GB18030 (POLAR) */</comment>
	<expr><block>{<expr><name>pg_latin12wchar_with_len</name></expr>, <expr><name>pg_wchar2single_with_len</name></expr>, <expr><name>pg_latin1_mblen</name></expr>, <expr><name>pg_latin1_dsplen</name></expr>, <expr><name>pg_latin1_verifier</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>, <comment type="block">/* PG_KOI8U */</comment>
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>pg_sjis_mblen</name></expr>, <expr><name>pg_sjis_dsplen</name></expr>, <expr><name>pg_sjis_verifier</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>, <comment type="block">/* PG_SJIS */</comment>
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>pg_big5_mblen</name></expr>, <expr><name>pg_big5_dsplen</name></expr>, <expr><name>pg_big5_verifier</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>, <comment type="block">/* PG_BIG5 */</comment>
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>pg_uhc_mblen</name></expr>, <expr><name>pg_uhc_dsplen</name></expr>, <expr><name>pg_uhc_verifier</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,	<comment type="block">/* PG_UHC */</comment>
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>pg_johab_mblen</name></expr>, <expr><name>pg_johab_dsplen</name></expr>, <expr><name>pg_johab_verifier</name></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,	<comment type="block">/* PG_JOHAB */</comment>
	<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>pg_sjis_mblen</name></expr>, <expr><name>pg_sjis_dsplen</name></expr>, <expr><name>pg_sjis_verifier</name></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>	<comment type="block">/* PG_SHIFT_JIS_2004 */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* returns the byte length of a word for mule internal code */</comment>
<function><type><name>int</name></type>
<name>pg_mic_mblen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>mbstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_mule_mblen</name><argument_list>(<argument><expr><name>mbstr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the byte length of a multibyte character.
 */</comment>
<function><type><name>int</name></type>
<name>pg_encoding_mblen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mbstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>PG_VALID_ENCODING</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			<expr><name><name>pg_wchar_table</name><index>[<expr><name>encoding</name></expr>]</index></name><operator>.</operator><call><name>mblen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>mbstr</name></expr></argument>)</argument_list></call></expr> </then><else>:
			<expr><name><name>pg_wchar_table</name><index>[<expr><name>PG_SQL_ASCII</name></expr>]</index></name><operator>.</operator><call><name>mblen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>mbstr</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the display length of a multibyte character.
 */</comment>
<function><type><name>int</name></type>
<name>pg_encoding_dsplen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mbstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>PG_VALID_ENCODING</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			<expr><name><name>pg_wchar_table</name><index>[<expr><name>encoding</name></expr>]</index></name><operator>.</operator><call><name>dsplen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>mbstr</name></expr></argument>)</argument_list></call></expr> </then><else>:
			<expr><name><name>pg_wchar_table</name><index>[<expr><name>PG_SQL_ASCII</name></expr>]</index></name><operator>.</operator><call><name>dsplen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>mbstr</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Verify the first multibyte character of the given string.
 * Return its byte length if good, -1 if bad.  (See comments above for
 * full details of the mbverify API.)
 */</comment>
<function><type><name>int</name></type>
<name>pg_encoding_verifymb</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mbstr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>PG_VALID_ENCODING</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
			<expr><name><name>pg_wchar_table</name><index>[<expr><name>encoding</name></expr>]</index></name><operator>.</operator><call><name>mbverify</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>mbstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr> </then><else>:
			<expr><name><name>pg_wchar_table</name><index>[<expr><name>PG_SQL_ASCII</name></expr>]</index></name><operator>.</operator><call><name>mbverify</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>mbstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fetch maximum length of a given encoding
 */</comment>
<function><type><name>int</name></type>
<name>pg_encoding_max_length</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PG_VALID_ENCODING</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>pg_wchar_table</name><index>[<expr><name>encoding</name></expr>]</index></name><operator>.</operator><name>maxmblen</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>

<comment type="block">/*
 * fetch maximum length of the encoding for the current database
 */</comment>
<function><type><name>int</name></type>
<name>pg_database_encoding_max_length</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>pg_wchar_table</name><index>[<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr>]</index></name><operator>.</operator><name>maxmblen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get the character incrementer for the encoding for the current database
 */</comment>
<function><type><name>mbcharacter_incrementer</name></type>
<name>pg_database_encoding_character_incrementer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Eventually it might be best to add a field to pg_wchar_table[], but for
	 * now we just use a switch.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_UTF8</name></expr>:</case>
			<return>return <expr><name>pg_utf8_increment</name></expr>;</return>

		<case>case <expr><name>PG_EUC_JP</name></expr>:</case>
			<return>return <expr><name>pg_eucjp_increment</name></expr>;</return>

		<default>default:</default>
			<return>return <expr><name>pg_generic_charinc</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Verify mbstr to make sure that it is validly encoded in the current
 * database encoding.  Otherwise same as pg_verify_mbstr().
 */</comment>
<function><type><name>bool</name></type>
<name>pg_verifymbstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mbstr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return
		<expr><call><name>pg_verify_mbstr_len</name><argument_list>(<argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mbstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>noError</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Verify mbstr to make sure that it is validly encoded in the specified
 * encoding.
 */</comment>
<function><type><name>bool</name></type>
<name>pg_verify_mbstr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mbstr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_verify_mbstr_len</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>mbstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>noError</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Verify mbstr to make sure that it is validly encoded in the specified
 * encoding.
 *
 * mbstr is not necessarily zero terminated; length of mbstr is
 * specified by len.
 *
 * If OK, return length of string in the encoding.
 * If a problem is found, return -1 when noError is
 * true; when noError is false, ereport() a descriptive message.
 */</comment>
<function><type><name>int</name></type>
<name>pg_verify_mbstr_len</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mbstr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>mbverifier</name></type>	<name>mbverify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mb_len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PG_VALID_ENCODING</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In single-byte encodings, we need only reject nulls (\0).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_encoding_max_length</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nullpos</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>mbstr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>nullpos</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>report_invalid_encoding</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>nullpos</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* fetch function pointer just once */</comment>
	<expr_stmt><expr><name>mbverify</name> <operator>=</operator> <name><name>pg_wchar_table</name><index>[<expr><name>encoding</name></expr>]</index></name><operator>.</operator><name>mbverify</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>mb_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>l</name></decl>;</decl_stmt>

		<comment type="block">/* fast path for ASCII-subset characters */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>mbstr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>mbstr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>mb_len</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>mbstr</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>report_invalid_encoding</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>mbstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>l</name> <operator>=</operator> <call>(<modifier>*</modifier><name>mbverify</name>) <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>mbstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>report_invalid_encoding</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>mbstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>mbstr</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>l</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mb_len</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>mb_len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_encoding_conversion_args: check arguments of a conversion function
 *
 * "expected" arguments can be either an encoding ID or -1 to indicate that
 * the caller will check whether it accepts the ID.
 *
 * Note: the errors here are not really user-facing, so elog instead of
 * ereport seems sufficient.  Also, we trust that the "expected" encoding
 * arguments are valid encoding IDs, but we don't trust the actuals.
 */</comment>
<function><type><name>void</name></type>
<name>check_encoding_conversion_args</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>src_encoding</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>dest_encoding</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>expected_src_encoding</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>expected_dest_encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_VALID_ENCODING</name><argument_list>(<argument><expr><name>src_encoding</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid source encoding ID: %d"</literal></expr></argument>, <argument><expr><name>src_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>src_encoding</name> <operator>!=</operator> <name>expected_src_encoding</name> <operator>&amp;&amp;</operator> <name>expected_src_encoding</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected source encoding \"%s\", but got \"%s\""</literal></expr></argument>,
			 <argument><expr><name><name>pg_enc2name_tbl</name><index>[<expr><name>expected_src_encoding</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
			 <argument><expr><name><name>pg_enc2name_tbl</name><index>[<expr><name>src_encoding</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_VALID_ENCODING</name><argument_list>(<argument><expr><name>dest_encoding</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid destination encoding ID: %d"</literal></expr></argument>, <argument><expr><name>dest_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dest_encoding</name> <operator>!=</operator> <name>expected_dest_encoding</name> <operator>&amp;&amp;</operator> <name>expected_dest_encoding</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected destination encoding \"%s\", but got \"%s\""</literal></expr></argument>,
			 <argument><expr><name><name>pg_enc2name_tbl</name><index>[<expr><name>expected_dest_encoding</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
			 <argument><expr><name><name>pg_enc2name_tbl</name><index>[<expr><name>dest_encoding</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"encoding conversion length must not be negative"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * report_invalid_encoding: complain about invalid multibyte character
 *
 * note: len is remaining length of string, not length of character;
 * len must be greater than zero, as we always examine the first byte.
 */</comment>
<function><type><name>void</name></type>
<name>report_invalid_encoding</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mbstr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name> <init>= <expr><call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>mbstr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">5</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>,
				<decl><type ref="prev"/><name>jlimit</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>jlimit</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>jlimit</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>jlimit</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* prevent buffer overrun */</comment>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>jlimit</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"0x%02x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>mbstr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>jlimit</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CHARACTER_NOT_IN_REPERTOIRE</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid byte sequence for encoding \"%s\": %s"</literal></expr></argument>,
					<argument><expr><name><name>pg_enc2name_tbl</name><index>[<expr><name>encoding</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
					<argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * report_untranslatable_char: complain about untranslatable character
 *
 * note: len is remaining length of string, not length of character;
 * len must be greater than zero, as we always examine the first byte.
 */</comment>
<function><type><name>void</name></type>
<name>report_untranslatable_char</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>src_encoding</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest_encoding</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mbstr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>l</name> <init>= <expr><call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name>src_encoding</name></expr></argument>, <argument><expr><name>mbstr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">5</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>,
				<decl><type ref="prev"/><name>jlimit</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>jlimit</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>jlimit</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>jlimit</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* prevent buffer overrun */</comment>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>jlimit</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"0x%02x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>mbstr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>jlimit</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNTRANSLATABLE_CHARACTER</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"character with byte sequence %s in encoding \"%s\" has no equivalent in encoding \"%s\""</literal></expr></argument>,
					<argument><expr><name>buf</name></expr></argument>,
					<argument><expr><name><name>pg_enc2name_tbl</name><index>[<expr><name>src_encoding</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
					<argument><expr><name><name>pg_enc2name_tbl</name><index>[<expr><name>dest_encoding</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !FRONTEND */</comment>
</unit>
