<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/cache/partcache.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * partcache.c
 *		Support routines for manipulating partition information cached in
 *		relcache
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *		  src/backend/utils/cache/partcache.c
 *
 *-------------------------------------------------------------------------
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_partitioned_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partbounds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_partition_qual</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>qsort_partition_hbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>qsort_partition_list_value_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
							   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>qsort_partition_rbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
						   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * RelationBuildPartitionKey
 *		Build partition key data of relation, and attach to relcache
 *
 * Partitioning key data is a complex structure; to avoid complicated logic to
 * free individual elements whenever the relcache entry is flushed, we give it
 * its own memory context, a child of CacheMemoryContext, which can easily be
 * deleted on its own.  To avoid leaking memory in that context in case of an
 * error partway through this function, the context is initially created as a
 * child of CurTransactionContext and only re-parented to CacheMemoryContext
 * at the end, when no further errors are possible.  Also, we don't make this
 * context the current context except in very brief code sections, out of fear
 * that some of our callees allocate memory on their own which would be leaked
 * permanently.
 */</comment>
<function><type><name>void</name></type>
<name>RelationBuildPartitionKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_partitioned_table</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>opclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexprs_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>partkeycxt</name></decl>,
				<decl><type ref="prev"/><name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>procnum</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>,
							<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The following happens when we have created our pg_class entry but not
	 * the pg_partitioned_table entry yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>partkeycxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>,
									   <argument><expr><literal type="string">"partition key"</literal></expr></argument>,
									   <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextCopyAndSetIdentifier</name><argument_list>(<argument><expr><name>partkeycxt</name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>(</operator><name>PartitionKey</name><operator>)</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>partkeycxt</name></expr></argument>,
												<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fixed-length attributes */</comment>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_partitioned_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>partstrat</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can rely on the first variable-length attribute being mapped to the
	 * relevant field of the catalog's C struct, because all previous
	 * attributes are non-nullable and fixed-length.
	 */</comment>
	<expr_stmt><expr><name>attrs</name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>partattrs</name><operator>.</operator><name>values</name></name></expr>;</expr_stmt>

	<comment type="block">/* But use the hard way to retrieve further variable-length attributes */</comment>
	<comment type="block">/* Operator class */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_partitioned_table_partclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Collation */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_partitioned_table_partcollation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collation</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Expressions */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_partitioned_table_partexprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprString</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>exprString</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>exprString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>exprString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Run the expressions through const-simplification since the planner
		 * will be comparing them to similarly-processed qual clause operands,
		 * and may fail to detect valid matches without this step; fix
		 * opfuncids while at it.  We don't need to bother with
		 * canonicalize_qual() though, because partition expressions should be
		 * in canonical form already (ie, no need for OR-merging or constant
		 * elimination).
		 */</comment>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>partkeycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allocate assorted arrays in the partkeycxt, which we'll fill below */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>partkeycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>partopfamily</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name></name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name></name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttypalign</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* determine support function number to search for */</comment>
	<expr_stmt><expr><name>procnum</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name><operator>)</operator></expr> ?</condition><then>
		<expr><name>HASHEXTENDED_PROC</name></expr> </then><else>: <expr><name>BTORDER_PROC</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Copy partattrs and fill other per-attribute info */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name></name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opclasstup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opclassform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>

		<comment type="block">/* Collect opfamily information */</comment>
		<expr_stmt><expr><name>opclasstup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>opclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opclasstup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name><name>opclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>opclassform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opclasstup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>partopfamily</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>opclassform</name><operator>-&gt;</operator><name>opcfamily</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>partopcintype</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>opclassform</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>

		<comment type="block">/* Get a support function for the specified opfamily and datatypes */</comment>
		<expr_stmt><expr><name>funcid</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>opclassform</name><operator>-&gt;</operator><name>opcfamily</name></name></expr></argument>,
								   <argument><expr><name><name>opclassform</name><operator>-&gt;</operator><name>opcintype</name></name></expr></argument>,
								   <argument><expr><name><name>opclassform</name><operator>-&gt;</operator><name>opcintype</name></name></expr></argument>,
								   <argument><expr><name>procnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator class \"%s\" of access method %s is missing support function %d for type %s"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>opclassform</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><ternary><condition><expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name><operator>)</operator></expr> ?</condition><then>
							<expr><literal type="string">"hash"</literal></expr> </then><else>: <expr><literal type="string">"btree"</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name>procnum</name></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>opclassform</name><operator>-&gt;</operator><name>opcintype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>partkeycxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Collation */</comment>
		<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>collation</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* Collect type information */</comment>
		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>partexprs_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of partition key expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttypmod</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>parttypcoll</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>partexprs_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>partexprs_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>parttypalign</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opclasstup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assert that we're not leaking any old data during assignments below */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkeycxt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkey</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Success --- reparent our context and make the relcache point to the
	 * newly constructed key
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name>partkeycxt</name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkeycxt</name></name> <operator>=</operator> <name>partkeycxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_partkey</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationBuildPartitionDesc
 *		Form rel's partition descriptor, and store in relcache entry
 *
 * Note: the descriptor won't be flushed from the cache by
 * RelationClearRelation() unless it's changed because of
 * addition or removal of a partition.  Hence, code holding a lock
 * that's sufficient to prevent that can assume that rd_partdesc
 * won't change underneath it.
 */</comment>
<function><type><name>void</name></type>
<name>RelationBuildPartitionDesc</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inhoids</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>partoids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>boundspecs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>nparts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionDesc</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>ndatums</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>default_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Hash partitioning specific */</comment>
	<decl_stmt><decl><type><name>PartitionHashBound</name> <modifier>*</modifier><modifier>*</modifier></type><name>hbounds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* List partitioning specific */</comment>
	<decl_stmt><decl><type><name>PartitionListValue</name> <modifier>*</modifier><modifier>*</modifier></type><name>all_values</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Range partitioning specific */</comment>
	<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier><modifier>*</modifier></type><name>rbounds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get partition oids from pg_inherits */</comment>
	<expr_stmt><expr><name>inhoids</name> <operator>=</operator> <call><name>find_inheritance_children</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Collect bound spec nodes in a list */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>partoids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>inhoids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>inhrelid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>boundspec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								<argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null relpartbound for relation %u"</literal></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>boundspec</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sanity check: If the PartitionBoundSpec says this is the default
		 * partition, its OID should correspond to whatever's stored in
		 * pg_partitioned_table.partdefid; if not, the catalog is corrupt.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>, <argument><expr><name>boundspec</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>is_default</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>partdefid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>partdefid</name> <operator>=</operator> <call><name>get_default_partition_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>partdefid</name> <operator>!=</operator> <name>inhrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected partdefid %u, but got %u"</literal></expr></argument>,
					 <argument><expr><name>inhrelid</name></expr></argument>, <argument><expr><name>partdefid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>boundspecs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>boundspecs</name></expr></argument>, <argument><expr><name>boundspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partoids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>partoids</name></expr></argument>, <argument><expr><name>inhrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>nparts</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>partoids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nparts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oids</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>partoids</argument>)</argument_list></macro>
			<expr_stmt><expr><name><name>oids</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Convert from node to the internal representation */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name>nparts</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>hbounds</name> <operator>=</operator> <operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionHashBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>boundspecs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>,
													<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy in partition bound spec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><operator>)</operator>
					<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionHashBound</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>modulus</name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>remainder</name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/* Sort all the bounds in ascending order */</comment>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>hbounds</name></expr></argument>, <argument><expr><name>nparts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionHashBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>qsort_partition_hbound_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>non_null_values</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Create a unified list of non-null values across all partitions.
			 */</comment>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>null_index</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>boundspecs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>,
													<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy in partition bound spec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Note the index of the partition bound spec for the default
				 * partition. There's no datum to add to the list of non-null
				 * datums for this partition.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>default_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>c</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>PartitionListValue</name> <modifier>*</modifier></type><name>list_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>list_value</name> <operator>=</operator> <operator>(</operator><name>PartitionListValue</name> <operator>*</operator><operator>)</operator>
							<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>list_value</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>list_value</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * Never put a null into the values array, flag
						 * instead for the code further down below where we
						 * construct the actual relcache struct.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>null_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found null more than once"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>null_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>list_value</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>non_null_values</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_null_values</name></expr></argument>,
												  <argument><expr><name>list_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>non_null_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Collect all list values in one array. Alongside the value, we
			 * also save the index of partition the value comes from.
			 */</comment>
			<expr_stmt><expr><name>all_values</name> <operator>=</operator> <operator>(</operator><name>PartitionListValue</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator>
														<sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>non_null_values</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionListValue</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionListValue</name> <operator>*</operator><operator>)</operator>
					<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>value</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>all_values</name></expr></argument>, <argument><expr><name>ndatums</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionListValue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
					  <argument><expr><name>qsort_partition_list_value_cmp</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier><modifier>*</modifier></type><name>all_bounds</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>all_bounds</name> <operator>=</operator> <operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <name>nparts</name> <operator>*</operator>
														  <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Create a unified list of range bounds across all the
			 * partitions.
			 */</comment>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <name>ndatums</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>boundspecs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>,
													<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>lower</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>upper</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid strategy in partition bound spec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Note the index of the partition bound spec for the default
				 * partition. There's no datum to add to the allbounds array
				 * for this partition.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>default_index</name> <operator>=</operator> <name>i</name><operator>++</operator></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>lower</name> <operator>=</operator> <call><name>make_one_partition_rbound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>upper</name> <operator>=</operator> <call><name>make_one_partition_rbound</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>all_bounds</name><index>[<expr><name>ndatums</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>lower</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>all_bounds</name><index>[<expr><name>ndatums</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>upper</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndatums</name> <operator>==</operator> <name>nparts</name> <operator>*</operator> <literal type="number">2</literal> <operator>||</operator>
				   <operator>(</operator><name>default_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>ndatums</name> <operator>==</operator> <operator>(</operator><name>nparts</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Sort all the bounds in ascending order */</comment>
			<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>all_bounds</name></expr></argument>, <argument><expr><name>ndatums</name></expr></argument>,
					  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
					  <argument><expr><name>qsort_partition_rbound_cmp</name></expr></argument>,
					  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Save distinct bounds from all_bounds into rbounds. */</comment>
			<expr_stmt><expr><name>rbounds</name> <operator>=</operator> <operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeBound</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name><name>all_bounds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>is_distinct</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

				<comment type="block">/* Is the current bound distinct from the previous one? */</comment>
				<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Datum</name></type>		<name>cmpval</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>cur</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>prev</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>is_distinct</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If the bounds are both MINVALUE or MAXVALUE, stop now
					 * and treat them as equal, since any values after this
					 * point must be ignored.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>cmpval</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name><name>prev</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>cmpval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>is_distinct</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/*
				 * Only if the bound is distinct save it into a temporary
				 * array i.e. rbounds which is later copied into boundinfo
				 * datums array.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>is_distinct</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>rbounds</name><index>[<expr><name>k</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>all_bounds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/* Update ndatums to hold the count of distinct datums. */</comment>
			<expr_stmt><expr><name>ndatums</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Assert we aren't about to leak any old data structure */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pdcxt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partdesc</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now build the actual relcache partition descriptor.  Note that the
	 * order of operations here is fairly critical.  If we fail partway
	 * through this code, we won't have leaked memory because the rd_pdcxt is
	 * attached to the relcache entry immediately, so it'll be freed whenever
	 * the entry is rebuilt or destroyed.  However, we don't assign to
	 * rd_partdesc until the cached data structure is fully complete and
	 * valid, so that no other code might try to use it.
	 */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pdcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
										  <argument><expr><literal type="string">"partition descriptor"</literal></expr></argument>,
										  <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextCopyAndSetIdentifier</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pdcxt</name></name></expr></argument>,
									  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pdcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PartitionDescData</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nparts</name></name> <operator>=</operator> <name>nparts</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nparts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionBoundInfo</name></type> <name>boundinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>mapping</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>next_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>oids</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nparts</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>boundinfo</name> <operator>=</operator> <operator>(</operator><name>PartitionBoundInfoData</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PartitionBoundInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name>ndatums</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize mapping array with invalid values */</comment>
		<expr_stmt><expr><name>mapping</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>mapping</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

		<switch>switch <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/* Moduli are stored in ascending order */</comment>
					<decl_stmt><decl><type><name>int</name></type>			<name>greatest_modulus</name> <init>= <expr><name><name>hbounds</name><index>[<expr><name>ndatums</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>modulus</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>greatest_modulus</name> <operator>*</operator>
														<sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>greatest_modulus</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>modulus</name> <init>= <expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>modulus</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>remainder</name> <init>= <expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>remainder</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator>
																<sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>modulus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<while>while <condition>(<expr><name>remainder</name> <operator>&lt;</operator> <name>greatest_modulus</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* overlap? */</comment>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>remainder</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>remainder</name> <operator>+=</operator> <name>modulus</name></expr>;</expr_stmt>
						</block_content>}</block></while>

						<expr_stmt><expr><name><name>mapping</name><index>[<expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>hbounds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hbounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Copy values.  Indexes of individual values are mapped
					 * to canonical values so that they match for any two list
					 * partitioned tables with same number of partitions and
					 * same lists per partition.  One way to canonicalize is
					 * to assign the index in all_values[] of the smallest
					 * value of each partition, as the index of all of the
					 * partition's values.
					 */</comment>
					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>value</name></expr></argument>,
															<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
															<argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* If the old index has no mapping, assign one */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>mapping</name><index>[<expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>mapping</name><index>[<expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr>]</index></name> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>mapping</name><index>[<expr><name><name>all_values</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></for>

					<comment type="block">/*
					 * If null-accepting partition has no mapped index yet,
					 * assign one.  This could happen if such partition
					 * accepts only null and hence not covered in the above
					 * loop which only handled non-null values.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>null_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>null_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>mapping</name><index>[<expr><name>null_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>mapping</name><index>[<expr><name>null_index</name></expr>]</index></name> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>null_index</name></name> <operator>=</operator> <name><name>mapping</name><index>[<expr><name>null_index</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* Assign mapped index for the default partition. */</comment>
					<if_stmt><if>if <condition>(<expr><name>default_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * The default partition accepts any value not
						 * specified in the lists of other partitions, hence
						 * it should not get mapped index while assigning
						 * those for non-null datums.
						 */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>default_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
							   <name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* All partitions must now have a valid mapping */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>next_index</name> <operator>==</operator> <name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>*</operator><operator>)</operator>
						<call><name>palloc</name><argument_list>(<argument><expr><name>ndatums</name> <operator>*</operator>
							   <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>ndatums</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
														<sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator>
																<sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PartitionRangeDatumKind</name> <operator>*</operator><operator>)</operator>
							<call><name>palloc</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name> <operator>*</operator>
								   <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>kind</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator>
									<call><name>datumCopy</name><argument_list>(<argument><expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>datums</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttypbyval</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
											  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>parttyplen</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>kind</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>kind</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
						</block_content>}</block></for>

						<comment type="block">/*
						 * There is no mapping for invalid indexes.
						 *
						 * Any lower bounds in the rbounds array have invalid
						 * indexes assigned, because the values between the
						 * previous bound (if there is one) and this (lower)
						 * bound are not part of the range of any existing
						 * partition.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>lower</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
						<else>else
						<block>{<block_content>
							<decl_stmt><decl><type><name>int</name></type>			<name>orig_index</name> <init>= <expr><name><name>rbounds</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>index</name></expr></init></decl>;</decl_stmt>

							<comment type="block">/* If the old index has no mapping, assign one */</comment>
							<if_stmt><if>if <condition>(<expr><name><name>mapping</name><index>[<expr><name>orig_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name><name>mapping</name><index>[<expr><name>orig_index</name></expr>]</index></name> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

							<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>mapping</name><index>[<expr><name>orig_index</name></expr>]</index></name></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></for>

					<comment type="block">/* Assign mapped index for the default partition. */</comment>
					<if_stmt><if>if <condition>(<expr><name>default_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>default_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name> <operator>=</operator> <name>next_index</name><operator>++</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>default_index</name></name> <operator>=</operator> <name><name>mapping</name><index>[<expr><name>default_index</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>boundinfo</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>key</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>boundinfo</name></name> <operator>=</operator> <name>boundinfo</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now assign OIDs from the original array into mapped indexes of the
		 * result array.  Order of OIDs in the former is defined by the
		 * catalog scan that retrieved them, whereas that in the latter is
		 * defined by canonicalized representation of the partition bounds.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>oids</name><index>[<expr><name><name>mapping</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name><name>oids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partdesc</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RelationGetPartitionQual
 *
 * Returns a list of partition quals
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RelationGetPartitionQual</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick exit */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>generate_partition_qual</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_partition_qual_relid
 *
 * Returns an expression tree describing the passed-in relation's partition
 * constraint.
 *
 * If the relation is not found, or is not a partition, or there is no
 * partition constraint, return NULL.  We must guard against the first two
 * cases because this supports a SQL function that could be passed any OID.
 * The last case can happen even if relispartition is true, when a default
 * partition is the only partition.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>get_partition_qual_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do the work only if this relation exists and is a partition. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_rel_relispartition</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>and_args</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>and_args</name> <operator>=</operator> <call><name>generate_partition_qual</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Convert implicit-AND list format to boolean expression */</comment>
		<if_stmt><if>if <condition>(<expr><name>and_args</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>and_args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>and_args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>and_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Keep the lock, to allow safe deparsing against the rel by caller. */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_partition_qual
 *
 * Generate partition predicate from rel's partition bound expression. The
 * function returns a NIL list if there is no predicate.
 *
 * We cache a copy of the result in the relcache entry, after constructing
 * it using the caller's context.  This approach avoids leaking any data
 * into long-lived cache contexts, especially if we fail partway through.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_partition_qual</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>boundDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>my_qual</name> <init>= <expr><name>NIL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

	<comment type="block">/* Guard against stack overflow due to overly deep partition tree */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we already cached the result, just return a copy */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheckvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheck</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Grab at least an AccessShareLock on the parent table */</comment>
	<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><call><name>get_partition_parent</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get pg_class.relpartbound */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>boundDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								 <argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>bound</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>bound</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>,
						 <argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>boundDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>my_qual</name> <operator>=</operator> <call><name>get_qual_from_partbound</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the parent's quals to the list (if any) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>generate_partition_qual</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>my_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>my_qual</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Change Vars to have partition's attnos instead of the parent's. We do
	 * this after we concatenate the parent's quals, because we want every Var
	 * in it to bear this relation's attnos. It's safe to assume varno = 1
	 * here.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>map_partition_varattnos</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* There can never be a whole-row reference here */</comment>
	<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected whole-row reference found in partition key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Assert that we're not leaking any old data during assignments below */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheckcxt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheck</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save a copy in the relcache.  The order of these operations is fairly
	 * critical to avoid memory leaks and ensure that we don't leave a corrupt
	 * relcache entry if we fail partway through copyObject.
	 *
	 * If, as is definitely possible, the partcheck list is NIL, then we do
	 * not need to make a context to hold it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheckcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
													 <argument><expr><literal type="string">"partition constraint"</literal></expr></argument>,
													 <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextCopyAndSetIdentifier</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheckcxt</name></name></expr></argument>,
										  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheckcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheck</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheck</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_partcheckvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Keep the parent locked until commit */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return the working copy to the caller */</comment>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_partition_hbound_cmp
 *
 * We sort hash bounds by modulus, then by remainder.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>qsort_partition_hbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionHashBound</name> <modifier>*</modifier></type><name>h1</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionHashBound</name> <modifier>*</modifier></type><name>h2</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionHashBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>partition_hbound_cmp</name><argument_list>(<argument><expr><name><name>h1</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>, <argument><expr><name><name>h1</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>,
								<argument><expr><name><name>h2</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>, <argument><expr><name><name>h2</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_partition_list_value_cmp
 *
 * Compare two list partition bound datums
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>qsort_partition_list_value_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val1</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>PartitionListValue</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>,
				<decl><type ref="prev"/><name>val2</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>PartitionListValue</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>value</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>PartitionKey</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
										   <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
										   <argument><expr><name>val1</name></expr></argument>, <argument><expr><name>val2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Used when sorting range bounds across all range partitions */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>qsort_partition_rbound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>b1</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeBound</name> <modifier>*</modifier></type><name>b2</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>PartitionRangeBound</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>PartitionKey</name><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>partition_rbound_cmp</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partnatts</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partsupfunc</name></name></expr></argument>,
								<argument><expr><name><name>key</name><operator>-&gt;</operator><name>partcollation</name></name></expr></argument>, <argument><expr><name><name>b1</name><operator>-&gt;</operator><name>datums</name></name></expr></argument>, <argument><expr><name><name>b1</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>,
								<argument><expr><name><name>b1</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
