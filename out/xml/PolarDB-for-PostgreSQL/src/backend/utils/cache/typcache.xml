<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/cache/typcache.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * typcache.c
 *	  POSTGRES type cache code
 *
 * The type cache exists to speed lookup of certain information about data
 * types that is not directly available from a type's pg_type row.  For
 * example, we use a type's default btree opclass, or the default hash
 * opclass if no btree opclass exists, to determine which operators should
 * be used for grouping and sorting the type (GROUP BY, ORDER BY ASC/DESC).
 *
 * Several seemingly-odd choices have been made to support use of the type
 * cache by generic array and record handling routines, such as array_eq(),
 * record_cmp(), and hash_array().  Because those routines are used as index
 * support operations, they cannot leak memory.  To allow them to execute
 * efficiently, all information that they would like to re-use across calls
 * is kept in the type cache.
 *
 * Once created, a type cache entry lives as long as the backend does, so
 * there is no need for a call to release a cache entry.  If the type is
 * dropped, the cache entry simply becomes wasted storage.  This is not
 * expected to happen often, and assuming that typcache entries are good
 * permanently allows caching pointers to them in long-lived places.
 *
 * We have some provisions for updating cache entries if the stored data
 * becomes obsolete.  Information dependent on opclasses is cleared if we
 * detect updates to pg_opclass.  We also support clearing the tuple
 * descriptor and operator/function parts of a rowtype's cache entry,
 * since those may need to change as a consequence of ALTER TABLE.
 * Domain constraint changes are also tracked properly.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/cache/typcache.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/session.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_enum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/dshash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/* The main type cache hashtable searched by lookup_type_cache */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>TypeCacheHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* List of type cache entries for domain types */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TypeCacheEntry</name> <modifier>*</modifier></type><name>firstDomainTypeEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Private flag bits in the TypeCacheEntry.flags field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_CHECKED_BTREE_OPCLASS</name></cpp:macro>		<cpp:value>0x000001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_CHECKED_HASH_OPCLASS</name></cpp:macro>		<cpp:value>0x000002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_CHECKED_EQ_OPR</name></cpp:macro>				<cpp:value>0x000004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_CHECKED_LT_OPR</name></cpp:macro>				<cpp:value>0x000008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_CHECKED_GT_OPR</name></cpp:macro>				<cpp:value>0x000010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_CHECKED_CMP_PROC</name></cpp:macro>			<cpp:value>0x000020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_CHECKED_HASH_PROC</name></cpp:macro>			<cpp:value>0x000040</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_CHECKED_HASH_EXTENDED_PROC</name></cpp:macro>	<cpp:value>0x000080</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_CHECKED_ELEM_PROPERTIES</name></cpp:macro>		<cpp:value>0x000100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_HAVE_ELEM_EQUALITY</name></cpp:macro>			<cpp:value>0x000200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_HAVE_ELEM_COMPARE</name></cpp:macro>			<cpp:value>0x000400</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_HAVE_ELEM_HASHING</name></cpp:macro>			<cpp:value>0x000800</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</name></cpp:macro>	<cpp:value>0x001000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_CHECKED_FIELD_PROPERTIES</name></cpp:macro>	<cpp:value>0x002000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_HAVE_FIELD_EQUALITY</name></cpp:macro>			<cpp:value>0x004000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_HAVE_FIELD_COMPARE</name></cpp:macro>			<cpp:value>0x008000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</name></cpp:macro>	<cpp:value>0x010000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCFLAGS_DOMAIN_BASE_IS_COMPOSITE</name></cpp:macro>	<cpp:value>0x020000</cpp:value></cpp:define>

<comment type="block">/*
 * Data stored about a domain type's constraints.  Note that we do not create
 * this struct for the common case of a constraint-less domain; we just set
 * domainData to NULL to indicate that.
 *
 * Within a DomainConstraintCache, we store expression plan trees, but the
 * check_exprstate fields of the DomainConstraintState nodes are just NULL.
 * When needed, expression evaluation nodes are built by flat-copying the
 * DomainConstraintState nodes and applying ExecInitExpr to check_expr.
 * Such a node tree is not part of the DomainConstraintCache, but is
 * considered to belong to a DomainConstraintRef.
 */</comment>
<struct>struct <name>DomainConstraintCache</name>
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>constraints</name></decl>;</decl_stmt>	<comment type="block">/* list of DomainConstraintState nodes */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>dccContext</name></decl>;</decl_stmt>	<comment type="block">/* memory context holding all associated data */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>dccRefCount</name></decl>;</decl_stmt>	<comment type="block">/* number of references to this struct */</comment>
}</block>;</struct>

<comment type="block">/* Private information to support comparisons of enum values */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>enum_oid</name></decl>;</decl_stmt>		<comment type="block">/* OID of one enum value */</comment>
	<decl_stmt><decl><type><name>float4</name></type>		<name>sort_order</name></decl>;</decl_stmt>		<comment type="block">/* its sort position */</comment>
}</block></struct></type> <name>EnumItem</name>;</typedef>

<typedef>typedef <type><struct>struct <name>TypeCacheEnumData</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>bitmap_base</name></decl>;</decl_stmt>	<comment type="block">/* OID corresponding to bit 0 of bitmapset */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>sorted_values</name></decl>;</decl_stmt>	<comment type="block">/* Set of OIDs known to be in order */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_values</name></decl>;</decl_stmt>		<comment type="block">/* total number of values in enum */</comment>
	<decl_stmt><decl><type><name>EnumItem</name></type>	<name><name>enum_values</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>TypeCacheEnumData</name>;</typedef>

<comment type="block">/*
 * We use a separate table for storing the definitions of non-anonymous
 * record types.  Once defined, a record type will be remembered for the
 * life of the backend.  Subsequent uses of the "same" record type (where
 * sameness means equalTupleDescs) will refer to the existing table entry.
 *
 * Stored record types are remembered in a linear array of TupleDescs,
 * which can be indexed quickly with the assigned typmod.  There is also
 * a hash table to speed searches for matching TupleDescs.
 */</comment>

<typedef>typedef <type><struct>struct <name>RecordCacheEntry</name>
<block>{
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
}</block></struct></type> <name>RecordCacheEntry</name>;</typedef>

<comment type="block">/*
 * To deal with non-anonymous record types that are exchanged by backends
 * involved in a parallel query, we also need a shared version of the above.
 */</comment>
<struct>struct <name>SharedRecordTypmodRegistry</name>
<block>{
	<comment type="block">/* A hash table for finding a matching TupleDesc. */</comment>
	<decl_stmt><decl><type><name>dshash_table_handle</name></type> <name>record_table_handle</name></decl>;</decl_stmt>
	<comment type="block">/* A hash table for finding a TupleDesc by typmod. */</comment>
	<decl_stmt><decl><type><name>dshash_table_handle</name></type> <name>typmod_table_handle</name></decl>;</decl_stmt>
	<comment type="block">/* A source of new record typmod numbers. */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>next_typmod</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * When using shared tuple descriptors as hash table keys we need a way to be
 * able to search for an equal shared TupleDesc using a backend-local
 * TupleDesc.  So we use this type which can hold either, and hash and compare
 * functions that know how to handle both.
 */</comment>
<typedef>typedef <type><struct>struct <name>SharedRecordTableKey</name>
<block>{
	<union>union
	<block>{
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>local_tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>shared_tupdesc</name></decl>;</decl_stmt>
	}</block>			<decl><name>u</name></decl>;</union>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shared</name></decl>;</decl_stmt>
}</block></struct></type> <name>SharedRecordTableKey</name>;</typedef>

<comment type="block">/*
 * The shared version of RecordCacheEntry.  This lets us look up a typmod
 * using a TupleDesc which may be in local or shared memory.
 */</comment>
<typedef>typedef <type><struct>struct <name>SharedRecordTableEntry</name>
<block>{
	<decl_stmt><decl><type><name>SharedRecordTableKey</name></type> <name>key</name></decl>;</decl_stmt>
}</block></struct></type> <name>SharedRecordTableEntry</name>;</typedef>

<comment type="block">/*
 * An entry in SharedRecordTypmodRegistry's typmod table.  This lets us look
 * up a TupleDesc in shared memory using a typmod.
 */</comment>
<typedef>typedef <type><struct>struct <name>SharedTypmodTableEntry</name>
<block>{
	<decl_stmt><decl><type><name>uint32</name></type>		<name>typmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>shared_tupdesc</name></decl>;</decl_stmt>
}</block></struct></type> <name>SharedTypmodTableEntry</name>;</typedef>

<comment type="block">/*
 * A comparator function for SharedRecordTableKey.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>shared_record_table_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
							<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>area</name> <init>= <expr><operator>(</operator><name>dsa_area</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedRecordTableKey</name> <modifier>*</modifier></type><name>k1</name> <init>= <expr><operator>(</operator><name>SharedRecordTableKey</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedRecordTableKey</name> <modifier>*</modifier></type><name>k2</name> <init>= <expr><operator>(</operator><name>SharedRecordTableKey</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>t1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>t2</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>k1</name><operator>-&gt;</operator><name>shared</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>t1</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name><operator>)</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>k1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>shared_tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>t1</name> <operator>=</operator> <name><name>k1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>local_tupdesc</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>k2</name><operator>-&gt;</operator><name>shared</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>t2</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name><operator>)</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>k2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>shared_tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>t2</name> <operator>=</operator> <name><name>k2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>local_tupdesc</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><ternary><condition><expr><call><name>equalTupleDescs</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A hash function for SharedRecordTableKey.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>shared_record_table_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>area</name> <init>= <expr><operator>(</operator><name>dsa_area</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedRecordTableKey</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><operator>(</operator><name>SharedRecordTableKey</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>t</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>k</name><operator>-&gt;</operator><name>shared</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name><operator>)</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name><name>k</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>shared_tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>local_tupdesc</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><call><name>hashTupleDesc</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parameters for SharedRecordTypmodRegistry's TupleDesc table. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>dshash_parameters</name></type> <name>srtr_record_table_params</name> <init>= <expr><block>{
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedRecordTableKey</name></expr></argument>)</argument_list></sizeof></expr>,	<comment type="block">/* unused */</comment>
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedRecordTableEntry</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><name>shared_record_table_compare</name></expr>,
	<expr><name>shared_record_table_hash</name></expr>,
	<expr><name>LWTRANCHE_SESSION_RECORD_TABLE</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Parameters for SharedRecordTypmodRegistry's typmod hash table. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>dshash_parameters</name></type> <name>srtr_typmod_table_params</name> <init>= <expr><block>{
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedTypmodTableEntry</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><name>dshash_memcmp</name></expr>,
	<expr><name>dshash_memhash</name></expr>,
	<expr><name>LWTRANCHE_SESSION_TYPMOD_TABLE</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* hashtable for recognizing registered record types */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>RecordCacheHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* arrays of info about registered record types, indexed by assigned typmod */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TupleDesc</name> <modifier>*</modifier></type><name>RecordCacheArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name> <modifier>*</modifier></type><name>RecordIdentifierArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int32</name></type> <name>RecordCacheArrayLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* allocated length of above arrays */</comment>
<decl_stmt><decl><type><name>int32</name></type> <name>NextRecordTypmod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* number of entries used */</comment>

<comment type="block">/*
 * Process-wide counter for generating unique tupledesc identifiers.
 * Zero and one (INVALID_TUPLEDESC_IDENTIFIER) aren't allowed to be chosen
 * as identifiers, so we start the counter at INVALID_TUPLEDESC_IDENTIFIER.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>tupledesc_id_counter</name> <init>= <expr><name>INVALID_TUPLEDESC_IDENTIFIER</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_typcache_tupdesc</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_rangetype_info</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_domaintype_info</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>dcs_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>decr_dcc_refcount</name><parameter_list>(<parameter><decl><type><name>DomainConstraintCache</name> <modifier>*</modifier></type><name>dcc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dccref_deletion_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>prep_domain_constraints</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>execctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>array_element_has_equality</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>array_element_has_compare</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>array_element_has_hashing</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>array_element_has_extended_hashing</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cache_array_element_properties</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>record_fields_have_equality</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>record_fields_have_compare</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cache_record_field_properties</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>range_element_has_hashing</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>range_element_has_extended_hashing</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cache_range_element_properties</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TypeCacheRelCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TypeCacheOpcCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TypeCacheConstrCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_enum_cache_data</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>EnumItem</name> <modifier>*</modifier></type><name>find_enumitem</name><parameter_list>(<parameter><decl><type><name>TypeCacheEnumData</name> <modifier>*</modifier></type><name>enumdata</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>enum_oid_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shared_record_typmod_registry_detach</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl></parameter>,
									 <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>find_or_make_matching_shared_tupledesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>dsa_pointer</name></type> <name>share_tupledesc</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
				<parameter><decl><type><name>uint32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * lookup_type_cache
 *
 * Fetch the type cache entry for the specified datatype, and make sure that
 * all the fields requested by bits in 'flags' are valid.
 *
 * The result is never NULL --- we will ereport() if the passed type OID is
 * invalid.  Note however that we may fail to find one or more of the
 * values requested by 'flags'; the caller needs to check whether the fields
 * are InvalidOid or not.
 */</comment>
<function><type><name>TypeCacheEntry</name> <modifier>*</modifier></type>
<name>lookup_type_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>TypeCacheHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through: initialize the hash table */</comment>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TypeCacheEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>TypeCacheHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Type information cache"</literal></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Also set up callbacks for SI invalidations */</comment>
		<expr_stmt><expr><call><name>CacheRegisterRelcacheCallback</name><argument_list>(<argument><expr><name>TypeCacheRelCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><name>TypeCacheOpcCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>TypeCacheConstrCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><name>TypeCacheConstrCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Also make sure CacheMemoryContext exists */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CacheMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Try to look up an existing entry */</comment>
	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>TypeCacheHash</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>type_id</name></expr></argument>,
											  <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typentry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we didn't find one, we want to make one.  But first look up the
		 * pg_type row, just to make sure we don't make a cache entry for an
		 * invalid type OID.  If the type OID is not valid, present a
		 * user-facing error, since some code paths such as domain_in() allow
		 * this function to be reached with a user-supplied OID.
		 */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>type_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>typtup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>typtup</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" is only a shell"</literal></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typtup</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Now make the typcache entry */</comment>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>TypeCacheHash</name></expr></argument>,
												  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>type_id</name></expr></argument>,
												  <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* it wasn't there a moment ago */</comment>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TypeCacheEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name> <operator>=</operator> <name>type_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>typalign</name></name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>typstorage</name></name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>typrelid</name></name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>typelem</name></name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</expr_stmt>

		<comment type="block">/* If it's a domain, immediately thread it into the domain cache list */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>nextDomain</name></name> <operator>=</operator> <name>firstDomainTypeEntry</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>firstDomainTypeEntry</name> <operator>=</operator> <name>typentry</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look up opclasses if we haven't already and any dependent info is
	 * requested.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>TYPECACHE_EQ_OPR</name> <operator>|</operator> <name>TYPECACHE_LT_OPR</name> <operator>|</operator> <name>TYPECACHE_GT_OPR</name> <operator>|</operator>
				  <name>TYPECACHE_CMP_PROC</name> <operator>|</operator>
				  <name>TYPECACHE_EQ_OPR_FINFO</name> <operator>|</operator> <name>TYPECACHE_CMP_PROC_FINFO</name> <operator>|</operator>
				  <name>TYPECACHE_BTREE_OPFAMILY</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_BTREE_OPCLASS</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opclass</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>opclass</name> <operator>=</operator> <call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>BTREE_AM_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opf</name></name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opintype</name></name> <operator>=</operator> <call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opf</name></name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>btree_opintype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Reset information derived from btree opclass.  Note in particular
		 * that we'll redetermine the eq_opr even if we previously found one;
		 * this matters in case a btree opclass has been added to a type that
		 * previously had only a hash opclass.
		 */</comment>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TCFLAGS_CHECKED_EQ_OPR</name> <operator>|</operator>
							 <name>TCFLAGS_CHECKED_LT_OPR</name> <operator>|</operator>
							 <name>TCFLAGS_CHECKED_GT_OPR</name> <operator>|</operator>
							 <name>TCFLAGS_CHECKED_CMP_PROC</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_BTREE_OPCLASS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we need to look up equality operator, and there's no btree opclass,
	 * force lookup of hash opclass.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>TYPECACHE_EQ_OPR</name> <operator>|</operator> <name>TYPECACHE_EQ_OPR_FINFO</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_EQ_OPR</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>btree_opf</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>TYPECACHE_HASH_OPFAMILY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>TYPECACHE_HASH_PROC</name> <operator>|</operator> <name>TYPECACHE_HASH_PROC_FINFO</name> <operator>|</operator>
				  <name>TYPECACHE_HASH_EXTENDED_PROC</name> <operator>|</operator>
				  <name>TYPECACHE_HASH_EXTENDED_PROC_FINFO</name> <operator>|</operator>
				  <name>TYPECACHE_HASH_OPFAMILY</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_HASH_OPCLASS</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opclass</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>opclass</name> <operator>=</operator> <call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>HASH_AM_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opf</name></name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name> <operator>=</operator> <call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opf</name></name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Reset information derived from hash opclass.  We do *not* reset the
		 * eq_opr; if we already found one from the btree opclass, that
		 * decision is still good.
		 */</comment>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TCFLAGS_CHECKED_HASH_PROC</name> <operator>|</operator>
							 <name>TCFLAGS_CHECKED_HASH_EXTENDED_PROC</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_HASH_OPCLASS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look for requested operators and functions, if we haven't already.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>TYPECACHE_EQ_OPR</name> <operator>|</operator> <name>TYPECACHE_EQ_OPR_FINFO</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_EQ_OPR</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_opr</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opf</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>eq_opr</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opf</name></name></expr></argument>,
										 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opintype</name></name></expr></argument>,
										 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opintype</name></name></expr></argument>,
										 <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>eq_opr</name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
			<name><name>typentry</name><operator>-&gt;</operator><name>hash_opf</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>eq_opr</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opf</name></name></expr></argument>,
										 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name></expr></argument>,
										 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name></expr></argument>,
										 <argument><expr><name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the proposed equality operator is array_eq or record_eq, check
		 * to see if the element type or column types support equality.  If
		 * not, array_eq or record_eq would fail at runtime, so we don't want
		 * to report that the type has equality.  (We can omit similar
		 * checking for ranges because ranges can't be created in the first
		 * place unless their subtypes support equality.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>eq_opr</name> <operator>==</operator> <name>ARRAY_EQ_OP</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>array_element_has_equality</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>eq_opr</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>eq_opr</name> <operator>==</operator> <name>RECORD_EQ_OP</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><call><name>record_fields_have_equality</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>eq_opr</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Force update of eq_opr_finfo only if we're changing state */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name> <operator>!=</operator> <name>eq_opr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr_finfo</name><operator>.</operator><name>fn_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name> <operator>=</operator> <name>eq_opr</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset info about hash functions whenever we pick up new info about
		 * equality operator.  This is so we can ensure that the hash
		 * functions match the operator.
		 */</comment>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>TCFLAGS_CHECKED_HASH_PROC</name> <operator>|</operator>
							 <name>TCFLAGS_CHECKED_HASH_EXTENDED_PROC</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_EQ_OPR</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TYPECACHE_LT_OPR</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_LT_OPR</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>lt_opr</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opf</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lt_opr</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opf</name></name></expr></argument>,
										 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opintype</name></name></expr></argument>,
										 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opintype</name></name></expr></argument>,
										 <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * As above, make sure array_cmp or record_cmp will succeed; but again
		 * we need no special check for ranges.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lt_opr</name> <operator>==</operator> <name>ARRAY_LT_OP</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>array_element_has_compare</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lt_opr</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>lt_opr</name> <operator>==</operator> <name>RECORD_LT_OP</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><call><name>record_fields_have_compare</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lt_opr</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>lt_opr</name></name> <operator>=</operator> <name>lt_opr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_LT_OPR</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TYPECACHE_GT_OPR</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_GT_OPR</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>gt_opr</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opf</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>gt_opr</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opf</name></name></expr></argument>,
										 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opintype</name></name></expr></argument>,
										 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opintype</name></name></expr></argument>,
										 <argument><expr><name>BTGreaterStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * As above, make sure array_cmp or record_cmp will succeed; but again
		 * we need no special check for ranges.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>gt_opr</name> <operator>==</operator> <name>ARRAY_GT_OP</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>array_element_has_compare</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>gt_opr</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>gt_opr</name> <operator>==</operator> <name>RECORD_GT_OP</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><call><name>record_fields_have_compare</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>gt_opr</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>gt_opr</name></name> <operator>=</operator> <name>gt_opr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_GT_OPR</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>TYPECACHE_CMP_PROC</name> <operator>|</operator> <name>TYPECACHE_CMP_PROC_FINFO</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_CMP_PROC</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>cmp_proc</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opf</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp_proc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opf</name></name></expr></argument>,
										 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opintype</name></name></expr></argument>,
										 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>btree_opintype</name></name></expr></argument>,
										 <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * As above, make sure array_cmp or record_cmp will succeed; but again
		 * we need no special check for ranges.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cmp_proc</name> <operator>==</operator> <name>F_BTARRAYCMP</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>array_element_has_compare</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp_proc</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>cmp_proc</name> <operator>==</operator> <name>F_BTRECORDCMP</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><call><name>record_fields_have_compare</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmp_proc</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Force update of cmp_proc_finfo only if we're changing state */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name> <operator>!=</operator> <name>cmp_proc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name><operator>.</operator><name>fn_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name> <operator>=</operator> <name>cmp_proc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_CMP_PROC</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>TYPECACHE_HASH_PROC</name> <operator>|</operator> <name>TYPECACHE_HASH_PROC_FINFO</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_HASH_PROC</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>hash_proc</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We insist that the eq_opr, if one has been determined, match the
		 * hash opclass; else report there is no hash function.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opf</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name> <operator>==</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opf</name></name></expr></argument>,
													 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name></expr></argument>,
													 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name></expr></argument>,
													 <argument><expr><name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hash_proc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opf</name></name></expr></argument>,
										  <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name></expr></argument>,
										  <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name></expr></argument>,
										  <argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * As above, make sure hash_array will succeed.  We don't currently
		 * support hashing for composite types, but when we do, we'll need
		 * more logic here to check that case too.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hash_proc</name> <operator>==</operator> <name>F_HASH_ARRAY</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>array_element_has_hashing</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hash_proc</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Likewise for hash_range.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hash_proc</name> <operator>==</operator> <name>F_HASH_RANGE</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>range_element_has_hashing</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hash_proc</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Force update of hash_proc_finfo only if we're changing state */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_proc</name></name> <operator>!=</operator> <name>hash_proc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_proc_finfo</name><operator>.</operator><name>fn_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_proc</name></name> <operator>=</operator> <name>hash_proc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_HASH_PROC</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>TYPECACHE_HASH_EXTENDED_PROC</name> <operator>|</operator>
				  <name>TYPECACHE_HASH_EXTENDED_PROC_FINFO</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_HASH_EXTENDED_PROC</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>hash_extended_proc</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We insist that the eq_opr, if one has been determined, match the
		 * hash opclass; else report there is no hash function.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opf</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name> <operator>==</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opf</name></name></expr></argument>,
													 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name></expr></argument>,
													 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name></expr></argument>,
													 <argument><expr><name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hash_extended_proc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opf</name></name></expr></argument>,
												   <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name></expr></argument>,
												   <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_opintype</name></name></expr></argument>,
												   <argument><expr><name>HASHEXTENDED_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * As above, make sure hash_array_extended will succeed.  We don't
		 * currently support hashing for composite types, but when we do,
		 * we'll need more logic here to check that case too.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hash_extended_proc</name> <operator>==</operator> <name>F_HASH_ARRAY_EXTENDED</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>array_element_has_extended_hashing</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hash_extended_proc</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Likewise for hash_range_extended.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hash_extended_proc</name> <operator>==</operator> <name>F_HASH_RANGE_EXTENDED</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>range_element_has_extended_hashing</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hash_extended_proc</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Force update of proc finfo only if we're changing state */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_extended_proc</name></name> <operator>!=</operator> <name>hash_extended_proc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_extended_proc_finfo</name><operator>.</operator><name>fn_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_extended_proc</name></name> <operator>=</operator> <name>hash_extended_proc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_HASH_EXTENDED_PROC</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set up fmgr lookup info as requested
	 *
	 * Note: we tell fmgr the finfo structures live in CacheMemoryContext,
	 * which is not quite right (they're really in the hash table's private
	 * memory context) but this will do for our purposes.
	 *
	 * Note: the code above avoids invalidating the finfo structs unless the
	 * referenced operator/function OID actually changes.  This is to prevent
	 * unnecessary leakage of any subsidiary data attached to an finfo, since
	 * that would cause session-lifespan memory leaks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TYPECACHE_EQ_OPR_FINFO</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>eq_opr_finfo</name><operator>.</operator><name>fn_oid</name></name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_opr_func</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>eq_opr_func</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>eq_opr_func</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>eq_opr_func</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr_finfo</name></name></expr></argument>,
						  <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TYPECACHE_CMP_PROC_FINFO</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name><operator>.</operator><name>fn_oid</name></name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name></name></expr></argument>,
					  <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TYPECACHE_HASH_PROC_FINFO</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>hash_proc_finfo</name><operator>.</operator><name>fn_oid</name></name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>hash_proc</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_proc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>hash_proc_finfo</name></name></expr></argument>,
					  <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TYPECACHE_HASH_EXTENDED_PROC_FINFO</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>hash_extended_proc_finfo</name><operator>.</operator><name>fn_oid</name></name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>hash_extended_proc</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_extended_proc</name></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>hash_extended_proc_finfo</name></name></expr></argument>,
					  <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's a composite type (row type), get tupdesc if requested
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TYPECACHE_TUPDESC</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>load_typcache_tupdesc</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If requested, get information about a range type
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TYPECACHE_RANGE_INFO</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>rngelemtype</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_RANGE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>load_rangetype_info</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If requested, get information about a domain type
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TYPECACHE_DOMAIN_BASE_INFO</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>domainBaseType</name></name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseTypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseType</name></name> <operator>=</operator>
			<call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseTypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>TYPECACHE_DOMAIN_CONSTR_INFO</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>load_domaintype_info</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>typentry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * load_typcache_tupdesc --- helper routine to set up composite type's tupDesc
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_typcache_tupdesc</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid typrelid for composite type %u"</literal></expr></argument>,
			 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Link to the tupdesc and increment its refcount (we assert it's a
	 * refcounted descriptor).  We don't use IncrTupleDescRefCount() for this,
	 * because the reference mustn't be entered in the current resource owner;
	 * it can outlive the current query.
	 */</comment>
	<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>tdrefcount</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * In future, we could take some pains to not change tupDesc_identifier if
	 * the tupdesc didn't really change; but for now it's not worth it.
	 */</comment>
	<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc_identifier</name></name> <operator>=</operator> <operator>++</operator><name>tupledesc_id_counter</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * load_rangetype_info --- helper routine to set up range type information
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_rangetype_info</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_range</name></type> <name>pg_range</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>subtypeOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opclassOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>canonicalOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>subdiffOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamilyOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opcintype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>cmpFnOid</name></decl>;</decl_stmt>

	<comment type="block">/* get information from pg_range */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RANGETYPE</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* should not fail, since we already checked typtype ... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for range type %u"</literal></expr></argument>,
			 <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pg_range</name> <operator>=</operator> <operator>(</operator><name>Form_pg_range</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>subtypeOid</name> <operator>=</operator> <name><name>pg_range</name><operator>-&gt;</operator><name>rngsubtype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>rng_collation</name></name> <operator>=</operator> <name><name>pg_range</name><operator>-&gt;</operator><name>rngcollation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>opclassOid</name> <operator>=</operator> <name><name>pg_range</name><operator>-&gt;</operator><name>rngsubopc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>canonicalOid</name> <operator>=</operator> <name><name>pg_range</name><operator>-&gt;</operator><name>rngcanonical</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>subdiffOid</name> <operator>=</operator> <name><name>pg_range</name><operator>-&gt;</operator><name>rngsubdiff</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get opclass properties and look up the comparison function */</comment>
	<expr_stmt><expr><name>opfamilyOid</name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name>opclassOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opcintype</name> <operator>=</operator> <call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name>opclassOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmpFnOid</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name>opfamilyOid</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>,
								 <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegProcedureIsValid</name><argument_list>(<argument><expr><name>cmpFnOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d(%u,%u) in opfamily %u"</literal></expr></argument>,
			 <argument><expr><name>BTORDER_PROC</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opfamilyOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* set up cached fmgrinfo structs */</comment>
	<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>cmpFnOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>rng_cmp_proc_finfo</name></name></expr></argument>,
				  <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>canonicalOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>canonicalOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>rng_canonical_finfo</name></name></expr></argument>,
					  <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>subdiffOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>subdiffOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>rng_subdiff_finfo</name></name></expr></argument>,
					  <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Lastly, set up link to the element type --- this marks data valid */</comment>
	<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>rngelemtype</name></name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>subtypeOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * load_domaintype_info --- helper routine to set up domain constraint info
 *
 * Note: we assume we're called in a relatively short-lived context, so it's
 * okay to leak data into the current context while scanning pg_constraint.
 * We build the new DomainConstraintCache data in a context underneath
 * CurrentMemoryContext, and reparent it under CacheMemoryContext when
 * complete.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_domaintype_info</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name> <init>= <expr><name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DomainConstraintCache</name> <modifier>*</modifier></type><name>dcc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>notNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DomainConstraintState</name> <modifier>*</modifier><modifier>*</modifier></type><name>ccons</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cconslen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're here, any existing constraint info is stale, so release it.
	 * For safety, be sure to null the link before trying to delete the data.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>domainData</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dcc</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>domainData</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>decr_dcc_refcount</name><argument_list>(<argument><expr><name>dcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We try to optimize the common case of no domain constraints, so don't
	 * create the dcc object and context until we find a constraint.  Likewise
	 * for the temp sorting array.
	 */</comment>
	<expr_stmt><expr><name>dcc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ccons</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cconslen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan pg_constraint for relevant constraints.  We want to find
	 * constraints for not just this domain, but any ancestor domains, so the
	 * outer loop crawls up the domain stack.
	 */</comment>
	<expr_stmt><expr><name>conRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>conTup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nccons</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Not a domain, so done */</comment>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Test for NOT NULL Constraint */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>notNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Look for CHECK Constraints on this domain */</comment>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conRel</name></expr></argument>, <argument><expr><name>ConstraintTypidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>conTup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>c</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>conTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>constring</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>check_expr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DomainConstraintState</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

			<comment type="block">/* Ignore non-CHECK constraints (presently, shouldn't be any) */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Not expecting conbin to be NULL, but we'll test for it anyway */</comment>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>conTup</name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>,
							  <argument><expr><name><name>conRel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"domain \"%s\" constraint \"%s\" has NULL conbin"</literal></expr></argument>,
					 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Convert conbin to C string in caller context */</comment>
			<expr_stmt><expr><name>constring</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Create the DomainConstraintCache object and context if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name>dcc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
											<argument><expr><literal type="string">"Domain constraints"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dcc</name> <operator>=</operator> <operator>(</operator><name>DomainConstraintCache</name> <operator>*</operator><operator>)</operator>
					<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DomainConstraintCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dcc</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccContext</name></name> <operator>=</operator> <name>cxt</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccRefCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Create node trees in DomainConstraintCache's context */</comment>
			<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>check_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>constring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* ExecInitExpr will assume we've planned the expression */</comment>
			<expr_stmt><expr><name>check_expr</name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>check_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DomainConstraintState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>constrainttype</name></name> <operator>=</operator> <name>DOM_CONSTRAINT_CHECK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>check_expr</name></name> <operator>=</operator> <name>check_expr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>check_exprstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Accumulate constraints in an array, for sorting below */</comment>
			<if_stmt><if>if <condition>(<expr><name>ccons</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cconslen</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>ccons</name> <operator>=</operator> <operator>(</operator><name>DomainConstraintState</name> <operator>*</operator><operator>*</operator><operator>)</operator>
					<call><name>palloc</name><argument_list>(<argument><expr><name>cconslen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DomainConstraintState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>nccons</name> <operator>&gt;=</operator> <name>cconslen</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cconslen</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>ccons</name> <operator>=</operator> <operator>(</operator><name>DomainConstraintState</name> <operator>*</operator><operator>*</operator><operator>)</operator>
					<call><name>repalloc</name><argument_list>(<argument><expr><name>ccons</name></expr></argument>, <argument><expr><name>cconslen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DomainConstraintState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>ccons</name><index>[<expr><name>nccons</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nccons</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Sort the items for this domain, so that CHECKs are applied in a
			 * deterministic order.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>nccons</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>ccons</name></expr></argument>, <argument><expr><name>nccons</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DomainConstraintState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>dcs_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Now attach them to the overall list.  Use lcons() here because
			 * constraints of parent domains should be applied earlier.
			 */</comment>
			<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>nccons</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dcc</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name><name>ccons</name><index>[<expr><operator>--</operator><name>nccons</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>dcc</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* loop to next domain in stack */</comment>
		<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <name><name>typTup</name><operator>-&gt;</operator><name>typbasetype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>conRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only need to add one NOT NULL check regardless of how many domains in
	 * the stack request it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>notNull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DomainConstraintState</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

		<comment type="block">/* Create the DomainConstraintCache object and context if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>dcc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										<argument><expr><literal type="string">"Domain constraints"</literal></expr></argument>,
										<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dcc</name> <operator>=</operator> <operator>(</operator><name>DomainConstraintCache</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DomainConstraintCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dcc</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccContext</name></name> <operator>=</operator> <name>cxt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccRefCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Create node trees in DomainConstraintCache's context */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DomainConstraintState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>constrainttype</name></name> <operator>=</operator> <name>DOM_CONSTRAINT_NOTNULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>check_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>check_exprstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* lcons to apply the nullness check FIRST */</comment>
		<expr_stmt><expr><name><name>dcc</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>dcc</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we made a constraint object, move it into CacheMemoryContext and
	 * attach it to the typcache entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dcc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSetParent</name><argument_list>(<argument><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccContext</name></name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainData</name></name> <operator>=</operator> <name>dcc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccRefCount</name></name><operator>++</operator></expr>;</expr_stmt>		<comment type="block">/* count the typcache's reference */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Either way, the typcache entry's domain data is now valid. */</comment>
	<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator to sort DomainConstraintState pointers by name
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dcs_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DomainConstraintState</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ca</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>DomainConstraintState</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DomainConstraintState</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>cb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>DomainConstraintState</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>ca</name><operator>)</operator><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>cb</name><operator>)</operator><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * decr_dcc_refcount --- decrement a DomainConstraintCache's refcount,
 * and free it if no references remain
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>decr_dcc_refcount</name><parameter_list>(<parameter><decl><type><name>DomainConstraintCache</name> <modifier>*</modifier></type><name>dcc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccRefCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>--</operator><operator>(</operator><name><name>dcc</name><operator>-&gt;</operator><name>dccRefCount</name></name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Context reset/delete callback for a DomainConstraintRef
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dccref_deletion_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DomainConstraintRef</name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><operator>(</operator><name>DomainConstraintRef</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DomainConstraintCache</name> <modifier>*</modifier></type><name>dcc</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>dcc</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Paranoia --- be sure link is nulled before trying to release */</comment>
	<if_stmt><if>if <condition>(<expr><name>dcc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>dcc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>decr_dcc_refcount</name><argument_list>(<argument><expr><name>dcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * prep_domain_constraints --- prepare domain constraints for execution
 *
 * The expression trees stored in the DomainConstraintCache's list are
 * converted to executable expression state trees stored in execctx.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>prep_domain_constraints</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraints</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>execctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>execctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DomainConstraintState</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><name>DomainConstraintState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DomainConstraintState</name> <modifier>*</modifier></type><name>newr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DomainConstraintState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newr</name><operator>-&gt;</operator><name>constrainttype</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>constrainttype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newr</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newr</name><operator>-&gt;</operator><name>check_expr</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>check_expr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newr</name><operator>-&gt;</operator><name>check_exprstate</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>check_expr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>newr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InitDomainConstraintRef --- initialize a DomainConstraintRef struct
 *
 * Caller must tell us the MemoryContext in which the DomainConstraintRef
 * lives.  The ref will be cleaned up when that context is reset/deleted.
 *
 * Caller must also tell us whether it wants check_exprstate fields to be
 * computed in the DomainConstraintState nodes attached to this ref.
 * If it doesn't, we need not make a copy of the DomainConstraintState list.
 */</comment>
<function><type><name>void</name></type>
<name>InitDomainConstraintRef</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>DomainConstraintRef</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>,
						<parameter><decl><type><name>MemoryContext</name></type> <name>refctx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_exprstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Look up the typcache entry --- we assume it survives indefinitely */</comment>
	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>tcache</name></name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>TYPECACHE_DOMAIN_CONSTR_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>need_exprstate</name></name> <operator>=</operator> <name>need_exprstate</name></expr>;</expr_stmt>
	<comment type="block">/* For safety, establish the callback before acquiring a refcount */</comment>
	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>refctx</name></name> <operator>=</operator> <name>refctx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>dcc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>callback</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>dccref_deletion_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>callback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ref</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextRegisterResetCallback</name><argument_list>(<argument><expr><name>refctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ref</name><operator>-&gt;</operator><name>callback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Acquire refcount if there are constraints, and set up exported list */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>tcache</name><operator>-&gt;</operator><name>domainData</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>dcc</name></name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>tcache</name><operator>-&gt;</operator><name>domainData</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>dcc</name><operator>-&gt;</operator><name>dccRefCount</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>need_exprstate</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>prep_domain_constraints</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>dcc</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>,
													   <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name><name>ref</name><operator>-&gt;</operator><name>dcc</name><operator>-&gt;</operator><name>constraints</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * UpdateDomainConstraintRef --- recheck validity of domain constraint info
 *
 * If the domain's constraint set changed, ref-&gt;constraints is updated to
 * point at a new list of cached constraints.
 *
 * In the normal case where nothing happened to the domain, this is cheap
 * enough that it's reasonable (and expected) to check before *each* use
 * of the constraint info.
 */</comment>
<function><type><name>void</name></type>
<name>UpdateDomainConstraintRef</name><parameter_list>(<parameter><decl><type><name>DomainConstraintRef</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>tcache</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Make sure typcache entry's data is up to date */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>load_domaintype_info</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Transfer to ref object if there's new info, adjusting refcounts */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>dcc</name></name> <operator>!=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>domainData</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Paranoia --- be sure link is nulled before trying to release */</comment>
		<decl_stmt><decl><type><name>DomainConstraintCache</name> <modifier>*</modifier></type><name>dcc</name> <init>= <expr><name><name>ref</name><operator>-&gt;</operator><name>dcc</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>dcc</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note: we just leak the previous list of executable domain
			 * constraints.  Alternatively, we could keep those in a child
			 * context of ref-&gt;refctx and free that context at this point.
			 * However, in practice this code path will be taken so seldom
			 * that the extra bookkeeping for a child context doesn't seem
			 * worthwhile; we'll just allow a leak for the lifespan of refctx.
			 */</comment>
			<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>dcc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>decr_dcc_refcount</name><argument_list>(<argument><expr><name>dcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>dcc</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>domainData</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dcc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>dcc</name></name> <operator>=</operator> <name>dcc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dcc</name><operator>-&gt;</operator><name>dccRefCount</name></name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>need_exprstate</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>prep_domain_constraints</name><argument_list>(<argument><expr><name><name>dcc</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>,
														   <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>refctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ref</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name><name>dcc</name><operator>-&gt;</operator><name>constraints</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DomainHasConstraints --- utility routine to check if a domain has constraints
 *
 * This is defined to return false, not fail, if type is not a domain.
 */</comment>
<function><type><name>bool</name></type>
<name>DomainHasConstraints</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: a side effect is to cause the typcache's domain data to become
	 * valid.  This is fine since we'll likely need it soon if there is any.
	 */</comment>
	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>TYPECACHE_DOMAIN_CONSTR_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>domainData</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * array_element_has_equality and friends are helper routines to check
 * whether we should believe that array_eq and related functions will work
 * on the given array type or composite type.
 *
 * The logic above may call these repeatedly on the same type entry, so we
 * make use of the typentry-&gt;flags field to cache the results once known.
 * Also, we assume that we'll probably want all these facts about the type
 * if we want any, so we cache them all using only one lookup of the
 * component datatype(s).
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>array_element_has_equality</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_ELEM_PROPERTIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_array_element_properties</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_HAVE_ELEM_EQUALITY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>array_element_has_compare</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_ELEM_PROPERTIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_array_element_properties</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_HAVE_ELEM_COMPARE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>array_element_has_hashing</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_ELEM_PROPERTIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_array_element_properties</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_HAVE_ELEM_HASHING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>array_element_has_extended_hashing</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_ELEM_PROPERTIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_array_element_properties</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cache_array_element_properties</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>elem_type</name> <init>= <expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elem_type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>elementry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>elementry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>elem_type</name></expr></argument>,
									  <argument><expr><name>TYPECACHE_EQ_OPR</name> <operator>|</operator>
									  <name>TYPECACHE_CMP_PROC</name> <operator>|</operator>
									  <name>TYPECACHE_HASH_PROC</name> <operator>|</operator>
									  <name>TYPECACHE_HASH_EXTENDED_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>elementry</name><operator>-&gt;</operator><name>eq_opr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_HAVE_ELEM_EQUALITY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>elementry</name><operator>-&gt;</operator><name>cmp_proc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_HAVE_ELEM_COMPARE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>elementry</name><operator>-&gt;</operator><name>hash_proc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_HAVE_ELEM_HASHING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>elementry</name><operator>-&gt;</operator><name>hash_extended_proc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_ELEM_PROPERTIES</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Likewise, some helper functions for composite types.
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>record_fields_have_equality</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_FIELD_PROPERTIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_record_field_properties</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_HAVE_FIELD_EQUALITY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>record_fields_have_compare</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_FIELD_PROPERTIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_record_field_properties</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_HAVE_FIELD_COMPARE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cache_record_field_properties</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * For type RECORD, we can't really tell what will work, since we don't
	 * have access here to the specific anonymous type.  Just assume that
	 * everything will (we may get a failure at runtime ...)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <operator>(</operator><name>TCFLAGS_HAVE_FIELD_EQUALITY</name> <operator>|</operator>
							<name>TCFLAGS_HAVE_FIELD_COMPARE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>newflags</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Fetch composite type's tupdesc if we don't have it already */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>load_typcache_tupdesc</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>

		<comment type="block">/* Must bump the refcount while we do additional catalog lookups */</comment>
		<expr_stmt><expr><call><name>IncrTupleDescRefCount</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Have each property if all non-dropped fields have the property */</comment>
		<expr_stmt><expr><name>newflags</name> <operator>=</operator> <operator>(</operator><name>TCFLAGS_HAVE_FIELD_EQUALITY</name> <operator>|</operator>
					<name>TCFLAGS_HAVE_FIELD_COMPARE</name><operator>)</operator></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>fieldentry</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>fieldentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
										   <argument><expr><name>TYPECACHE_EQ_OPR</name> <operator>|</operator>
										   <name>TYPECACHE_CMP_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>fieldentry</name><operator>-&gt;</operator><name>eq_opr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newflags</name> <operator>&amp;=</operator> <operator>~</operator><name>TCFLAGS_HAVE_FIELD_EQUALITY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>fieldentry</name><operator>-&gt;</operator><name>cmp_proc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newflags</name> <operator>&amp;=</operator> <operator>~</operator><name>TCFLAGS_HAVE_FIELD_COMPARE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* We can drop out of the loop once we disprove all bits */</comment>
			<if_stmt><if>if <condition>(<expr><name>newflags</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>newflags</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If it's domain over composite, copy base type's properties */</comment>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>baseentry</name></decl>;</decl_stmt>

		<comment type="block">/* load up basetype info if we didn't already */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseType</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseTypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseType</name></name> <operator>=</operator>
				<call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseTypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>baseentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseType</name></name></expr></argument>,
									  <argument><expr><name>TYPECACHE_EQ_OPR</name> <operator>|</operator>
									  <name>TYPECACHE_CMP_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>baseentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_DOMAIN_BASE_IS_COMPOSITE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name><name>baseentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>TCFLAGS_HAVE_FIELD_EQUALITY</name> <operator>|</operator>
												   <name>TCFLAGS_HAVE_FIELD_COMPARE</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_FIELD_PROPERTIES</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Likewise, some helper functions for range types.
 *
 * We can borrow the flag bits for array element properties to use for range
 * element properties, since those flag bits otherwise have no use in a
 * range type's typcache entry.
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>range_element_has_hashing</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_ELEM_PROPERTIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_range_element_properties</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_HAVE_ELEM_HASHING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>range_element_has_extended_hashing</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_CHECKED_ELEM_PROPERTIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cache_range_element_properties</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cache_range_element_properties</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* load up subtype link if we didn't already */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>rngelemtype</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>load_rangetype_info</name><argument_list>(<argument><expr><name>typentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>rngelemtype</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>elementry</name></decl>;</decl_stmt>

		<comment type="block">/* might need to calculate subtype's hash function properties */</comment>
		<expr_stmt><expr><name>elementry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
									  <argument><expr><name>TYPECACHE_HASH_PROC</name> <operator>|</operator>
									  <name>TYPECACHE_HASH_EXTENDED_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>elementry</name><operator>-&gt;</operator><name>hash_proc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_HAVE_ELEM_HASHING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>elementry</name><operator>-&gt;</operator><name>hash_extended_proc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_HAVE_ELEM_EXTENDED_HASHING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TCFLAGS_CHECKED_ELEM_PROPERTIES</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make sure that RecordCacheArray and RecordIdentifierArray are large enough
 * to store 'typmod'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ensure_record_cache_typmod_slot_exists</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>RecordCacheArray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>RecordCacheArray</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><literal type="number">64</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>RecordIdentifierArray</name> <operator>=</operator> <operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>, <argument><expr><literal type="number">64</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>RecordCacheArrayLen</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <name>RecordCacheArrayLen</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>newlen</name> <init>= <expr><name>RecordCacheArrayLen</name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <name>newlen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newlen</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><name>RecordCacheArray</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>RecordCacheArray</name></expr></argument>,
												  <argument><expr><name>newlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>RecordCacheArray</name> <operator>+</operator> <name>RecordCacheArrayLen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><operator>(</operator><name>newlen</name> <operator>-</operator> <name>RecordCacheArrayLen</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>RecordIdentifierArray</name> <operator>=</operator> <operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>RecordIdentifierArray</name></expr></argument>,
													<argument><expr><name>newlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>RecordIdentifierArray</name> <operator>+</operator> <name>RecordCacheArrayLen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><operator>(</operator><name>newlen</name> <operator>-</operator> <name>RecordCacheArrayLen</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>RecordCacheArrayLen</name> <operator>=</operator> <name>newlen</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * lookup_rowtype_tupdesc_internal --- internal routine to lookup a rowtype
 *
 * Same API as lookup_rowtype_tupdesc_noerror, but the returned tupdesc
 * hasn't had its refcount bumped.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>lookup_rowtype_tupdesc_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>type_id</name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It's a named composite type, so use the regular typcache.
		 */</comment>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>TYPECACHE_TUPDESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not composite"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * It's a transient record type, so look in our record-type table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* It is already in our local cache? */</comment>
			<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <name>RecordCacheArrayLen</name> <operator>&amp;&amp;</operator>
				<name><name>RecordCacheArray</name><index>[<expr><name>typmod</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>RecordCacheArray</name><index>[<expr><name>typmod</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* Are we attached to a shared record typmod registry? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_registry</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SharedTypmodTableEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

				<comment type="block">/* Try to find it in the shared typmod index. */</comment>
				<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>dshash_find</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name><operator>)</operator>
						<call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>area</name></name></expr></argument>,
										<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>shared_tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typmod</name> <operator>==</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* We may need to extend the local RecordCacheArray. */</comment>
					<expr_stmt><expr><call><name>ensure_record_cache_typmod_slot_exists</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Our local array can now point directly to the TupleDesc
					 * in shared memory, which is non-reference-counted.
					 */</comment>
					<expr_stmt><expr><name><name>RecordCacheArray</name><index>[<expr><name>typmod</name></expr>]</index></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * We don't share tupdesc identifiers across processes, so
					 * assign one locally.
					 */</comment>
					<expr_stmt><expr><name><name>RecordIdentifierArray</name><index>[<expr><name>typmod</name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>tupledesc_id_counter</name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>dshash_release_lock</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name></expr></argument>,
										<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<return>return <expr><name><name>RecordCacheArray</name><index>[<expr><name>typmod</name></expr>]</index></name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record type has not been registered"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * lookup_rowtype_tupdesc
 *
 * Given a typeid/typmod that should describe a known composite type,
 * return the tuple descriptor for the type.  Will ereport on failure.
 * (Use ereport because this is reachable with user-specified OIDs,
 * for example from record_in().)
 *
 * Note: on success, we increment the refcount of the returned TupleDesc,
 * and log the reference in CurrentResourceOwner.  Caller should call
 * ReleaseTupleDesc or DecrTupleDescRefCount when done using the tupdesc.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>lookup_rowtype_tupdesc</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_internal</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PinTupleDesc</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tupDesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lookup_rowtype_tupdesc_noerror
 *
 * As above, but if the type is not a known composite type and noError
 * is true, returns NULL instead of ereport'ing.  (Note that if a bogus
 * type_id is passed, you'll get an ereport anyway.)
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>lookup_rowtype_tupdesc_noerror</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_internal</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>noError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tupDesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PinTupleDesc</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>tupDesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lookup_rowtype_tupdesc_copy
 *
 * Like lookup_rowtype_tupdesc(), but the returned TupleDesc has been
 * copied into the CurrentMemoryContext and is not reference-counted.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>lookup_rowtype_tupdesc_copy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_internal</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lookup_rowtype_tupdesc_domain
 *
 * Same as lookup_rowtype_tupdesc_noerror(), except that the type can also be
 * a domain over a named composite type; so this is effectively equivalent to
 * lookup_rowtype_tupdesc_noerror(getBaseType(type_id), typmod, noError)
 * except for being a tad faster.
 *
 * Note: the reason we don't fold the look-through-domain behavior into plain
 * lookup_rowtype_tupdesc() is that we want callers to know they might be
 * dealing with a domain.  Otherwise they might construct a tuple that should
 * be of the domain type, but not apply domain constraints.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>lookup_rowtype_tupdesc_domain</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>type_id</name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check for domain or named composite type.  We might as well load
		 * whichever data is needed.
		 */</comment>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>,
									 <argument><expr><name>TYPECACHE_TUPDESC</name> <operator>|</operator>
									 <name>TYPECACHE_DOMAIN_BASE_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>lookup_rowtype_tupdesc_noerror</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseType</name></name></expr></argument>,
												  <argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseTypmod</name></name></expr></argument>,
												  <argument><expr><name>noError</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>noError</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not composite"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_internal</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>noError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tupDesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PinTupleDesc</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>tupDesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Hash function for the hash table of RecordCacheEntry.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>record_type_typmod_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecordCacheEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>RecordCacheEntry</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>hashTupleDesc</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Match function for the hash table of RecordCacheEntry.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>record_type_typmod_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecordCacheEntry</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><operator>(</operator><name>RecordCacheEntry</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecordCacheEntry</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><operator>(</operator><name>RecordCacheEntry</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><ternary><condition><expr><call><name>equalTupleDescs</name><argument_list>(<argument><expr><name><name>left</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * assign_record_type_typmod
 *
 * Given a tuple descriptor for a RECORD type, find or create a cache entry
 * for the type, and set the tupdesc's tdtypmod field to a value that will
 * identify this cache entry to lookup_rowtype_tupdesc.
 */</comment>
<function><type><name>void</name></type>
<name>assign_record_type_typmod</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecordCacheEntry</name> <modifier>*</modifier></type><name>recentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>entDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>RecordCacheHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through: initialize the hash table */</comment>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TupleDesc</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>	<comment type="block">/* just the pointer */</comment>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RecordCacheEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>record_type_typmod_hash</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>record_type_typmod_compare</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>RecordCacheHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Record information cache"</literal></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
									  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Also make sure CacheMemoryContext exists */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CacheMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Find or create a hashtable entry for this tuple descriptor */</comment>
	<expr_stmt><expr><name>recentry</name> <operator>=</operator> <operator>(</operator><name>RecordCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>RecordCacheHash</name></expr></argument>,
												<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tupDesc</name></expr></argument>,
												<argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <name><name>recentry</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <name><name>recentry</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Not present, so need to manufacture an entry */</comment>
	<expr_stmt><expr><name><name>recentry</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look in the SharedRecordTypmodRegistry, if attached */</comment>
	<expr_stmt><expr><name>entDesc</name> <operator>=</operator> <call><name>find_or_make_matching_shared_tupledesc</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>entDesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Reference-counted local cache only. */</comment>
		<expr_stmt><expr><name>entDesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entDesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <name>NextRecordTypmod</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ensure_record_cache_typmod_slot_exists</name><argument_list>(<argument><expr><name><name>entDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>RecordCacheArray</name><index>[<expr><name><name>entDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>]</index></name> <operator>=</operator> <name>entDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>recentry</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name>entDesc</name></expr>;</expr_stmt>

	<comment type="block">/* Assign a unique tupdesc identifier, too. */</comment>
	<expr_stmt><expr><name><name>RecordIdentifierArray</name><index>[<expr><name><name>entDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>tupledesc_id_counter</name></expr>;</expr_stmt>

	<comment type="block">/* Update the caller's tuple descriptor. */</comment>
	<expr_stmt><expr><name><name>tupDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <name><name>entDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * assign_record_type_identifier
 *
 * Get an identifier, which will be unique over the lifespan of this backend
 * process, for the current tuple descriptor of the specified composite type.
 * For named composite types, the value is guaranteed to change if the type's
 * definition does.  For registered RECORD types, the value will not change
 * once assigned, since the registered type won't either.  If an anonymous
 * RECORD type is specified, we return a new identifier on each call.
 */</comment>
<function><type><name>uint64</name></type>
<name>assign_record_type_identifier</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>type_id</name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It's a named composite type, so use the regular typcache.
		 */</comment>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>TYPECACHE_TUPDESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not composite"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc_identifier</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc_identifier</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * It's a transient record type, so look in our record-type table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>typmod</name> <operator>&lt;</operator> <name>RecordCacheArrayLen</name> <operator>&amp;&amp;</operator>
			<name><name>RecordCacheArray</name><index>[<expr><name>typmod</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>RecordIdentifierArray</name><index>[<expr><name>typmod</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>RecordIdentifierArray</name><index>[<expr><name>typmod</name></expr>]</index></name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* For anonymous or unrecognized record type, generate a new ID */</comment>
		<return>return <expr><operator>++</operator><name>tupledesc_id_counter</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the amout of shmem required to hold a SharedRecordTypmodRegistry.
 * This exists only to avoid exposing private innards of
 * SharedRecordTypmodRegistry in a header.
 */</comment>
<function><type><name>size_t</name></type>
<name>SharedRecordTypmodRegistryEstimate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedRecordTypmodRegistry</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize 'registry' in a pre-existing shared memory region, which must be
 * maximally aligned and have space for SharedRecordTypmodRegistryEstimate()
 * bytes.
 *
 * 'area' will be used to allocate shared memory space as required for the
 * typemod registration.  The current process, expected to be a leader process
 * in a parallel query, will be attached automatically and its current record
 * types will be loaded into *registry.  While attached, all calls to
 * assign_record_type_typmod will use the shared registry.  Worker backends
 * will need to attach explicitly.
 *
 * Note that this function takes 'area' and 'segment' as arguments rather than
 * accessing them via CurrentSession, because they aren't installed there
 * until after this function runs.
 */</comment>
<function><type><name>void</name></type>
<name>SharedRecordTypmodRegistryInit</name><parameter_list>(<parameter><decl><type><name>SharedRecordTypmodRegistry</name> <modifier>*</modifier></type><name>registry</name></decl></parameter>,
							   <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl></parameter>,
							   <parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>record_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>typmod_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can't already be attached to a shared registry. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_registry</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the hash table of tuple descriptors indexed by themselves. */</comment>
	<expr_stmt><expr><name>record_table</name> <operator>=</operator> <call><name>dshash_create</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srtr_record_table_params</name></expr></argument>, <argument><expr><name>area</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the hash table of tuple descriptors indexed by typmod. */</comment>
	<expr_stmt><expr><name>typmod_table</name> <operator>=</operator> <call><name>dshash_create</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srtr_typmod_table_params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the SharedRecordTypmodRegistry. */</comment>
	<expr_stmt><expr><name><name>registry</name><operator>-&gt;</operator><name>record_table_handle</name></name> <operator>=</operator> <call><name>dshash_get_hash_table_handle</name><argument_list>(<argument><expr><name>record_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>registry</name><operator>-&gt;</operator><name>typmod_table_handle</name></name> <operator>=</operator> <call><name>dshash_get_hash_table_handle</name><argument_list>(<argument><expr><name>typmod_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>registry</name><operator>-&gt;</operator><name>next_typmod</name></name></expr></argument>, <argument><expr><name>NextRecordTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy all entries from this backend's private registry into the shared
	 * registry.
	 */</comment>
	<for>for <control>(<init><expr><name>typmod</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>typmod</name> <operator>&lt;</operator> <name>NextRecordTypmod</name></expr>;</condition> <incr><expr><operator>++</operator><name>typmod</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SharedTypmodTableEntry</name> <modifier>*</modifier></type><name>typmod_table_entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SharedRecordTableEntry</name> <modifier>*</modifier></type><name>record_table_entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SharedRecordTableKey</name></type> <name>record_table_key</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>shared_dp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>RecordCacheArray</name><index>[<expr><name>typmod</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Copy the TupleDesc into shared memory. */</comment>
		<expr_stmt><expr><name>shared_dp</name> <operator>=</operator> <call><name>share_tupledesc</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Insert into the typmod table. */</comment>
		<expr_stmt><expr><name>typmod_table_entry</name> <operator>=</operator> <call><name>dshash_find_or_insert</name><argument_list>(<argument><expr><name>typmod_table</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot create duplicate shared record typmod"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>typmod_table_entry</name><operator>-&gt;</operator><name>typmod</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typmod_table_entry</name><operator>-&gt;</operator><name>shared_tupdesc</name></name> <operator>=</operator> <name>shared_dp</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dshash_release_lock</name><argument_list>(<argument><expr><name>typmod_table</name></expr></argument>, <argument><expr><name>typmod_table_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Insert into the record table. */</comment>
		<expr_stmt><expr><name><name>record_table_key</name><operator>.</operator><name>shared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>record_table_key</name><operator>.</operator><name>u</name><operator>.</operator><name>local_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>record_table_entry</name> <operator>=</operator> <call><name>dshash_find_or_insert</name><argument_list>(<argument><expr><name>record_table</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>record_table_key</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>record_table_entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>shared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>record_table_entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>u</name><operator>.</operator><name>shared_tupdesc</name></name> <operator>=</operator> <name>shared_dp</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>dshash_release_lock</name><argument_list>(<argument><expr><name>record_table</name></expr></argument>, <argument><expr><name>record_table_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Set up the global state that will tell assign_record_type_typmod and
	 * lookup_rowtype_tupdesc_internal about the shared registry.
	 */</comment>
	<expr_stmt><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name> <operator>=</operator> <name>record_table</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name> <operator>=</operator> <name>typmod_table</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_registry</name></name> <operator>=</operator> <name>registry</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We install a detach hook in the leader, but only to handle cleanup on
	 * failure during GetSessionDsmHandle().  Once GetSessionDsmHandle() pins
	 * the memory, the leader process will use a shared registry until it
	 * exits.
	 */</comment>
	<expr_stmt><expr><call><name>on_dsm_detach</name><argument_list>(<argument><expr><name>segment</name></expr></argument>, <argument><expr><name>shared_record_typmod_registry_detach</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attach to 'registry', which must have been initialized already by another
 * backend.  Future calls to assign_record_type_typmod and
 * lookup_rowtype_tupdesc_internal will use the shared registry until the
 * current session is detached.
 */</comment>
<function><type><name>void</name></type>
<name>SharedRecordTypmodRegistryAttach</name><parameter_list>(<parameter><decl><type><name>SharedRecordTypmodRegistry</name> <modifier>*</modifier></type><name>registry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>record_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dshash_table</name> <modifier>*</modifier></type><name>typmod_table</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can't already be attached to a shared registry. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentSession</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>segment</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>area</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_registry</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can't already have typmods in our local cache, because they'd clash
	 * with those imported by SharedRecordTypmodRegistryInit.  This should be
	 * a freshly started parallel worker.  If we ever support worker
	 * recycling, a worker would need to zap its local cache in between
	 * servicing different queries, in order to be able to call this and
	 * synchronize typmods with a new leader; but that's problematic because
	 * we can't be very sure that record-typmod-related state hasn't escaped
	 * to anywhere else in the process.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NextRecordTypmod</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Attach to the two hash tables. */</comment>
	<expr_stmt><expr><name>record_table</name> <operator>=</operator> <call><name>dshash_attach</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>area</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>srtr_record_table_params</name></expr></argument>,
								 <argument><expr><name><name>registry</name><operator>-&gt;</operator><name>record_table_handle</name></name></expr></argument>,
								 <argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>area</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typmod_table</name> <operator>=</operator> <call><name>dshash_attach</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>area</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>srtr_typmod_table_params</name></expr></argument>,
								 <argument><expr><name><name>registry</name><operator>-&gt;</operator><name>typmod_table_handle</name></name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up detach hook to run at worker exit.  Currently this is the same
	 * as the leader's detach hook, but in future they might need to be
	 * different.
	 */</comment>
	<expr_stmt><expr><call><name>on_dsm_detach</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>segment</name></name></expr></argument>,
				  <argument><expr><name>shared_record_typmod_registry_detach</name></expr></argument>,
				  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>registry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up the session state that will tell assign_record_type_typmod and
	 * lookup_rowtype_tupdesc_internal about the shared registry.
	 */</comment>
	<expr_stmt><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_registry</name></name> <operator>=</operator> <name>registry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name> <operator>=</operator> <name>record_table</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name> <operator>=</operator> <name>typmod_table</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TypeCacheRelCallback
 *		Relcache inval callback function
 *
 * Delete the cached tuple descriptor (if any) for the given rel's composite
 * type, or for all composite types if relid == InvalidOid.  Also reset
 * whatever info we have cached about the composite type's comparability.
 *
 * This is called when a relcache invalidation event occurs for the given
 * relid.  We must scan the whole typcache hash since we don't know the
 * type OID corresponding to the relid.  We could do a direct search if this
 * were a syscache-flush callback on pg_type, but then we would need all
 * ALTER-TABLE-like commands that could modify a rowtype to issue syscache
 * invals against the rel's pg_type OID.  The extra SI signaling could very
 * well cost more than we'd save, since in most usages there are not very
 * many entries in a backend's typcache.  The risk of bugs-of-omission seems
 * high, too.
 *
 * Another possibility, with only localized impact, is to maintain a second
 * hashtable that indexes composite-type typcache entries by their typrelid.
 * But it's still not clear it's worth the trouble.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TypeCacheRelCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

	<comment type="block">/* TypeCacheHash must exist, else this callback wouldn't be registered */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>TypeCacheHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>typentry</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Skip if no match, unless we're zapping all composite types */</comment>
			<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>!=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typrelid</name></name> <operator>&amp;&amp;</operator> <name>relid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Delete tupdesc if we have it */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Release our refcount, and free the tupdesc if none remain.
				 * (Can't use DecrTupleDescRefCount because this reference is
				 * not logged in current resource owner.)
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Also clear tupDesc_identifier, so that anything watching
				 * that will realize that the tupdesc has possibly changed.
				 * (Alternatively, we could specify that to detect possible
				 * tupdesc change, one must check for tupDesc != NULL as well
				 * as tupDesc_identifier being the same as what was previously
				 * seen.  That seems error-prone.)
				 */</comment>
				<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc_identifier</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Reset equality/comparison/hashing validity information */</comment>
			<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If it's domain over composite, reset flags.  (We don't bother
			 * trying to determine whether the specific base type needs a
			 * reset.)  Note that if we haven't determined whether the base
			 * type is composite, we don't need to reset anything.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TCFLAGS_DOMAIN_BASE_IS_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * TypeCacheOpcCallback
 *		Syscache inval callback function
 *
 * This is called when a syscache invalidation event occurs for any pg_opclass
 * row.  In principle we could probably just invalidate data dependent on the
 * particular opclass, but since updates on pg_opclass are rare in production
 * it doesn't seem worth a lot of complication: we just mark all cached data
 * invalid.
 *
 * Note that we don't bother watching for updates on pg_amop or pg_amproc.
 * This should be safe because ALTER OPERATOR FAMILY ADD/DROP OPERATOR/FUNCTION
 * is not allowed to be used to add/drop the primary operators and functions
 * of an opclass, only cross-type members of a family; and the latter sorts
 * of members are not going to get cached here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TypeCacheOpcCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

	<comment type="block">/* TypeCacheHash must exist, else this callback wouldn't be registered */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>TypeCacheHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>typentry</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Reset equality/comparison/hashing validity information */</comment>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * TypeCacheConstrCallback
 *		Syscache inval callback function
 *
 * This is called when a syscache invalidation event occurs for any
 * pg_constraint or pg_type row.  We flush information about domain
 * constraints when this happens.
 *
 * It's slightly annoying that we can't tell whether the inval event was for a
 * domain constraint/type record or not; there's usually more update traffic
 * for table constraints/types than domain constraints, so we'll do a lot of
 * useless flushes.  Still, this is better than the old no-caching-at-all
 * approach to domain constraints.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TypeCacheConstrCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Because this is called very frequently, and typically very few of the
	 * typcache entries are for domains, we don't use hash_seq_search here.
	 * Instead we thread all the domain-type entries together so that we can
	 * visit them cheaply.
	 */</comment>
	<for>for <control>(<init><expr><name>typentry</name> <operator>=</operator> <name>firstDomainTypeEntry</name></expr>;</init>
		 <condition><expr><name>typentry</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>typentry</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>nextDomain</name></name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Reset domain constraint validity information */</comment>
		<expr_stmt><expr><name><name>typentry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * build_tuple_node_list
 *
 * Wrap TupleDesc with TupleDescNode. Return all record type in record cache.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>build_tuple_node_list</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>transientTypeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>NextRecordTypmod</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>transientTypeList</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NextRecordTypmod</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tmp</name> <init>= <expr><name><name>RecordCacheArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>TupleDescNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleDescNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_TupleDescNode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>natts</name></name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>transientTypeList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>transientTypeList</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>transientTypeList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if given OID is part of the subset that's sortable by comparisons
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>enum_known_sorted</name><parameter_list>(<parameter><decl><type><name>TypeCacheEnumData</name> <modifier>*</modifier></type><name>enumdata</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>offset</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&lt;</operator> <name><name>enumdata</name><operator>-&gt;</operator><name>bitmap_base</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>arg</name> <operator>-</operator> <name><name>enumdata</name><operator>-&gt;</operator><name>bitmap_base</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>bms_is_member</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>offset</name></expr></argument>, <argument><expr><name><name>enumdata</name><operator>-&gt;</operator><name>sorted_values</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * compare_values_of_enum
 *		Compare two members of an enum type.
 *		Return &lt;0, 0, or &gt;0 according as arg1 &lt;, =, or &gt; arg2.
 *
 * Note: currently, the enumData cache is refreshed only if we are asked
 * to compare an enum value that is not already in the cache.  This is okay
 * because there is no support for re-ordering existing values, so comparisons
 * of previously cached values will return the right answer even if other
 * values have been added since we last loaded the cache.
 *
 * Note: the enum logic has a special-case rule about even-numbered versus
 * odd-numbered OIDs, but we take no account of that rule here; this
 * routine shouldn't even get called when that rule applies.
 */</comment>
<function><type><name>int</name></type>
<name>compare_values_of_enum</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeCacheEnumData</name> <modifier>*</modifier></type><name>enumdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EnumItem</name>   <modifier>*</modifier></type><name>item1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EnumItem</name>   <modifier>*</modifier></type><name>item2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Equal OIDs are certainly equal --- this case was probably handled by
	 * our caller, but we may as well check.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>==</operator> <name>arg2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Load up the cache if first time through */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tcache</name><operator>-&gt;</operator><name>enumData</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>load_enum_cache_data</name><argument_list>(<argument><expr><name>tcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>enumdata</name> <operator>=</operator> <name><name>tcache</name><operator>-&gt;</operator><name>enumData</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If both OIDs are known-sorted, we can just compare them directly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>enum_known_sorted</name><argument_list>(<argument><expr><name>enumdata</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>enum_known_sorted</name><argument_list>(<argument><expr><name>enumdata</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&lt;</operator> <name>arg2</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Slow path: we have to identify their actual sort-order positions.
	 */</comment>
	<expr_stmt><expr><name>item1</name> <operator>=</operator> <call><name>find_enumitem</name><argument_list>(<argument><expr><name>enumdata</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>item2</name> <operator>=</operator> <call><name>find_enumitem</name><argument_list>(<argument><expr><name>enumdata</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>item1</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>item2</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We couldn't find one or both values.  That means the enum has
		 * changed under us, so re-initialize the cache and try again. We
		 * don't bother retrying the known-sorted case in this path.
		 */</comment>
		<expr_stmt><expr><call><name>load_enum_cache_data</name><argument_list>(<argument><expr><name>tcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>enumdata</name> <operator>=</operator> <name><name>tcache</name><operator>-&gt;</operator><name>enumData</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>item1</name> <operator>=</operator> <call><name>find_enumitem</name><argument_list>(<argument><expr><name>enumdata</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>item2</name> <operator>=</operator> <call><name>find_enumitem</name><argument_list>(<argument><expr><name>enumdata</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we still can't find the values, complain: we must have corrupt
		 * data.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>item1</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"enum value %u not found in cache for enum %s"</literal></expr></argument>,
				 <argument><expr><name>arg1</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>tcache</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>item2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"enum value %u not found in cache for enum %s"</literal></expr></argument>,
				 <argument><expr><name>arg2</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>tcache</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>item1</name><operator>-&gt;</operator><name>sort_order</name></name> <operator>&lt;</operator> <name><name>item2</name><operator>-&gt;</operator><name>sort_order</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>item1</name><operator>-&gt;</operator><name>sort_order</name></name> <operator>&gt;</operator> <name><name>item2</name><operator>-&gt;</operator><name>sort_order</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Load (or re-load) the enumData member of the typcache entry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_enum_cache_data</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>tcache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeCacheEnumData</name> <modifier>*</modifier></type><name>enumdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>enum_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>enum_scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>enum_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EnumItem</name>   <modifier>*</modifier></type><name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>bitmap_base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>bitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bm_size</name></decl>,
				<decl><type ref="prev"/><name>start_pos</name></decl>;</decl_stmt>

	<comment type="block">/* Check that this is actually an enum */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tcache</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_ENUM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not an enum"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>tcache</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Read all the information for members of the enum type.  We collect the
	 * info in working memory in the caller's context, and then transfer it to
	 * permanent memory in CacheMemoryContext.  This minimizes the risk of
	 * leaking memory from CacheMemoryContext in the event of an error partway
	 * through.
	 */</comment>
	<expr_stmt><expr><name>maxitems</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>items</name> <operator>=</operator> <operator>(</operator><name>EnumItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EnumItem</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>maxitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numitems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Scan pg_enum for the members of the target enum type. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_enum_enumtypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>tcache</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>enum_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>EnumRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>enum_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>enum_rel</name></expr></argument>,
								   <argument><expr><name>EnumTypIdLabelIndexId</name></expr></argument>,
								   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>enum_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>enum_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>en</name> <init>= <expr><operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>enum_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>numitems</name> <operator>&gt;=</operator> <name>maxitems</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>maxitems</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>items</name> <operator>=</operator> <operator>(</operator><name>EnumItem</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EnumItem</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>maxitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>numitems</name></expr>]</index></name><operator>.</operator><name>enum_oid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>enum_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>items</name><index>[<expr><name>numitems</name></expr>]</index></name><operator>.</operator><name>sort_order</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>enumsortorder</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numitems</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>enum_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>enum_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort the items into OID order */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>numitems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EnumItem</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>enum_oid_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Here, we create a bitmap listing a subset of the enum's OIDs that are
	 * known to be in order and can thus be compared with just OID comparison.
	 *
	 * The point of this is that the enum's initial OIDs were certainly in
	 * order, so there is some subset that can be compared via OID comparison;
	 * and we'd rather not do binary searches unnecessarily.
	 *
	 * This is somewhat heuristic, and might identify a subset of OIDs that
	 * isn't exactly what the type started with.  That's okay as long as the
	 * subset is correctly sorted.
	 */</comment>
	<expr_stmt><expr><name>bitmap_base</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bm_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>				<comment type="block">/* only save sets of at least 2 OIDs */</comment>

	<for>for <control>(<init><expr><name>start_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>start_pos</name> <operator>&lt;</operator> <name>numitems</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>start_pos</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Identify longest sorted subsequence starting at start_pos
		 */</comment>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>this_bitmap</name> <init>= <expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>this_bm_size</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>start_oid</name> <init>= <expr><name><name>items</name><index>[<expr><name>start_pos</name></expr>]</index></name><operator>.</operator><name>enum_oid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float4</name></type>		<name>prev_order</name> <init>= <expr><name><name>items</name><index>[<expr><name>start_pos</name></expr>]</index></name><operator>.</operator><name>sort_order</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>offset</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>enum_oid</name> <operator>-</operator> <name>start_oid</name></expr>;</expr_stmt>
			<comment type="block">/* quit if bitmap would be too large; cutoff is arbitrary */</comment>
			<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">8192</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/* include the item if it's in-order */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sort_order</name> <operator>&gt;</operator> <name>prev_order</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>prev_order</name> <operator>=</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sort_order</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>this_bitmap</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>this_bitmap</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>this_bm_size</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Remember it if larger than previous best */</comment>
		<if_stmt><if>if <condition>(<expr><name>this_bm_size</name> <operator>&gt;</operator> <name>bm_size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bitmap_base</name> <operator>=</operator> <name>start_oid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <name>this_bitmap</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bm_size</name> <operator>=</operator> <name>this_bm_size</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>this_bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Done if it's not possible to find a longer sequence in the rest of
		 * the list.  In typical cases this will happen on the first
		 * iteration, which is why we create the bitmaps on the fly instead of
		 * doing a second pass over the list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>bm_size</name> <operator>&gt;=</operator> <operator>(</operator><name>numitems</name> <operator>-</operator> <name>start_pos</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* OK, copy the data into CacheMemoryContext */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>enumdata</name> <operator>=</operator> <operator>(</operator><name>TypeCacheEnumData</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>TypeCacheEnumData</name></expr></argument>, <argument><expr><name>enum_values</name></expr></argument>)</argument_list></call> <operator>+</operator>
			   <name>numitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EnumItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>enumdata</name><operator>-&gt;</operator><name>bitmap_base</name></name> <operator>=</operator> <name>bitmap_base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>enumdata</name><operator>-&gt;</operator><name>sorted_values</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>enumdata</name><operator>-&gt;</operator><name>num_values</name></name> <operator>=</operator> <name>numitems</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>enumdata</name><operator>-&gt;</operator><name>enum_values</name></name></expr></argument>, <argument><expr><name>items</name></expr></argument>, <argument><expr><name>numitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EnumItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>bitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And link the finished cache struct into the typcache */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tcache</name><operator>-&gt;</operator><name>enumData</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tcache</name><operator>-&gt;</operator><name>enumData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>tcache</name><operator>-&gt;</operator><name>enumData</name></name> <operator>=</operator> <name>enumdata</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Locate the EnumItem with the given OID, if present
 */</comment>
<function><type><specifier>static</specifier> <name>EnumItem</name> <modifier>*</modifier></type>
<name>find_enumitem</name><parameter_list>(<parameter><decl><type><name>TypeCacheEnumData</name> <modifier>*</modifier></type><name>enumdata</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EnumItem</name></type>	<name>srch</name></decl>;</decl_stmt>

	<comment type="block">/* On some versions of Solaris, bsearch of zero items dumps core */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>enumdata</name><operator>-&gt;</operator><name>num_values</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>srch</name><operator>.</operator><name>enum_oid</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
	<return>return <expr><call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srch</name></expr></argument>, <argument><expr><name><name>enumdata</name><operator>-&gt;</operator><name>enum_values</name></name></expr></argument>, <argument><expr><name><name>enumdata</name><operator>-&gt;</operator><name>num_values</name></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EnumItem</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>enum_oid_cmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparison function for OID-ordered EnumItems
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>enum_oid_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>EnumItem</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>EnumItem</name> <operator>*</operator><operator>)</operator> <name>left</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>EnumItem</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>EnumItem</name> <operator>*</operator><operator>)</operator> <name>right</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>enum_oid</name></name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>enum_oid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>enum_oid</name></name> <operator>&gt;</operator> <name><name>r</name><operator>-&gt;</operator><name>enum_oid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy 'tupdesc' into newly allocated shared memory in 'area', set its typmod
 * to the given value and return a dsa_pointer.
 */</comment>
<function><type><specifier>static</specifier> <name>dsa_pointer</name></type>
<name>share_tupledesc</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>area</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>shared_dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>shared</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>shared_dp</name> <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><call><name>TupleDescSize</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>shared</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name><operator>)</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>area</name></expr></argument>, <argument><expr><name>shared_dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescCopy</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>

	<return>return <expr><name>shared_dp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If we are attached to a SharedRecordTypmodRegistry, use it to find or
 * create a shared TupleDesc that matches 'tupdesc'.  Otherwise return NULL.
 * Tuple descriptors returned by this function are not reference counted, and
 * will exist at least as long as the current backend remained attached to the
 * current session.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>find_or_make_matching_shared_tupledesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedRecordTableKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedRecordTableEntry</name> <modifier>*</modifier></type><name>record_table_entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedTypmodTableEntry</name> <modifier>*</modifier></type><name>typmod_table_entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>shared_dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>typmod</name></decl>;</decl_stmt>

	<comment type="block">/* If not even attached, nothing to do. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_registry</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Try to find a matching tuple descriptor in the record table. */</comment>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>shared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>u</name><operator>.</operator><name>local_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>record_table_entry</name> <operator>=</operator> <operator>(</operator><name>SharedRecordTableEntry</name> <operator>*</operator><operator>)</operator>
		<call><name>dshash_find</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record_table_entry</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>record_table_entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dshash_release_lock</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name></expr></argument>,
							<argument><expr><name>record_table_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name><operator>)</operator>
			<call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>area</name></name></expr></argument>,
							<argument><expr><name><name>record_table_entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>u</name><operator>.</operator><name>shared_tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Allocate a new typmod number.  This will be wasted if we error out. */</comment>
	<expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator>
		<call><name>pg_atomic_fetch_add_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_registry</name><operator>-&gt;</operator><name>next_typmod</name></name></expr></argument>,
								<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the TupleDesc into shared memory. */</comment>
	<expr_stmt><expr><name>shared_dp</name> <operator>=</operator> <call><name>share_tupledesc</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create an entry in the typmod table so that others will understand this
	 * typmod number.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>typmod_table_entry</name> <operator>=</operator> <operator>(</operator><name>SharedTypmodTableEntry</name> <operator>*</operator><operator>)</operator>
			<call><name>dshash_find_or_insert</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot create duplicate shared record typmod"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>shared_dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typmod_table_entry</name><operator>-&gt;</operator><name>typmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typmod_table_entry</name><operator>-&gt;</operator><name>shared_tupdesc</name></name> <operator>=</operator> <name>shared_dp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dshash_release_lock</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name></expr></argument>,
						<argument><expr><name>typmod_table_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally create an entry in the record table so others with matching
	 * tuple descriptors can reuse the typmod.
	 */</comment>
	<expr_stmt><expr><name>record_table_entry</name> <operator>=</operator> <operator>(</operator><name>SharedRecordTableEntry</name> <operator>*</operator><operator>)</operator>
		<call><name>dshash_find_or_insert</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Someone concurrently inserted a matching tuple descriptor since the
		 * first time we checked.  Use that one instead.
		 */</comment>
		<expr_stmt><expr><call><name>dshash_release_lock</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name></expr></argument>,
							<argument><expr><name>record_table_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Might as well free up the space used by the one we created. */</comment>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>dshash_delete_key</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>shared_dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Return the one we found. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>record_table_entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name><operator>)</operator>
			<call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>area</name></name></expr></argument>,
							<argument><expr><name><name>record_table_entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Store it and return it. */</comment>
	<expr_stmt><expr><name><name>record_table_entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>shared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record_table_entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>u</name><operator>.</operator><name>shared_tupdesc</name></name> <operator>=</operator> <name>shared_dp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dshash_release_lock</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name></expr></argument>,
						<argument><expr><name>record_table_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name><operator>)</operator>
		<call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>area</name></name></expr></argument>, <argument><expr><name>shared_dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * On-DSM-detach hook to forget about the current shared record typmod
 * infrastructure.  This is currently used by both leader and workers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shared_record_typmod_registry_detach</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Be cautious here: maybe we didn't finish initializing. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dshash_detach</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_record_table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dshash_detach</name><argument_list>(<argument><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>shared_typmod_registry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
