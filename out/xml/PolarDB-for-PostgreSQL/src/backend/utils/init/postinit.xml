<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/init/postinit.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * postinit.c
 *	  postgres initialization utilities
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/init/postinit.c
 *
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/session.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_db_role_setting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-be.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/syslogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_dma/polar_dma.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<comment type="block">/* POLAR px */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<comment type="block">/* POLAR end */</comment>

<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>GetDatabaseTuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>GetDatabaseTupleByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PerformAuthentication</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckMyDatabase</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>am_superuser</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>override_allow_connections</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitCommunication</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShutdownPostgres</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StatementTimeoutHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LockTimeoutHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IdleInTransactionSessionTimeoutHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ThereIsAtLeastOneRole</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_startup_options</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>am_superuser</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_settings</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PX</name></cpp:ifdef>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>InitPXOPT</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>TerminatePXOPT</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*** InitPostgres support ***/</comment>


<comment type="block">/*
 * GetDatabaseTuple -- fetch the pg_database row for a database
 *
 * This is used during backend startup when we don't yet have any access to
 * system catalogs in general.  In the worst case, we can seqscan pg_database
 * using nothing but the hard-wired descriptor that relcache.c creates for
 * pg_database.  In more typical cases, relcache.c was able to load
 * descriptors for both pg_database and its indexes from the shared relcache
 * cache file, and so we can do an indexscan.  criticalSharedRelcachesBuilt
 * tells whether we got the cached descriptors.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>GetDatabaseTuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * form a scan key
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_database_datname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open pg_database and fetch a tuple.  Force heap scan if we haven't yet
	 * built the critical shared relcache entries (i.e., we're starting up
	 * without a shared relcache cache file).
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>DatabaseNameIndexId</name></expr></argument>,
							  <argument><expr><name>criticalSharedRelcachesBuilt</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must copy tuple before releasing buffer */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* all done */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetDatabaseTupleByOid -- as above, but search by database OID
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>GetDatabaseTupleByOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * form a scan key
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open pg_database and fetch a tuple.  Force heap scan if we haven't yet
	 * built the critical shared relcache entries (i.e., we're starting up
	 * without a shared relcache cache file).
	 */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>DatabaseOidIndexId</name></expr></argument>,
							  <argument><expr><name>criticalSharedRelcachesBuilt</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must copy tuple before releasing buffer */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* all done */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PerformAuthentication -- authenticate a remote client
 *
 * returns: nothing.  Will not return at all if there's any failure.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PerformAuthentication</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This should be set already, but let's make sure */</comment>
	<expr_stmt><expr><name>ClientAuthInProgress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* limit visibility of log messages */</comment>

	<comment type="block">/*
	 * In EXEC_BACKEND case, we didn't inherit the contents of pg_hba.conf
	 * etcetera from the postmaster, and have to load them ourselves.
	 *
	 * FIXME: [fork/exec] Ugh.  Is there a way around this overhead?
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

	<comment type="block">/*
	 * load_hba() and load_ident() want to work within the PostmasterContext,
	 * so create that if it doesn't exist (which it won't).  We'll delete it
	 * again later, in PostgresMain.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PostmasterContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>PostmasterContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
												  <argument><expr><literal type="string">"Postmaster"</literal></expr></argument>,
												  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>load_hba</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It makes no sense to continue if we fail to load the HBA file,
		 * since there is no way to connect to the database in this case.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not load pg_hba.conf"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>load_ident</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It is ok to continue if we fail to load the IDENT file, although it
		 * means that you cannot log in using any of the authentication
		 * methods that need a user name mapping. load_ident() already logged
		 * the details of error to the log.
		 */</comment>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Set up a timeout in case a buggy or malicious client fails to respond
	 * during authentication.  Since we're inside a transaction and might do
	 * database access, we have to use the statement_timeout infrastructure.
	 */</comment>
	<expr_stmt><expr><call><name>enable_timeout_after</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>AuthenticationTimeout</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now perform authentication exchange.
	 */</comment>
	<expr_stmt><expr><call><name>ClientAuthentication</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* might not return, if failure */</comment>

	<comment type="block">/*
	 * Done with authentication.  Disable the timeout, and log if needed.
	 */</comment>
	<expr_stmt><expr><call><name>disable_timeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Log_connections</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replication connection authorized: user=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)"</literal></expr></argument>,
								<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>,
								<argument><expr><call><name>be_tls_get_version</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>be_tls_get_cipher</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>be_tls_get_cipher_bits</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><ternary><condition><expr><call><name>be_tls_get_compression</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replication connection authorized: user=%s"</literal></expr></argument>,
								<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>ssl_in_use</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection authorized: user=%s database=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)"</literal></expr></argument>,
								<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>,
								<argument><expr><call><name>be_tls_get_version</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>be_tls_get_cipher</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>be_tls_get_cipher_bits</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><ternary><condition><expr><call><name>be_tls_get_compression</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection authorized: user=%s database=%s"</literal></expr></argument>,
								<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>polar_enable_multi_syslogger</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ErrorData</name></type> <name>edata</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>POLAR_ERROR_DATA_INIT_FOR_AUDITLOG</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>polar_write_audit_log</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>,
						<argument><expr><literal type="string">"connection authorized: user=%s database=%s"</literal></expr></argument>,
								<argument><expr><name><name>port</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"startup"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ClientAuthInProgress</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* client_min_messages is active now */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * CheckMyDatabase -- fetch information from the pg_database entry for our DB
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckMyDatabase</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>am_superuser</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>override_allow_connections</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_database</name></type> <name>dbform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ctype</name></decl>;</decl_stmt>

	<comment type="block">/* Fetch our pg_database row normally, via syscache */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for database %u"</literal></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>dbform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This recheck is strictly paranoia */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dbform</name><operator>-&gt;</operator><name>datname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_DATABASE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" has disappeared from pg_database"</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Database OID %u now seems to belong to \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dbform</name><operator>-&gt;</operator><name>datname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check permissions to connect to the database.
	 *
	 * These checks are not enforced when in standalone mode, so that there is
	 * a way to recover from disabling all access to all databases, for
	 * example "UPDATE pg_database SET datallowconn = false;".
	 *
	 * We do not enforce them for autovacuum worker processes either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check that the database is currently allowing connections.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dbform</name><operator>-&gt;</operator><name>datallowconn</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>override_allow_connections</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" is not currently accepting connections"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check privilege to connect to the database.  (The am_superuser test
		 * is redundant, but since we have the flag, might as well check it
		 * and save a few cycles.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_superuser</name> <operator>&amp;&amp;</operator>
			<call><name>pg_database_aclcheck</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
								 <argument><expr><name>ACL_CONNECT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for database \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"User does not have CONNECT privilege."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check connection limit for this database.
		 *
		 * There is a race condition here --- we create our PGPROC before
		 * checking for other PGPROCs.  If two backends did this at about the
		 * same time, they might both think they were over the limit, while
		 * ideally one should succeed and one fail.  Getting that to work
		 * exactly seems more trouble than it is worth, however; instead we
		 * just document that the connection limit is approximate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dbform</name><operator>-&gt;</operator><name>datconnlimit</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>am_superuser</name> <operator>&amp;&amp;</operator>
			<call><name>CountDBConnections</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>dbform</name><operator>-&gt;</operator><name>datconnlimit</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many connections for database \"%s\""</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK, we're golden.  Next to-do item is to save the encoding info out of
	 * the pg_database tuple.
	 */</comment>
	<expr_stmt><expr><call><name>SetDatabaseEncoding</name><argument_list>(<argument><expr><name><name>dbform</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Record it as a GUC internal option, too */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"server_encoding"</literal></expr></argument>, <argument><expr><call><name>GetDatabaseEncodingName</name><argument_list>()</argument_list></call></expr></argument>,
					<argument><expr><name>PGC_INTERNAL</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If we have no other source of client_encoding, use server encoding */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"client_encoding"</literal></expr></argument>, <argument><expr><call><name>GetDatabaseEncodingName</name><argument_list>()</argument_list></call></expr></argument>,
					<argument><expr><name>PGC_BACKEND</name></expr></argument>, <argument><expr><name>PGC_S_DYNAMIC_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* assign locale variables */</comment>
	<expr_stmt><expr><name>collate</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>dbform</name><operator>-&gt;</operator><name>datcollate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctype</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>dbform</name><operator>-&gt;</operator><name>datctype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_perm_setlocale</name><argument_list>(<argument><expr><name>LC_COLLATE</name></expr></argument>, <argument><expr><name>collate</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database locale is incompatible with operating system"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database was initialized with LC_COLLATE \"%s\", "</literal>
						   <literal type="string">" which is not recognized by setlocale()."</literal></expr></argument>, <argument><expr><name>collate</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Recreate the database with another locale or install the missing locale."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_perm_setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database locale is incompatible with operating system"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database was initialized with LC_CTYPE \"%s\", "</literal>
						   <literal type="string">" which is not recognized by setlocale()."</literal></expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Recreate the database with another locale or install the missing locale."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make the locale settings visible as GUC variables, too */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"lc_collate"</literal></expr></argument>, <argument><expr><name>collate</name></expr></argument>, <argument><expr><name>PGC_INTERNAL</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"lc_ctype"</literal></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>PGC_INTERNAL</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>check_strxfrm_bug</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/* --------------------------------
 *		InitCommunication
 *
 *		This routine initializes stuff needed for ipc, locking, etc.
 *		it should be called something more informative.
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitCommunication</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * initialize shared memory and semaphores appropriately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>		<comment type="block">/* postmaster already did this */</comment>
	<block>{<block_content>
		<comment type="block">/*
		 * We're running a postgres bootstrap process or a standalone backend.
		 * Though we won't listen on PostPortNumber, use it to select a shmem
		 * key.  This increases the chance of detecting a leftover live
		 * backend of this DataDir.
		 */</comment>
		<expr_stmt><expr><call><name>CreateSharedMemoryAndSemaphores</name><argument_list>(<argument><expr><name>PostPortNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_split_opts -- split a string of options and append it to an argv array
 *
 * The caller is responsible for ensuring the argv array is large enough.  The
 * maximum possible number of arguments added by this routine is
 * (strlen(optstr) + 1) / 2.
 *
 * Because some option values can contain spaces we allow escaping using
 * backslashes, with \\ representing a literal backslash.
 */</comment>
<function><type><name>void</name></type>
<name>pg_split_opts</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argcp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>optstr</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>last_was_escape</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* skip over leading space */</comment>
		<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>optstr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>optstr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>optstr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Parse a single option, stopping at the first space, unless it's
		 * escaped.
		 */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>optstr</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>optstr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>last_was_escape</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last_was_escape</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>optstr</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>last_was_escape</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>last_was_escape</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><operator>*</operator><name>optstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>optstr</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* now store the option in the next argv[] position */</comment>
		<expr_stmt><expr><name><name>argv</name><index>[<expr><operator>(</operator><operator>*</operator><name>argcp</name><operator>)</operator><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize MaxBackends value from config options.
 *
 * This must be called after modules have had the chance to register background
 * workers in shared_preload_libraries, and before shared memory size is
 * determined.
 *
 * Note that in EXEC_BACKEND environment, the value is passed down from
 * postmaster to subprocesses via BackendParameters in SubPostmasterMain; only
 * postmaster itself and processes not under postmaster control should call
 * this.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeMaxBackends</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MaxBackends</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the extra unit accounts for the autovacuum launcher */</comment>
	<expr_stmt><expr><name>MaxBackends</name> <operator>=</operator> <name>MaxConnections</name> <operator>+</operator> <name>autovacuum_max_workers</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>
		<name>max_worker_processes</name></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><name>MaxNormalBackends</name>
		<operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>floor</name><argument_list>(<argument><expr><name>polar_max_normal_backends_factor</name> <operator>*</operator> <name>MaxConnections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* internal error because the values were all checked previously */</comment>
	<if_stmt><if>if <condition>(<expr><name>MaxBackends</name> <operator>&gt;</operator> <name>MAX_BACKENDS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many backends configured"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Early initialization of a backend (either standalone or under postmaster).
 * This happens even before InitPostgres.
 *
 * This is separate from InitPostgres because it is also called by auxiliary
 * processes, such as the background writer process, which may not call
 * InitPostgres at all.
 */</comment>
<function><type><name>void</name></type>
<name>BaseInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Attach to shared memory and semaphores, and initialize our
	 * input/output/debugging file descriptors.
	 */</comment>
	<expr_stmt><expr><call><name>InitCommunication</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DebugFileOpen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do local initialization of file, storage and buffer managers */</comment>
	<expr_stmt><expr><call><name>InitFileAccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrinit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitBufferPoolAccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 * InitPostgres
 *		Initialize POSTGRES.
 *
 * The database can be specified by name, using the in_dbname parameter, or by
 * OID, using the dboid parameter.  In the latter case, the actual database
 * name can be returned to the caller in out_dbname.  If out_dbname isn't
 * NULL, it must point to a buffer of size NAMEDATALEN.
 *
 * Similarly, the username can be passed by name, using the username parameter,
 * or by OID using the useroid parameter.
 *
 * In bootstrap mode no parameters are used.  The autovacuum launcher process
 * doesn't use any parameters either, because it only goes far enough to be
 * able to read pg_database; it doesn't connect to any particular database.
 * In walsender mode only username is used.
 *
 * As of PostgreSQL 8.2, we expect InitProcess() was already called, so we
 * already have a PGPROC struct ... but it's not completely filled in yet.
 *
 * Note:
 *		Be very careful with the order of calls in the InitPostgres function.
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>InitPostgres</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in_dbname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>dboid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>useroid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out_dbname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>override_allow_connections</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bootstrap</name> <init>= <expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>am_superuser</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fullpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>dbname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* POLAR */</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>nosupercount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>supercount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"InitPostgres"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add my PGPROC struct to the ProcArray.
	 *
	 * Once I have done this, I am visible to other backends!
	 */</comment>
	<expr_stmt><expr><call><name>InitProcessPhase2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PX</name></cpp:ifdef>
	<comment type="block">/* Initialize PXOPT */</comment>
	<expr_stmt><expr><name>px_OptimizerMemoryContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
												   <argument><expr><literal type="string">"PXOPT Top-level Memory Context"</literal></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
												   <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InitPXOPT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Initialize my entry in the shared-invalidation manager's array of
	 * per-backend data.
	 *
	 * Sets up MyBackendId, a unique backend identifier.
	 */</comment>
	<expr_stmt><expr><name>MyBackendId</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SharedInvalBackendInit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyBackendId</name> <operator>&gt;</operator> <name>MaxBackends</name> <operator>||</operator> <name>MyBackendId</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"bad backend ID: %d"</literal></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now that we have a BackendId, we can participate in ProcSignal */</comment>
	<expr_stmt><expr><call><name>ProcSignalInit</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also set up timeout handlers needed for backend operation.  We need
	 * these in every case except bootstrap.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RegisterTimeout</name><argument_list>(<argument><expr><name>DEADLOCK_TIMEOUT</name></expr></argument>, <argument><expr><name>CheckDeadLockAlert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RegisterTimeout</name><argument_list>(<argument><expr><name>STATEMENT_TIMEOUT</name></expr></argument>, <argument><expr><name>StatementTimeoutHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RegisterTimeout</name><argument_list>(<argument><expr><name>LOCK_TIMEOUT</name></expr></argument>, <argument><expr><name>LockTimeoutHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RegisterTimeout</name><argument_list>(<argument><expr><name>IDLE_IN_TRANSACTION_SESSION_TIMEOUT</name></expr></argument>,
						<argument><expr><name>IdleInTransactionSessionTimeoutHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* POLAR px: register wait lock timer and get a valid timeout id. */</comment>
		<expr_stmt><expr><name>px_wait_lock_timer_id</name> <operator>=</operator> <call><name>RegisterTimeout</name><argument_list>(<argument><expr><name>USER_TIMEOUT</name></expr></argument>,
												<argument><expr><name>px_wait_lock_timeout_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_VALID_TIMER_ID</name><argument_list>(<argument><expr><name>px_wait_lock_timer_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* POLAR end */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * bufmgr needs another initialization call too
	 */</comment>
	<expr_stmt><expr><call><name>InitBufferPoolBackend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize local process's access to XLOG.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The postmaster already started the XLOG machinery, but we need to
		 * call InitXLOGAccess(), if the system isn't in hot-standby mode.
		 * This is handled by calling RecoveryInProgress and ignoring the
		 * result.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>

		<comment type="block">/*
		 * We are either a bootstrap process or a standalone backend. Either
		 * way, start up the XLOG machinery, and register to have it closed
		 * down at exit.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DMA</name></cpp:ifdef>
		<comment type="block">/* POLAR: disable consensus */</comment>
		<expr_stmt><expr><name>polar_enable_dma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>StartupXLOG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>ShutdownXLOG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Initialize the relation cache and the system catalog caches.  Note that
	 * no catalog access happens here; we only set up the hashtable structure.
	 * We must do this before starting a transaction because transaction abort
	 * would try to touch these hashtables.
	 */</comment>
	<expr_stmt><expr><call><name>RelationCacheInitialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitCatalogCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitPlanCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize portal manager */</comment>
	<expr_stmt><expr><call><name>EnablePortalManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize stats collection --- must happen before first xact */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Load relcache entries for the shared system catalogs.  This must create
	 * at least entries for pg_database and catalogs used for authentication.
	 */</comment>
	<expr_stmt><expr><call><name>RelationCacheInitializePhase2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up process-exit callback to do pre-shutdown cleanup.  This is the
	 * first before_shmem_exit callback we register; thus, this will be the
	 * last thing we do before low-level modules like the buffer manager begin
	 * to close down.  We need to have this in place before we begin our first
	 * transaction --- if we fail during the initialization transaction, as is
	 * entirely possible, we need the AbortTransaction call to clean up.
	 */</comment>
	<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>ShutdownPostgres</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The autovacuum launcher is done here */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumLauncherProcess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* report this backend in the PgBackendStatus array */</comment>
		<expr_stmt><expr><call><name>pgstat_bestart</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Start a new transaction here before first access to db, and get a
	 * snapshot.  We don't have a use for the snapshot itself, but we're
	 * interested in the secondary effect that it sets RecentGlobalXmin. (This
	 * is critical for anything that reads heap pages, because HOT may decide
	 * to prune them even if the process doesn't attempt to modify any
	 * tuples.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* statement_timestamp must be set for timeouts to work correctly */</comment>
		<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * transaction_isolation will have been set to the default by the
		 * above.  If the default is "serializable", and we are in hot
		 * standby, we will fail if we don't change it to something lower.
		 * Fortunately, "read committed" is plenty good enough.
		 */</comment>
		<expr_stmt><expr><name>XactIsoLevel</name> <operator>=</operator> <name>XACT_READ_COMMITTED</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Perform client authentication if necessary, then figure out our
	 * postgres user ID, and see if we are a superuser.
	 *
	 * In standalone mode and in autovacuum worker processes, we use a fixed
	 * ID, otherwise we figure it out from the authenticated user name.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bootstrap</name> <operator>||</operator> <call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InitializeSessionUserIdStandalone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>am_superuser</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InitializeSessionUserIdStandalone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>am_superuser</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ThereIsAtLeastOneRole</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no roles are defined in this database system"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You should immediately run CREATE USER \"%s\" SUPERUSER;."</literal></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>username</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>username</name></expr> </then><else>: <expr><literal type="string">"postgres"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>IsBackgroundWorker</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>username</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>useroid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>InitializeSessionUserIdStandalone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>am_superuser</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>InitializeSessionUserId</name><argument_list>(<argument><expr><name>username</name></expr></argument>, <argument><expr><name>useroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>am_superuser</name> <operator>=</operator> <call><name>superuser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* normal multiuser case */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProcPort</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PerformAuthentication</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InitializeSessionUserId</name><argument_list>(<argument><expr><name>username</name></expr></argument>, <argument><expr><name>useroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>am_superuser</name> <operator>=</operator> <call><name>superuser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If we're trying to shut down, only superusers can connect, and new
	 * replication connections are not allowed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>POLAR_ENABLE_DMA</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>am_superuser</name> <operator>||</operator> <name>am_walsender</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>MyProcPort</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>MyProcPort</name><operator>-&gt;</operator><name>canAcceptConnections</name></name> <operator>==</operator> <name>CAC_WAITBACKUP</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new replication connections are not allowed during database shutdown"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to connect during database shutdown"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Binary upgrades only allowed super-user connections
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>am_superuser</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to connect in binary upgrade mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The last few connections slots are reserved for superusers and replication
	 * connections. Whenever connections is replication connections or superuser,
	 * we all allow connection. But in official design, they refuse replication
	 * connections where it is up to superuser_reserved_connections.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_superuser</name> <operator>&amp;&amp;</operator>
		<name>ReservedBackends</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>HaveNFreeProcs</name><argument_list>(<argument><expr><name>ReservedBackends</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remaining connection slots are reserved for non-replication superuser connections"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* POLAR: we can get all user num and superuser num in one scan procarray*/</comment>
	<expr_stmt><expr><call><name>polar_get_nosuper_and_super_conn_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nosupercount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>supercount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * POLAR: for all user(not including walsender and superuser), check if all connections exceeded
	 * polar_max_non_super_conns. Note We do not restrict walsender any more,we must keep slave
	 * alive
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_superuser</name> <operator>&amp;&amp;</operator> <name>polar_max_non_super_conns</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>polar_max_non_super_conns</name> <operator>&lt;</operator> <name>nosupercount</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Sorry, too many clients already"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * POLAR: for super(not including walsenders), check if all connections exceeded
	 * polar_max_super_conns. Note We do not restrict walsender any more,we must
	 * keep slave alive
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_superuser</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>am_walsender</name> <operator>&amp;&amp;</operator> <name>polar_max_super_conns</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>polar_max_super_conns</name> <operator>&lt;</operator> <name>supercount</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Sorry, number of superuser connections has exceeded polar_max_super_conns:%d"</literal></expr></argument>, <argument><expr><name>polar_max_super_conns</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * POLAR: reserve connections for polar_superuser, when the connection counts
	 * exceeded polar_reserve_polar_super_conns, new connections are fobidden. Note that
	 * the priority of superuser is higher than poalr_super_user, the limit is only
	 * valid for normal users.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_superuser</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>am_superuser</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>am_walsender</name> <operator>&amp;&amp;</operator>
		<name>polar_max_non_super_conns</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>polar_reserved_polar_super_conns</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>nosupercount</name> <operator>+</operator> <name>polar_reserved_polar_super_conns</name> <operator>&gt;</operator> <name>polar_max_non_super_conns</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Sorry, number of normal user connections (%d) plus polar super user connections (%d) have exceeded limits"</literal></expr></argument>,
				 <argument><expr><name>nosupercount</name></expr></argument>, <argument><expr><name>polar_reserved_polar_super_conns</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/* Check replication permissions needed for walsender processes. */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_walsender</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>bootstrap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>has_rolreplication</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or replication role to start walsender"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this is a plain walsender only supporting physical replication, we
	 * don't want to connect to any particular database. Just finish the
	 * backend startup by processing any options from the startup packet, and
	 * we're done.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_walsender</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>am_db_walsender</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* process any options passed in the startup packet */</comment>
		<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>process_startup_options</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>, <argument><expr><name>am_superuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Apply PostAuthDelay as soon as we've read all options */</comment>
		<if_stmt><if>if <condition>(<expr><name>PostAuthDelay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>PostAuthDelay</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* initialize client encoding */</comment>
		<expr_stmt><expr><call><name>InitializeClientEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* report this backend in the PgBackendStatus array */</comment>
		<expr_stmt><expr><call><name>pgstat_bestart</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* close the transaction we started above */</comment>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set up the global variables holding database id and default tablespace.
	 * But note we won't actually try to touch the database just yet.
	 *
	 * We take a shortcut in the bootstrap case, otherwise we have to look up
	 * the db's entry in pg_database.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bootstrap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>MyDatabaseId</name> <operator>=</operator> <name>TemplateDbOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>MyDatabaseTableSpace</name> <operator>=</operator> <name>DEFAULTTABLESPACE_OID</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>in_dbname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_database</name></type> <name>dbform</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>GetDatabaseTuple</name><argument_list>(<argument><expr><name>in_dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_DATABASE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>in_dbname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>dbform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>MyDatabaseId</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>MyDatabaseTableSpace</name> <operator>=</operator> <name><name>dbform</name><operator>-&gt;</operator><name>dattablespace</name></name></expr>;</expr_stmt>
		<comment type="block">/* take database name from the caller, just for paranoia */</comment>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>in_dbname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* caller specified database by OID */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_database</name></type> <name>dbform</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>GetDatabaseTupleByOid</name><argument_list>(<argument><expr><name>dboid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_DATABASE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database %u does not exist"</literal></expr></argument>, <argument><expr><name>dboid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>dbform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>MyDatabaseId</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>MyDatabaseTableSpace</name> <operator>=</operator> <name><name>dbform</name><operator>-&gt;</operator><name>dattablespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyDatabaseId</name> <operator>==</operator> <name>dboid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dbform</name><operator>-&gt;</operator><name>datname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* pass the database name back to the caller */</comment>
		<if_stmt><if>if <condition>(<expr><name>out_dbname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>out_dbname</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If this is a background worker not bound to any particular
		 * database, we're done now.  Everything that follows only makes sense
		 * if we are bound to a specific database.  We do need to close the
		 * transaction we started before returning.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgstat_bestart</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Now, take a writer's lock on the database we are trying to connect to.
	 * If there is a concurrently running DROP DATABASE on that database, this
	 * will block us until it finishes (and has committed its update of
	 * pg_database).
	 *
	 * Note that the lock is not held long, only until the end of this startup
	 * transaction.  This is OK since we will advertise our use of the
	 * database in the ProcArray before dropping the lock (in fact, that's the
	 * next thing to do).  Anyone trying a DROP DATABASE after this point will
	 * see us in the array once they have the lock.  Ordering is important for
	 * this because we don't want to advertise ourselves as being in this
	 * database until we have the lock; otherwise we create what amounts to a
	 * deadlock with CountOtherDBBackends().
	 *
	 * Note: use of RowExclusiveLock here is reasonable because we envision
	 * our session as being a concurrent writer of the database.  If we had a
	 * way of declaring a session as being guaranteed-read-only, we could use
	 * AccessShareLock for such sessions and thereby not conflict against
	 * CREATE DATABASE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LockSharedObject</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						 <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now we can mark our PGPROC entry with the database ID.
	 *
	 * We assume this is an atomic store so no lock is needed; though actually
	 * things would work fine even if it weren't atomic.  Anyone searching the
	 * ProcArray for this database's ID should hold the database lock, so they
	 * would not be executing concurrently with this store.  A process looking
	 * for another database's ID could in theory see a chance match if it read
	 * a partially-updated databaseId value; but as long as all such searches
	 * wait and retry, as in CountOtherDBBackends(), they will certainly see
	 * the correct value on their next try.
	 */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We established a catalog snapshot while reading pg_authid and/or
	 * pg_database; but until we have set up MyDatabaseId, we won't react to
	 * incoming sinval messages for unshared catalogs, so we won't realize it
	 * if the snapshot has been invalidated.  Assume it's no good anymore.
	 */</comment>
	<expr_stmt><expr><call><name>InvalidateCatalogSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recheck pg_database to make sure the target database hasn't gone away.
	 * If there was a concurrent DROP DATABASE, this ensures we will die
	 * cleanly without creating a mess.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>GetDatabaseTuple</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>MyDatabaseId</name> <operator>!=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name>MyDatabaseTableSpace</name> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>dattablespace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_DATABASE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"It seems to have just been dropped or renamed."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now we should be able to access the database directory safely. Verify
	 * it's there and looks reasonable.
	 */</comment>
	<expr_stmt><expr><name>fullpath</name> <operator>=</operator> <call><name>GetDatabasePath</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>MyDatabaseTableSpace</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_DATABASE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name>dbname</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database subdirectory \"%s\" is missing."</literal></expr></argument>,
								   <argument><expr><name>fullpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access directory \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>fullpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ValidatePgVersion</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SetDatabasePath</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>polar_fullpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>polar_fullpath</name> <operator>=</operator> <call><name>polar_get_database_path</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>MyDatabaseTableSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>polar_access</name><argument_list>(<argument><expr><name>polar_fullpath</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_DATABASE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" does not exist"</literal></expr></argument>,
									<argument><expr><name>dbname</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The database subdirectory \"%s\" is missing."</literal></expr></argument>,
									   <argument><expr><name>fullpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access directory \"%s\": %m"</literal></expr></argument>,
									<argument><expr><name>fullpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>polar_set_database_path</name><argument_list>(<argument><expr><name>polar_fullpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It's now possible to do real access to the system catalogs.
	 *
	 * Load relcache entries for the system catalogs.  This must create at
	 * least the minimum set of "nailed-in" cache entries.
	 */</comment>
	<expr_stmt><expr><call><name>RelationCacheInitializePhase3</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set up ACL framework (so CheckMyDatabase can check permissions) */</comment>
	<expr_stmt><expr><call><name>initialize_acl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-read the pg_database row for our database, check permissions and set
	 * up database-specific GUC settings.  We can't do this until all the
	 * database-access infrastructure is up.  (Also, it wants to know if the
	 * user is a superuser, so the above stuff has to happen first.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CheckMyDatabase</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>am_superuser</name></expr></argument>, <argument><expr><name>override_allow_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now process any command-line switches and any additional GUC variable
	 * settings passed in the startup packet.   We couldn't do this before
	 * because we didn't know if client is a superuser.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>process_startup_options</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>, <argument><expr><name>am_superuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Process pg_db_role_setting options */</comment>
	<expr_stmt><expr><call><name>process_settings</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Apply PostAuthDelay as soon as we've read all options */</comment>
	<if_stmt><if>if <condition>(<expr><name>PostAuthDelay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>PostAuthDelay</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize various default states that can't be set up until we've
	 * selected the active user and gotten the right GUC settings.
	 */</comment>

	<comment type="block">/* set default namespace search path */</comment>
	<expr_stmt><expr><call><name>InitializeSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize client encoding */</comment>
	<expr_stmt><expr><call><name>InitializeClientEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize this backend's session state. */</comment>
	<expr_stmt><expr><call><name>InitializeSession</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* report this backend in the PgBackendStatus array */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_bestart</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* close the transaction we started above */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process any command-line switches and any additional GUC variable
 * settings passed in the startup packet.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_startup_options</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>am_superuser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GucContext</name></type>	<name>gucctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>gucopts</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>gucctx</name> <operator>=</operator> <ternary><condition><expr><name>am_superuser</name></expr> ?</condition><then> <expr><name>PGC_SU_BACKEND</name></expr> </then><else>: <expr><name>PGC_BACKEND</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * First process any command-line switches that were included in the
	 * startup packet, if we are in a regular backend.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>cmdline_options</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The maximum possible number of commandline arguments that could
		 * come from port-&gt;cmdline_options is (strlen + 1) / 2; see
		 * pg_split_opts().
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>av</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>maxac</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ac</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>maxac</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>cmdline_options</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>av</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>maxac</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_split_opts</name><argument_list>(<argument><expr><name>av</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ac</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>cmdline_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <name>maxac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>process_postgres_switches</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>, <argument><expr><name>gucctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process any additional GUC variable settings passed in startup packet.
	 * These are handled exactly like command-line variables.
	 */</comment>
	<expr_stmt><expr><name>gucopts</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>guc_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>gucopts</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>gucopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>gucopts</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>gucopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>gucopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>gucopts</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>gucopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>gucctx</name></expr></argument>, <argument><expr><name>PGC_S_CLIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Load GUC settings from pg_db_role_setting.
 *
 * We try specific settings for the database/role combination, as well as
 * general for this database and for this user.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_settings</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relsetting</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relsetting</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DbRoleSettingRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read all the settings under the same snapshot for efficiency */</comment>
	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetCatalogSnapshot</name><argument_list>(<argument><expr><name>DbRoleSettingRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Later settings are ignored if set earlier. */</comment>
	<expr_stmt><expr><call><name>ApplySetting</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>databaseid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>relsetting</name></expr></argument>, <argument><expr><name>PGC_S_DATABASE_USER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ApplySetting</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>relsetting</name></expr></argument>, <argument><expr><name>PGC_S_USER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ApplySetting</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>databaseid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>relsetting</name></expr></argument>, <argument><expr><name>PGC_S_DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: if indicated, disable global settings for super users. Since we have
	 * allowed non-super users to set global settings which include
	 * search_patch/client_encoding/etc that could have impact on super user's
	 * session, we have to disable applying global settings (set by ALTER ROLE
	 * ALL SET ....) for super users
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MyProc</name><operator>-&gt;</operator><name>issuper</name></name> <operator>||</operator> <name>polar_apply_global_guc_for_super</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ApplySetting</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>relsetting</name></expr></argument>, <argument><expr><name>PGC_S_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relsetting</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Backend-shutdown callback.  Do cleanup that we want to be sure happens
 * before all the supporting modules begin to nail their doors shut via
 * their own callbacks.
 *
 * User-level cleanup, such as temp-relation removal and UNLISTEN, happens
 * via separate callbacks that execute before this one.  We don't combine the
 * callbacks because we still want this one to happen if the user-level
 * cleanup fails.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShutdownPostgres</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Make sure we've killed any active transaction */</comment>
	<expr_stmt><expr><call><name>AbortOutOfAnyTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PX</name></cpp:ifdef>
	<expr_stmt><expr><call><name>TerminatePXOPT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_OptimizerMemoryContext</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>px_OptimizerMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * User locks are not released by transaction end, so be sure to release
	 * them explicitly.
	 */</comment>
	<expr_stmt><expr><call><name>LockReleaseAll</name><argument_list>(<argument><expr><name>USER_LOCKMETHOD</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * STATEMENT_TIMEOUT handler: trigger a query-cancel interrupt.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StatementTimeoutHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>sig</name> <init>= <expr><name>SIGINT</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * During authentication the timeout is used to deal with
	 * authentication_timeout - we want to quit in response to such timeouts.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ClientAuthInProgress</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>SIGTERM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETSID</name></cpp:ifdef>
	<comment type="block">/* try to signal whole process group */</comment>
	<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><operator>-</operator><name>MyProcPid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * LOCK_TIMEOUT handler: trigger a query-cancel interrupt.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LockTimeoutHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETSID</name></cpp:ifdef>
	<comment type="block">/* try to signal whole process group */</comment>
	<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><operator>-</operator><name>MyProcPid</name></expr></argument>, <argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>IdleInTransactionSessionTimeoutHandler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>IdleInTransactionSessionTimeoutPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if at least one role is defined in this database cluster.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ThereIsAtLeastOneRole</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_authid_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_authid_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>pg_authid_rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_authid_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: 
 * 	  Initialization for making polar dynamic bgworker visible 
 * 		in pg_stat_activity and polar_stat_activity
 *    Then how other backends implement this?
 *    	* client backends: InitPostgres()
 *    	* static bg worker: also InitPostgres()
 *    	* Auxiliary proc: in AuxiliaryProcessMain
 * 	  
 *    So we need to borrow codes from InitPostgres/AuxiliaryProcessMain and 
 * 		we'd better minimize this work for not involving additional initialization
 * 		and reducing the side effects.
 */</comment>
<function><type><name>void</name></type>
<name>polar_init_dynamic_bgworker_in_backends</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bootstrap</name> <init>= <expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* 
	 * POLAR: Add PGPROC struct to the ProcArray 
	 *  we do this to show myself activity in pg_stat_activity
	 * 
	 *  but now it would cause standby panic when btree_xlog_delete_get_latestRemovedXid
	 *  because CountDBBackends &gt; 0
	 */</comment>
	<comment type="line">// InitProcessPhase2();</comment>

	<comment type="block">/* POLAR: Get MyBackendId */</comment>
	<expr_stmt><expr><name>MyBackendId</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SharedInvalBackendInit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyBackendId</name> <operator>&gt;</operator> <name>MaxBackends</name> <operator>||</operator> <name>MyBackendId</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"bad backend ID: %d"</literal></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* POLAR: Now that we have a BackendId, we can participate in ProcSignal */</comment>
	<expr_stmt><expr><call><name>ProcSignalInit</name><argument_list>(<argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: Initialize stats collection */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bootstrap</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgstat_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>ShutdownPostgres</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: init session user id because we are B_BG_WORKER */</comment>
	<expr_stmt><expr><call><name>InitializeSessionUserIdStandalone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_bestart</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
