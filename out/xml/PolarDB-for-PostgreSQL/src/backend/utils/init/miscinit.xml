<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/init/miscinit.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * miscinit.c
 *	  miscellaneous initialization support stuff
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/init/miscinit.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UTIME_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pidfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/clog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_csnlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/polar_local_cache.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIRECTORY_LOCK_FILE</name></cpp:macro>		<cpp:value>"postmaster.pid"</cpp:value></cpp:define>

<comment type="block">/* POLAR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_SHMEM_FILE</name></cpp:macro>		<cpp:value>"polar_shmem"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>polar_shmem_file_exists</name><parameter_list>(<parameter><type><name>status</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(status == SHMEM_FILE_INVALID || status == SHMEM_FILE_SHM_NOT_IN_USE)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>ProcessingMode</name></type> <name>Mode</name> <init>= <expr><name>InitProcessing</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* List of lock files to be removed at proc exit */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>lock_files</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Latch</name></type> <name>LocalLatchData</name></decl>;</decl_stmt>

<comment type="block">/* POLAR */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_remove_old_shmem_info_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PolarShmemFileStatus</name></type> <name>polar_shmem_file_status</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_remove_local_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------------------------------------------------------------
 *		ignoring system indexes support stuff
 *
 * NOTE: "ignoring system indexes" means we do not use the system indexes
 * for lookups (either in hardwired catalog accesses or in planner-generated
 * plans).  We do, however, still update the indexes when a catalog
 * modification is made.
 * ----------------------------------------------------------------
 */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>IgnoreSystemIndexes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* ----------------------------------------------------------------
 *				database path / name support stuff
 * ----------------------------------------------------------------
 */</comment>

<function><type><name>void</name></type>
<name>SetDatabasePath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This should happen only once per process */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>DatabasePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>DatabasePath</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Validate the proposed data directory.
 *
 * Also initialize file and directory create modes and mode mask.
 */</comment>
<function><type><name>void</name></type>
<name>checkDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data directory \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read permissions of directory \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* eventual chdir would fail anyway, but let's test ... */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specified data directory \"%s\" is not a directory"</literal></expr></argument>,
						<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the directory belongs to my userid; if not, reject.
	 *
	 * This check is an essential part of the interlock that prevents two
	 * postmasters from starting in the same directory (see CreateLockFile()).
	 * Do not remove or weaken it.
	 *
	 * XXX can we safely enable this check on Windows?
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>stat_buf</name><operator>.</operator><name>st_uid</name></name> <operator>!=</operator> <call><name>geteuid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data directory \"%s\" has wrong ownership"</literal></expr></argument>,
						<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The server must be started by the user that owns the data directory."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Check if the directory has correct permissions.  If not, reject.
	 *
	 * Only two possible modes are allowed, 0700 and 0750.  The latter mode
	 * indicates that group read/execute should be allowed on all newly
	 * created files and directories.
	 *
	 * XXX temporarily suppress check when on Windows, because there may not
	 * be proper support for Unix-y file permissions.  Need to think of a
	 * reasonable check to apply on Windows.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>PG_MODE_MASK_GROUP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data directory \"%s\" has invalid permissions"</literal></expr></argument>,
						<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Permissions should be u=rwx (0700) or u=rwx,g=rx (0750)."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Reset creation modes and mask based on the mode of the data directory.
	 *
	 * The mask was set earlier in startup to disallow group permissions on
	 * newly created files and directories.  However, if group read/execute
	 * are present on the data directory then modify the create modes and mask
	 * to allow group read/execute on newly created files and directories and
	 * set the data_directory_mode GUC.
	 *
	 * Suppress when on Windows, because there may not be proper support for
	 * Unix-y file permissions.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><call><name>SetDataDirectoryCreatePerm</name><argument_list>(<argument><expr><name><name>stat_buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>pg_mode_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data_directory_mode</name> <operator>=</operator> <name>pg_dir_create_mode</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Check for PG_VERSION */</comment>
	<expr_stmt><expr><call><name>ValidatePgVersion</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set data directory, but make sure it's an absolute path.  Use this,
 * never set DataDir directly.
 */</comment>
<function><type><name>void</name></type>
<name>SetDataDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If presented path is relative, convert to absolute */</comment>
	<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>DataDir</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>DataDir</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Change working directory to DataDir.  Most of the postmaster and backend
 * code assumes that we are in DataDir so it can use relative paths to access
 * stuff in and under the data directory.  For convenience during path
 * setup, however, we don't force the chdir to occur during SetDataDir.
 */</comment>
<function><type><name>void</name></type>
<name>ChangeToDataDir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not change directory to \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *	User ID state
 *
 * We have to track several different values associated with the concept
 * of "user ID".
 *
 * AuthenticatedUserId is determined at connection start and never changes.
 *
 * SessionUserId is initially the same as AuthenticatedUserId, but can be
 * changed by SET SESSION AUTHORIZATION (if AuthenticatedUserIsSuperuser).
 * This is the ID reported by the SESSION_USER SQL function.
 *
 * OuterUserId is the current user ID in effect at the "outer level" (outside
 * any transaction or function).  This is initially the same as SessionUserId,
 * but can be changed by SET ROLE to any role that SessionUserId is a
 * member of.  (XXX rename to something like CurrentRoleId?)
 *
 * CurrentUserId is the current effective user ID; this is the one to use
 * for all normal permissions-checking purposes.  At outer level this will
 * be the same as OuterUserId, but it changes during calls to SECURITY
 * DEFINER functions, as well as locally in some specialized commands.
 *
 * SecurityRestrictionContext holds flags indicating reason(s) for changing
 * CurrentUserId.  In some cases we need to lock down operations that are
 * not directly controlled by privilege settings, and this provides a
 * convenient way to do it.
 * ----------------------------------------------------------------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>AuthenticatedUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>SessionUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>OuterUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>CurrentUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* We also have to remember the superuser state of some of these levels */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>AuthenticatedUserIsSuperuser</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>SessionUserIsSuperuser</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>SecurityRestrictionContext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* We also remember if a SET ROLE is currently active */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>SetRoleIsActive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Initialize the basic environment for a postmaster child
 *
 * Should be called as early as possible after the child's startup.
 */</comment>
<function><type><name>void</name></type>
<name>InitPostmasterChild</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>IsUnderPostmaster</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* we are a postmaster subprocess now */</comment>

	<expr_stmt><expr><name>MyProcPid</name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* reset MyProcPid */</comment>

	<expr_stmt><expr><name>MyStartTime</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* set our start time in case we call elog */</comment>

	<comment type="block">/*
	 * make sure stderr is in binary mode before anything can possibly be
	 * written to it, in case it's actually the syslogger pipe, so the pipe
	 * chunking protocol isn't disturbed. Non-logpipe data gets translated on
	 * redirection (e.g. via pg_ctl -l) anyway.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* We don't want the postmaster's proc_exit() handlers */</comment>
	<expr_stmt><expr><call><name>on_exit_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: pfs tls init when subprocess forked
	 * we need set cleanup function.
	 */</comment>
	<expr_stmt><expr><call><name>polar_register_tls_cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize process-local latch support */</comment>
	<expr_stmt><expr><call><name>InitializeLatchSupport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyLatch</name> <operator>=</operator> <operator>&amp;</operator><name>LocalLatchData</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If possible, make this process a group leader, so that the postmaster
	 * can signal any child processes too. Not all processes will have
	 * children, but for consistency we make all postmaster child processes do
	 * this.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SETSID</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>setsid</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"setsid() failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the basic environment for a standalone process.
 *
 * argv0 has to be suitable to find the program's executable.
 */</comment>
<function><type><name>void</name></type>
<name>InitStandaloneProcess</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsPostmasterEnvironment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyProcPid</name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* reset MyProcPid */</comment>

	<expr_stmt><expr><name>MyStartTime</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* set our start time in case we call elog */</comment>

	<comment type="block">/*
	 * Initialize random() for the first time, like PostmasterMain() would.
	 * In a regular IsUnderPostmaster backend, BackendRun() computes a
	 * high-entropy seed before any user query.  Fewer distinct initial seeds
	 * can occur here.
	 */</comment>
	<expr_stmt><expr><call><name>srandom</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><name>MyProcPid</name> <operator>^</operator> <name>MyStartTime</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize process-local latch support */</comment>
	<expr_stmt><expr><call><name>InitializeLatchSupport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyLatch</name> <operator>=</operator> <operator>&amp;</operator><name>LocalLatchData</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute paths, no postmaster to inherit from */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>my_exec_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>find_my_exec</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"%s: could not locate my own executable path"</literal></expr></argument>,
				 <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pkglib_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_pkglib_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>pkglib_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SwitchToSharedLatch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyLatch</name> <operator>==</operator> <operator>&amp;</operator><name>LocalLatchData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyLatch</name> <operator>=</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>FeBeWaitSet</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ModifyWaitEvent</name><argument_list>(<argument><expr><name>FeBeWaitSet</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Set the shared latch as the local one might have been set. This
	 * shouldn't normally be necessary as code is supposed to check the
	 * condition before waiting for the latch, but a bit care can't hurt.
	 */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SwitchBackToLocalLatch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyLatch</name> <operator>!=</operator> <operator>&amp;</operator><name>LocalLatchData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>MyLatch</name> <operator>==</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>MyLatch</name> <operator>=</operator> <operator>&amp;</operator><name>LocalLatchData</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>FeBeWaitSet</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ModifyWaitEvent</name><argument_list>(<argument><expr><name>FeBeWaitSet</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetUserId - get the current effective user ID.
 *
 * Note: there's no SetUserId() anymore; use SetUserIdAndSecContext().
 */</comment>
<function><type><name>Oid</name></type>
<name>GetUserId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>CurrentUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>CurrentUserId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetOuterUserId/SetOuterUserId - get/set the outer-level user ID.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetOuterUserId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>OuterUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>OuterUserId</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetOuterUserId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name>SecurityRestrictionContext</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>OuterUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>

	<comment type="block">/* We force the effective user ID to match, too */</comment>
	<expr_stmt><expr><name>CurrentUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetSessionUserId/SetSessionUserId - get/set the session user ID.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetSessionUserId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>SessionUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SessionUserId</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>SetSessionUserId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_superuser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name>SecurityRestrictionContext</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>SessionUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SessionUserIsSuperuser</name> <operator>=</operator> <name>is_superuser</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SetRoleIsActive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* We force the effective user IDs to match, too */</comment>
	<expr_stmt><expr><name>OuterUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetAuthenticatedUserId - get the authenticated user ID
 */</comment>
<function><type><name>Oid</name></type>
<name>GetAuthenticatedUserId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>AuthenticatedUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>AuthenticatedUserId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetUserIdAndSecContext/SetUserIdAndSecContext - get/set the current user ID
 * and the SecurityRestrictionContext flags.
 *
 * Currently there are three valid bits in SecurityRestrictionContext:
 *
 * SECURITY_LOCAL_USERID_CHANGE indicates that we are inside an operation
 * that is temporarily changing CurrentUserId via these functions.  This is
 * needed to indicate that the actual value of CurrentUserId is not in sync
 * with guc.c's internal state, so SET ROLE has to be disallowed.
 *
 * SECURITY_RESTRICTED_OPERATION indicates that we are inside an operation
 * that does not wish to trust called user-defined functions at all.  This
 * bit prevents not only SET ROLE, but various other changes of session state
 * that normally is unprotected but might possibly be used to subvert the
 * calling session later.  An example is replacing an existing prepared
 * statement with new code, which will then be executed with the outer
 * session's permissions when the prepared statement is next used.  Since
 * these restrictions are fairly draconian, we apply them only in contexts
 * where the called functions are really supposed to be side-effect-free
 * anyway, such as VACUUM/ANALYZE/REINDEX.
 *
 * SECURITY_NOFORCE_RLS indicates that we are inside an operation which should
 * ignore the FORCE ROW LEVEL SECURITY per-table indication.  This is used to
 * ensure that FORCE RLS does not mistakenly break referential integrity
 * checks.  Note that this is intentionally only checked when running as the
 * owner of the table (which should always be the case for referential
 * integrity checks).
 *
 * Unlike GetUserId, GetUserIdAndSecContext does *not* Assert that the current
 * value of CurrentUserId is valid; nor does SetUserIdAndSecContext require
 * the new value to be valid.  In fact, these routines had better not
 * ever throw any kind of error.  This is because they are used by
 * StartTransaction and AbortTransaction to save/restore the settings,
 * and during the first transaction within a backend, the value to be saved
 * and perhaps restored is indeed invalid.  We have to be able to get
 * through AbortTransaction without asserting in case InitPostgres fails.
 */</comment>
<function><type><name>void</name></type>
<name>GetUserIdAndSecContext</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>userid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sec_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>userid</name> <operator>=</operator> <name>CurrentUserId</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>sec_context</name> <operator>=</operator> <name>SecurityRestrictionContext</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SetUserIdAndSecContext</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sec_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>CurrentUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SecurityRestrictionContext</name> <operator>=</operator> <name>sec_context</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InLocalUserIdChange - are we inside a local change of CurrentUserId?
 */</comment>
<function><type><name>bool</name></type>
<name>InLocalUserIdChange</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>SecurityRestrictionContext</name> <operator>&amp;</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InSecurityRestrictedOperation - are we inside a security-restricted command?
 */</comment>
<function><type><name>bool</name></type>
<name>InSecurityRestrictedOperation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>SecurityRestrictionContext</name> <operator>&amp;</operator> <name>SECURITY_RESTRICTED_OPERATION</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InNoForceRLSOperation - are we ignoring FORCE ROW LEVEL SECURITY ?
 */</comment>
<function><type><name>bool</name></type>
<name>InNoForceRLSOperation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>SecurityRestrictionContext</name> <operator>&amp;</operator> <name>SECURITY_NOFORCE_RLS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * These are obsolete versions of Get/SetUserIdAndSecContext that are
 * only provided for bug-compatibility with some rather dubious code in
 * pljava.  We allow the userid to be set, but only when not inside a
 * security restriction context.
 */</comment>
<function><type><name>void</name></type>
<name>GetUserIdAndContext</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>userid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>sec_def_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>userid</name> <operator>=</operator> <name>CurrentUserId</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>sec_def_context</name> <operator>=</operator> <call><name>InLocalUserIdChange</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SetUserIdAndContext</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sec_def_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We throw the same error SET ROLE would. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>InSecurityRestrictedOperation</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set parameter \"%s\" within security-restricted operation"</literal></expr></argument>,
						<argument><expr><literal type="string">"role"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>CurrentUserId</name> <operator>=</operator> <name>userid</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sec_def_context</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>SecurityRestrictionContext</name> <operator>|=</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>SecurityRestrictionContext</name> <operator>&amp;=</operator> <operator>~</operator><name>SECURITY_LOCAL_USERID_CHANGE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether specified role has explicit REPLICATION privilege
 */</comment>
<function><type><name>bool</name></type>
<name>has_rolreplication</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>utup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>utup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rolreplication</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>utup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize user identity during normal backend startup
 */</comment>
<function><type><name>void</name></type>
<name>InitializeSessionUserId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rolename</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>roleTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_authid</name></type> <name>rform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rname</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't do scans if we're bootstrapping, none of the system catalogs
	 * exist yet, and they should be owned by postgres anyway.
	 */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* call only once */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>AuthenticatedUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rolename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>roleTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHNAME</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>rolename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"role \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>rolename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>roleTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"role with OID %u does not exist"</literal></expr></argument>, <argument><expr><name>roleid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>rform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>roleid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>rform</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>AuthenticatedUserId</name> <operator>=</operator> <name>roleid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>AuthenticatedUserIsSuperuser</name> <operator>=</operator> <name><name>rform</name><operator>-&gt;</operator><name>rolsuper</name></name></expr>;</expr_stmt>

	<comment type="block">/* This sets OuterUserId/CurrentUserId too */</comment>
	<expr_stmt><expr><call><name>SetSessionUserId</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>AuthenticatedUserIsSuperuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also mark our PGPROC entry with the authenticated user id */</comment>
	<comment type="block">/* (We assume this is an atomic store so no lock is needed) */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>roleId</name></name> <operator>=</operator> <name>roleid</name></expr>;</expr_stmt>

	<comment type="block">/* POLAR: mark role is superuser? */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>issuper</name></name> <operator>=</operator> <name><name>rform</name><operator>-&gt;</operator><name>rolsuper</name></name></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * These next checks are not enforced when in standalone mode, so that
	 * there is a way to recover from sillinesses like "UPDATE pg_authid SET
	 * rolcanlogin = false;".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Is role allowed to login at all?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rform</name><operator>-&gt;</operator><name>rolcanlogin</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"role \"%s\" is not permitted to log in"</literal></expr></argument>,
							<argument><expr><name>rname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check connection limit for this role.
		 *
		 * There is a race condition here --- we create our PGPROC before
		 * checking for other PGPROCs.  If two backends did this at about the
		 * same time, they might both think they were over the limit, while
		 * ideally one should succeed and one fail.  Getting that to work
		 * exactly seems more trouble than it is worth, however; instead we
		 * just document that the connection limit is approximate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rform</name><operator>-&gt;</operator><name>rolconnlimit</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>AuthenticatedUserIsSuperuser</name> <operator>&amp;&amp;</operator>
			<call><name>CountUserBackends</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>rform</name><operator>-&gt;</operator><name>rolconnlimit</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many connections for role \"%s\""</literal></expr></argument>,
							<argument><expr><name>rname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Record username and superuser status as GUC settings too */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"session_authorization"</literal></expr></argument>, <argument><expr><name>rname</name></expr></argument>,
					<argument><expr><name>PGC_BACKEND</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"is_superuser"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><name>AuthenticatedUserIsSuperuser</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>,
					<argument><expr><name>PGC_INTERNAL</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>roleTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Initialize user identity during special backend startup
 */</comment>
<function><type><name>void</name></type>
<name>InitializeSessionUserIdStandalone</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This function should only be called in single-user mode, in autovacuum
	 * workers, and in background workers.
	 */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><operator>!</operator><name>IsUnderPostmaster</name> <operator>||</operator> <call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IsBackgroundWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* call only once */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>AuthenticatedUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>AuthenticatedUserId</name> <operator>=</operator> <name>BOOTSTRAP_SUPERUSERID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>AuthenticatedUserIsSuperuser</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetSessionUserId</name><argument_list>(<argument><expr><name>BOOTSTRAP_SUPERUSERID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Change session auth ID while running
 *
 * Only a superuser may set auth ID to something other than himself.  Note
 * that in case of multiple SETs in a single session, the original userid's
 * superuserness is what matters.  But we set the GUC variable is_superuser
 * to indicate whether the *current* session userid is a superuser.
 *
 * Note: this is not an especially clean place to do the permission check.
 * It's OK because the check does not require catalog access and can't
 * fail during an end-of-transaction GUC reversion, but we may someday
 * have to push it up into assign_session_authorization.
 */</comment>
<function><type><name>void</name></type>
<name>SetSessionAuthorization</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_superuser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Must have authenticated already, else can't make permission check */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>AuthenticatedUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: polar_superuser is allowed change session auth id who is not superuser */</comment>
	<if_stmt><if>if <condition>(<expr><name>userid</name> <operator>!=</operator> <name>AuthenticatedUserId</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>AuthenticatedUserIsSuperuser</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><call><name>polar_superuser_arg</name><argument_list>(<argument><expr><name>AuthenticatedUserId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>polar_has_more_privs_than_role</name><argument_list>(<argument><expr><name>AuthenticatedUserId</name></expr></argument>, <argument><expr><name>userid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to set session authorization"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SetSessionUserId</name><argument_list>(<argument><expr><name>userid</name></expr></argument>, <argument><expr><name>is_superuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"is_superuser"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><name>is_superuser</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>,
					<argument><expr><name>PGC_INTERNAL</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report current role id
 *		This follows the semantics of SET ROLE, ie return the outer-level ID
 *		not the current effective ID, and return InvalidOid when the setting
 *		is logically SET ROLE NONE.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetCurrentRoleId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>SetRoleIsActive</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>OuterUserId</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Change Role ID while running (SET ROLE)
 *
 * If roleid is InvalidOid, we are doing SET ROLE NONE: revert to the
 * session user authorization.  In this case the is_superuser argument
 * is ignored.
 *
 * When roleid is not InvalidOid, the caller must have checked whether
 * the session user has permission to become that role.  (We cannot check
 * here because this routine must be able to execute in a failed transaction
 * to restore a prior value of the ROLE GUC variable.)
 */</comment>
<function><type><name>void</name></type>
<name>SetCurrentRoleId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_superuser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Get correct info if it's SET ROLE NONE
	 *
	 * If SessionUserId hasn't been set yet, just do nothing --- the eventual
	 * SetSessionUserId call will fix everything.  This is needed since we
	 * will get called during GUC initialization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>SessionUserId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>roleid</name> <operator>=</operator> <name>SessionUserId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_superuser</name> <operator>=</operator> <name>SessionUserIsSuperuser</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>SetRoleIsActive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>SetRoleIsActive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>SetOuterUserId</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"is_superuser"</literal></expr></argument>,
					<argument><expr><ternary><condition><expr><name>is_superuser</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>,
					<argument><expr><name>PGC_INTERNAL</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Get user name from user oid, returns NULL for nonexistent roleid if noerr
 * is true.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetUserNameFromId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noerr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>noerr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid role OID: %u"</literal></expr></argument>, <argument><expr><name>roleid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rolname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 *				Interlock-file support
 *
 * These routines are used to create both a data-directory lockfile
 * ($DATADIR/postmaster.pid) and Unix-socket-file lockfiles ($SOCKFILE.lock).
 * Both kinds of files contain the same info initially, although we can add
 * more information to a data-directory lockfile after it's created, using
 * AddToDataDirLockFile().  See pidfile.h for documentation of the contents
 * of these lockfiles.
 *
 * On successful lockfile creation, a proc_exit callback to remove the
 * lockfile is automatically created.
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * proc_exit callback to remove lockfiles.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnlinkLockFiles</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>lock_files</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curfile</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>curfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Should we complain if the unlink fails? */</comment>
	</block_content>}</block>
	<comment type="block">/* Since we're about to exit, no need to reclaim storage */</comment>
	<expr_stmt><expr><name>lock_files</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lock file removal should always be the last externally visible action
	 * of a postmaster or standalone backend, while we won't come here at all
	 * when exiting postmaster child processes.  Therefore, this is a good
	 * place to log completion of shutdown.  We could alternatively teach
	 * proc_exit() to do it, but that seems uglier.  In a standalone backend,
	 * use NOTICE elevel to be less chatty.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>IsPostmasterEnvironment</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database system is shut down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a lockfile.
 *
 * filename is the path name of the lockfile to create.
 * amPostmaster is used to determine how to encode the output PID.
 * socketDir is the Unix socket directory path to include (possibly empty).
 * isDDLock and refName are used to determine what error message to produce.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amPostmaster</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>socketDir</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>isDDLock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>encoded_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>other_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>my_pid</name></decl>,
				<decl><type ref="prev"/><name>my_p_pid</name></decl>,
				<decl><type ref="prev"/><name>my_gp_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>envvar</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the PID in the lockfile is our own PID or our parent's or
	 * grandparent's PID, then the file must be stale (probably left over from
	 * a previous system boot cycle).  We need to check this because of the
	 * likelihood that a reboot will assign exactly the same PID as we had in
	 * the previous reboot, or one that's only one or two counts larger and
	 * hence the lockfile's PID now refers to an ancestor shell process.  We
	 * allow pg_ctl to pass down its parent shell PID (our grandparent PID)
	 * via the environment variable PG_GRANDPARENT_PID; this is so that
	 * launching the postmaster via pg_ctl can be just as reliable as
	 * launching it directly.  There is no provision for detecting
	 * further-removed ancestor processes, but if the init script is written
	 * carefully then all but the immediate parent shell will be root-owned
	 * processes and so the kill test will fail with EPERM.  Note that we
	 * cannot get a false negative this way, because an existing postmaster
	 * would surely never launch a competing postmaster or pg_ctl process
	 * directly.
	 */</comment>
	<expr_stmt><expr><name>my_pid</name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>my_p_pid</name> <operator>=</operator> <call><name>getppid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * Windows hasn't got getppid(), but doesn't need it since it's not using
	 * real kill() either...
	 */</comment>
	<expr_stmt><expr><name>my_p_pid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>envvar</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PG_GRANDPARENT_PID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>envvar</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>my_gp_pid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>envvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>my_gp_pid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We need a loop here because of race conditions.  But don't loop forever
	 * (for example, a non-writable $PGDATA directory might cause a failure
	 * that won't go away).  100 tries seems like plenty.
	 */</comment>
	<for>for <control>(<init><expr><name>ntries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>ntries</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Try to create the lock file --- O_EXCL makes this atomic.
		 *
		 * Think not to make the file protection weaker than 0600/0640.  See
		 * comments below.
		 */</comment>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* Success; exit the retry loop */</comment>

		<comment type="block">/*
		 * Couldn't create the pid file. Probably it already exists.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>errno</name> <operator>!=</operator> <name>EEXIST</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EACCES</name><operator>)</operator> <operator>||</operator> <name>ntries</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create lock file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Read the file to get the old owner's PID.  Note race condition
		 * here: file might have been deleted since we tried to create it.
		 */</comment>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* race condition; try again */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open lock file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_CREATE_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read lock file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_FILE_EXISTS</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lock file \"%s\" is empty"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Either another server is starting, or the lock file is the remnant of a previous server startup crash."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>encoded_pid</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if pid &lt; 0, the pid is for postgres, not postmaster */</comment>
		<expr_stmt><expr><name>other_pid</name> <operator>=</operator> <operator>(</operator><name>pid_t</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><name>encoded_pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>encoded_pid</name></expr> </then><else>: <expr><name>encoded_pid</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>other_pid</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"bogus data in lock file \"%s\": \"%s\""</literal></expr></argument>,
				 <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check to see if the other process still exists
		 *
		 * Per discussion above, my_pid, my_p_pid, and my_gp_pid can be
		 * ignored as false matches.
		 *
		 * Normally kill() will fail with ESRCH if the given PID doesn't
		 * exist.
		 *
		 * We can treat the EPERM-error case as okay because that error
		 * implies that the existing process has a different userid than we
		 * do, which means it cannot be a competing postmaster.  A postmaster
		 * cannot successfully attach to a data directory owned by a userid
		 * other than its own, as enforced in checkDataDir(). Also, since we
		 * create the lockfiles mode 0600/0640, we'd have failed above if the
		 * lockfile belonged to another userid --- which means that whatever
		 * process kill() is reporting about isn't the one that made the
		 * lockfile.  (NOTE: this last consideration is the only one that
		 * keeps us from blowing away a Unix socket file belonging to an
		 * instance of Postgres being run by someone else, at least on
		 * machines where /tmp hasn't got a stickybit.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>other_pid</name> <operator>!=</operator> <name>my_pid</name> <operator>&amp;&amp;</operator> <name>other_pid</name> <operator>!=</operator> <name>my_p_pid</name> <operator>&amp;&amp;</operator>
			<name>other_pid</name> <operator>!=</operator> <name>my_gp_pid</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>other_pid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<operator>(</operator><name>errno</name> <operator>!=</operator> <name>ESRCH</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EPERM</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* lockfile belongs to a live process */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_FILE_EXISTS</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lock file \"%s\" already exists"</literal></expr></argument>,
								<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><name>isDDLock</name></expr> ?</condition><then>
						 <expr><operator>(</operator><ternary><condition><expr><name>encoded_pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
						  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another postgres (PID %d) running in data directory \"%s\"?"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>other_pid</name></expr></argument>, <argument><expr><name>refName</name></expr></argument>)</argument_list></call></expr> </then><else>:
						  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another postmaster (PID %d) running in data directory \"%s\"?"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>other_pid</name></expr></argument>, <argument><expr><name>refName</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr> </then><else>:
						 <expr><operator>(</operator><ternary><condition><expr><name>encoded_pid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
						  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another postgres (PID %d) using socket file \"%s\"?"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>other_pid</name></expr></argument>, <argument><expr><name>refName</name></expr></argument>)</argument_list></call></expr> </then><else>:
						  <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another postmaster (PID %d) using socket file \"%s\"?"</literal></expr></argument>,
								  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>other_pid</name></expr></argument>, <argument><expr><name>refName</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * No, the creating process did not exist.  However, it could be that
		 * the postmaster crashed (or more likely was kill -9'd by a clueless
		 * admin) but has left orphan backends behind.  Check for this by
		 * looking to see if there is an associated shmem segment that is
		 * still in use.
		 *
		 * Note: because postmaster.pid is written in multiple steps, we might
		 * not find the shmem ID values in it; we can't treat that as an
		 * error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isDDLock</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>id1</name></decl>,
						<decl><type ref="prev"/><name>id2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>lineno</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>lineno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lineno</name> <operator>&lt;</operator> <name>LOCK_FILE_LINE_SHMEM_KEY</name></expr>;</condition> <incr><expr><name>lineno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<call><name>sscanf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"%lu %lu"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>id1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>PGSharedMemoryIsInUse</name><argument_list>(<argument><expr><name>id1</name></expr></argument>, <argument><expr><name>id2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_FILE_EXISTS</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pre-existing shared memory block (key %lu, ID %lu) is still in use"</literal></expr></argument>,
									<argument><expr><name>id1</name></expr></argument>, <argument><expr><name>id2</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Terminate any old server processes associated with data directory \"%s\"."</literal></expr></argument>,
									 <argument><expr><name>refName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Looks like nobody's home.  Unlink the file and try again to create
		 * it.  Need a loop because of possible race condition against other
		 * would-be creators.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove old lock file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The file seems accidentally left over, but "</literal>
							 <literal type="string">"it could not be removed. Please remove the file "</literal>
							 <literal type="string">"by hand and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Successfully created the file, now fill it.  See comment in pidfile.h
	 * about the contents.  Note that we write the same first five lines into
	 * both datadir and socket lockfiles; although more stuff may get added to
	 * the datadir lockfile later.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d\n%s\n%ld\n%d\n%s\n"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>amPostmaster</name></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator> <name>my_pid</name></expr> </then><else>: <expr><operator>-</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name>my_pid</name><operator>)</operator></expr></else></ternary></expr></argument>,
			 <argument><expr><name>DataDir</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>MyStartTime</name></expr></argument>,
			 <argument><expr><name>PostPortNumber</name></expr></argument>,
			 <argument><expr><name>socketDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a standalone backend, the next line (LOCK_FILE_LINE_LISTEN_ADDR)
	 * will never receive data, so fill it in as empty now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isDDLock</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>amPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcat</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_CREATE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name>save_errno</name></expr> ?</condition><then> <expr><name>save_errno</name></expr> </then><else>: <expr><name>ENOSPC</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write lock file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_CREATE_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write lock file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write lock file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Arrange to unlink the lock file(s) at proc_exit.  If this is the first
	 * one, set up the on_proc_exit function to do it; then add this lock file
	 * to the list of files to unlink.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lock_files</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>UnlinkLockFiles</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Use lcons so that the lock files are unlinked in reverse order of
	 * creation; this is critical!
	 */</comment>
	<expr_stmt><expr><name>lock_files</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lock_files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create the data directory lockfile.
 *
 * When this is called, we must have already switched the working
 * directory to DataDir, so we can just use a relative path.  This
 * helps ensure that we are locking the directory we should be.
 *
 * Note that the socket directory path line is initially written as empty.
 * postmaster.c will rewrite it upon creating the first Unix socket.
 */</comment>
<function><type><name>void</name></type>
<name>CreateDataDirLockFile</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>amPostmaster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CreateLockFile</name><argument_list>(<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>, <argument><expr><name>amPostmaster</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_create_shmem_info_file</name><argument_list>(<argument><expr><name>amPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a lockfile for the specified Unix socket file.
 */</comment>
<function><type><name>void</name></type>
<name>CreateSocketLockFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>socketfile</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amPostmaster</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>socketDir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>lockfile</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>lockfile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lockfile</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.lock"</literal></expr></argument>, <argument><expr><name>socketfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CreateLockFile</name><argument_list>(<argument><expr><name>lockfile</name></expr></argument>, <argument><expr><name>amPostmaster</name></expr></argument>, <argument><expr><name>socketDir</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>socketfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TouchSocketLockFiles -- mark socket lock files as recently accessed
 *
 * This routine should be called every so often to ensure that the socket
 * lock files have a recent mod or access date.  That saves them
 * from being removed by overenthusiastic /tmp-directory-cleaner daemons.
 * (Another reason we should never have put the socket file in /tmp...)
 */</comment>
<function><type><name>void</name></type>
<name>TouchSocketLockFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>lock_files</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>socketLockFile</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* No need to touch the data directory lock file, we trust */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>socketLockFile</name></expr></argument>, <argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * utime() is POSIX standard, utimes() is a common alternative; if we
		 * have neither, fall back to actually reading the file (which only
		 * sets the access time not mod time, but that should be enough in
		 * most cases).  In all paths, we ignore errors.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UTIME</name></cpp:ifdef>
		<expr_stmt><expr><call><name>utime</name><argument_list>(<argument><expr><name>socketLockFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !HAVE_UTIME */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UTIMES</name></cpp:ifdef>
		<expr_stmt><expr><call><name>utimes</name><argument_list>(<argument><expr><name>socketLockFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !HAVE_UTIMES */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>socketLockFile</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_UTIMES */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_UTIME */</comment>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * Add (or replace) a line in the data directory lock file.
 * The given string should not include a trailing newline.
 *
 * Note: because we don't truncate the file, if we were to rewrite a line
 * with less data than it had before, there would be garbage after the last
 * line.  While we could fix that by adding a truncate call, that would make
 * the file update non-atomic, which we'd rather avoid.  Therefore, callers
 * should endeavor never to shorten a line once it's been written.
 */</comment>
<function><type><name>void</name></type>
<name>AddToDataDirLockFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>target_line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lineno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srcptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>destptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>srcbuffer</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>destbuffer</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>srcbuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>srcbuffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>srcbuffer</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advance over lines we are not supposed to rewrite, then copy them to
	 * destbuffer.
	 */</comment>
	<expr_stmt><expr><name>srcptr</name> <operator>=</operator> <name>srcbuffer</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>lineno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lineno</name> <operator>&lt;</operator> <name>target_line</name></expr>;</condition> <incr><expr><name>lineno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>eol</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>srcptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>eol</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* not enough lines in file yet */</comment>
		<expr_stmt><expr><name>srcptr</name> <operator>=</operator> <name>eol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destbuffer</name></expr></argument>, <argument><expr><name>srcbuffer</name></expr></argument>, <argument><expr><name>srcptr</name> <operator>-</operator> <name>srcbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>destptr</name> <operator>=</operator> <name>destbuffer</name> <operator>+</operator> <operator>(</operator><name>srcptr</name> <operator>-</operator> <name>srcbuffer</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in any missing lines before the target line, in case lines are
	 * added to the file out of order.
	 */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>lineno</name> <operator>&lt;</operator> <name>target_line</name></expr>;</condition> <incr><expr><name>lineno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>destptr</name> <operator>&lt;</operator> <name>destbuffer</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>destbuffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>destptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Write or rewrite the target line.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>destbuffer</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>destbuffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>destptr</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>destptr</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are more lines in the old file, append them to destbuffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>srcptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>srcptr</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>srcptr</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>destbuffer</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>destbuffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>destptr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
				 <argument><expr><name>srcptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * And rewrite the data.  Since we write in a single kernel call, this
	 * update should appear atomic to onlookers.
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>destbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<operator>(</operator><name>int</name><operator>)</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>destbuffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Recheck that the data directory lock file still exists with expected
 * content.  Return true if the lock file appears OK, false if it isn't.
 *
 * We call this periodically in the postmaster.  The idea is that if the
 * lock file has been removed or replaced by another postmaster, we should
 * do a panic database shutdown.  Therefore, we should return true if there
 * is any doubt: we do not want to cause a panic shutdown unnecessarily.
 * Transient failures like EINTR or ENFILE should not cause us to fail.
 * (If there really is something wrong, we'll detect it on a future recheck.)
 */</comment>
<function><type><name>bool</name></type>
<name>RecheckDataDirLockFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>file_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><name>BLCKSZ</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There are many foreseeable false-positive error conditions.  For
		 * safety, fail only on enumerated clearly-something-is-wrong
		 * conditions.
		 */</comment>
		<switch>switch <condition>(<expr><name>errno</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ENOENT</name></expr>:</case>
			<case>case <expr><name>ENOTDIR</name></expr>:</case>
				<comment type="block">/* disaster */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			<default>default:</default>
				<comment type="block">/* non-fatal, at least for now */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m; continuing anyway"</literal></expr></argument>,
								<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>			<comment type="block">/* treat read failure as nonfatal */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>file_pid</name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file_pid</name> <operator>==</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* all is well */</comment>

	<comment type="block">/* Trouble: someone's overwritten the lock file */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lock file \"%s\" contains wrong PID: %ld instead of %ld"</literal></expr></argument>,
					<argument><expr><name>DIRECTORY_LOCK_FILE</name></expr></argument>, <argument><expr><name>file_pid</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 *				Version checking support
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Determine whether the PG_VERSION file in directory `path' indicates
 * a data version compatible with the version of this program.
 *
 * If compatible, return. Otherwise, ereport(FATAL).
 */</comment>
<function><type><name>void</name></type>
<name>ValidatePgVersion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>full_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>file_major</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>my_major</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>file_version_string</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>my_version_string</name> <init>= <expr><name>PG_VERSION</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR: FIXME not support fopen */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>my_major</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>my_version_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>full_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/PG_VERSION"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>file</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a valid data directory"</literal></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"File \"%s\" is missing."</literal></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>full_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>file_version_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fscanf</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"%63s"</literal></expr></argument>, <argument><expr><name>file_version_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>file_major</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>file_version_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>endptr</name> <operator>==</operator> <name>file_version_string</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a valid data directory"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"File \"%s\" does not contain valid data."</literal></expr></argument>,
						   <argument><expr><name>full_path</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to initdb."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>my_major</name> <operator>!=</operator> <name>file_major</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database files are incompatible with server"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The data directory was initialized by PostgreSQL version %s, "</literal>
						   <literal type="string">"which is not compatible with this version %s."</literal></expr></argument>,
						   <argument><expr><name>file_version_string</name></expr></argument>, <argument><expr><name>my_version_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------------------
 *				Library preload support
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * GUC variables: lists of library names to be preloaded at postmaster
 * start and at backend start
 */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>session_preload_libraries_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>shared_preload_libraries_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>local_preload_libraries_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Flag telling that we are loading shared_preload_libraries */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>process_shared_preload_libraries_in_progress</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR: used for shared libraries update when binary upgrade */</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>polar_internal_shared_preload_libraries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * load the shared libraries listed in 'libraries'
 *
 * 'gucname': name of GUC variable, for error reports
 * 'restricted': if true, force libraries to be in $libdir/plugins/
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_libraries</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libraries</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gucname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>restricted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>libraries</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>libraries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>libraries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of filename paths */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitDirectoriesString</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in list */</comment>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid list syntax in parameter \"%s\""</literal></expr></argument>,
						<argument><expr><name>gucname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* Note that filename was already canonicalized */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>expanded</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If restricting, insert $libdir/plugins if not mentioned already */</comment>
		<if_stmt><if>if <condition>(<expr><name>restricted</name> <operator>&amp;&amp;</operator> <call><name>first_dir_separator</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>expanded</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"$libdir/plugins/%s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>expanded</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>load_file</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>restricted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"loaded library \"%s\""</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>expanded</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * process any libraries that should be preloaded at postmaster start
 */</comment>
<function><type><name>void</name></type>
<name>process_shared_preload_libraries</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>process_shared_preload_libraries_in_progress</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: we load the internal libraries with high priority, if
	 * the internal libraries have presented in shared_preload_libraries,
	 * it doesn't matter, it allows to call load_libraries with the same
	 * library many times, load_libraries will skip to load a library
	 * which has been loaded already
	 */</comment>
	<expr_stmt><expr><call><name>load_libraries</name><argument_list>(<argument><expr><name>polar_internal_shared_preload_libraries</name></expr></argument>,
				   <argument><expr><literal type="string">"polar_internal_shared_preload_libraries"</literal></expr></argument>,
				   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>load_libraries</name><argument_list>(<argument><expr><name>shared_preload_libraries_string</name></expr></argument>,
				   <argument><expr><literal type="string">"shared_preload_libraries"</literal></expr></argument>,
				   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>process_shared_preload_libraries_in_progress</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * process any libraries that should be preloaded at backend start
 */</comment>
<function><type><name>void</name></type>
<name>process_session_preload_libraries</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>load_libraries</name><argument_list>(<argument><expr><name>session_preload_libraries_string</name></expr></argument>,
				   <argument><expr><literal type="string">"session_preload_libraries"</literal></expr></argument>,
				   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>load_libraries</name><argument_list>(<argument><expr><name>local_preload_libraries_string</name></expr></argument>,
				   <argument><expr><literal type="string">"local_preload_libraries"</literal></expr></argument>,
				   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pg_bindtextdomain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_NLS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>my_exec_path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>locale_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_locale_path</name><argument_list>(<argument><expr><name>my_exec_path</name></expr></argument>, <argument><expr><name>locale_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bindtextdomain</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><name>locale_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_bind_textdomain_codeset</name><argument_list>(<argument><expr><name>domain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/* POLAR: set base dir in shared storage */</comment>
<function><type><name>void</name></type>
<name>polar_set_database_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This should happen only once per process */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>polar_database_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>polar_database_path</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Remove all subdirectories and files in a directory
 */</comment>
<function><type><name>void</name></type>
<name>polar_remove_file_in_dir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>          <name><name>rm_path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type>   <name>statbuf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
			        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>rm_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* recursively remove contents, then directory itself */</comment>
			<expr_stmt><expr><call><name>polar_remove_file_in_dir</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>rmdir</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>rm_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>rm_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: judge whether the gap between replica's latest redoPtr and master's latest redoPtr exceeds the size specified
 * return true when 1)the gap exceeds the size, 2)local pg_control file doesn't exists, 3) redoPtr of master &lt; redoPtr of replica
 * return false when the gap is within the size
 */</comment>
<function><type><name>bool</name></type>
<name>polar_replica_behind_exceed_size</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>polar_control_file_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ControlFileData</name> <modifier>*</modifier></type><name>controlfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>local_redo</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>  <name>shared_redo</name> <init>= <expr><name>InvalidXLogRecPtr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>saved_errno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_enable_shared_storage_mode</name> <operator>||</operator> <operator>!</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name>controlfile</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: open and check local pg_control file */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>polar_control_file_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>polar_read_control_file</name><argument_list>(<argument><expr><name>polar_control_file_path</name></expr></argument>, <argument><expr><name>controlfile</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: return true when local pg_control file doesn't exist, need to copy it from shared storage */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>false</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>saved_errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>controlfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* POLAR: get redoPtr of local pg_control file */</comment>
		<expr_stmt><expr><name>local_redo</name> <operator>=</operator> <name><name>controlfile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* POLAR: open and check pg_control file in shared storage */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>controlfile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ControlFileData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>polar_control_file_path</name></expr></argument>, <argument><expr><name>XLOG_CONTROL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>polar_read_control_file</name><argument_list>(<argument><expr><name>polar_control_file_path</name></expr></argument>, <argument><expr><name>controlfile</name></expr></argument>, <argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saved_errno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* POLAR: get redoPtr of shared pg_control file */</comment>
		<expr_stmt><expr><name>shared_redo</name> <operator>=</operator> <name><name>controlfile</name><operator>-&gt;</operator><name>checkPointCopy</name><operator>.</operator><name>redo</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>controlfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"shared_redo:%lX, local_redo:%lX"</literal></expr></argument>, <argument><expr><name>shared_redo</name></expr></argument>, <argument><expr><name>local_redo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: shared_redo maybe smaller than local_redo when in backup and recovery scene, need to copy it from shared storage */</comment>
	<if_stmt><if>if <condition>(<expr><name>shared_redo</name> <operator>&lt;</operator> <name>local_redo</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"redoPtr of pg_control in shared storage is smaller than that in local"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>shared_redo</name> <operator>-</operator> <name>local_redo</name> <operator>&gt;</operator> <name>size</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: judge whether it is needed for replica to copy base dirs and other trans status log files 
 * from shared storage to local, only do the copy process when this func return true
 * return true when: 
 * 1) first boot after initdb or demote from a primary
 * 2) polar_replica_redo_gap_limit is 0, which means the judgement is disabled
 * 3) the gap between replica's latest redoPtr and master's latest redoPtr exceeds the size specified
 */</comment>
<function><type><name>bool</name></type>
<name>polar_need_copy_local_dir_for_replica</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>	   <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_enable_shared_storage_mode</name> <operator>||</operator> <operator>!</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		
	<comment type="block">/* 
	 * POLAR: return true when POLAR_REPLICA_BOOTED_FILE doesn't exist regardless of the redoptr gap
	 * which indicates it is the first time for replica node to boot after initdb or demote from a primary
	 * and create POLAR_REPLICA_BOOTED_FILE file after copy process is executed successfully
	 * so that next time we could judge whether to execute copy process depend on the redoptr gap
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>path</name><operator>)</operator></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>, <argument><expr><name>POLAR_REPLICA_BOOTED_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* POLAR: set replica_update_dirs_by_redo as FALSE, which means we need update dirs by copy */</comment>
		<expr_stmt><expr><call><name>polar_set_replica_update_dirs_by_redo</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* 
	 * POLAR: return true when 1)polar_replica_redo_gap_limit is 0, which means the comparison is disabled
	 * 2) the gap exceeds polar_replica_redo_gap_limit, polar_replica_redo_gap_limit unit is KB
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_replica_redo_gap_limit</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>polar_replica_behind_exceed_size</name><argument_list>(<argument><expr><name>polar_replica_redo_gap_limit</name> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* 
		 * POLAR: set replica_update_dirs_by_redo as FALSE
		 * so that startup process can copy local dirs for replica after postmaster process 
		 * copy pg_control file form shared storage to local, otherwise startup process will skip the copy process
		 * because the gap is 0 after pg_control file is copied
		 */</comment>
		<expr_stmt><expr><call><name>polar_set_replica_update_dirs_by_redo</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>polar_set_replica_update_dirs_by_redo</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: copy base dirs and other trans status log files from shared storage to local for replica
 * called by startup process
 */</comment> 
<function><type><name>void</name></type>
<name>polar_copy_dirs_from_shared_storage_to_local</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>dirs_to_copy</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"pg_csnlog"</literal></expr>, <expr><literal type="string">"pg_twophase"</literal></expr>, <expr><literal type="string">"pg_xact"</literal></expr>, <expr><literal type="string">"pg_commit_ts"</literal></expr>, <expr><literal type="string">"pg_multixact"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><literal type="string">"base"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>cur_dir</name> <init>= <expr><name>dirs_to_copy</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>ss_path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>to_path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>read_dir_err</name></decl>;</decl_stmt>

	<comment type="block">/* For base directory, copy the new files from shared storage */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>S_IRWXU</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>EEXIST</name> <operator>!=</operator> <name>errno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
			        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Copy base subdirectories to local */</comment>
	<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>ss_path</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For polar store, the readdir will cache a dir entry, if the dir is deleted
	 * when readdir, it will fail. So we should retry.
	 */</comment>
<label><name>read_dir_failed</name>:</label>

	<expr_stmt><expr><name>read_dir_err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>polar_allocate_dir</name><argument_list>(<argument><expr><name>ss_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
			        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>ss_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>polar_read_dir_ext</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>ss_path</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>read_dir_err</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>

		<comment type="block">/* If we got a cancel signal during the copy of the directory, quit */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>to_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>to_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>ss_path</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>ss_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* May be deleted after ReadDir */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
			        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>ss_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Skip it, continue to deal with other directories */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>fst</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If it is nonexistent, create one, if has error, skip it */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>S_IRWXU</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>EEXIST</name> <operator>!=</operator> <name>errno</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
				     <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>to_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>read_dir_err</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"When readdir, some entries were deleted, retry."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>read_dir_failed</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Copy other trans status log files */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>cur_dir</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>skip_open_dir_err</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* 
		 * POLAR csn
		 * When hot upgrade to csn version, old rw instance has no csnlog directory,
		 * we set skip_dir_err to true when copy csnlog in replica mode
	     */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>*</operator><name>cur_dir</name></expr></argument>, <argument><expr><literal type="string">"pg_csnlog"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>skip_open_dir_err</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Copy files from shared storage to local. */</comment>
		<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>ss_path</name></expr></argument>, <argument><expr><operator>*</operator><name>cur_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_copydir</name><argument_list>(<argument><expr><name>ss_path</name></expr></argument>, <argument><expr><operator>*</operator><name>cur_dir</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>skip_open_dir_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur_dir</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* 
	 * POLAR: create the polar_replica_booted file after copy process is done successfully
	 * so that we can copy relevant dirs at next boot time if the previous copy process failed
	 */</comment>
	<expr_stmt><expr><call><name>polar_create_replica_booted_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Initialize the local directories
 * for primary and standby, remove local cache file
 * for replica, if replica doesn't update local dirs by redo, which occurs when 
 * 1) the gap between replica's latest redoPtr and vmaster's latest redoPtr exceeds polar_replica_redo_gap_limit
 * 2) replica node is newly created or demoted from a master node
 * then remove local cache file and copy them from shared storage to local, execute this copy process 
 * in startup process so that postmaster can respond to the detection of cm timely
 */</comment>
<function><type><name>void</name></type>
<name>polar_init_local_dir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <name>polar_enable_shared_storage_mode</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_replica_update_dirs_by_redo</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_remove_local_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"copy dirs from shared storage to local for replica"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>polar_copy_dirs_from_shared_storage_to_local</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: copy pg_control file from shared storage to local for replica or standby
 * for standby, maintain local copy of control file to ensure promote
 * can be triggered successfully.
 */</comment>
<function><type><name>void</name></type> <name>polar_copy_pg_control_from_shared_storage_to_local</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>global</name> <init>= <expr><literal type="string">"global"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>control</name> <init>= <expr><literal type="string">"pg_control"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>ss_path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>to_path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* For global directory, if exists, clean it and copy the pg_control file */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>global</name></expr></argument>, <argument><expr><name>S_IRWXU</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>EEXIST</name> <operator>==</operator> <name>errno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_remove_file_in_dir</name><argument_list>(<argument><expr><name>global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": %m"</literal></expr></argument>, <argument><expr><name>global</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Copy the pg_control file */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>to_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>to_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>global</name></expr></argument>, <argument><expr><name>control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_make_file_path_level2</name><argument_list>(<argument><expr><name>ss_path</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_copy_file</name><argument_list>(<argument><expr><name>ss_path</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Initialize the local global directories for replica or standby node
 * copy pg_control file from shared storage to local, called by postmaster
 * 
 * for replica, only copy when 1)the gap between replica's latest redoPtr and 
 * master's latest redoPtr exceeds polar_replica_redo_gap_limit
 * 2) replica node is newly created or demoted from a master node
 */</comment>
<function><type><name>void</name></type>
<name>polar_init_global_dir_for_replica_or_standby</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name>
		<operator>&amp;&amp;</operator> <name>polar_enable_shared_storage_mode</name>
		<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>polar_need_copy_local_dir_for_replica</name><argument_list>()</argument_list></call><operator>)</operator>
			 <operator>||</operator> <call><name>polar_is_standby</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"copy pg_control file from shared storage to local"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_copy_pg_control_from_shared_storage_to_local</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * POLAR: create the POLAR_REPLICA_BOOTED_FILE file so that we could judge whether to execute copy dirs process 
 * depend on the redoptr gap next time when replica starts
 */</comment>
<function><type><name>void</name></type>
<name>polar_create_replica_booted_file</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	   <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		   <name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>path</name><operator>)</operator></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>, <argument><expr><name>POLAR_REPLICA_BOOTED_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_open_transient_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create file \"%s\": %m, local dir initialization will be executed next time when replica start regardless of the redoptr gap "</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"create file \"%s\""</literal></expr></argument>, <argument><expr><name>POLAR_REPLICA_BOOTED_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: detele POLAR_REPLICA_BOOTED_FILE if current node is not replica 
 * so that we can execute local dir initilization when master demote to a replica
 */</comment>
<function><type><name>void</name></type>
<name>polar_remove_replica_booted_file</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	   <name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>path</name><operator>)</operator></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>, <argument><expr><name>POLAR_REPLICA_BOOTED_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"remove file \"%s\""</literal></expr></argument>, <argument><expr><name>POLAR_REPLICA_BOOTED_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Create file to store polar persisted shared memory key and ID,
 * like CreateLockFile.
 */</comment>
<function><type><name>void</name></type>
<name>polar_create_shmem_info_file</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>am_postmaster</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>		<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>ntries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>key</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolarShmemFileStatus</name></type> <name>status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_postmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>polar_enable_persisted_buffer_pool</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_remove_old_shmem_info_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>ntries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>ntries</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Couldn't create the shmem file. Probably it already exists. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>errno</name> <operator>!=</operator> <name>EEXIST</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EACCES</name><operator>)</operator> <operator>||</operator> <name>ntries</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
						<argument><expr><literal type="string">"could not create polar persisted shmem file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>polar_shmem_file_status</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>SHMEM_FILE_NOT_EXIST</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>SHMEM_FILE_SHM_IN_USE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				 <argument><expr><literal type="string">"pre-existing polar shared memory block (key %lu, ID %lu) is still in use."</literal></expr></argument>,
				 <argument><expr><name>key</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>polar_shmem_file_exists</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				 <argument><expr><literal type="string">"polar shmem file %s (key %lu, ID %lu) already exists, try to reuse it."</literal></expr></argument>,
				 <argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We do not unlink the lock file(s) at proc_exit. So do not add this file
	 * to lock_files.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Store polar shmem key and ID in a separate file. We will check it
 * when reuse the shared memory. We always cover the old content.
 */</comment>
<function><type><name>void</name></type>
<name>polar_write_shmem_info_to_file</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>		<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>str</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%9lu %9lu\n"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
					<argument><expr><literal type="string">"could not open polar shmem file \"%s\": %m"</literal></expr></argument>,
					<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<operator>(</operator><name>int</name><operator>)</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
					<argument><expr><literal type="string">"could not write to polar shmem file \"%s\": %m"</literal></expr></argument>,
					<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
					<argument><expr><literal type="string">"could not writer to polar shmem file \"%s\": %m"</literal></expr></argument>,
					<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
					<argument><expr><literal type="string">"could not write to polar shmem file \"%s\": %m"</literal></expr></argument>,
					<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Write polar shmem info (key %lu, ID %lu) to file."</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Read shmem key and ID from the file. If skip_enoent is true, we return
 * false when the file does not exist.
 */</comment>
<function><type><name>PolarShmemFileStatus</name></type>
<name>polar_read_shmem_info_from_file</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
								<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>skip_enoent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>		<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>buffer</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><name>pg_file_create_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <name>skip_enoent</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>SHMEM_FILE_NOT_EXIST</name></expr>;</return></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
						<argument><expr><literal type="string">"could not open polar shmem file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
					<argument><expr><literal type="string">"count not read polar shmem file \"%s\": %m"</literal></expr></argument>,
					<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(
					<argument><expr><literal type="string">"could not read from polar shmem file \"%s\": %m"</literal></expr></argument>,
					<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%lu %lu"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SHMEM_FILE_VALID</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>SHMEM_FILE_INVALID</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PolarShmemFileStatus</name></type>
<name>polar_shmem_file_status</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolarShmemFileStatus</name></type> <name>status</name> <init>= <expr><call><name>polar_read_shmem_info_from_file</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>SHMEM_FILE_VALID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * POLAR: Already read valid shared memory key and ID from file, now
	 * check if it can be reused.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PGSharedMemoryIsInUse</name><argument_list>(<argument><expr><operator>*</operator><name>key</name></expr></argument>, <argument><expr><operator>*</operator><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SHMEM_FILE_SHM_IN_USE</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>SHMEM_FILE_SHM_NOT_IN_USE</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check if polar shmem info file exists, if yes, try to delete the
 * shared memory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_remove_old_shmem_info_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolarShmemFileStatus</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>key</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>polar_shmem_file_status</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>SHMEM_FILE_NOT_EXIST</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>SHMEM_FILE_SHM_IN_USE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			 <argument><expr><literal type="string">"pre-existing polar shared memory block (key %lu, ID %lu) is still in use."</literal></expr></argument>,
			 <argument><expr><name>key</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_shmem_file_exists</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Delete shared memory and delete file. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>polar_delete_shmem</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove old shmem file \"%s\": %m"</literal></expr></argument>,
								   <argument><expr><name>POLAR_SHMEM_FILE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(
								<argument><expr><literal type="string">"The file seems accidentally left over, but "</literal>
								<literal type="string">"it could not be removed. Please remove the file "</literal>
								<literal type="string">"by hand and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				 <argument><expr><literal type="string">"Delete polar persisted shared memory (key %lu, ID %lu) and remove old polar shmem info file."</literal></expr></argument>,
				 <argument><expr><name>key</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				 <argument><expr><literal type="string">"polar shared memory can not be deleted. Please delete it by hand and try again. key %lu ID %lu"</literal></expr></argument>,
				 <argument><expr><name>key</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px
 * get AuthenticatedUserIsSuperuser
 */</comment>
<function><type><name>bool</name></type>
<name>px_authenticated_user_is_superuser</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>AuthenticatedUserId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>AuthenticatedUserIsSuperuser</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR: remove local cache */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_remove_local_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_remove_clog_local_cache_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_remove_commit_ts_local_cache_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_remove_multixcat_local_cache_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_remove_csnlog_local_cache_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function></unit>
