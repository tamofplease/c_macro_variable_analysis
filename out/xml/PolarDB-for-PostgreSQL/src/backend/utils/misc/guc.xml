<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/misc/guc.c"><comment type="block">/*--------------------------------------------------------------------
 * guc.c
 *
 * Support for grand unified configuration scheme, including SET
 * command, configuration file, and command line options.
 * See src/backend/utils/misc/README for more information.
 *
 *
 * Copyright (c) 2000-2018, PostgreSQL Global Development Group
 * Written by Peter Eisentraut &lt;peter_e@gmx.net&gt;.
 *
 * IDENTIFICATION
 *	  src/backend/utils/misc/guc.c
 *
 *--------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;syslog.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/rmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/geqo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/syslogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/walwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicallauncher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/syncrep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/encryption.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm_impl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/kmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/large_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/bytea.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/plancache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tzparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/xml.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_async_ddl_lock_replay.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/polar_queue_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/subtrans.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/username.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_flashback/polar_flashback_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/polar_priority_replication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_io_stat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/replnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/s_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"polar_dma/polar_dma.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_KRB_SRVTAB</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_KRB_SRVTAB</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONFIG_FILENAME</name></cpp:macro> <cpp:value>"postgresql.conf"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HBA_FILENAME</name></cpp:macro>	<cpp:value>"pg_hba.conf"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IDENT_FILENAME</name></cpp:macro>	<cpp:value>"pg_ident.conf"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_DMA_FILENAME</name></cpp:macro>	<cpp:value>"polar_dma.conf"</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONFIG_EXEC_PARAMS</name></cpp:macro> <cpp:value>"global/config_exec_params"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONFIG_EXEC_PARAMS_NEW</name></cpp:macro> <cpp:value>"global/config_exec_params.new"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Precision with which REAL type guc values are to be printed for GUC
 * serialization.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REALTYPE_PRECISION</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define>


<comment type="block">/* XXX these should appear in other modules' header files */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>Log_disconnections</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>	<name>CommitDelay</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>	<name>CommitSiblings</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>default_tablespace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>temp_tablespaces</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>ignore_checksum_failure</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>synchronize_seqscans</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SYNCSCAN</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>trace_syncscan</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_BOUNDED_SORT</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>optimize_bounded_sort</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>GUC_check_errcode_value</name></decl>;</decl_stmt>

<comment type="block">/* global variables for check hook support */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>GUC_check_errmsg_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>GUC_check_errdetail_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>GUC_check_errhint_string</name></decl>;</decl_stmt>

<comment type="block">/* POLAR GUCS */</comment>
<decl_stmt><decl><type><name>bool</name></type>           <name>polar_force_unlogged_to_logged_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>           <name>polar_allow_huge_alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_suppress_preload_error</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>           <name>polar_hold_truncate_interrupt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 		   <name>polar_replay_fpi_check_lsn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>           <name>polar_enable_localfs_test_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 			<name>polar_enable_ro_prewarm</name></decl>;</decl_stmt>

<comment type="block">/* polar_realease_date, format:YYYYMMDD */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>polar_release_date</name></decl>;</decl_stmt>
<comment type="block">/* polar_version, format:1.1.0 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>polar_version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>           <name>polar_enable_polar_superuser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>           <name>polar_apply_global_guc_for_super</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>      <modifier>*</modifier></type><name>polar_available_extensions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>      <modifier>*</modifier></type><name>polar_forbidden_extensions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>      <modifier>*</modifier></type><name>polar_supported_extensions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>      <modifier>*</modifier></type><name>polar_internal_allowed_extensions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier></type><name>polar_internal_allowed_roles</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>                   <name>polar_force_trans_ro_non_sup</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>                    <name>polar_max_non_super_conns</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>                    <name>polar_max_super_conns</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>                    <name>polar_reserved_polar_super_conns</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 	<name>polar_dma_max_standby_wait_delay_size_mb</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR */</comment>
<decl_stmt><decl><type><name>double</name></type>	<name>polar_max_normal_backends_factor</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>polar_virtual_pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>polar_cancel_key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_delay_dml_option</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_primary_dml_delay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_delay_dml_lsn_lag_threshold</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_shutdown_walsnd_wait_non_super</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_shutdown_walsnd_wait_replication_kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_temp_relation_file_in_shared_storage</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_enable_convert_or_to_union_all</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 		<name>polar_publish_via_partition_root</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>polar_partition_recursive_reloptions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR: GUC variable for audit log */</comment>
<decl_stmt><decl><type><name>bool</name></type> 		<name>polar_enable_audit_log_bind_sql_parameter</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 		<name>polar_enable_audit_log_bind_sql_parameter_new</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_enable_replica_use_smgr_cache</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 		<name>polar_enable_standby_use_smgr_cache</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_nblocks_cache_mode</name></decl>;</decl_stmt>

<comment type="block">/* auto cascade extensions */</comment>
<decl_stmt><decl><type><name>char</name>      <modifier>*</modifier></type><name>polar_auto_cascade_extensions</name></decl>;</decl_stmt>

<comment type="block">/* POLAR: timeout for sync replication */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_sync_replication_timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_sync_rep_timeout_break_lsn_lag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_semi_sync_observation_window</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_semi_sync_max_backoff_window</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_semi_sync_min_backoff_window</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_enable_semi_sync_optimization</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>polar_enable_flashback_drop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR: gap limit between local redoptr and shared redoptr for replica */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_replica_redo_gap_limit</name></decl>;</decl_stmt>

<comment type="block">/* POLAR: Crash recovery RTO */</comment>
<decl_stmt><decl><type><name>double</name></type> 		<name>polar_crash_recovery_rto_threshold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_crash_recovery_rto</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_crash_recovery_rto_delay_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_io_read_throughtput_userset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 		<name>polar_crash_recovery_rto_statistics_count</name></decl>;</decl_stmt>

<comment type="block">/* POLAR: Btree build page buffer count */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>polar_bt_write_page_buffer_size</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_serialize</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>destptr</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>maxbytes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>3<operator>,</operator> 4</function_decl>)<empty_stmt>;</empty_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_config_sourcefile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourcefile</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>sourceline</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>call_bool_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>call_int_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>,
					<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>call_real_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>call_string_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>,
					   <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>call_enum_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_log_destination</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_log_destination</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_wal_consistency_checking</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
							   <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_wal_consistency_checking</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>syslog_facility</name> <init>= <expr><name>LOG_LOCAL0</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>syslog_facility</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_syslog_facility</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_syslog_ident</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_session_replication_role</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_client_min_messages</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_temp_buffers</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_bonjour</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_ssl</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_stage_log_stats</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_log_stats</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_canonical_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_timezone_abbreviations</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_timezone_abbreviations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pg_timezone_abbrev_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_archive_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_tcp_keepalives_idle</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_tcp_keepalives_interval</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_tcp_keepalives_count</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_tcp_keepalives_idle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_tcp_keepalives_interval</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_tcp_keepalives_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_maxconnections</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_max_worker_processes</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_autovacuum_max_workers</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_autovacuum_work_mem</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_effective_io_concurrency</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_effective_io_concurrency</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_pgstat_temp_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_application_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_application_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_cluster_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_unix_socket_permissions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_log_file_mode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_data_directory_mode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR px */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_assign_max_normal_backends</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Private functions in guc-file.l that need to be called from guc.c */</comment>
<function_decl><type><specifier>static</specifier> <name>ConfigVariable</name> <modifier>*</modifier></type><name>ProcessConfigFileInternal</name><parameter_list>(<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>applySettings</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR: Private functions in guc-file.l that need to be called from guc.c */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_process_polar_node_static_config_internal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR: for security definer function */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_verify_list_syntax</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>liststring</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_polar_forbidden_functions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_polar_forbidden_functions</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_polar_supported_extensions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_polar_available_extensions</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_polar_allowed_roles</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_session_preload_libs</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_polar_rename_wal_ready_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_check_internal_shared_preload_libraries</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_check_nblocks_cache_mode</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_check_recursive_reloptions</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_assign_recursive_reloptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_assign_virtual_pid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_assign_cancel_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>polar_show_max_connections</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_high_priority_replication_standby_names</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_low_priority_replication_standby_names</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_check_xact_split_xids</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_assign_xact_split_wait_lsn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_assign_crash_recovery_rto</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_assign_crash_recovery_rto_threshold</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_assign_crash_recovery_rto_delay_time</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_check_enable_lazy_checkpoint</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_check_enable_full_page_writes</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Options for enum values defined in this module.
 *
 * NOTE! Option values may not contain double quotes!
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>bytea_output_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"escape"</literal></expr>, <expr><name>BYTEA_OUTPUT_ESCAPE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"hex"</literal></expr>, <expr><name>BYTEA_OUTPUT_HEX</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * We have different sets for client and server message level options because
 * they sort slightly different (see "log" level)
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>client_message_level_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug5"</literal></expr>, <expr><name>DEBUG5</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug4"</literal></expr>, <expr><name>DEBUG4</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug3"</literal></expr>, <expr><name>DEBUG3</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug2"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug1"</literal></expr>, <expr><name>DEBUG1</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"log"</literal></expr>, <expr><name>LOG</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"info"</literal></expr>, <expr><name>INFO</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"notice"</literal></expr>, <expr><name>NOTICE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"warning"</literal></expr>, <expr><name>WARNING</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"error"</literal></expr>, <expr><name>ERROR</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"fatal"</literal></expr>, <expr><name>FATAL</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"panic"</literal></expr>, <expr><name>PANIC</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>server_message_level_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug5"</literal></expr>, <expr><name>DEBUG5</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug4"</literal></expr>, <expr><name>DEBUG4</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug3"</literal></expr>, <expr><name>DEBUG3</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug2"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug1"</literal></expr>, <expr><name>DEBUG1</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"info"</literal></expr>, <expr><name>INFO</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"notice"</literal></expr>, <expr><name>NOTICE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"warning"</literal></expr>, <expr><name>WARNING</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"error"</literal></expr>, <expr><name>ERROR</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"log"</literal></expr>, <expr><name>LOG</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"fatal"</literal></expr>, <expr><name>FATAL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"panic"</literal></expr>, <expr><name>PANIC</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>polar_save_stack_info_level_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"error"</literal></expr>, <expr><name>ERROR</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"fatal"</literal></expr>, <expr><name>FATAL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"panic"</literal></expr>, <expr><name>PANIC</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"none"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>intervalstyle_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"postgres"</literal></expr>, <expr><name>INTSTYLE_POSTGRES</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"postgres_verbose"</literal></expr>, <expr><name>INTSTYLE_POSTGRES_VERBOSE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"sql_standard"</literal></expr>, <expr><name>INTSTYLE_SQL_STANDARD</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"iso_8601"</literal></expr>, <expr><name>INTSTYLE_ISO_8601</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>log_error_verbosity_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"terse"</literal></expr>, <expr><name>PGERROR_TERSE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"default"</literal></expr>, <expr><name>PGERROR_DEFAULT</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"verbose"</literal></expr>, <expr><name>PGERROR_VERBOSE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>log_statement_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"none"</literal></expr>, <expr><name>LOGSTMT_NONE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ddl"</literal></expr>, <expr><name>LOGSTMT_DDL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"mod"</literal></expr>, <expr><name>LOGSTMT_MOD</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"all"</literal></expr>, <expr><name>LOGSTMT_ALL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>isolation_level_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"serializable"</literal></expr>, <expr><name>XACT_SERIALIZABLE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"repeatable read"</literal></expr>, <expr><name>XACT_REPEATABLE_READ</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"read committed"</literal></expr>, <expr><name>XACT_READ_COMMITTED</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"read uncommitted"</literal></expr>, <expr><name>XACT_READ_UNCOMMITTED</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>session_replication_role_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"origin"</literal></expr>, <expr><name>SESSION_REPLICATION_ROLE_ORIGIN</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"replica"</literal></expr>, <expr><name>SESSION_REPLICATION_ROLE_REPLICA</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local"</literal></expr>, <expr><name>SESSION_REPLICATION_ROLE_LOCAL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>syslog_facility_options</name><index>[]</index></name> <init>= <expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"local0"</literal></expr>, <expr><name>LOG_LOCAL0</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local1"</literal></expr>, <expr><name>LOG_LOCAL1</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local2"</literal></expr>, <expr><name>LOG_LOCAL2</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local3"</literal></expr>, <expr><name>LOG_LOCAL3</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local4"</literal></expr>, <expr><name>LOG_LOCAL4</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local5"</literal></expr>, <expr><name>LOG_LOCAL5</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local6"</literal></expr>, <expr><name>LOG_LOCAL6</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local7"</literal></expr>, <expr><name>LOG_LOCAL7</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr><block>{<expr><literal type="string">"none"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>track_function_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"none"</literal></expr>, <expr><name>TRACK_FUNC_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"pl"</literal></expr>, <expr><name>TRACK_FUNC_PL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"all"</literal></expr>, <expr><name>TRACK_FUNC_ALL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>xmlbinary_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"base64"</literal></expr>, <expr><name>XMLBINARY_BASE64</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"hex"</literal></expr>, <expr><name>XMLBINARY_HEX</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>xmloption_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"content"</literal></expr>, <expr><name>XMLOPTION_CONTENT</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"document"</literal></expr>, <expr><name>XMLOPTION_DOCUMENT</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Although only "on", "off", and "safe_encoding" are documented, we
 * accept all the likely variants of "on" and "off".
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>backslash_quote_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"safe_encoding"</literal></expr>, <expr><name>BACKSLASH_QUOTE_SAFE_ENCODING</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>BACKSLASH_QUOTE_ON</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>BACKSLASH_QUOTE_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>BACKSLASH_QUOTE_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>BACKSLASH_QUOTE_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>BACKSLASH_QUOTE_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>BACKSLASH_QUOTE_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>BACKSLASH_QUOTE_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>BACKSLASH_QUOTE_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Although only "on", "off", and "partition" are documented, we
 * accept all the likely variants of "on" and "off".
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>constraint_exclusion_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"partition"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_PARTITION</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_ON</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Although only "on", "off", "remote_apply", "remote_write", and "local" are
 * documented, we accept all the likely variants of "on" and "off".
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>synchronous_commit_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"local"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_LOCAL_FLUSH</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"remote_write"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_REMOTE_WRITE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"remote_apply"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_REMOTE_APPLY</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_ON</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Although only "on", "off", "try" are documented, we accept all the likely
 * variants of "on" and "off".
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>huge_pages_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>HUGE_PAGES_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>HUGE_PAGES_ON</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"try"</literal></expr>, <expr><name>HUGE_PAGES_TRY</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>HUGE_PAGES_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>HUGE_PAGES_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>HUGE_PAGES_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>HUGE_PAGES_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>HUGE_PAGES_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>HUGE_PAGES_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>force_parallel_mode_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>FORCE_PARALLEL_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>FORCE_PARALLEL_ON</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"regress"</literal></expr>, <expr><name>FORCE_PARALLEL_REGRESS</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>FORCE_PARALLEL_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>FORCE_PARALLEL_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>FORCE_PARALLEL_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>FORCE_PARALLEL_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>FORCE_PARALLEL_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>FORCE_PARALLEL_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * password_encryption used to be a boolean, so accept all the likely
 * variants of "on", too. "off" used to store passwords in plaintext,
 * but we don't support that anymore.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>password_encryption_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"md5"</literal></expr>, <expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"scram-sha-256"</literal></expr>, <expr><name>PASSWORD_TYPE_SCRAM_SHA_256</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Polar: Options for core_dump options
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>coredump_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"disable"</literal></expr>, <expr><name>POLAR_CORE_DUMP_DISABLE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"stack_print"</literal></expr>, <expr><name>POLAR_CORE_DUMP_PRINT</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"core_clear"</literal></expr>, <expr><name>POLAR_CORE_DUMP_CLEAR</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"all"</literal></expr>, <expr><name>POLAR_CORE_DUMP_ALL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* Polar: end */</comment>

<comment type="block">/* POLAR: Options for delay dml */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>delay_dml_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"once"</literal></expr>, <expr><name>POLAR_DELAY_DML_ONCE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"multi"</literal></expr>, <expr><name>POLAR_DELAY_DML_MULTI</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>POLAR_DELAY_DML_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>data_encryption_cipher_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"off"</literal></expr>,		<expr><name>TDE_ENCRYPTION_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"aes-128"</literal></expr>, <expr><name>TDE_ENCRYPTION_AES_128</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"aes-256"</literal></expr>, <expr><name>TDE_ENCRYPTION_AES_256</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>OPENSSL_NO_SM4</name></cpp:ifndef>
	<expr><block>{<expr><literal type="string">"sm4"</literal></expr>,		<expr><name>TDE_ENCRYPTION_SM4</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR: Options for shutdown optimization */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>polar_shutdown_walsnd_wait_replication_kind_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"none"</literal></expr>, <expr><name>POLAR_REPLICATION_KIND_INVALID</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"logical"</literal></expr>, <expr><name>REPLICATION_KIND_LOGICAL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"physical"</literal></expr>, <expr><name>REPLICATION_KIND_PHYSICAL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"all"</literal></expr>, <expr><name>POLAR_REPLICATION_KIND_ALL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * POLAR: Priority replication mode options
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>polar_priority_replication_mode_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"any"</literal></expr>, <expr><name>POLAR_PRI_REP_ANY</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"all"</literal></expr>, <expr><name>POLAR_PRI_REP_ALL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>POLAR_PRI_REP_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>POLAR_PRI_REP_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>POLAR_PRI_REP_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>POLAR_PRI_REP_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR: smgr nblocks cache mode */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>polar_block_cache_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"all"</literal></expr>, <expr><name>POLAR_NBLOCKS_CACHE_ALL_MODE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"bitmapscan"</literal></expr>, <expr><name>POLAR_NBLOCKS_CACHE_BITMAPSCAN_MODE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"scan"</literal></expr>, <expr><name>POLAR_NBLOCKS_CACHE_SCAN_MODE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>POLAR_NBLOCKS_CACHE_OFF_MODE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>POLAR_NBLOCKS_CACHE_OFF_MODE</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>POLAR_NBLOCKS_CACHE_OFF_MODE</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>POLAR_NBLOCKS_CACHE_OFF_MODE</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * POLAR
 * instance specification for cpu and memory
 * 
 * CPU/MEM
 * 0  indicates ignore instance specification, features rely on instance specification should enable
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_instance_spec_cpu</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_instance_spec_mem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_instance_spec_normal_mem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR: operator level mem limit */</comment>
<decl_stmt><decl><type><name>int</name></type>	<name>polar_max_dsm_request_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_max_hashagg_mem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_max_setop_mem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_max_subplan_mem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_max_recursiveunion_mem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Options for enum values stored in other modules
 */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>wal_level_options</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>archive_mode_options</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>sync_method_options</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>dynamic_shared_memory_options</name><index>[]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * GUC option variables that are exported from this module
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_duration</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_print_plan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_print_parse</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_print_rewritten</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_pretty_print</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>log_parser_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_planner_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_executor_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_statement_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* this is sort of all three above
											 * together */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_btree_build_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>event_source</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>row_security</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>check_function_bodies</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>default_with_oids</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>session_auth_is_superuser</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>log_min_error_statement</name> <init>= <expr><name>ERROR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>log_min_messages</name> <init>= <expr><name>WARNING</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>client_min_messages</name> <init>= <expr><name>NOTICE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>log_min_duration_statement</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>log_temp_files</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>trace_recovery_messages</name> <init>= <expr><name>LOG</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>temp_file_limit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>num_temp_buffers</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cluster_name</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ConfigFileName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>HbaFileName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>IdentFileName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>PolarDMAFileName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>external_pid_file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pgstat_temp_directory</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>application_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>tcp_keepalives_idle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>tcp_keepalives_interval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>tcp_keepalives_count</name></decl>;</decl_stmt>


<comment type="block">/*
 * SSL renegotiation was been removed in PostgreSQL 9.5, but we tolerate it
 * being set to zero (meaning never renegotiate) for backward compatibility.
 * This avoids breaking compatibility with clients that have never supported
 * renegotiation and therefore always try to zero it.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>ssl_renegotiation_limit</name></decl>;</decl_stmt>

<comment type="block">/*
 * This really belongs in pg_shmem.c, but is defined here so that it doesn't
 * need to be duplicated in all the different implementations of pg_shmem.c.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>huge_pages</name></decl>;</decl_stmt>

<comment type="block">/* POLAR */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_csn_enable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 		<name>polar_csn_elog_panic_enable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_csnlog_upperbound_enable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_csn_xid_snapshot</name></decl>;</decl_stmt>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/* POLAR wal pipeline */</comment>

<comment type="block">/* general params */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>polar_wal_pipeline_enable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * mode 1	advance+write+flush+notify 	1 thread
 * mode 2	advance+write+flush notify	2 threads
 * mode 3	advance write+flush notify  3 threads
 * mode 4	advance+write flush notify  3 threads
 * mode 5	advance write flush notify  4 threads
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_mode</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>polar_wal_pipeline_wait_object_align</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>	<name>polar_wal_pipeline_wait_timeout</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>				<comment type="block">/* unit us */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_commit_wait_spin_delay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 1000 spin corresponds to 4us */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_commit_wait_timeout</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* unit us */</comment>
<decl_stmt><decl><type><name>int</name></type>	<name>polar_wal_pipeline_flush_event_array_size</name> <init>= <expr><literal type="number">128</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* should be multiple of 2 */</comment>
<decl_stmt><decl><type><name>int</name></type>	<name>polar_wal_pipeline_flush_event_slot_size</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* should be multiple of 2 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_unflushed_xlog_array_size</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* should be multiple of 2 */</comment>

<comment type="block">/* params for advance worker */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_advance_worker_spin_delay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_advance_worker_timeout</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_advance_worker_write_max_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 0 indicate no limit */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_recent_written_array_size</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* should be multiple of 2 */</comment>

<comment type="block">/* params for write worker */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_write_worker_spin_delay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_write_worker_timeout</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* params for flush worker */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_flush_worker_spin_delay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_flush_worker_timeout</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* params for notify worker */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_notify_worker_spin_delay</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>polar_wal_pipeline_notify_worker_timeout</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>	<name>polar_wal_pipeline_notify_worker_num</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * These variables are all dummies that don't do anything, except in some
 * cases provide the value for SHOW to display.  The real state is elsewhere
 * and is kept in sync by assign_hooks.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>syslog_ident_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>phony_random_seed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>client_encoding_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>datestyle_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>locale_collate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>locale_ctype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>server_encoding_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>server_version_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>server_version_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>timezone_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>log_timezone_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>timezone_abbreviations_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>XactIsoLevel_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>data_directory</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>session_authorization_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>max_function_args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>max_index_keys</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>max_identifier_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>block_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>segment_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>wal_block_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>data_checksums</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>integer_datetimes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>assert_enabled</name></decl>;</decl_stmt>

<comment type="block">/* POLAR */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>polar_log_statement_with_duration</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* Log statement text
														 * along with duration
														 * info, in order to
														 * facilitate slow query
														 * collection */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>num_forbidden_functions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>polar_forbidden_functions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>polar_rename_wal_ready_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_max_log_files</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_max_auditlog_files</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_max_slowlog_files</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_max_logindex_files</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 	<name>polar_trace_logindex_messages</name> <init>= <expr><name>LOG</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Forbidden functions names for non-superuser
 *
 * Note: these strings are deliberately not localized.
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>polar_forbidden_funcnames</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><literal type="string">"pg_ls_dir"</literal></expr>,
	<expr><literal type="string">"pg_read_file"</literal></expr>,
	<expr><literal type="string">"pg_read_binary_file"</literal></expr>,
	<expr><literal type="string">"pg_stat_file"</literal></expr>,
	<expr><literal type="string">"set_config"</literal></expr>,
	<expr><literal type="string">"pg_reload_conf"</literal></expr>,
	<expr><literal type="string">"pg_rotate_logfile"</literal></expr>,
	<expr><literal type="string">"pg_drop_replication_slot"</literal></expr>,
	<expr><literal type="string">"pg_create_logical_replication_slot"</literal></expr>,
	<expr><literal type="string">"pg_create_physical_replication_slot"</literal></expr>,
	<expr><literal type="string">"pg_start_backup"</literal></expr>,
	<expr><literal type="string">"pg_stop_backup"</literal></expr>,
	<expr><literal type="string">"lo_import"</literal></expr>,
	<expr><literal type="string">"lo_export"</literal></expr>,
	<expr><name>NULL</name></expr> <comment type="block">/* end */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>polar_super_run_as_secdef</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>polar_forbidden_functions_ext</name></decl>;</decl_stmt>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/* should be static, but commands/variable.c needs to get at this */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>role_string</name></decl>;</decl_stmt>

<comment type="block">/* POLAR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_MAX_PDB_HOSTID</name></cpp:macro>			<cpp:value>512</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_hostid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_bulk_extend_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_min_bulk_extend_table_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_bulk_read_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_recovery_bulk_extend_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 	<name>polar_enable_master_recovery_bulk_extend</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_index_create_bulk_extend_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_index_bulk_extend_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 	<name>polar_csnlog_slot_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_clog_slot_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_committs_buffer_slot_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_mxact_offset_buffer_slot_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_mxact_member_buffer_slot_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 	<name>polar_subtrans_buffer_slot_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_async_buffer_slot_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_oldserxid_buffer_slot_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 	<name>polar_clog_max_local_cache_segments</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_logindex_max_local_cache_segments</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 	<name>polar_commit_ts_max_local_cache_segments</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 	<name>polar_multixact_max_local_cache_segments</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_csnlog_max_local_cache_segments</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 	<name>polar_parallel_replay_proc_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 	<name>polar_parallel_replay_task_queue_depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>polar_datadir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>polar_disk_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>polar_storage_cluster_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_use_statistical_relpages</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_shared_storage_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_ddl_sync_mode</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_transaction_sync_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_debug</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_pwrite</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_pread</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_parallel_replay_standby_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  	<name>polar_check_checkpoint_legal_interval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  	<name>polar_copy_buffers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 	<name>polar_logindex_table_batch_size</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 	<name>polar_enable_copy_buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 	<name>polar_enable_flushlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  	<name>polar_bgwriter_max_batch_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  	<name>polar_bgwriter_batch_size_flushlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 	<name>polar_force_flush_buffer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  	<name>polar_buffer_copy_min_modified_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  	<name>polar_buffer_copy_lsn_lag_with_cons_lsn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 	<name>polar_enable_normal_bgwriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  	<name>polar_bgwriter_sleep_lsn_lag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  	<name>polar_ring_buffer_vacuum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>  	<name>polar_enable_control_vm_flush</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_lazy_checkpoint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_read_ahead_xlog_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_master_xlog_read_ahead</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_parallel_bgwriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_parallel_bgwriter_workers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_parallel_bgwriter_delay</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_parallel_bgwriter_check_interval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_parallel_new_bgwriter_threshold_lag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_parallel_new_bgwriter_threshold_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_parallel_bgwriter_enable_dynamic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_physical_repl_non_super_wal_snd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_wal_snd_reserved_for_superuser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_repl_slots_reserved_for_superuser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_logical_repl_workers_reserved_for_superuser</name></decl>;</decl_stmt>

<comment type="block">/* POLAR gucs */</comment>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_force_change_checkpoint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_resolve_conflict</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_fallocate_walfile</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_skip_fill_walfile_zero_page</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_maxscale_support</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_xlog_buffer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>	    <name>polar_xlog_page_buffers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_xlog_queue_buffers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_logindex_mem_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_logindex_bloom_blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_rel_size_cache_blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>     <name>polar_unit_test_mem_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> 	<name>polar_bg_replay_batch_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_enable_coredump_handler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_dropdb_write_wal_beforehand</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_full_page_write_in_backup</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_lazy_checkpoint_in_backup</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_checkpoint_in_backup</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_switch_wal_in_backup</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_create_backup_history_file_in_backup</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_persisted_logical_slot</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_persisted_physical_slot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_persisted_spill_file</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_early_launch_checkpointer</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_fullpage_snapshot_min_modified_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_fullpage_snapshot_replay_delay_threshold</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_fullpage_snapshot_oldest_lsn_delay_threshold</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_write_logindex_active_table_delay</name> <init>= <expr><literal type="number">200</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_fullpage_snapshot</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_startup_replay_delay_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_wait_old_version_page_timeout</name> <init>= <expr><literal type="number">30</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_keep_wal_ready_file</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 	<name>polar_enable_node_static_config</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_slru_hash_index</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_fullpage_keep_segments</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_track_lock_timing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_track_lock_stat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_track_network_timing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_track_network_stat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_stat_wait_info</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> 	<name>polar_super_call_all_trigger_event</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_track_sql_time_stat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_droptbl_write_wal_beforehand</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_promote_wait_for_walreceive_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_send_stop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_buffer_alignment</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_io_fencing</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_operator_mem_limit</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_operator_mem_limit_by_level</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_dump_incorrect_checksum_xlog</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_trace_heap_scan_flow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * polar replica multi version snapshot related GUC parameters
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> 	<name>polar_replica_multi_version_snapshot_enable</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  	<name>polar_replica_multi_version_snapshot_slot_num</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>  	<name>polar_replica_multi_version_snapshot_retry_times</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_simply_redo_error_log</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_persisted_buffer_pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_early_launch_parallel_bgwriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_alb_client_address</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_enable_lazy_end_of_recovery_checkpoint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_create_table_with_full_replica_identity</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_standby_pbp</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_master_pbp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>polar_save_stack_info_level</name> <init>= <expr><name>FATAL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* POLAR: xact split */</comment>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_xact_split</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>    <name>polar_enable_xact_split_debug</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>polar_xact_split_xids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>polar_xact_split_enable_sethintbits</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>polar_xact_split_wait_lsn_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 * Displayable names for context types (enum GucContext)
 *
 * Note: these strings are deliberately not localized.
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>GucContext_Names</name><index>[]</index></name> <init>=
<expr><block>{
	 <comment type="block">/* PGC_INTERNAL */</comment> <expr><literal type="string">"internal"</literal></expr>,
	 <comment type="block">/* PGC_POSTMASTER */</comment> <expr><literal type="string">"postmaster"</literal></expr>,
	 <comment type="block">/* PGC_SIGHUP */</comment> <expr><literal type="string">"sighup"</literal></expr>,
	 <comment type="block">/* PGC_SU_BACKEND */</comment> <expr><literal type="string">"superuser-backend"</literal></expr>,
	 <comment type="block">/* PGC_BACKEND */</comment> <expr><literal type="string">"backend"</literal></expr>,
	 <comment type="block">/* PGC_SUSET */</comment> <expr><literal type="string">"superuser"</literal></expr>,
	 <comment type="block">/* PGC_USERSET */</comment> <expr><literal type="string">"user"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Displayable names for source types (enum GucSource)
 *
 * Note: these strings are deliberately not localized.
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>GucSource_Names</name><index>[]</index></name> <init>=
<expr><block>{
	 <comment type="block">/* PGC_S_DEFAULT */</comment> <expr><literal type="string">"default"</literal></expr>,
	 <comment type="block">/* PGC_S_DYNAMIC_DEFAULT */</comment> <expr><literal type="string">"default"</literal></expr>,
	 <comment type="block">/* PGC_S_ENV_VAR */</comment> <expr><literal type="string">"environment variable"</literal></expr>,
	 <comment type="block">/* PGC_S_FILE */</comment> <expr><literal type="string">"configuration file"</literal></expr>,
	 <comment type="block">/* PGC_S_ARGV */</comment> <expr><literal type="string">"command line"</literal></expr>,
	 <comment type="block">/* PGC_S_GLOBAL */</comment> <expr><literal type="string">"global"</literal></expr>,
	 <comment type="block">/* PGC_S_DATABASE */</comment> <expr><literal type="string">"database"</literal></expr>,
	 <comment type="block">/* PGC_S_USER */</comment> <expr><literal type="string">"user"</literal></expr>,
	 <comment type="block">/* PGC_S_DATABASE_USER */</comment> <expr><literal type="string">"database user"</literal></expr>,
	 <comment type="block">/* PGC_S_CLIENT */</comment> <expr><literal type="string">"client"</literal></expr>,
	 <comment type="block">/* PGC_S_OVERRIDE */</comment> <expr><literal type="string">"override"</literal></expr>,
	 <comment type="block">/* PGC_S_INTERACTIVE */</comment> <expr><literal type="string">"interactive"</literal></expr>,
	 <comment type="block">/* PGC_S_TEST */</comment> <expr><literal type="string">"test"</literal></expr>,
	 <comment type="block">/* PGC_S_SESSION */</comment> <expr><literal type="string">"session"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Displayable names for the groupings defined in enum config_group
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>config_group_names</name><index>[]</index></name> <init>=
<expr><block>{
	<comment type="block">/* UNGROUPED */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Ungrouped"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* FILE_LOCATIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"File Locations"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CONN_AUTH */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Connections and Authentication"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CONN_AUTH_SETTINGS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Connections and Authentication / Connection Settings"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CONN_AUTH_AUTH */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Connections and Authentication / Authentication"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CONN_AUTH_SSL */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Connections and Authentication / SSL"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_MEM */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Memory"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_DISK */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Disk"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_KERNEL */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Kernel Resources"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_VACUUM_DELAY */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Cost-Based Vacuum Delay"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_BGWRITER */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Background Writer"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_ASYNCHRONOUS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Asynchronous Behavior"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* WAL */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write-Ahead Log"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* WAL_SETTINGS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write-Ahead Log / Settings"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* WAL_CHECKPOINTS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write-Ahead Log / Checkpoints"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* WAL_ARCHIVING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write-Ahead Log / Archiving"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* REPLICATION */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Replication"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* REPLICATION_SENDING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Replication / Sending Servers"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* REPLICATION_MASTER */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Replication / Master Server"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* REPLICATION_STANDBY */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Replication / Standby Servers"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* REPLICATION_SUBSCRIBERS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Replication / Subscribers"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* QUERY_TUNING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Query Tuning"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* QUERY_TUNING_METHOD */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Query Tuning / Planner Method Configuration"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* QUERY_TUNING_COST */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Query Tuning / Planner Cost Constants"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* QUERY_TUNING_GEQO */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Query Tuning / Genetic Query Optimizer"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* QUERY_TUNING_OTHER */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Query Tuning / Other Planner Options"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* LOGGING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Reporting and Logging"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* LOGGING_WHERE */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Reporting and Logging / Where to Log"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* LOGGING_WHEN */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Reporting and Logging / When to Log"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* LOGGING_WHAT */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Reporting and Logging / What to Log"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* PROCESS_TITLE */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Process Title"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* STATS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Statistics"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* STATS_MONITORING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Statistics / Monitoring"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* STATS_COLLECTOR */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Statistics / Query and Index Statistics Collector"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* Encryption for TDE */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Encryption for TDE"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* AUTOVACUUM */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Autovacuum"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CLIENT_CONN */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Client Connection Defaults"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CLIENT_CONN_STATEMENT */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Client Connection Defaults / Statement Behavior"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CLIENT_CONN_LOCALE */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Client Connection Defaults / Locale and Formatting"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CLIENT_CONN_PRELOAD */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Client Connection Defaults / Shared Library Preloading"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CLIENT_CONN_OTHER */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Client Connection Defaults / Other Defaults"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* LOCK_MANAGEMENT */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Lock Management"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* COMPAT_OPTIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Version and Platform Compatibility"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* COMPAT_OPTIONS_PREVIOUS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Version and Platform Compatibility / Previous PostgreSQL Versions"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* COMPAT_OPTIONS_CLIENT */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Version and Platform Compatibility / Other Platforms and Clients"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* ERROR_HANDLING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Error Handling"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* PRESET_OPTIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Preset Options"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CUSTOM_OPTIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Customized Options"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* DEVELOPER_OPTIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Developer Options"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* POLAR_NODE_STATIC */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar node static arguments group"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* PX PX_WORKER_IDENTITY */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><name>PACKAGE_NAME</name> <literal type="string">" / Worker Process Identity"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* PX PX_ARRAY_TUNING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><name>PACKAGE_NAME</name> <literal type="string">" / Array Tuning"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* help_config wants this array to be null-terminated */</comment>
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Displayable names for GUC variable types (enum config_type)
 *
 * Note: these strings are deliberately not localized.
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>config_type_names</name><index>[]</index></name> <init>=
<expr><block>{
	 <comment type="block">/* PGC_BOOL */</comment> <expr><literal type="string">"bool"</literal></expr>,
	 <comment type="block">/* PGC_INT */</comment> <expr><literal type="string">"integer"</literal></expr>,
	 <comment type="block">/* PGC_REAL */</comment> <expr><literal type="string">"real"</literal></expr>,
	 <comment type="block">/* PGC_STRING */</comment> <expr><literal type="string">"string"</literal></expr>,
	 <comment type="block">/* PGC_ENUM */</comment> <expr><literal type="string">"enum"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Unit conversion tables.
 *
 * There are two tables, one for memory units, and another for time units.
 * For each supported conversion from one unit to another, we have an entry
 * in the table.
 *
 * To keep things simple, and to avoid intermediate-value overflows,
 * conversions are never chained.  There needs to be a direct conversion
 * between all units (of the same type).
 *
 * The conversions from each base unit must be kept in order from greatest
 * to smallest unit; convert_from_base_unit() relies on that.  (The order of
 * the base units does not matter.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_UNIT_LEN</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>	<comment type="block">/* length of longest recognized unit string */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>unit</name><index>[<expr><name>MAX_UNIT_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* unit, as a string, like "kB" or
										 * "min" */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>base_unit</name></decl>;</decl_stmt>		<comment type="block">/* GUC_UNIT_XXX */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>multiplier</name></decl>;</decl_stmt>		<comment type="block">/* If positive, multiply the value with this
								 * for unit -&gt; base_unit conversion.  If
								 * negative, divide (with the absolute value) */</comment>
}</block></struct></type> <name>unit_conversion</name>;</typedef>

<comment type="block">/* Ensure that the constants in the tables don't overflow or underflow */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name><name>BLCKSZ</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1024</literal> <operator>||</operator> <name>BLCKSZ</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> BLCKSZ must be between 1KB and 1MB</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name><name>XLOG_BLCKSZ</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1024</literal> <operator>||</operator> <name>XLOG_BLCKSZ</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> XLOG_BLCKSZ must be between 1KB and 1MB</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>memory_units_hint</name> <init>= <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Valid units for this parameter are \"B\", \"kB\", \"MB\", \"GB\", and \"TB\"."</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unit_conversion</name></type> <name><name>memory_unit_conversion_table</name><index>[]</index></name> <init>=
<expr><block>{
	<comment type="block">/*
	 * TB -&gt; bytes conversion always overflows 32-bit integer, so this always
	 * produces an error.  Include it nevertheless for completeness, and so
	 * that you get an "out of range" error, rather than "invalid unit".
	 */</comment>
	<expr><block>{<expr><literal type="string">"TB"</literal></expr>, <expr><name>GUC_UNIT_BYTE</name></expr>, <expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"GB"</literal></expr>, <expr><name>GUC_UNIT_BYTE</name></expr>, <expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MB"</literal></expr>, <expr><name>GUC_UNIT_BYTE</name></expr>, <expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"kB"</literal></expr>, <expr><name>GUC_UNIT_BYTE</name></expr>, <expr><literal type="number">1024</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"B"</literal></expr>, <expr><name>GUC_UNIT_BYTE</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"TB"</literal></expr>, <expr><name>GUC_UNIT_KB</name></expr>, <expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"GB"</literal></expr>, <expr><name>GUC_UNIT_KB</name></expr>, <expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MB"</literal></expr>, <expr><name>GUC_UNIT_KB</name></expr>, <expr><literal type="number">1024</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"kB"</literal></expr>, <expr><name>GUC_UNIT_KB</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"B"</literal></expr>, <expr><name>GUC_UNIT_KB</name></expr>, <expr><operator>-</operator><literal type="number">1024</literal></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"TB"</literal></expr>, <expr><name>GUC_UNIT_MB</name></expr>, <expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"GB"</literal></expr>, <expr><name>GUC_UNIT_MB</name></expr>, <expr><literal type="number">1024</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MB"</literal></expr>, <expr><name>GUC_UNIT_MB</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"kB"</literal></expr>, <expr><name>GUC_UNIT_MB</name></expr>, <expr><operator>-</operator><literal type="number">1024</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"B"</literal></expr>, <expr><name>GUC_UNIT_MB</name></expr>, <expr><operator>-</operator><operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"TB"</literal></expr>, <expr><name>GUC_UNIT_BLOCKS</name></expr>, <expr><operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"GB"</literal></expr>, <expr><name>GUC_UNIT_BLOCKS</name></expr>, <expr><operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MB"</literal></expr>, <expr><name>GUC_UNIT_BLOCKS</name></expr>, <expr><literal type="number">1024</literal> <operator>/</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"kB"</literal></expr>, <expr><name>GUC_UNIT_BLOCKS</name></expr>, <expr><operator>-</operator><operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"B"</literal></expr>, <expr><name>GUC_UNIT_BLOCKS</name></expr>, <expr><operator>-</operator><name>BLCKSZ</name></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"TB"</literal></expr>, <expr><name>GUC_UNIT_XBLOCKS</name></expr>, <expr><operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"GB"</literal></expr>, <expr><name>GUC_UNIT_XBLOCKS</name></expr>, <expr><operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MB"</literal></expr>, <expr><name>GUC_UNIT_XBLOCKS</name></expr>, <expr><literal type="number">1024</literal> <operator>/</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"kB"</literal></expr>, <expr><name>GUC_UNIT_XBLOCKS</name></expr>, <expr><operator>-</operator><operator>(</operator><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"B"</literal></expr>, <expr><name>GUC_UNIT_XBLOCKS</name></expr>, <expr><operator>-</operator><name>XLOG_BLCKSZ</name></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">""</literal></expr>}</block></expr>						<comment type="block">/* end of table marker */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>time_units_hint</name> <init>= <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Valid units for this parameter are \"ms\", \"s\", \"min\", \"h\", and \"d\"."</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unit_conversion</name></type> <name><name>time_unit_conversion_table</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{<expr><literal type="string">"d"</literal></expr>, <expr><name>GUC_UNIT_MS</name></expr>, <expr><literal type="number">1000</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">24</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"h"</literal></expr>, <expr><name>GUC_UNIT_MS</name></expr>, <expr><literal type="number">1000</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"min"</literal></expr>, <expr><name>GUC_UNIT_MS</name></expr>, <expr><literal type="number">1000</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"s"</literal></expr>, <expr><name>GUC_UNIT_MS</name></expr>, <expr><literal type="number">1000</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ms"</literal></expr>, <expr><name>GUC_UNIT_MS</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"d"</literal></expr>, <expr><name>GUC_UNIT_S</name></expr>, <expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">24</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"h"</literal></expr>, <expr><name>GUC_UNIT_S</name></expr>, <expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"min"</literal></expr>, <expr><name>GUC_UNIT_S</name></expr>, <expr><literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"s"</literal></expr>, <expr><name>GUC_UNIT_S</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ms"</literal></expr>, <expr><name>GUC_UNIT_S</name></expr>, <expr><operator>-</operator><literal type="number">1000</literal></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"d"</literal></expr>, <expr><name>GUC_UNIT_MIN</name></expr>, <expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">24</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"h"</literal></expr>, <expr><name>GUC_UNIT_MIN</name></expr>, <expr><literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"min"</literal></expr>, <expr><name>GUC_UNIT_MIN</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"s"</literal></expr>, <expr><name>GUC_UNIT_MIN</name></expr>, <expr><operator>-</operator><literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ms"</literal></expr>, <expr><name>GUC_UNIT_MIN</name></expr>, <expr><operator>-</operator><literal type="number">1000</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">""</literal></expr>}</block></expr>						<comment type="block">/* end of table marker */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Contents of GUC tables
 *
 * See src/backend/utils/misc/README for design notes.
 *
 * TO ADD AN OPTION:
 *
 * 1. Declare a global variable of type bool, int, double, or char*
 *	  and make use of it.
 *
 * 2. Decide at what times it's safe to set the option. See guc.h for
 *	  details.
 *
 * 3. Decide on a name, a default value, upper and lower bounds (if
 *	  applicable), etc.
 *
 * 4. Add a record below.
 *
 * 5. Add it to src/backend/utils/misc/postgresql.conf.sample, if
 *	  appropriate.
 *
 * 6. Don't forget to document the option (at least in config.sgml).
 *
 * 7. If it's a new GUC_LIST_QUOTE option, you must add it to
 *	  variable_is_guc_list_quote() in src/bin/pg_dump/dumputils.c.
 *
 * 8. In PX, the guc is force explicit declare whether it needs to sync value
 *	  between master and primary. Add guc name into either sync_guc_names_array
 *	  or unsync_guc_names_array.
 */</comment>


<comment type="block" format="doxygen">/******** option records follow ********/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_bool</name></name></type> <name><name>ConfigureNamesBool</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_flashback_drop"</literal></expr>,<expr><name>PGC_SUSET</name></expr>,<expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"whether to open flashback_drop"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_flashback_drop</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>,<expr><name>NULL</name></expr>,<expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_master_pbp"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		    <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable master persisted buffer pool."</literal></expr></argument>)</argument_list></call></expr>,
		    <expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_master_pbp</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_standby_pbp"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		    <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable standby persisted buffer pool."</literal></expr></argument>)</argument_list></call></expr>,
		    <expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_standby_pbp</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_create_table_with_full_replica_identity"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar create table with full replica identity."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_create_table_with_full_replica_identity</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DMA</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_dma"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"whether to enable data max availability"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_dma</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_async_commit"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"whether to enable async consensus commit"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_async_commit</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_auto_purge"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"whether to auto purge log"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_auto_purge</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_auto_leader_transfer"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"whether to disable election"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_auto_leader_transfer</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_auto_leader_transfer</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_disable_election"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"whether to disable election"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_disable_election</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_disable_election</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_delay_election"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"whether to delay election"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_delay_election</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_delay_election</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_sync_meta"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"whether to force to change consensus meta"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_force_change_meta</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_init_meta"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"whether to force to initiailize meta"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_init_meta</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_openfile_with_readonly_in_replica"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"open datafile with readonly mode in replica"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_openfile_with_readonly_in_replica</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_enable"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"whether enable wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_enable</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_wait_object_align"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"whether enable wal pipeline mutex align"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_wait_object_align</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_csn_xid_snapshot"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enable polar xid snapshot under csn mode"</literal></expr></argument>)</argument_list></call></expr>,
		    <expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_csn_xid_snapshot</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_csn_enable"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enable polar csn snapshot"</literal></expr></argument>)</argument_list></call></expr>,
		    <expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_csn_enable</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_csn_elog_panic_enable"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enable polar csn "</literal></expr></argument>)</argument_list></call></expr>,
		    <expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_csn_elog_panic_enable</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_csnlog_upperbound_enable"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enable polar csn upperbound cache"</literal></expr></argument>)</argument_list></call></expr>,
		    <expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_csnlog_upperbound_enable</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_early_launch_parallel_bgwriter"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable launch parallel bgwriter when recovery start"</literal></expr></argument>)</argument_list></call></expr>,
		 	<expr><name>NULL</name></expr>,
		 	<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_early_launch_parallel_bgwriter</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_temp_relation_file_in_shared_storage"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Force temp relation file in remote storage."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_temp_relation_file_in_shared_storage</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dropdb_write_wal_before_rm_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_dropdb_write_wal_before_modify_file"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dropdb_write_wal_beforehand</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_droptbl_write_wal_before_rm_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_droptbl_write_wal_before_modify_file"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_droptbl_write_wal_beforehand</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_force_change_checkpoint"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Force to recovery from redo point set in pg_control"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_force_change_checkpoint</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_replica_multi_version_snapshot_enable"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Whether use polar replica multi version snapshot."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_replica_multi_version_snapshot_enable</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_parallel_bgwriter_enable_dynamic"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Start or stop extra parallel background writer dynamically."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_parallel_bgwriter_enable_dynamic</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_parallel_bgwriter"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the use of parallel background writer."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_parallel_bgwriter</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_skip_fill_walfile_zero_page"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar skip fill walfile zere page."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_skip_fill_walfile_zero_page</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_fallocate_walfile"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar enable fallocate walfile."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_fallocate_walfile</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_lazy_checkpoint"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable the use of lazy checkpoint."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_lazy_checkpoint</name></expr>,
		<comment type="block">/* POLAR: default to true, we need lazy checkpoint to advance checkpoint ptr regularly */</comment>
		<expr><name>true</name></expr>,
		<expr><name>polar_check_enable_lazy_checkpoint</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_control_vm_flush"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable control visibility map to flush buffer."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_control_vm_flush</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_normal_bgwriter"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable the use of normal background writer."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_normal_bgwriter</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_force_flush_buffer"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(
			 <argument><expr><literal type="string">"Enable the use of force flush buffer, this parameter is only helpful when there are not replicas."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_force_flush_buffer</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_copy_buffer"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable the use of copy buffer."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_copy_buffer</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_flushlist"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable the use of flush list."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_flushlist</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_pread"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_enable_pread."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_pread</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_parallel_replay_standby_mode"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable WAL parallel replay in a standby node."</literal>
						 <literal type="string">"This has no effect on non-standby nodes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_parallel_replay_standby_mode</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_pwrite"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_enable_pwrite."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_pwrite</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_debug"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_enable_debug."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_debug</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_use_statistical_relpages"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_use_statistical_relpages."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_use_statistical_relpages</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_transaction_sync_mode"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_enable_transaction_sync_mode."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_transaction_sync_mode</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_ddl_sync_mode"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_enable_ddl_sync_mode."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_ddl_sync_mode</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_shared_storage_mode"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_enable_shared_storage_mode."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_shared_storage_mode</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_seqscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of sequential-scan plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_seqscan</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_indexscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of index-scan plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_indexscan</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_indexonlyscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of index-only-scan plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_indexonlyscan</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_bitmapscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of bitmap-scan plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_bitmapscan</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_tidscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of TID scan plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_tidscan</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_sort"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of explicit sort steps."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_sort</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_hashagg"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of hashed aggregation plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_hashagg</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_material"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of materialization."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_material</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_nestloop"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of nested-loop join plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_nestloop</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_mergejoin"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of merge join plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_mergejoin</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_hashjoin"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of hash join plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_hashjoin</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_gathermerge"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of gather merge plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_gathermerge</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_partitionwise_join"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables partitionwise join."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_partitionwise_join</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_partitionwise_aggregate"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables partitionwise aggregation and grouping."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_partitionwise_aggregate</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_parallel_append"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of parallel append plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_parallel_append</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_parallel_hash"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of parallel hash plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_parallel_hash</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_partition_pruning"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable plan-time and run-time partition pruning."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Allows the query planner and executor to compare partition "</literal>
						 <literal type="string">"bounds to conditions in the query to determine which "</literal>
						 <literal type="string">"partitions must be scanned."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_partition_pruning</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_GEQO</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables genetic query optimization."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"This algorithm attempts to do planning without "</literal>
						 <literal type="string">"exhaustive searching."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_geqo</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_inline_cte"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner' to inline a CTE."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_inline_cte</name></expr>,
		<comment type="block">/*
		 * Set it to false to keep the previous behavior, for new instance,
		 * dbaas willl set it to true for new created instance.
		 */</comment>
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<comment type="block">/* Not for general use --- used by SET SESSION AUTHORIZATION */</comment>
		<expr><block>{<expr><literal type="string">"is_superuser"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows whether the current user is a superuser."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>session_auth_is_superuser</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"bonjour"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables advertising the server via Bonjour."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_bonjour</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_bonjour</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_commit_timestamp"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>REPLICATION</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collects transaction commit time."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>track_commit_timestamp</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables SSL connections."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>EnableSSL</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_ssl</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_passphrase_command_supports_reload"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Also use ssl_passphrase_command during server reload."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_passphrase_command_supports_reload</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_prefer_server_ciphers"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Give priority to server ciphersuite order."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>SSLPreferServerCiphers</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"fsync"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Forces synchronization of updates to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"The server will use the fsync() system call in several places to make "</literal>
						 <literal type="string">"sure that updates are physically written to disk. This insures "</literal>
						 <literal type="string">"that a database cluster will recover to a consistent state after "</literal>
						 <literal type="string">"an operating system or hardware crash."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enableFsync</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"ignore_checksum_failure"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Continues processing after a checksum failure."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Detection of a checksum failure normally causes PostgreSQL to "</literal>
						 <literal type="string">"report an error, aborting the current transaction. Setting "</literal>
						 <literal type="string">"ignore_checksum_failure to true causes the system to ignore the failure "</literal>
						 <literal type="string">"(but still report a warning), and continue processing. This "</literal>
						 <literal type="string">"behavior could cause crashes or other serious problems. Only "</literal>
						 <literal type="string">"has an effect if checksums are enabled."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ignore_checksum_failure</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"zero_damaged_pages"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Continues processing past damaged page headers."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Detection of a damaged page header normally causes PostgreSQL to "</literal>
						 <literal type="string">"report an error, aborting the current transaction. Setting "</literal>
						 <literal type="string">"zero_damaged_pages to true causes the system to instead report a "</literal>
						 <literal type="string">"warning, zero out the damaged page, and continue processing. This "</literal>
						 <literal type="string">"behavior will destroy data, namely all the rows on the damaged page."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>zero_damaged_pages</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"full_page_writes"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes full pages to WAL when first modified after a checkpoint."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"A page write in process during an operating system crash might be "</literal>
						 <literal type="string">"only partially written to disk.  During recovery, the row changes "</literal>
						 <literal type="string">"stored in WAL are not enough to recover.  This option writes "</literal>
						 <literal type="string">"pages when first modified after a checkpoint to WAL so full recovery "</literal>
						 <literal type="string">"is possible."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>fullPageWrites</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>polar_check_enable_full_page_writes</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_log_hints"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes full pages to WAL when first modified after a checkpoint, even for a non-critical modifications."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_log_hints</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_compression"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Compresses full-page writes written in WAL file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_compression</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_recycle"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Recycles WAL files by renaming them."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_recycle</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_checkpoints"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each checkpoint."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_checkpoints</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_connections"</literal></expr>, <expr><name>PGC_SU_BACKEND</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each successful connection."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_connections</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_disconnections"</literal></expr>, <expr><name>PGC_SU_BACKEND</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs end of a session, including duration."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_disconnections</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_replication_commands"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each replication command."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_replication_commands</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_assertions"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows whether the running server has assertion checks enabled."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>assert_enabled</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<expr><name>true</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><name>false</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"exit_on_error"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>ERROR_HANDLING_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Terminate session on any error."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ExitOnAnyError</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"restart_after_crash"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>ERROR_HANDLING_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Reinitialize server after backend crash."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>restart_after_crash</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_duration"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs the duration of each completed SQL statement."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_duration</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_print_parse"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each query's parse tree."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Debug_print_parse</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_print_rewritten"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each query's rewritten parse tree."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Debug_print_rewritten</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_print_plan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each query's execution plan."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Debug_print_plan</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_pretty_print"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Indents parse and plan tree displays."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Debug_pretty_print</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_parser_stats"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_MONITORING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes parser performance statistics to the server log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_parser_stats</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_stage_log_stats</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_planner_stats"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_MONITORING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes planner performance statistics to the server log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_planner_stats</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_stage_log_stats</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_executor_stats"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_MONITORING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes executor performance statistics to the server log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_executor_stats</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_stage_log_stats</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_statement_stats"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_MONITORING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes cumulative performance statistics to the server log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_statement_stats</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_log_stats</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BTREE_BUILD_STATS</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_btree_build_stats"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs system resource usage statistics (memory and CPU) on various B-tree operations."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_btree_build_stats</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_activities"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collects information about executing commands."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Enables the collection of information on the currently "</literal>
						 <literal type="string">"executing command of each session, along with "</literal>
						 <literal type="string">"the time at which that command began execution."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pgstat_track_activities</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_counts"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collects statistics on database activity."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pgstat_track_counts</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_io_timing"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collects timing statistics for database I/O activity."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>track_io_timing</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"update_process_title"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>PROCESS_TITLE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Updates the process title to show the active SQL command."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Enables updating of the process title every time a new SQL command is received by the server."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>update_process_title</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<expr><name>false</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><name>true</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Starts the autovacuum subprocess."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_start_daemon</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_notify"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Generates debugging output for LISTEN and NOTIFY."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_notify</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LWLOCK_DEBUG</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_lwlocks"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emits information about lightweight lock usage."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_lwlocks</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_locks"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emits information about lock usage."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_locks</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_userlocks"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emits information about user lock usage."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_userlocks</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_deadlocks"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Dumps information about all current locks when a deadlock timeout occurs."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Debug_deadlocks</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_trace_lock_flow"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Print all log when try to acquire or release lock"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_trace_lock_flow</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_trace_system_table"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Trace locks set on system table"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_trace_system_table</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_lock_waits"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs long lock waits."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_lock_waits</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_hostname"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs the host name in the connection logs."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"By default, connection logs only show the IP address "</literal>
						 <literal type="string">"of the connecting host. If you want them to show the host name you "</literal>
						 <literal type="string">"can turn this on, but depending on your host name resolution "</literal>
						 <literal type="string">"setup it might impose a non-negligible performance penalty."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_hostname</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"transform_null_equals"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_CLIENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Treats \"expr=NULL\" as \"expr IS NULL\"."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"When turned on, expressions of the form expr = NULL "</literal>
						 <literal type="string">"(or NULL = expr) are treated as expr IS NULL, that is, they "</literal>
						 <literal type="string">"return true if expr evaluates to the null value, and false "</literal>
						 <literal type="string">"otherwise. The correct behavior of expr = NULL is to always "</literal>
						 <literal type="string">"return null (unknown)."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Transform_null_equals</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"db_user_namespace"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_AUTH</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables per-database user names."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Db_user_namespace</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_transaction_read_only"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the default read-only status of new transactions."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>DefaultXactReadOnly</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"transaction_read_only"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the current transaction's read-only status."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XactReadOnly</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_transaction_read_only</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_transaction_deferrable"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the default deferrable status of new transactions."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>DefaultXactDeferrable</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"transaction_deferrable"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Whether to defer a read-only serializable transaction until it can be executed with no possible serialization failures."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XactDeferrable</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_transaction_deferrable</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"row_security"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable row security."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"When enabled, row security will be applied to all users."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>row_security</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"check_function_bodies"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Check function bodies during CREATE FUNCTION."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>check_function_bodies</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"array_nulls"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable input of NULL elements in arrays."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"When turned on, unquoted NULL in an array input "</literal>
						 <literal type="string">"value means a null value; "</literal>
						 <literal type="string">"otherwise it is taken literally."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Array_nulls</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_with_oids"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Create new tables with OIDs by default."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>default_with_oids</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"logging_collector"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Start a subprocess to capture stderr output and/or csvlogs into log files."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Logging_collector</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_truncate_on_rotation"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Truncate existing log files of same name during log rotation."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_truncate_on_rotation</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_sort"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emit information about resource usage in sorting."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>trace_sort</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SYNCSCAN</name></cpp:ifdef>
	<comment type="block">/* this is undocumented because not exposed in a standard build */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_syncscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Generate debugging output for synchronized scanning."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>trace_syncscan</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_BOUNDED_SORT</name></cpp:ifdef>
	<comment type="block">/* this is undocumented because not exposed in a standard build */</comment>
	<expr><block>{
		<expr><block>{
			<expr><literal type="string">"optimize_bounded_sort"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable bounded sorting using heap sort."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>optimize_bounded_sort</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_debug"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emit WAL-related debugging output."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XLOG_DEBUG</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"integer_datetimes"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Datetimes are integer based."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>integer_datetimes</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"krb_caseins_users"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_AUTH</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets whether Kerberos and GSSAPI user names should be treated as case-insensitive."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pg_krb_caseins_users</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"escape_string_warning"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Warn about backslash escapes in ordinary string literals."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>escape_string_warning</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"standard_conforming_strings"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Causes '...' strings to treat backslashes literally."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>standard_conforming_strings</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"synchronize_seqscans"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable synchronized sequential scans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>synchronize_seqscans</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"hot_standby"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allows connections and queries during recovery."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>EnableHotStandby</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"hot_standby_feedback"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allows feedback from a hot standby to the primary that will avoid query conflicts."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>hot_standby_feedback</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_standby_feedback"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar standby use this parameter to make hot_standby_feedback off"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_standby_feedback</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* POLAR: maybe we want to modify catalog sometimes */</comment>
		<expr><block>{<expr><literal type="string">"allow_system_table_mods"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allows modifications of the structure of system tables."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>allowSystemTableMods</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ignore_system_indexes"</literal></expr>, <expr><name>PGC_BACKEND</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Disables reading from system indexes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"It does not prevent updating the indexes, so it is safe "</literal>
						 <literal type="string">"to use.  The worst consequence is slowness."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>IgnoreSystemIndexes</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lo_compat_privileges"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables backward compatibility mode for privilege checks on large objects."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Skips privilege checks when reading or modifying large objects, "</literal>
						 <literal type="string">"for compatibility with PostgreSQL releases prior to 9.0."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>lo_compat_privileges</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"operator_precedence_warning"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emit a warning for constructs that changed meaning since PostgreSQL 9.4."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>operator_precedence_warning</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"quote_all_identifiers"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"When generating SQL fragments, quote all identifiers."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>quote_all_identifiers</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"data_checksums"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows whether data checksums are turned on for this cluster."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>data_checksums</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"syslog_sequence_numbers"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Add sequence number to syslog messages to avoid duplicate suppression."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>syslog_sequence_numbers</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"syslog_split_messages"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Split messages sent to syslog by lines and to fit into 1024 bytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>syslog_split_messages</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"parallel_leader_participation"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Controls whether Gather and Gather Merge also run subplans."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Should gather nodes also run subplans, or just gather tuples?"</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>parallel_leader_participation</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allow JIT compilation."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_enabled</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_debugging_support"</literal></expr>, <expr><name>PGC_SU_BACKEND</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Register JIT compiled function with debugger."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_debugging_support</name></expr>,
		<expr><name>false</name></expr>,

		<comment type="block">/*
		 * This is not guaranteed to be available, but given it's a developer
		 * oriented option, it doesn't seem worth adding code checking
		 * availability.
		 */</comment>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_dump_bitcode"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write out LLVM bitcode to facilitate JIT debugging."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_dump_bitcode</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_expressions"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allow JIT compilation of expressions."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_expressions</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_profiling_support"</literal></expr>, <expr><name>PGC_SU_BACKEND</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Register JIT compiled function with perf profiler."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_profiling_support</name></expr>,
		<expr><name>false</name></expr>,

		<comment type="block">/*
		 * This is not guaranteed to be available, but given it's a developer
		 * oriented option, it doesn't seem worth adding code checking
		 * availability.
		 */</comment>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_tuple_deforming"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allow JIT compilation of tuple deforming."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_tuple_deforming</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"data_sync_retry"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>ERROR_HANDLING_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Whether to continue running after a failure to sync data files."</literal></expr></argument>)</argument_list></call></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>data_sync_retry</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* POLAR Bool GUCs, the end of block */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_force_unlogged_to_logged_table"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control whether to force use of logged table for unlogged table creation."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_force_unlogged_to_logged_table</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_master_recovery_bulk_extend"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control whether to use xlog bulk extend opt during recovery on master."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_master_recovery_bulk_extend</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_allow_huge_alloc"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Whether enable alloc huge query string memory or not"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_allow_huge_alloc</name></expr>,
		<comment type="block">/* if false, default max alloc size is 512M, if true, it can be 1G-1 */</comment>
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_super_run_as_secdef"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control whether to superuser run as security definer."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_super_run_as_secdef</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_replay_fpi_check_lsn"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"When this flag is true and replay FPI xlog we will not restore full image if page lsn is larger than xlog record lsn"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_replay_fpi_check_lsn</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_polar_superuser"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables polar user which use create polar_useruser to take superuser privilege do something."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_polar_superuser</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_apply_global_guc_for_super"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control whether to apply all-user-settings for super users."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_apply_global_guc_for_super</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_physical_repl_non_super_wal_snd"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enabel pysical replication request by non-super users"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_physical_repl_non_super_wal_snd</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_suppress_preload_error"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control whether to suppress error for shared preload libraries."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_suppress_preload_error</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_hold_truncate_interrupt"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control whether to disable query cancel during truncating."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_hold_truncate_interrupt</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_force_trans_ro_non_sup"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control whether to force all non-super users' transaction to be readonly"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_force_trans_ro_non_sup</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_log_statement_with_duration"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables printing SQL statement along with duration inforation."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_log_statement_with_duration</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_resolve_conflict"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control conflict resolving in polar standby mode"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_resolve_conflict</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_simply_redo_error_log"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to print simple message in pg_log of rm_redo_error_callback"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_simply_redo_error_log</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* POLAR */</comment>
 	<expr><block>{
 		<expr><block>{<expr><literal type="string">"polar_enable_multi_syslogger"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING</name></expr>,
 			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable polar multi sys logger"</literal></expr></argument>)</argument_list></call></expr>,
 			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
 		}</block></expr>,
 		<expr><operator>&amp;</operator><name>polar_enable_multi_syslogger</name></expr>,
		<expr><name>DEFAULT_MULTI_SYSLOGGER_FLAG</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
 	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_syslog_pipe_buffer"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable log pipe buffer"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_syslog_pipe_buffer</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_error_to_audit_log"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable error sql print to audit log"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_error_to_audit_log</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_maxscale_support"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable Maxscale support."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_maxscale_support</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_syslog_file_buffer"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable log file buffer"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_syslog_file_buffer</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_xlog_buffer"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable xlog buffer"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_xlog_buffer</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_full_page_write_in_backup"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable full-page write in backup"</literal></expr></argument>)</argument_list></call></expr>,
			 <expr><name>NULL</name></expr>,
			 <expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_full_page_write_in_backup</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_lazy_checkpoint_in_backup"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable lazy checkpoint in backup"</literal></expr></argument>)</argument_list></call></expr>,
			 <expr><name>NULL</name></expr>,
			 <expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_lazy_checkpoint_in_backup</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_checkpoint_in_backup"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable checkpoint in backup"</literal></expr></argument>)</argument_list></call></expr>,
			 <expr><name>NULL</name></expr>,
			 <expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_checkpoint_in_backup</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_switch_wal_in_backup"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable switch wal in backup"</literal></expr></argument>)</argument_list></call></expr>,
			 <expr><name>NULL</name></expr>,
			 <expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_switch_wal_in_backup</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_create_backup_history_file_in_backup"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable create .backup file in backup"</literal></expr></argument>)</argument_list></call></expr>,
			 <expr><name>NULL</name></expr>,
			 <expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_create_backup_history_file_in_backup</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_persisted_logical_slot"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable persisted logical slot on shared storage"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_persisted_logical_slot</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_persisted_physical_slot"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable online promote for polardb rw"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_persisted_physical_slot</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_persisted_spill_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable persisted spill file on shared storage"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_persisted_spill_file</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_early_launch_checkpointer"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable launch checkpointer and bgwriter when recovery start"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_early_launch_checkpointer</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_keep_wal_ready_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable remove wal.ready file in recovery"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_keep_wal_ready_file</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_node_static_config"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable load polar_node_static.conf file"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_node_static_config</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_virtual_pid"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable virtual pid when use proxy"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_virtual_pid</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_fullpage_snapshot"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable fullpage snapshot feature"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_fullpage_snapshot</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_master_xlog_read_ahead"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable master xlog read ahead in recovery"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_master_xlog_read_ahead</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_slru_hash_index"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable slru hash index"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_slru_hash_index</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_stat_wait_info"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable to stat wait object and wait time."</literal></expr></argument>)</argument_list></call></expr>,
		 	<expr><name>NULL</name></expr>,
		 	<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_stat_wait_info</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_super_call_all_trigger_event"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Superuser enable to call all event_triggers."</literal></expr></argument>)</argument_list></call></expr>,
		 	<expr><name>NULL</name></expr>,
		 	<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_super_call_all_trigger_event</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_tde_warning"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable to log warning when the page is not encrypted with data encryption enabled."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_tde_warning</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_persisted_buffer_pool"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable persisted buffer pool."</literal></expr></argument>)</argument_list></call></expr>,
		 	<expr><name>NULL</name></expr>,
		 	<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_persisted_buffer_pool</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_track_lock_stat"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable track lock stat"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_track_lock_stat</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_track_lock_timing"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable track lock timing"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_track_lock_timing</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_track_network_stat"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable track net stat"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_track_network_stat</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_track_network_timing"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable track net timing"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_track_network_timing</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_alb_client_address"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Whether get real client address from ALB through getpeername."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_alb_client_address</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_shutdown_walsnd_wait_non_super"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Wait non-superuser's walsender or not during shutdown."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_shutdown_walsnd_wait_non_super</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_priority_replication_force_wait"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"In priority replication, whether wait if all higher level standbys are down."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_priority_replication_force_wait</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_semi_sync_optimization"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enable semi-synchronous replication optimization under network jitter."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_semi_sync_optimization</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_lazy_end_of_recovery_checkpoint"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable lazy checkpoint for end of recovery checkpoint."</literal></expr></argument>)</argument_list></call></expr>,
		 	<expr><name>NULL</name></expr>,
		 	<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_lazy_end_of_recovery_checkpoint</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_async_ddl_lock_replay"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable async ddl lock replay while db recovery"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_async_ddl_lock_replay</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_async_ddl_lock_replay_unit_test"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable async ddl lock replay unit test"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_async_ddl_lock_replay_unit_test</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_ro_prewarm"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable ro to prewarm block modified by rw"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_ro_prewarm</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_track_sql_time_stat"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable track sql time stat"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_track_sql_time_stat</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_audit_log_bind_sql_parameter"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable output audit log with sql and parameters"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_audit_log_bind_sql_parameter</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* 
	 * POLAR: this parameter is replace of polar_enable_audit_log_bind_sql_parameter, 
	 * the function of them is equal. polar_enable_audit_log_bind_sql_parameter is nolonger effect 
	 * since polar_enable_audit_log_bind_sql_parameter_new appears.
	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_audit_log_bind_sql_parameter_new"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable output audit log with sql and parameters"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_audit_log_bind_sql_parameter_new</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

   	<comment type="block">/*
	 * POLAR: this parameter is different from polar_vfs.localfs_mode.
   	 * When creating rw and ro nodes by polardb_build.sh for testing, superuser
   	 * can create tablespace, and link a directory on the machine. If rw
	 * drop a tablespace, ro will replay the xlog, drop the tablespace and
   	 * remove the tablespace directory. Then rw goes to remove the directory,
	 * it will get a warnning elog. This situation happens some regression test
   	 * cases. polar_enable_localfs_test_mode always set to false except in
   	 * polardb_build.sh
   	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_localfs_test_mode"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable local pfs test mode"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_localfs_test_mode</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_promote_wait_for_walreceive_done"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable wait for receiving all wal when promote"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_promote_wait_for_walreceive_done</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_convert_or_to_union_all"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"support convert OR clauses to UNION ALL queries."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_convert_or_to_union_all</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_publish_via_partition_root"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"support publish via partition root on pgoutput."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_publish_via_partition_root</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_xact_split"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Switch to decide whether transactions rw-split support is on."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_xact_split</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_xact_split_debug"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Switch to decide whether transactions rw-split debug support is on."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_xact_split_debug</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_xact_split_enable_sethintbits"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allow to set hintbit in xact split query"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_xact_split_enable_sethintbits</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/*
	 * POLAR: In the event that some backend dumps core, send SIGSTOP rather than SIGQUIT
	 * to all its peers, this lets the wily post_hacker collect core dumps from everyone.
	 * in original way, this is set with -T parameter when start postgres
	 * changes to set via guc parameter polar_enable_send_stop
	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_send_stop"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable to send SIGSTOP to all peers when some backend exit abnormally"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_send_stop</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>polar_assign_enable_send_stop</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_replica_use_smgr_cache"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"smgr shared cache used in polar relica"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_replica_use_smgr_cache</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_standby_use_smgr_cache"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"smgr shared cache used in polar standby"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_standby_use_smgr_cache</name></expr>,
		<expr><name>false</name></expr>,
                <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
        }</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_flashback_log"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes origin pages to flashback log when first exclusive lock after a checkpoint."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A page write in process during an operating system crash might be "</literal>
						 <literal type="string">"only partially written to disk.  During recovery, the row changes "</literal>
						 <literal type="string">"stored in WAL are not enough to recover.  This option writes "</literal>
						 <literal type="string">"pages when first exclusive lock after a checkpoint to flashback log so full recovery "</literal>
						 <literal type="string">"is possible. NB: It can't be on while polar_enable_lazy_checkpoint is on"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_flashback_log</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_log_debug"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable flashback log debug"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_log_debug</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_has_partial_write"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"There are partial write problems"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_has_partial_write</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_max_slot_wal_keep_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enable max_slot_wal_keep_size function"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_max_slot_wal_keep_size</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* POLAR end */</comment>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_io_fencing"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enable detection of more than one RW runging in one cluster."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_io_fencing</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_operator_mem_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enable operator memory limit."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_operator_mem_limit</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_operator_mem_limit_by_level"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enable operator memory limit by level."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_operator_mem_limit_by_level</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_dump_incorrect_checksum_xlog"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"enable dump incorrect checksum xlogrecord into file in primary node."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_dump_incorrect_checksum_xlog</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_trace_heap_scan_flow"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Print heap scan debug log if necessary"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_trace_heap_scan_flow</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* End-of-list marker */</comment>
	<expr><block>{
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><name>false</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_int</name></name></type> <name><name>ConfigureNamesInt</name><index>[]</index></name> <init>=
<expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DMA</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_cluster_id"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar consensus cluster id."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_cluster_id</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_port_deviation"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number which is added to the client port number to "</literal>
					<literal type="string">"obtain polar consensus port."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_port_deviation</name></expr>,
		<expr><literal type="number">10000</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">65535</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_hb_thread_count"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number of polar consensus heartbeat thread."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_hb_thread_count</name></expr>,
		<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">256</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,


	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_io_thread_count"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number of polar consensus io thread."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_io_thread_count</name></expr>,
		<expr><literal type="number">8</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">256</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_worker_thread_count"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number of polar consensus worker thread."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_worker_thread_count</name></expr>,
		<expr><literal type="number">8</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">256</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_log_slot_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number of polar consensus log slots. "</literal>
					<literal type="string">"each slot corresponds to an 8K memory block."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_log_slots</name></expr>,
		<expr><literal type="number">8192</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">16</literal> <operator>*</operator> <literal type="number">128</literal> <operator>*</operator> <literal type="number">1024</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_log_keep_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the size of polar consensus log held for non-leader servers. "</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_log_keep_size_mb</name></expr>,
		<expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_log_keep_size</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_xlog_check_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Polar consensus log append wait N ms before WAL flushed."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_xlog_check_timeout</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">600</literal> <operator>*</operator> <literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_xlog_check_timeout</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_send_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Polar consensus send packet timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_send_timeout</name></expr>,
		<expr><literal type="number">5</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">600</literal> <operator>*</operator> <literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_send_timeout</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_election_timeout"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Polar consensus election timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_election_timeout</name></expr>,
		<expr><literal type="number">5000</literal></expr>, <expr><literal type="number">1000</literal></expr>, <expr><literal type="number">600</literal> <operator>*</operator> <literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_delay_election_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Polar consensus delay election timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_delay_electionTimeout</name></expr>,
		<expr><literal type="number">36</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><literal type="number">1000</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_delay_election_timeout</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_pipeline_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Polar consensus election timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_pipeline_timeout</name></expr>,
		<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_pipeline_timeout</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_config_change_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Polar consensus configure change timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_config_change_timeout</name></expr>,
		<expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">600</literal> <operator>*</operator> <literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_config_change_timeout</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_purge_timeout"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Polar consensus log purge timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_purge_timeout</name></expr>,
		<expr><literal type="number">30</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><literal type="number">24</literal> <operator>*</operator> <literal type="number">3600</literal> <operator>*</operator> <literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_max_packet_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Polar consensus max packet size send at once."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_max_packet_size</name></expr>,
		<expr><literal type="number">128</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_max_packet_size</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_max_delay_index"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Polar consensus max index delay for pipeline log delivery."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_max_delay_index</name></expr>,
		<expr><literal type="number">50000</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_max_delay_index</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_min_delay_index"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Polar consensus min index delay for pipeline log delivery."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_min_delay_index</name></expr>,
		<expr><literal type="number">5000</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_min_delay_index</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_max_standby_wait_delay_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum delay WAL size for standby wait conflict snapshot."</literal></expr></argument>)</argument_list></call></expr>,
		  <expr><name>NULL</name></expr>,
		  <expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_max_standby_wait_delay_size_mb</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_new_follower_threshold"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Polar consensus max delay index to allow a learner becomes to a follower."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_min_delay_index</name></expr>,
		<expr><literal type="number">5000</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_dma_new_follower_threshold</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_mode"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set mode for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_mode</name></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">5</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_flush_event_array_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set flush event array size for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_flush_event_array_size</name></expr>,
		<expr><literal type="number">128</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_flush_event_slot_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set flush event slot size for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_flush_event_slot_size</name></expr>,
		<expr><literal type="number">1024</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_unflushed_xlog_array_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set unflushed xlog array size for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_unflushed_xlog_array_size</name></expr>,
		<expr><literal type="number">1024</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_recent_written_array_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set recent written array size for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_recent_written_array_size</name></expr>,
		<expr><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_wait_timeout"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set default wait timeout for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_wait_timeout</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><name>POLAR_MIN_WAIT_TIMEOUT_USEC</name></expr>, <expr><name>POLAR_MAX_WAIT_TIMEOUT_USEC</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_commit_wait_spin_delay"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set commit wait spin delay for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_commit_wait_spin_delay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>POLAR_MIN_WAIT_SPINS</name></expr>, <expr><name>POLAR_MAX_WAIT_SPINS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_commit_wait_timeout"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set commit wait timeout for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_commit_wait_timeout</name></expr>,
		<expr><literal type="number">10000</literal></expr>, <expr><name>POLAR_MIN_WAIT_TIMEOUT_USEC</name></expr>, <expr><name>POLAR_MAX_WAIT_TIMEOUT_USEC</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_advance_worker_spin_delay"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set spin delay of advance worker for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_advance_worker_spin_delay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>POLAR_MIN_WAIT_SPINS</name></expr>, <expr><name>POLAR_MAX_WAIT_SPINS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_advance_worker_timeout"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set timeout of advance worker for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_advance_worker_timeout</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><name>POLAR_MIN_WAIT_TIMEOUT_USEC</name></expr>, <expr><name>POLAR_MAX_WAIT_TIMEOUT_USEC</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_advance_worker_write_max_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set max wal size per advance of advance worker for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_advance_worker_write_max_size</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_write_worker_spin_delay"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set spin delay of write worker for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_write_worker_spin_delay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>POLAR_MIN_WAIT_SPINS</name></expr>, <expr><name>POLAR_MAX_WAIT_SPINS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_write_worker_timeout"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set timeout of write worker for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_write_worker_timeout</name></expr>,
		<expr><literal type="number">10000</literal></expr>, <expr><name>POLAR_MIN_WAIT_TIMEOUT_USEC</name></expr>, <expr><name>POLAR_MAX_WAIT_TIMEOUT_USEC</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_flush_worker_spin_delay"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set spin delay of flush worker for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_flush_worker_spin_delay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>POLAR_MIN_WAIT_SPINS</name></expr>, <expr><name>POLAR_MAX_WAIT_SPINS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_flush_worker_timeout"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set timeout of flush worker for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_flush_worker_timeout</name></expr>,
		<expr><literal type="number">10000</literal></expr>, <expr><name>POLAR_MIN_WAIT_TIMEOUT_USEC</name></expr>, <expr><name>POLAR_MAX_WAIT_TIMEOUT_USEC</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_notify_worker_spin_delay"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set spin delay of notify worker for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_notify_worker_spin_delay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>POLAR_MIN_WAIT_SPINS</name></expr>, <expr><name>POLAR_MAX_WAIT_SPINS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_notify_worker_timeout"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set timeout of notify worker for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_notify_worker_timeout</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><name>POLAR_MIN_WAIT_TIMEOUT_USEC</name></expr>, <expr><name>POLAR_MAX_WAIT_TIMEOUT_USEC</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_pipeline_notify_worker_num"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number of notify worker for wal pipeline"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_pipeline_notify_worker_num</name></expr>,
		<expr><literal type="number">1</literal></expr>, <expr><name>POLAR_WAL_PIPELINE_NOTIFY_WORKER_NUM_MIN</name></expr>, <expr><name>POLAR_WAL_PIPELINE_NOTIFY_WORKER_NUM_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wal_buffer_insert_locks"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number of locks for wal buffer insert"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_buffer_insert_locks</name></expr>,
		<expr><literal type="number">64</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_replica_multi_version_snapshot_slot_num"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set polar replica multi version snapshot slot number"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_replica_multi_version_snapshot_slot_num</name></expr>,
		<expr><literal type="number">32</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">128</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_replica_multi_version_snapshot_retry_times"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set polar replica multi version snapshot retry times"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_replica_multi_version_snapshot_retry_times</name></expr>,
		<expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_unit_test_mem_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set additional shared memory size for unit test"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_unit_test_mem_size</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_logindex_mem_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the size for logindex memory table"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_logindex_mem_size</name></expr>,
		<expr><literal type="number">512</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_logindex_bloom_blocks"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number of blocks for logindex bloom filter"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_logindex_bloom_blocks</name></expr>,
		<expr><literal type="number">1024</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_logindex_mem_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the size for flashback logindex memory table"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_logindex_mem_size</name></expr>,
		<expr><literal type="number">64</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_logindex_bloom_blocks"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number of blocks for flashback logindex bloom filter"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_logindex_bloom_blocks</name></expr>,
		<expr><literal type="number">512</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_rel_size_cache_blocks"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number of blocks to record relation size cache"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_rel_size_cache_blocks</name></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_parallel_new_bgwriter_threshold_lag"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(
			 <argument><expr><literal type="string">"Set the threshold to add a new bgwriter, if the consistent lag greater than "</literal>
			 <literal type="string">"this lag #polar_parallel_new_bgwriter_threshold_time, we will add a "</literal>
			 <literal type="string">"new parallel background writer."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_parallel_new_bgwriter_threshold_lag</name></expr>,
		<expr><literal type="number">1024</literal></expr>, <expr><literal type="number">256</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_parallel_new_bgwriter_threshold_time"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(
			 <argument><expr><literal type="string">"Set the threshold to add a new bgwriter, if the consistent lag greater than "</literal>
			 <literal type="string">"this lag #polar_parallel_new_bgwriter_threshold_time, we will add a "</literal>
			 <literal type="string">"new parallel background writer."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_parallel_new_bgwriter_threshold_time</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3600</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_parallel_bgwriter_check_interval"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"The interval to check whether the server has enough parallel background writers."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_parallel_bgwriter_check_interval</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">600</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_parallel_bgwriter_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Parallel background writer sleep time between rounds."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_parallel_bgwriter_delay</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_parallel_bgwriter_workers"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the max number of the parallel background workers."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_parallel_bgwriter_workers</name></expr>,
		<expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_NUM_OF_PARALLEL_BGWRITER</name><operator>/</operator><literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_logindex_table_batch_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the batch size of logindex table to be flushed in background process."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_logindex_table_batch_size</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_read_ahead_xlog_num"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(
			 <argument><expr><literal type="string">"How many xlog pages are read ahead. A value of 0 turns off this feature."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_read_ahead_xlog_num</name></expr>,
		<expr><literal type="number">20</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_READ_AHEAD_XLOGS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_copy_buffers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the size of copy buffer."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_copy_buffers</name></expr>,
		<expr><literal type="number">16384</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_ring_buffer_vacuum"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_ring_buffer_vacuum"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_ring_buffer_vacuum</name></expr>,
		<expr><literal type="number">128</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_bgwriter_sleep_lsn_lag"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_bgwriter_sleep_lsn_lag"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_bgwriter_sleep_lsn_lag</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_buffer_copy_lsn_lag_with_cons_lsn"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the max lag between consistent lsn and oldest lsn "</literal>
					  <literal type="string">"when a buffer should be copied"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_buffer_copy_lsn_lag_with_cons_lsn</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_buffer_copy_min_modified_count"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum modified count when a buffer should be copied"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_buffer_copy_min_modified_count</name></expr>,
		<expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_bgwriter_batch_size_flushlist"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
				<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the batch size when bgwriter get buffer from flush list"</literal></expr></argument>)</argument_list></call></expr>,
				<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_bgwriter_batch_size_flushlist</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_bgwriter_max_batch_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
		    <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum batch size when bgwriter flush buffer from flush list"</literal></expr></argument>)</argument_list></call></expr>,
		    <expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_bgwriter_max_batch_size</name></expr>,
		<expr><literal type="number">5000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_check_checkpoint_legal_interval"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum interval between check the checkpoint legal or not."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_check_checkpoint_legal_interval</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_csnlog_slot_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_csnlog_slot_size."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_csnlog_slot_size</name></expr>,
		<expr><literal type="number">8192</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">65536</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_clog_slot_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
				<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_clog_slot_size."</literal></expr></argument>)</argument_list></call></expr>,
				<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_clog_slot_size</name></expr>,
		<expr><literal type="number">512</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">65536</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_committs_buffer_slot_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
				<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_committs_buffer_slot_size."</literal></expr></argument>)</argument_list></call></expr>,
				<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_committs_buffer_slot_size</name></expr>,
		<expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">65536</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_mxact_offset_buffer_slot_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
				<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_mxact_offset_buffer_slot_size."</literal></expr></argument>)</argument_list></call></expr>,
				<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_mxact_offset_buffer_slot_size</name></expr>,
		<expr><name>NUM_MXACTOFFSET_BUFFERS</name></expr>, <expr><name>NUM_MXACTOFFSET_BUFFERS</name></expr>, <expr><literal type="number">65536</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_mxact_member_buffer_slot_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
				<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_mxact_member_buffer_slot_size."</literal></expr></argument>)</argument_list></call></expr>,
				<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_mxact_member_buffer_slot_size</name></expr>,
		<expr><name>NUM_MXACTMEMBER_BUFFERS</name></expr>, <expr><name>NUM_MXACTMEMBER_BUFFERS</name></expr>, <expr><literal type="number">65536</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_subtrans_buffer_slot_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
				<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_subtrans_buffer_slot_size."</literal></expr></argument>)</argument_list></call></expr>,
				<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_subtrans_buffer_slot_size</name></expr>,
		<expr><name>NUM_SUBTRANS_BUFFERS</name></expr>, <expr><name>NUM_SUBTRANS_BUFFERS</name></expr>, <expr><literal type="number">65536</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_async_buffer_slot_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
				<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_async_buffer_slot_size."</literal></expr></argument>)</argument_list></call></expr>,
				<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_async_buffer_slot_size</name></expr>,
		<expr><name>NUM_ASYNC_BUFFERS</name></expr>, <expr><name>NUM_ASYNC_BUFFERS</name></expr>, <expr><literal type="number">65536</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_oldserxid_buffer_slot_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
				<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar_oldserxid_buffer_slot_size."</literal></expr></argument>)</argument_list></call></expr>,
				<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_oldserxid_buffer_slot_size</name></expr>,
		<expr><name>NUM_OLDSERXID_BUFFERS</name></expr>, <expr><name>NUM_OLDSERXID_BUFFERS</name></expr>, <expr><literal type="number">65536</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_hostid"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>POLAR_NODE_STATIC</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polardb hostid."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_hostid</name></expr>,
		<comment type="block">/* -1 means this variable is disabled */</comment>
		<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>POLAR_MAX_PDB_HOSTID</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_auditlog_max_query_length"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polardb max audit log length"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_auditlog_max_query_length</name></expr>,
		<comment type="block">/* MIN should not be 0, MAX should better not larger than a half of LOG_CHANNEL_WRITE_BUFFER_SIZE */</comment>
		<expr><name>POLAR_DEFAULT_MAX_AUDIT_LOG_LEN</name></expr>, <expr><literal type="number">512</literal></expr>, <expr><literal type="number">48</literal> <operator>*</operator> <literal type="number">1024</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"archive_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_ARCHIVING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Forces a switch to the next WAL file if a "</literal>
						 <literal type="string">"new file has not been started within N seconds."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XLogArchiveTimeout</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"post_auth_delay"</literal></expr>, <expr><name>PGC_BACKEND</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Waits N seconds on connection startup after authentication."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"This allows attaching a debugger to the process."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>PostAuthDelay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">1000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_statistics_target"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the default statistics target."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"This applies to table columns that have not had a "</literal>
						 <literal type="string">"column-specific target set via ALTER TABLE SET STATISTICS."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>default_statistics_target</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"from_collapse_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the FROM-list size beyond which subqueries "</literal>
						 <literal type="string">"are not collapsed."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"The planner will merge subqueries into upper "</literal>
						 <literal type="string">"queries if the resulting FROM list would have no more than "</literal>
						 <literal type="string">"this many items."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>from_collapse_limit</name></expr>,
		<expr><literal type="number">8</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"join_collapse_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the FROM-list size beyond which JOIN "</literal>
						 <literal type="string">"constructs are not flattened."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"The planner will flatten explicit JOIN "</literal>
						 <literal type="string">"constructs into lists of FROM items whenever a "</literal>
						 <literal type="string">"list of no more than this many items would result."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>join_collapse_limit</name></expr>,
		<expr><literal type="number">8</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_threshold"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_GEQO</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the threshold of FROM items beyond which GEQO is used."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>geqo_threshold</name></expr>,
		<expr><literal type="number">12</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_effort"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_GEQO</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"GEQO: effort is used to set the default for other GEQO parameters."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Geqo_effort</name></expr>,
		<expr><name>DEFAULT_GEQO_EFFORT</name></expr>, <expr><name>MIN_GEQO_EFFORT</name></expr>, <expr><name>MAX_GEQO_EFFORT</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_pool_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_GEQO</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"GEQO: number of individuals in the population."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Zero selects a suitable default value."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Geqo_pool_size</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_generations"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_GEQO</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"GEQO: number of iterations of the algorithm."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Zero selects a suitable default value."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Geqo_generations</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* This is PGC_SUSET to prevent hiding from log_lock_waits. */</comment>
		<expr><block>{<expr><literal type="string">"deadlock_timeout"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the time to wait on a lock before checking for deadlock."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>DeadlockTimeout</name></expr>,
		<expr><literal type="number">1000</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_standby_archive_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum delay before canceling queries when a hot standby server is processing archived WAL data."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_standby_archive_delay</name></expr>,
		<expr><literal type="number">30</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_standby_streaming_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum delay before canceling queries when a hot standby server is processing streamed WAL data."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_standby_streaming_delay</name></expr>,
		<expr><literal type="number">30</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_receiver_status_interval"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum interval between WAL receiver status reports to the primary."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_receiver_status_interval</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_receiver_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum wait time to receive data from the primary."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_receiver_timeout</name></expr>,
		<expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_connections"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of concurrent connections."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>MaxConnections</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>check_maxconnections</name></expr>, <expr><name>NULL</name></expr>, <expr><name>polar_show_max_connections</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* see max_connections and max_wal_senders */</comment>
		<expr><block>{<expr><literal type="string">"superuser_reserved_connections"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of connection slots reserved for superusers."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ReservedBackends</name></expr>,
		<expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/*
	 * We sometimes multiply the number of shared buffers by two without
	 * checking for overflow, so we mustn't allow more than INT_MAX / 2.
	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"shared_buffers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of shared memory buffers used by the server."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>NBuffers</name></expr>,
		<expr><literal type="number">1024</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"temp_buffers"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of temporary buffers used by each session."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>num_temp_buffers</name></expr>,
		<expr><literal type="number">1024</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>check_temp_buffers</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the TCP port the server listens on."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>PostPortNumber</name></expr>,
		<expr><name>DEF_PGPORT</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">65535</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"unix_socket_permissions"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the access permissions of the Unix-domain socket."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Unix-domain sockets use the usual Unix file system "</literal>
						 <literal type="string">"permission set. The parameter value is expected "</literal>
						 <literal type="string">"to be a numeric mode specification in the form "</literal>
						 <literal type="string">"accepted by the chmod and umask system calls. "</literal>
						 <literal type="string">"(To use the customary octal format the number must "</literal>
						 <literal type="string">"start with a 0 (zero).)"</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Unix_socket_permissions</name></expr>,
		<expr><literal type="number">0777</literal></expr>, <expr><literal type="number">0000</literal></expr>, <expr><literal type="number">0777</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>show_unix_socket_permissions</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_file_mode"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the file permissions for log files."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"The parameter value is expected "</literal>
						 <literal type="string">"to be a numeric mode specification in the form "</literal>
						 <literal type="string">"accepted by the chmod and umask system calls. "</literal>
						 <literal type="string">"(To use the customary octal format the number must "</literal>
						 <literal type="string">"start with a 0 (zero).)"</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_file_mode</name></expr>,
		<expr><literal type="number">0600</literal></expr>, <expr><literal type="number">0000</literal></expr>, <expr><literal type="number">0777</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>show_log_file_mode</name></expr>
	}</block></expr>,


	<expr><block>{
		<expr><block>{<expr><literal type="string">"data_directory_mode"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Mode of the data directory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"The parameter value is a numeric mode specification "</literal>
						 <literal type="string">"in the form accepted by the chmod and umask system "</literal>
						 <literal type="string">"calls. (To use the customary octal format the number "</literal>
						 <literal type="string">"must start with a 0 (zero).)"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>data_directory_mode</name></expr>,
		<expr><literal type="number">0700</literal></expr>, <expr><literal type="number">0000</literal></expr>, <expr><literal type="number">0777</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>show_data_directory_mode</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"work_mem"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum memory to be used for query workspaces."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"This much memory can be used by each internal "</literal>
						 <literal type="string">"sort operation and hash table before switching to "</literal>
						 <literal type="string">"temporary disk files."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>work_mem</name></expr>,
		<expr><literal type="number">4096</literal></expr>, <expr><literal type="number">64</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"maintenance_work_mem"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum memory to be used for maintenance operations."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"This includes operations such as VACUUM and CREATE INDEX."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>maintenance_work_mem</name></expr>,
		<expr><literal type="number">65536</literal></expr>, <expr><literal type="number">1024</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/*
	 * We use the hopefully-safely-small value of 100kB as the compiled-in
	 * default for max_stack_depth.  InitializeGUCOptions will increase it if
	 * possible, depending on the actual platform-specific stack limit.
	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_stack_depth"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum stack depth, in kilobytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_stack_depth</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>check_max_stack_depth</name></expr>, <expr><name>assign_max_stack_depth</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* POLAR: many user want to change it, so let no-super to set it */</comment>
		<expr><block>{<expr><literal type="string">"temp_file_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_DISK</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Limits the total size of all temporary files used by each process."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"-1 means no limit."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>temp_file_limit</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cost_page_hit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_VACUUM_DELAY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost for a page found in the buffer cache."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>VacuumCostPageHit</name></expr>,
		<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cost_page_miss"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_VACUUM_DELAY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost for a page not found in the buffer cache."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>VacuumCostPageMiss</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cost_page_dirty"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_VACUUM_DELAY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost for a page dirtied by vacuum."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>VacuumCostPageDirty</name></expr>,
		<expr><literal type="number">20</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cost_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_VACUUM_DELAY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost amount available before napping."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>VacuumCostLimit</name></expr>,
		<expr><literal type="number">200</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cost_delay"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_VACUUM_DELAY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost delay in milliseconds."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>VacuumCostDelay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">100</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_vacuum_cost_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost delay in milliseconds, for autovacuum."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_vac_cost_delay</name></expr>,
		<expr><literal type="number">20</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">100</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_vacuum_cost_limit"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost amount available before napping, for autovacuum."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_vac_cost_limit</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_files_per_process"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_KERNEL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of simultaneously open files for each server process."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_files_per_process</name></expr>,
		<expr><literal type="number">1000</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"smgr_shared_relations"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of shared relation objects in memory at one time."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>smgr_shared_relations</name></expr>,
		<expr><literal type="number">128</literal></expr>, <expr><literal type="number">64</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"smgr_pool_sweep_times"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the times for smgr pool to clock sweep, 0 means always uses a random cache"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>smgr_pool_sweep_times</name></expr>,
		<expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/*
	 * See also CheckRequiredParameterValues() if this parameter changes
	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_prepared_transactions"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of simultaneously prepared transactions."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_prepared_xacts</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_lock_oidmin"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum OID of tables for tracking locks."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Is used to avoid output on system tables."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_lock_oidmin</name></expr>,
		<expr><name>FirstNormalObjectId</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_lock_table"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the OID of the table with unconditionally lock tracing."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_lock_table</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"statement_timeout"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum allowed duration of any statement."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off the timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>StatementTimeout</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>, 
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_audit_log_flush_timeout"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the audit log timeout to flush."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off the timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_audit_log_flush_timeout</name></expr>,
		<expr><literal type="number">30000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lock_timeout"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum allowed duration of any wait for a lock."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off the timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>LockTimeout</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_delay_dml_lsn_lag_threshold"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the polar dml delay size for replay."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off the size threshold."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_delay_dml_lsn_lag_threshold</name></expr>,
		<expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr> <comment type="block">/* default 10GB */</comment>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,


	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_primary_dml_delay"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the polar dml delay for replay."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off the timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_primary_dml_delay</name></expr>,
		<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"idle_in_transaction_session_timeout"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum allowed duration of any idling transaction."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off the timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>IdleInTransactionSessionTimeout</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_freeze_min_age"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Minimum age at which VACUUM should freeze a table row."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_freeze_min_age</name></expr>,
		<expr><literal type="number">50000000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_freeze_table_age"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Age at which VACUUM should scan whole table to freeze tuples."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_freeze_table_age</name></expr>,
		<expr><literal type="number">150000000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_multixact_freeze_min_age"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Minimum age at which VACUUM should freeze a MultiXactId in a table row."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_multixact_freeze_min_age</name></expr>,
		<expr><literal type="number">5000000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_multixact_freeze_table_age"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Multixact age at which VACUUM should scan whole table to freeze tuples."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_multixact_freeze_table_age</name></expr>,
		<expr><literal type="number">150000000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_defer_cleanup_age"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of transactions by which VACUUM and HOT cleanup should be deferred, if any."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_defer_cleanup_age</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/*
	 * See also CheckRequiredParameterValues() if this parameter changes
	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_locks_per_transaction"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of locks per transaction."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"The shared lock table is sized on the assumption that "</literal>
						 <literal type="string">"at most max_locks_per_transaction * max_connections distinct "</literal>
						 <literal type="string">"objects will need to be locked at any one time."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_locks_per_xact</name></expr>,
		<expr><literal type="number">64</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_pred_locks_per_transaction"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of predicate locks per transaction."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"The shared predicate lock table is sized on the assumption that "</literal>
						 <literal type="string">"at most max_pred_locks_per_transaction * max_connections distinct "</literal>
						 <literal type="string">"objects will need to be locked at any one time."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_predicate_locks_per_xact</name></expr>,
		<expr><literal type="number">64</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_pred_locks_per_relation"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of predicate-locked pages and tuples per relation."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"If more than this total of pages and tuples in the same relation are locked "</literal>
						 <literal type="string">"by a connection, those locks are replaced by a relation-level lock."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_predicate_locks_per_relation</name></expr>,
		<expr><operator>-</operator><literal type="number">2</literal></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_pred_locks_per_page"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of predicate-locked tuples per page."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"If more than this number of tuples on the same page are locked "</literal>
						 <literal type="string">"by a connection, those locks are replaced by a page-level lock."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_predicate_locks_per_page</name></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"authentication_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_AUTH</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum allowed time to complete client authentication."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>AuthenticationTimeout</name></expr>,
		<expr><literal type="number">60</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">600</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Not for general use */</comment>
		<expr><block>{<expr><literal type="string">"pre_auth_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Waits N seconds on connection startup before authentication."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"This allows attaching a debugger to the process."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>PreAuthDelay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">60</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_keep_segments"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_SENDING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of WAL files held for standby servers."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_keep_segments</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"min_wal_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum size to shrink the WAL to."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>min_wal_size_mb</name></expr>,
		<expr><name>DEFAULT_MIN_WAL_SEGS</name> <operator>*</operator> <operator>(</operator><name>DEFAULT_XLOG_SEG_SIZE</name> <operator>/</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_wal_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the WAL size that triggers a checkpoint."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_wal_size_mb</name></expr>,
		<expr><name>DEFAULT_MAX_WAL_SEGS</name> <operator>*</operator> <operator>(</operator><name>DEFAULT_XLOG_SEG_SIZE</name> <operator>/</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_max_wal_size</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"checkpoint_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum time between automatic WAL checkpoints."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>CheckPointTimeout</name></expr>,
		<expr><literal type="number">300</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">86400</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"checkpoint_warning"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables warnings if checkpoint segments are filled more "</literal>
						 <literal type="string">"frequently than this."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write a message to the server log if checkpoints "</literal>
						 <literal type="string">"caused by the filling of checkpoint segment files happens more "</literal>
						 <literal type="string">"frequently than this number of seconds. Zero turns off the warning."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>CheckPointWarning</name></expr>,
		<expr><literal type="number">30</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"checkpoint_flush_after"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of pages after which previously performed writes are flushed to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>checkpoint_flush_after</name></expr>,
		<expr><name>DEFAULT_CHECKPOINT_FLUSH_AFTER</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>WRITEBACK_MAX_PENDING_FLUSHES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_buffers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of disk-page buffers in shared memory for WAL."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_XBLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XLOGbuffers</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>(</operator><name>INT_MAX</name> <operator>/</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>,
		<expr><name>check_wal_buffers</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_writer_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time between WAL flushes performed in the WAL writer."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>WalWriterDelay</name></expr>,
		<expr><literal type="number">200</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_writer_flush_after"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Amount of WAL written out by WAL writer that triggers a flush."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_XBLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>WalWriterFlushAfter</name></expr>,
		<expr><operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <name>XLOG_BLCKSZ</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* see max_connections and superuser_reserved_connections */</comment>
		<expr><block>{<expr><literal type="string">"max_wal_senders"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>REPLICATION_SENDING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of simultaneously running WAL sender processes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_wal_senders</name></expr>,
		<expr><literal type="number">64</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* see max_wal_senders */</comment>
		<expr><block>{<expr><literal type="string">"max_replication_slots"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>REPLICATION_SENDING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of simultaneously defined replication slots."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_replication_slots</name></expr>,
		<expr><literal type="number">64</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_BACKENDS</name></expr> <comment type="block">/* XXX? */</comment> ,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_slot_wal_keep_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_SENDING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum WAL size that can be reserved by replication slots."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Replication slots will be marked as failed, and segments released "</literal>
						 <literal type="string">"for deletion or recycling, if this much space is occupied by WAL "</literal>
						 <literal type="string">"on disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_slot_wal_keep_size_mb</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_sender_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_SENDING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum time to wait for WAL replication."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_sender_timeout</name></expr>,
		<expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"commit_delay"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the delay in microseconds between transaction commit and "</literal>
						 <literal type="string">"flushing WAL to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
			<comment type="block">/* we have no microseconds designation, so can't supply units here */</comment>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>CommitDelay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">100000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"commit_siblings"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum concurrent open transactions before performing "</literal>
						 <literal type="string">"commit_delay."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>CommitSiblings</name></expr>,
		<expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"extra_float_digits"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of digits displayed for floating-point values."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"This affects real, double precision, and geometric data types. "</literal>
						 <literal type="string">"The parameter value is added to the standard number of digits "</literal>
						 <literal type="string">"(FLT_DIG or DBL_DIG as appropriate)."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>extra_float_digits</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><literal type="number">15</literal></expr>, <expr><literal type="number">3</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_min_duration_statement"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHEN</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum execution time above which "</literal>
						 <literal type="string">"statements will be logged."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Zero prints all queries. -1 turns this feature off."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_min_duration_statement</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_autovacuum_min_duration"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum execution time above which "</literal>
						 <literal type="string">"autovacuum actions will be logged."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Zero prints all actions. -1 turns autovacuum logging off."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_autovacuum_min_duration</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bgwriter_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Background writer sleep time between rounds."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>BgWriterDelay</name></expr>,
		<expr><literal type="number">200</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bgwriter_lru_maxpages"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Background writer maximum number of LRU pages to flush per round."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>bgwriter_lru_maxpages</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,	<comment type="block">/* Same upper limit as shared_buffers */</comment>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bgwriter_flush_after"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of pages after which previously performed writes are flushed to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>bgwriter_flush_after</name></expr>,
		<expr><name>DEFAULT_BGWRITER_FLUSH_AFTER</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>WRITEBACK_MAX_PENDING_FLUSHES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"effective_io_concurrency"</literal></expr>,
			<expr><name>PGC_USERSET</name></expr>,
			<expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of simultaneous requests that can be handled efficiently by the disk subsystem."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"For RAID arrays, this should be approximately the number of drive spindles in the array."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>effective_io_concurrency</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
		<expr><literal type="number">1</literal></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><literal type="number">0</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><literal type="number">0</literal></expr>, <expr><name>MAX_IO_CONCURRENCY</name></expr>,
		<expr><name>check_effective_io_concurrency</name></expr>, <expr><name>assign_effective_io_concurrency</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"backend_flush_after"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of pages after which previously performed writes are flushed to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>backend_flush_after</name></expr>,
		<expr><name>DEFAULT_BACKEND_FLUSH_AFTER</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>WRITEBACK_MAX_PENDING_FLUSHES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_worker_processes"</literal></expr>,
			<expr><name>PGC_POSTMASTER</name></expr>,
			<expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum number of concurrent worker processes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_worker_processes</name></expr>,
		<expr><literal type="number">24</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>check_max_worker_processes</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_logical_replication_workers"</literal></expr>,
			<expr><name>PGC_POSTMASTER</name></expr>,
			<expr><name>REPLICATION_SUBSCRIBERS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum number of logical replication worker processes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_logical_replication_workers</name></expr>,
		<expr><literal type="number">32</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_sync_workers_per_subscription"</literal></expr>,
			<expr><name>PGC_SIGHUP</name></expr>,
			<expr><name>REPLICATION_SUBSCRIBERS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum number of table synchronization workers per subscription."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_sync_workers_per_subscription</name></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_rotation_age"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Automatic log file rotation will occur after N minutes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_RotationAge</name></expr>,
		<expr><name>HOURS_PER_DAY</name> <operator>*</operator> <name>MINS_PER_HOUR</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <name>SECS_PER_MINUTE</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_rotation_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Automatic log file rotation will occur after N kilobytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_RotationSize</name></expr>,
		<expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1024</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">1024</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_function_args"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the maximum number of function arguments."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_function_args</name></expr>,
		<expr><name>FUNC_MAX_ARGS</name></expr>, <expr><name>FUNC_MAX_ARGS</name></expr>, <expr><name>FUNC_MAX_ARGS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_index_keys"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the maximum number of index keys."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_index_keys</name></expr>,
		<expr><name>INDEX_MAX_KEYS</name></expr>, <expr><name>INDEX_MAX_KEYS</name></expr>, <expr><name>INDEX_MAX_KEYS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_identifier_length"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the maximum identifier length."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_identifier_length</name></expr>,
		<expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>, <expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>, <expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"block_size"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the size of a disk block."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>block_size</name></expr>,
		<expr><name>BLCKSZ</name></expr>, <expr><name>BLCKSZ</name></expr>, <expr><name>BLCKSZ</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"segment_size"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the number of pages per disk file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>segment_size</name></expr>,
		<expr><name>RELSEG_SIZE</name></expr>, <expr><name>RELSEG_SIZE</name></expr>, <expr><name>RELSEG_SIZE</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_block_size"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the block size in the write ahead log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_block_size</name></expr>,
		<expr><name>XLOG_BLCKSZ</name></expr>, <expr><name>XLOG_BLCKSZ</name></expr>, <expr><name>XLOG_BLCKSZ</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_retrieve_retry_interval"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the time to wait before retrying to retrieve WAL "</literal>
						 <literal type="string">"after a failed attempt."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_retrieve_retry_interval</name></expr>,
		<expr><literal type="number">5000</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_segment_size"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the size of write ahead log segments."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BYTE</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_segment_size</name></expr>,
		<expr><name>DEFAULT_XLOG_SEG_SIZE</name></expr>,
		<expr><name>WalSegMinSize</name></expr>,
		<expr><name>WalSegMaxSize</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_naptime"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time to sleep between autovacuum runs."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_naptime</name></expr>,
		<expr><literal type="number">60</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_vacuum_threshold"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Minimum number of tuple updates or deletes prior to vacuum."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_vac_thresh</name></expr>,
		<expr><literal type="number">50</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_analyze_threshold"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Minimum number of tuple inserts, updates, or deletes prior to analyze."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_anl_thresh</name></expr>,
		<expr><literal type="number">50</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<comment type="block">/* see varsup.c for why this is PGC_POSTMASTER not PGC_SIGHUP */</comment>
		<expr><block>{<expr><literal type="string">"autovacuum_freeze_max_age"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Age at which to autovacuum a table to prevent transaction ID wraparound."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_freeze_max_age</name></expr>,
		<comment type="block">/* see pg_resetwal if you change the upper-limit value */</comment>
		<expr><literal type="number">200000000</literal></expr>, <expr><literal type="number">100000</literal></expr>, <expr><literal type="number">2000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<comment type="block">/* see multixact.c for why this is PGC_POSTMASTER not PGC_SIGHUP */</comment>
		<expr><block>{<expr><literal type="string">"autovacuum_multixact_freeze_max_age"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Multixact age at which to autovacuum a table to prevent multixact wraparound."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_multixact_freeze_max_age</name></expr>,
		<expr><literal type="number">400000000</literal></expr>, <expr><literal type="number">10000</literal></expr>, <expr><literal type="number">2000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<comment type="block">/* see max_connections */</comment>
		<expr><block>{<expr><literal type="string">"autovacuum_max_workers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of simultaneously running autovacuum worker processes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_max_workers</name></expr>,
		<expr><literal type="number">3</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>check_autovacuum_max_workers</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_parallel_maintenance_workers"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of parallel processes per maintenance operation."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_parallel_maintenance_workers</name></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1024</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_parallel_workers_per_gather"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of parallel processes per executor node."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_parallel_workers_per_gather</name></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_PARALLEL_WORKER_LIMIT</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_parallel_workers"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of parallel workers that can be active at one time."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_parallel_workers</name></expr>,
		<expr><literal type="number">16</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_PARALLEL_WORKER_LIMIT</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_work_mem"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum memory to be used by each autovacuum worker process."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_work_mem</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>check_autovacuum_work_mem</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"old_snapshot_threshold"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time before a snapshot is too old to read pages changed after the snapshot was taken."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of -1 disables this feature."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>old_snapshot_threshold</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>MINS_PER_HOUR</name> <operator>*</operator> <name>HOURS_PER_DAY</name> <operator>*</operator> <literal type="number">60</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"tcp_keepalives_idle"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time between issuing TCP keepalives."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 uses the system default."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>tcp_keepalives_idle</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_tcp_keepalives_idle</name></expr>, <expr><name>show_tcp_keepalives_idle</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"tcp_keepalives_interval"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time between TCP keepalive retransmits."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 uses the system default."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>tcp_keepalives_interval</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_tcp_keepalives_interval</name></expr>, <expr><name>show_tcp_keepalives_interval</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_renegotiation_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"SSL renegotiation is no longer supported; this can only be 0."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_renegotiation_limit</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"tcp_keepalives_count"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum number of TCP keepalive retransmits."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"This controls the number of consecutive keepalive retransmits that can be "</literal>
						 <literal type="string">"lost before a connection is considered dead. A value of 0 uses the "</literal>
						 <literal type="string">"system default."</literal></expr></argument>)</argument_list></call></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>tcp_keepalives_count</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_tcp_keepalives_count</name></expr>, <expr><name>show_tcp_keepalives_count</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"gin_fuzzy_search_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum allowed result for exact search by GIN."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><literal type="number">0</literal></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>GinFuzzySearchLimit</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"effective_cache_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's assumption about the total size of the data caches."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"That is, the total size of the caches (kernel cache and shared buffers) used for PostgreSQL data files. "</literal>
						 <literal type="string">"This is measured in disk pages, which are normally 8 kB each."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>effective_cache_size</name></expr>,
		<expr><name>DEFAULT_EFFECTIVE_CACHE_SIZE</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"min_parallel_table_scan_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum amount of table data for a parallel scan."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"If the planner estimates that it will read a number of table pages too small to reach this limit, a parallel scan will not be considered."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>min_parallel_table_scan_size</name></expr>,
		<expr><operator>(</operator><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">3</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"min_parallel_index_scan_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum amount of index data for a parallel scan."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"If the planner estimates that it will read a number of index pages too small to reach this limit, a parallel scan will not be considered."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>min_parallel_index_scan_size</name></expr>,
		<expr><operator>(</operator><literal type="number">512</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">3</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Can't be set in postgresql.conf */</comment>
		<expr><block>{<expr><literal type="string">"server_version_num"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the server version as an integer."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>server_version_num</name></expr>,
		<expr><name>PG_VERSION_NUM</name></expr>, <expr><name>PG_VERSION_NUM</name></expr>, <expr><name>PG_VERSION_NUM</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_temp_files"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Log the use of temporary files larger than this number of kilobytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Zero logs all files. The default is -1 (turning this feature off)."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_temp_files</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_activity_query_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the size reserved for pg_stat_activity.query, in bytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BYTE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pgstat_track_activity_query_size</name></expr>,
		<expr><literal type="number">1024</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><literal type="number">102400</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"gin_pending_list_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum size of the pending list for GIN index."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>gin_pending_list_limit</name></expr>,
		<expr><literal type="number">4096</literal></expr>, <expr><literal type="number">64</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* POLAR Int GUCs, the end of block */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_non_super_conns"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control number of max connections allowed for non-super users"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_non_super_conns</name></expr>,
		<comment type="block">/* -1 means this variable is disabled */</comment>
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_super_conns"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control number of max connections allowed for super users"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_super_conns</name></expr>,
		<comment type="block">/* -1 means this variable is disabled */</comment>
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<comment type="block">/* num of walsenders reserved for superuser */</comment>
		<expr><block>{<expr><literal type="string">"polar_wal_snd_reserved_for_superuser"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of walsenders reserved for superuser."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wal_snd_reserved_for_superuser</name></expr>,
		<expr><literal type="number">32</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_reserved_polar_super_conns"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control number of max connections allowed for polar_super users"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_reserved_polar_super_conns</name></expr>,
		<expr><literal type="number">8</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<comment type="block">/* num of replication slots reserved for superuser */</comment>
		<expr><block>{<expr><literal type="string">"polar_repl_slots_reserved_for_superuser"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the num of replication slots reserved for superuser."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_repl_slots_reserved_for_superuser</name></expr>,
		<expr><literal type="number">32</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<comment type="block">/* num of replication workers reserved for superuser */</comment>
		<expr><block>{<expr><literal type="string">"polar_logical_repl_workers_reserved_for_superuser"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the num of replication workers reserved for superuser."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_logical_repl_workers_reserved_for_superuser</name></expr>,
		<expr><literal type="number">16</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_log_files"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control number of max pg sys log files"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_log_files</name></expr>,
		<comment type="block">/* -1 means this variable is disabled */</comment>
		<expr><literal type="number">20</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_auditlog_files"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control number of max pg audit log files"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_auditlog_files</name></expr>,
		<comment type="block">/* -1 means this variable is disabled */</comment>
		<expr><literal type="number">20</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_slowlog_files"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control number of max pg slow log files"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_slowlog_files</name></expr>,
		<comment type="block">/* -1 means this variable is disabled */</comment>
		<expr><literal type="number">20</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_logindex_files"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control number of max logindex files.This param is used when truncate logindex file"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_logindex_files</name></expr>,
		<expr><literal type="number">80</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<comment type="block">/* POLAR */</comment>
 	<expr><block>{
 		<expr><block>{<expr><literal type="string">"polar_num_of_sysloggers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>LOGGING</name></expr>,
 			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of syslogger process."</literal></expr></argument>)</argument_list></call></expr>,
 			<expr><name>NULL</name></expr>,
 		}</block></expr>,
 		<expr><operator>&amp;</operator><name>polar_num_of_sysloggers</name></expr>,
 		<expr><name>DEFAULT_SYSLOGGER_NUM</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>MAX_SYSLOGGER_NUM</name></expr>,
 		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
 	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_bulk_extend_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the size of preallocate file, 0 (turning this feature off)."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_bulk_extend_size</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_clog_max_local_cache_segments"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the maximum number of local segment file cache for clog"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_clog_max_local_cache_segments</name></expr>,
		<expr><literal type="number">128</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_logindex_max_local_cache_segments"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the maximum number of local segment file cache for logindex"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_logindex_max_local_cache_segments</name></expr>,
		<expr><literal type="number">32</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_parallel_replay_proc_num"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number of processes to do parallel replay"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_parallel_replay_proc_num</name></expr>,
		<expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">256</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_parallel_replay_task_queue_depth"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the task queue depth when do parallel replay"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_parallel_replay_task_queue_depth</name></expr>,
		<expr><literal type="number">1024</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1048576</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
	
		<expr><block>{<expr><literal type="string">"polar_commit_ts_max_local_cache_segments"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the maximum number of local segment file cache for commit_ts"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_commit_ts_max_local_cache_segments</name></expr>,
		<expr><literal type="number">32</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
	
		<expr><block>{<expr><literal type="string">"polar_csnlog_max_local_cache_segments"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the maximum number of local segment file cache for csnlog"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_csnlog_max_local_cache_segments</name></expr>,
		<expr><literal type="number">256</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_index_bulk_extend_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the size of preallocate file for index, 0 (turning this feature off)."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<comment type="block">/* POLAR: default 1MB */</comment>
		<expr><operator>&amp;</operator><name>polar_index_bulk_extend_size</name></expr>,
		<expr><literal type="number">128</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_multixact_max_local_cache_segments"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the maximum number of local segment file cache for multixact"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_multixact_max_local_cache_segments</name></expr>,
		<expr><literal type="number">32</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_min_bulk_extend_table_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum amount of table data for bulk extend, "</literal>
						 <literal type="string">"bulk extend is enabled only when the table size &gt;= polar_min_bulk_extend_table_size"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_min_bulk_extend_table_size</name></expr>,
		<expr><operator>(</operator><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_recovery_bulk_extend_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the size for bulk file extension while replaying xlog on standby (0 turns this feature off)."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_recovery_bulk_extend_size</name></expr>,
		<expr><literal type="number">512</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2048</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_bulk_read_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets size of bulk read, 0 (turning this feature off)."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_bulk_read_size</name></expr>,
		<expr><operator>(</operator><literal type="number">128</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>POLAR_MAX_BULK_IO_SIZE</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_index_create_bulk_extend_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the size of preallocate file for index create, 0 (turning this feature off)."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<comment type="block">/* POLAR: default 4MB */</comment>
		<expr><operator>&amp;</operator><name>polar_index_create_bulk_extend_size</name></expr>,
		<expr><literal type="number">512</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_xlog_page_buffers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the size of xlog buffer used by startup and backedn in replica and standby mode."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_xlog_page_buffers</name></expr>,
		<expr><literal type="number">1</literal> <operator>*</operator> <literal type="number">1024</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_xlog_queue_buffers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the size of xlog queue buffer used to keep xlog meta. 0 means disable xlog buffer"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_xlog_queue_buffers</name></expr>,
		<expr><literal type="number">512</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_bg_replay_batch_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Batch size of each bgwriter replay run."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_bg_replay_batch_size</name></expr>,
		<expr><literal type="number">20000</literal></expr>, <expr><literal type="number">1000</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_virtual_pid"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the process cancel key which connect to rds proxy ."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_virtual_pid</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>INT32_MIN</name></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>polar_assign_virtual_pid</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_cancel_key"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the process cancel key which connect to rds proxy ."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_cancel_key</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>INT32_MIN</name></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>polar_assign_cancel_key</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_fullpage_snapshot_min_modified_count"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum modified count when log fullpage"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_fullpage_snapshot_min_modified_count</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_fullpage_snapshot_replay_delay_threshold"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Max diff lsn(MB) between page lsn and replay_lsn when log fullpage snapshot."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_fullpage_snapshot_replay_delay_threshold</name></expr>,
		<expr><literal type="number">16</literal></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_fullpage_snapshot_oldest_lsn_delay_threshold"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Minimum diff lsn(MB) between insert lsn and oldest_lsn when log fullpage snapshot."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_fullpage_snapshot_oldest_lsn_delay_threshold</name></expr>,
		<expr><literal type="number">1024</literal></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_write_logindex_active_table_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time between walwriter write active logindex table."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_write_logindex_active_table_delay</name></expr>,
		<expr><literal type="number">500</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_startup_replay_delay_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Manual startup replay delay wal size(MB), just for test!"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_startup_replay_delay_size</name></expr>,
		<expr><literal type="number">0</literal></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">40960</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_wait_old_version_page_timeout"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum time to wait for old version page when reading a future page."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_wait_old_version_page_timeout</name></expr>,
		<expr><literal type="number">30</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_fullpage_keep_segments"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of FULLPAGE files held for replica."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_fullpage_keep_segments</name></expr>,
		<expr><literal type="number">16</literal></expr>,
		<expr><literal type="number">3</literal></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_sync_replication_timeout"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum time to wait for WAL synchronous replication."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off the timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_sync_replication_timeout</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_sync_rep_timeout_break_lsn_lag"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimal lag between each process and timeout synchronous replication flush or write or apply lsn, in bytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"When the lag exceed the value, timeout synchronous replication back to synchronous."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_BYTE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_sync_rep_timeout_break_lsn_lag</name></expr>,
		<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_semi_sync_observation_window"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"The maximum window time to observe whether the network is healthy."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"If it is less than 2 * polar_sync_replication_timeout, it will be ignored."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_semi_sync_observation_window</name></expr>,
		<expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_semi_sync_max_backoff_window"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum value of semi-synchronous replication backoff window."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_semi_sync_max_backoff_window</name></expr>,
		<expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_semi_sync_min_backoff_window"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum initial value of the semi-synchronous replication backoff window."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_semi_sync_min_backoff_window</name></expr>,
		<expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_async_ddl_lock_replay_worker_num"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Async ddl lock replay worker count."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_async_ddl_lock_replay_worker_num</name></expr>,
		<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_ASYNC_DDL_LOCK_REPLAY_WORKER_NUM</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_datamax_remove_archivedone_wal_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time between remove archive done wal"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<comment type="block">/* POLAR: 0 means invalid remove archivedone wal */</comment>
		<expr><operator>&amp;</operator><name>polar_datamax_remove_archivedone_wal_timeout</name></expr>,
		<expr><literal type="number">60000</literal></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_datamax_archive_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time between archive wal"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<comment type="block">/* POLAR: 0 means invalid archive */</comment>
		<expr><operator>&amp;</operator><name>polar_datamax_archive_timeout</name></expr>,
		<expr><literal type="number">60000</literal></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_datamax_save_replication_slots_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time between save replication slots in datamax mode"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<comment type="block">/* POLAR: 0 means invalid save replication slots */</comment>
		<expr><operator>&amp;</operator><name>polar_datamax_save_replication_slots_timeout</name></expr>,
		<expr><literal type="number">300000</literal></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_datamax_prealloc_walfile_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time between prealloc wal file in datamax mode"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<comment type="block">/* POLAR: 0 means invalid prealloc walfile */</comment>
		<expr><operator>&amp;</operator><name>polar_datamax_prealloc_walfile_timeout</name></expr>,
		<expr><literal type="number">30000</literal></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_datamax_prealloc_walfile_num"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Prealloc walfile num in datamax mode"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_datamax_prealloc_walfile_num</name></expr>,
		<expr><literal type="number">2</literal></expr>,
		<expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_log_buffers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of disk-page(8kB) buffers in shared memory for flashback log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_log_buffers</name></expr>,
		<expr><name>POLAR_FLOG_DEFAULT_BUFFERS</name></expr>, <expr><literal type="number">4</literal></expr>, <expr><operator>(</operator><name>INT_MAX</name> <operator>/</operator> <name>POLAR_FLOG_BLCKSZ</name><operator>)</operator></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_log_insert_locks"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the number of locks for flashback log buffer insert"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_log_insert_locks</name></expr>,
		<expr><name>POLAR_FLOG_DEFAULT_BUFF_INSERT_LOCKS</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_log_keep_segments"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of flashback log files held, the files will be recycled."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_log_keep_segments</name></expr>,
		<expr><literal type="number">8</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>INT32_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_logindex_queue_buffers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the size (MB) of log queue buffer used to keep flashback logindex. "</literal>
					<literal type="string">"0 means disable flashback logindex queue"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_logindex_queue_buffers</name></expr>,
		<expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_log_bgwrite_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Flashback log background writer sleep time between rounds."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_log_bgwrite_delay</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_log_sync_buf_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"The process wait N ms before background worker inserting "</literal>
					<literal type="string">"flashback log record into buffer."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_log_sync_buf_timeout</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_log_insert_list_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Flashback log list background sleep time between rounds."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_log_insert_list_delay</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_log_flush_max_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Flashback log background writer will flush log no more than N kilobytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_log_flush_max_size</name></expr>,
		<expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">1024</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">1024</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_log_insert_list_max_num"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Flashback log background inserter will insert no more than N records."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_log_insert_list_max_num</name></expr>,
		<expr><literal type="number">10240</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_point_segments"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum WAL distance between automatic flashback point."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_point_segments</name></expr>,
		<expr><literal type="number">20</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_flashback_point_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum time between automatic flashback point."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_flashback_point_timeout</name></expr>,
		<expr><literal type="number">300</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">86400</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* POLAR end */</comment>


	<comment type="block">/* POLAR: gap limit between local redoptr and shared redoptr for replica */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_replica_redo_gap_limit"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"gap limit between local redoptr and shared redoptr for replica, copy base dirs and other trans status log files when gap exceeds the limit"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"disable the gap comparison when set 0, which means copy process will execute unconditionally when replica start"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_replica_redo_gap_limit</name></expr>,
		<expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_crash_recovery_rto"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the polar crash recovery rto."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off this option."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_S</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_crash_recovery_rto</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>polar_assign_crash_recovery_rto</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_crash_recovery_rto_delay_count"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the polar crash recovery delay time."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off this option."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_crash_recovery_rto_delay_count</name></expr>,
		<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>polar_assign_crash_recovery_rto_delay_time</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_io_read_throughtput_userset"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the io read throughtput by users."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off this option."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_io_read_throughtput_userset</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_crash_recovery_rto_statistics_count"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the polar crash recovery rto max statistics time."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off this option."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_crash_recovery_rto_statistics_count</name></expr>,
		<expr><literal type="number">100000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_bt_write_page_buffer_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the size of btbuild index page write buffer size."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_bt_write_page_buffer_size</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">8192</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_instance_spec_cpu"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PolarDB instance specification for cpu."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_instance_spec_cpu</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_instance_spec_mem"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PolarDB instance specification for memory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_instance_spec_mem</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_instance_spec_normal_mem"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PolarDB instance specification for normal memory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_instance_spec_normal_mem</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_dsm_request_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PolarDB max DSM memory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"0 means no limit."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_dsm_request_size</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_hashagg_mem"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PolarDB max HashAggregation operator memory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"0 means no limit."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_hashagg_mem</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_setop_mem"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PolarDB max SetOp operator memory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"0 means no limit."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_setop_mem</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_subplan_mem"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PolarDB max Subplan operator memory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"0 means no limit."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_subplan_mem</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_recursiveunion_mem"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PolarDB max RecursiveUnion operator memory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"0 means no limit."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_recursiveunion_mem</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* POLAR: relax strategies for cas spin */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>POLAR_ARM_S_LOCK_RELAX</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_spin_nops"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of nops in spin lock."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_spin_nops</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_spin_yield"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets yield in spin lock."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_spin_yield</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/* End-of-list marker */</comment>
	<expr><block>{
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_real</name></name></type> <name><name>ConfigureNamesReal</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><block>{<expr><literal type="string">"seq_page_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of a "</literal>
						 <literal type="string">"sequentially fetched disk page."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>seq_page_cost</name></expr>,
		<expr><name>DEFAULT_SEQ_PAGE_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"random_page_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of a "</literal>
						 <literal type="string">"nonsequentially fetched disk page."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>random_page_cost</name></expr>,
		<expr><name>DEFAULT_RANDOM_PAGE_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"cpu_tuple_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of "</literal>
						 <literal type="string">"processing each tuple (row)."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>cpu_tuple_cost</name></expr>,
		<expr><name>DEFAULT_CPU_TUPLE_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"cpu_index_tuple_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of "</literal>
						 <literal type="string">"processing each index entry during an index scan."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>cpu_index_tuple_cost</name></expr>,
		<expr><name>DEFAULT_CPU_INDEX_TUPLE_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"cpu_operator_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of "</literal>
						 <literal type="string">"processing each operator or function call."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>cpu_operator_cost</name></expr>,
		<expr><name>DEFAULT_CPU_OPERATOR_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_stat_stale_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
		 	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Add some extra cost to reduce the impact of stale statistics "</literal>
				<literal type="string">"0.01 should be a good value to start with"</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_stat_stale_cost</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"parallel_tuple_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of "</literal>
						 <literal type="string">"passing each tuple (row) from worker to master backend."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>parallel_tuple_cost</name></expr>,
		<expr><name>DEFAULT_PARALLEL_TUPLE_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"parallel_setup_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of "</literal>
						 <literal type="string">"starting up worker processes for parallel query."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>parallel_setup_cost</name></expr>,
		<expr><name>DEFAULT_PARALLEL_SETUP_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_above_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Perform JIT compilation if query is more expensive."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"-1 disables JIT compilation."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_above_cost</name></expr>,
		<expr><literal type="number">100000</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_optimize_above_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Optimize JITed functions if query is more expensive."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"-1 disables optimization."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_optimize_above_cost</name></expr>,
		<expr><literal type="number">500000</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_inline_above_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Perform JIT inlining if query is more expensive."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"-1 disables inlining."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_inline_above_cost</name></expr>,
		<expr><literal type="number">500000</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"cursor_tuple_fraction"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the fraction of "</literal>
						 <literal type="string">"a cursor's rows that will be retrieved."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>cursor_tuple_fraction</name></expr>,
		<expr><name>DEFAULT_CURSOR_TUPLE_FRACTION</name></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_selection_bias"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_GEQO</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"GEQO: selective pressure within the population."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Geqo_selection_bias</name></expr>,
		<expr><name>DEFAULT_GEQO_SELECTION_BIAS</name></expr>,
		<expr><name>MIN_GEQO_SELECTION_BIAS</name></expr>, <expr><name>MAX_GEQO_SELECTION_BIAS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_seed"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_GEQO</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"GEQO: seed for random path selection."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Geqo_seed</name></expr>,
		<expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bgwriter_lru_multiplier"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Multiple of the average buffer usage to free per round."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>bgwriter_lru_multiplier</name></expr>,
		<expr><literal type="number">2.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">10.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"seed"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the seed for random-number generation."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>phony_random_seed</name></expr>,
		<expr><literal type="number">0.0</literal></expr>, <expr><operator>-</operator><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>,
		<expr><name>check_random_seed</name></expr>, <expr><name>assign_random_seed</name></expr>, <expr><name>show_random_seed</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_vacuum_scale_factor"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of tuple updates or deletes prior to vacuum as a fraction of reltuples."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_vac_scale</name></expr>,
		<expr><literal type="number">0.2</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">100.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_analyze_scale_factor"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of tuple inserts, updates, or deletes prior to analyze as a fraction of reltuples."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_anl_scale</name></expr>,
		<expr><literal type="number">0.1</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">100.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"checkpoint_completion_target"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>CheckPointCompletionTarget</name></expr>,
		<expr><literal type="number">0.5</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cleanup_index_scale_factor"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of tuple inserts prior to index cleanup as a fraction of reltuples."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_cleanup_index_scale_factor</name></expr>,
		<expr><literal type="number">0.1</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">1e10</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_crash_recovery_rto_threshold"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the polar crash recovery threshold time to delay."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_crash_recovery_rto_threshold</name></expr>,
		<expr><literal type="number">0.8</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>polar_assign_crash_recovery_rto_threshold</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<comment type="block">/* POLAR begin */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_max_normal_backends_factor"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A switch to control max allowed normal backends based on max_connections"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_max_normal_backends_factor</name></expr>,
		<expr><literal type="number">1.2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>polar_assign_max_normal_backends</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<comment type="block">/* POLAR end*/</comment>
	<comment type="block">/* End-of-list marker */</comment>
	<expr><block>{
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_string</name></name></type> <name><name>ConfigureNamesString</name><index>[]</index></name> <init>=
<expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DMA</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_members_info"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar consensus nodes info"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_members_info_string</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_learners_info"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar consensus learners info"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_learners_info_string</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_logger_start_point"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar consensus logger start point"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_start_point_string</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_repl_slotname"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"consensus replication slot name"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_repl_slot_name</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_repl_appname"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"consensus replication application name"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_repl_app_name</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_repl_user"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"consensus replication user"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_repl_user</name></expr>,
		<expr><literal type="string">"repl"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_repl_passwd"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"consensus replication password"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_dma_repl_password</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>show_polar_dma_repl_password</name></expr> 
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_storage_cluster_name"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polar storage cluster name"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_storage_cluster_name</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_datadir"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>POLAR_NODE_STATIC</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"polardb datadir."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_datadir</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_polar_datadir</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_disk_name"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>POLAR_NODE_STATIC</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"The virtual disk name privided by polarFS."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_disk_name</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"archive_command"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_ARCHIVING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the shell command that will be called to archive a WAL file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XLogArchiveCommand</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>show_archive_command</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"client_encoding"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the client's character set encoding."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name> <operator>|</operator> <name>GUC_REPORT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>client_encoding_string</name></expr>,
		<expr><literal type="string">"SQL_ASCII"</literal></expr>,
		<expr><name>check_client_encoding</name></expr>, <expr><name>assign_client_encoding</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_line_prefix"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Controls information prefixed to each log line."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"If blank, no prefix is used."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_line_prefix</name></expr>,
		<expr><literal type="string">"%m [%p] "</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_timezone"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the time zone to use in log messages."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_timezone_string</name></expr>,
		<expr><literal type="string">"GMT"</literal></expr>,
		<expr><name>check_log_timezone</name></expr>, <expr><name>assign_log_timezone</name></expr>, <expr><name>show_log_timezone</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"DateStyle"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the display format for date and time values."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Also controls interpretation of ambiguous "</literal>
						 <literal type="string">"date inputs."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_REPORT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>datestyle_string</name></expr>,
		<expr><literal type="string">"ISO, MDY"</literal></expr>,
		<expr><name>check_datestyle</name></expr>, <expr><name>assign_datestyle</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_tablespace"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the default tablespace to create tables and indexes in."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"An empty string selects the database's default tablespace."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_IS_NAME</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>default_tablespace</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_default_tablespace</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"temp_tablespaces"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the tablespace(s) to use for temporary tables and sort files."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>temp_tablespaces</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_temp_tablespaces</name></expr>, <expr><name>assign_temp_tablespaces</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"dynamic_library_path"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the path for dynamically loadable modules."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"If a dynamically loadable module needs to be opened and "</literal>
						 <literal type="string">"the specified name does not have a directory component (i.e., the "</literal>
						 <literal type="string">"name does not contain a slash), the system will search this path for "</literal>
						 <literal type="string">"the specified file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Dynamic_library_path</name></expr>,
		<expr><literal type="string">"$libdir"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"krb_server_keyfile"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_AUTH</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the location of the Kerberos server key file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pg_krb_server_keyfile</name></expr>,
		<expr><name>PG_KRB_SRVTAB</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bonjour_name"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the Bonjour service name."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>bonjour_name</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* See main.c about why defaults for LC_foo are not all alike */</comment>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_collate"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the collation order locale."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_collate</name></expr>,
		<expr><literal type="string">"C"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_ctype"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the character classification and case conversion locale."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_ctype</name></expr>,
		<expr><literal type="string">"C"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_messages"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the language in which messages are displayed."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_messages</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_locale_messages</name></expr>, <expr><name>assign_locale_messages</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_monetary"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the locale for formatting monetary amounts."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_monetary</name></expr>,
		<expr><literal type="string">"C"</literal></expr>,
		<expr><name>check_locale_monetary</name></expr>, <expr><name>assign_locale_monetary</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_numeric"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the locale for formatting numbers."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_numeric</name></expr>,
		<expr><literal type="string">"C"</literal></expr>,
		<expr><name>check_locale_numeric</name></expr>, <expr><name>assign_locale_numeric</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_time"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the locale for formatting date and time values."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_time</name></expr>,
		<expr><literal type="string">"C"</literal></expr>,
		<expr><name>check_locale_time</name></expr>, <expr><name>assign_locale_time</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* POLAR: it's safe for non-superuser to change it */</comment>
		<expr><block>{<expr><literal type="string">"session_preload_libraries"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_PRELOAD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Lists shared libraries to preload into each backend."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>session_preload_libraries_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_session_preload_libs</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"shared_preload_libraries"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CLIENT_CONN_PRELOAD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Lists shared libraries to preload into server."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>shared_preload_libraries_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"local_preload_libraries"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_PRELOAD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Lists unprivileged shared libraries to preload into each backend."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>local_preload_libraries_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"search_path"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the schema search order for names that are not schema-qualified."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>namespace_search_path</name></expr>,
		<expr><literal type="string">"\"$user\", public"</literal></expr>,
		<expr><name>check_search_path</name></expr>, <expr><name>assign_search_path</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Can't be set in postgresql.conf */</comment>
		<expr><block>{<expr><literal type="string">"server_encoding"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the server (database) character set encoding."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name> <operator>|</operator> <name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>server_encoding_string</name></expr>,
		<expr><literal type="string">"SQL_ASCII"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Can't be set in postgresql.conf */</comment>
		<expr><block>{<expr><literal type="string">"server_version"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the server version."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>server_version_string</name></expr>,
		<expr><name>PG_VERSION</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Not for general use --- used by SET ROLE */</comment>
		<expr><block>{<expr><literal type="string">"role"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the current role."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>role_string</name></expr>,
		<expr><literal type="string">"none"</literal></expr>,
		<expr><name>check_role</name></expr>, <expr><name>assign_role</name></expr>, <expr><name>show_role</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Not for general use --- used by SET SESSION AUTHORIZATION */</comment>
		<expr><block>{<expr><literal type="string">"session_authorization"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the session user name."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name> <operator>|</operator> <name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>session_authorization_string</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>check_session_authorization</name></expr>, <expr><name>assign_session_authorization</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_destination"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the destination for server log output."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Valid values are combinations of \"stderr\", "</literal>
						 <literal type="string">"\"syslog\", \"csvlog\", and \"eventlog\", "</literal>
						 <literal type="string">"depending on the platform."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_LIST_INPUT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_destination_string</name></expr>,
		<expr><literal type="string">"polar_multi_dest"</literal></expr>,   <comment type="block">/* POLAR */</comment>
		<expr><name>check_log_destination</name></expr>, <expr><name>assign_log_destination</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_directory"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the destination directory for log files."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Can be specified as relative to the data directory "</literal>
						 <literal type="string">"or as absolute path."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_directory</name></expr>,
		<expr><literal type="string">"log"</literal></expr>,
		<expr><name>check_canonical_path</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_filename"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the file name pattern for log files."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_filename</name></expr>,
		<expr><literal type="string">"postgresql-%Y-%m-%d_%H%M%S.log"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"syslog_ident"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the program name used to identify PostgreSQL "</literal>
						 <literal type="string">"messages in syslog."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>syslog_ident_str</name></expr>,
		<expr><literal type="string">"postgres"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_syslog_ident</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"event_source"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the application name used to identify "</literal>
						 <literal type="string">"PostgreSQL messages in the event log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>event_source</name></expr>,
		<expr><name>DEFAULT_EVENT_SOURCE</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"TimeZone"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the time zone for displaying and interpreting time stamps."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>timezone_string</name></expr>,
		<expr><literal type="string">"GMT"</literal></expr>,
		<expr><name>check_timezone</name></expr>, <expr><name>assign_timezone</name></expr>, <expr><name>show_timezone</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"timezone_abbreviations"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Selects a file of time zone abbreviations."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>timezone_abbreviations_string</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>check_timezone_abbreviations</name></expr>, <expr><name>assign_timezone_abbreviations</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"transaction_isolation"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the current transaction's isolation level."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XactIsoLevel_string</name></expr>,
		<expr><literal type="string">"default"</literal></expr>,
		<expr><name>check_XactIsoLevel</name></expr>, <expr><name>assign_XactIsoLevel</name></expr>, <expr><name>show_XactIsoLevel</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"unix_socket_group"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the owning group of the Unix-domain socket."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"The owning user of the socket is always the user "</literal>
						 <literal type="string">"that starts the server."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Unix_socket_group</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"unix_socket_directories"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the directories where Unix-domain sockets will be created."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Unix_socket_directories</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
		<expr><name>DEFAULT_PGSOCKET_DIR</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><literal type="string">""</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"listen_addresses"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the host name or IP address(es) to listen to."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ListenAddresses</name></expr>,
		<expr><literal type="string">"localhost"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/*
		 * Can't be set by ALTER SYSTEM as it can lead to recursive definition
		 * of data_directory.
		 */</comment>
		<expr><block>{<expr><literal type="string">"data_directory"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>FILE_LOCATIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the server's data directory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>data_directory</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"config_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>FILE_LOCATIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the server's main configuration file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_DISALLOW_IN_FILE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ConfigFileName</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"hba_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>FILE_LOCATIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the server's \"hba\" configuration file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>HbaFileName</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ident_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>FILE_LOCATIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the server's \"ident\" configuration file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>IdentFileName</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_dma_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>FILE_LOCATIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the server's \"polar_dma\" configuration file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>PolarDMAFileName</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"external_pid_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>FILE_LOCATIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes the postmaster PID to the specified file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>external_pid_file</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>check_canonical_path</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_cert_file"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location of the SSL server certificate file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_cert_file</name></expr>,
		<expr><literal type="string">"server.crt"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_key_file"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location of the SSL server private key file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_key_file</name></expr>,
		<expr><literal type="string">"server.key"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_ca_file"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location of the SSL certificate authority file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_ca_file</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_crl_file"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location of the SSL certificate revocation list file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_crl_file</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"stats_temp_directory"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes temporary statistics files to the specified directory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pgstat_temp_directory</name></expr>,
		<expr><name>PG_STAT_TMP_DIR</name></expr>,
		<expr><name>check_canonical_path</name></expr>, <expr><name>assign_pgstat_temp_directory</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"synchronous_standby_names"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of synchronous standbys and list of names of potential synchronous ones."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>SyncRepStandbyNames</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_synchronous_standby_names</name></expr>, <expr><name>assign_synchronous_standby_names</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_text_search_config"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets default text search configuration."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>TSCurrentConfig</name></expr>,
		<expr><literal type="string">"pg_catalog.simple"</literal></expr>,
		<expr><name>check_TSCurrentConfig</name></expr>, <expr><name>assign_TSCurrentConfig</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_ciphers"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the list of allowed SSL ciphers."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>SSLCipherSuites</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<expr><literal type="string">"HIGH:MEDIUM:+3DES:!aNULL"</literal></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><literal type="string">"none"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_ecdh_curve"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the curve to use for ECDH."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>SSLECDHCurve</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<expr><literal type="string">"prime256v1"</literal></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><literal type="string">"none"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_dh_params_file"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location of the SSL DH parameters file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_dh_params_file</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_passphrase_command"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Command to obtain passphrases for SSL."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_passphrase_command</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"application_name"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the application name to be reported in statistics and logs."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name> <operator>|</operator> <name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>application_name</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_application_name</name></expr>, <expr><name>assign_application_name</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"cluster_name"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>PROCESS_TITLE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the name of the cluster, which is included in the process title."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>cluster_name</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_cluster_name</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_consistency_checking"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the WAL resource managers for which WAL consistency checks are done."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Full-page images will be logged for all data blocks and cross-checked against the results of WAL replay."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_consistency_checking_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_wal_consistency_checking</name></expr>, <expr><name>assign_wal_consistency_checking</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_provider"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CLIENT_CONN_PRELOAD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"JIT provider to use."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_provider</name></expr>,
		<expr><literal type="string">"llvmjit"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* POLAR String GUCs, the end of block */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_release_date"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Show the server release date."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_release_date</name></expr>,
		<expr><literal type="string">"20211231"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_version"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Show the PolarDB server version."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_version</name></expr>,
		<expr><literal type="string">"1.1.20"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_forbidden_functions_ext"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Changes the list of functions that are not allowed to create rule by nosuper users."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_forbidden_functions_ext</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_polar_forbidden_functions</name></expr>, <expr><name>assign_polar_forbidden_functions</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_available_extensions"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Changes the list of extensions that are allowed to create by polar users."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_available_extensions</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>check_polar_available_extensions</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_forbidden_extensions"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Changes the list of extensions that are't allowed to create by polar users."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_forbidden_extensions</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>check_polar_available_extensions</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_internal_allowed_extensions"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Changes the list of internal extensions that are allowed to create by polar users."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_internal_allowed_extensions</name></expr>,
		<comment type="block">/* POLAR: extensions in contrib dir */</comment>
		<expr><literal type="string">"pg_stat_statements,btree_gin,btree_gist,citext,cube,dict_int,earthdistance,"</literal>
		<literal type="string">"hstore,intagg,intarray,isn,ltree,pgcrypto,pgrowlocks,pg_prewarm,pg_trgm,"</literal>
		<literal type="string">"sslinfo,tablefunc,unaccent,fuzzystrmatch,pgstattuple,pg_buffercache,\"uuid-ossp\",bloom,"</literal>
		<comment type="block">/* POLAR: extensions in src/pl dir */</comment>
		<literal type="string">"plpgsql,plperl,"</literal>
		<comment type="block">/* POLAR: extensions in external dir */</comment>
		<literal type="string">"polar_csn,polar_monitor,polar_monitor_preload,polar_px"</literal></expr>,
		<expr><name>check_polar_available_extensions</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_auto_cascade_extensions"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
		 <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Changes the list of extensions that are "</literal>
			 <literal type="string">"automatically cascaded."</literal></expr></argument>)</argument_list></call></expr>,
		 <expr><name>NULL</name></expr>,
		 <expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_auto_cascade_extensions</name></expr>,
		<expr><literal type="string">"postgis, postgis_topology, postgis_sfcgal, address_standardizer, "</literal>
            <literal type="string">"address_standardizer_data_us, postgis_tiger_geocoder, pgrouting"</literal></expr>,
		<expr><name>check_polar_available_extensions</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_supported_extensions"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"The list of supported extensions that are allowed to create by polar users."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_supported_extensions</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>show_polar_supported_extensions</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_rename_wal_ready_file"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"rename file under /pfs-disk/data/pg_wal/archive_status from .ready to .done"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>, <expr><name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_rename_wal_ready_file</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_polar_rename_wal_ready_file</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_internal_shared_preload_libraries"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CLIENT_CONN_PRELOAD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Lists polardb internal shared libraries with high priority to preload into server."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_internal_shared_preload_libraries</name></expr>,
		<expr><literal type="string">"polar_vfs,polar_worker,polar_resource_group,polar_monitor_preload,pg_stat_statements,polar_stat_sql"</literal></expr>,
		<expr><name>polar_check_internal_shared_preload_libraries</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_internal_allowed_roles"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Mark roles that polar_superuser has privs to."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_internal_allowed_roles</name></expr>,
		<comment type="block">/* POLAR: roles are defined in src/include/catalog/pg_authid.dat */</comment>
		<expr><literal type="string">"pg_read_all_stats,pg_stat_scan_tables,pg_signal_backend,pg_polar_superuser"</literal></expr>,
		<expr><name>check_polar_allowed_roles</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_cluster_passphrase_command"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>ENCRYPTION</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Command to obtain passphrases for database encryption."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_cluster_passphrase_command</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_high_priority_replication_standby_names"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Comma-separated list of high priority replication standby names."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_high_priority_replication_standby_names</name></expr>,
		<expr><name>POLAR_DEFAULT_HIGH_PRI_REP_STANDBY_NAME</name></expr>,
		<expr><name>check_high_priority_replication_standby_names</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_low_priority_replication_standby_names"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Comma-separated list of low priority replication standby names."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_low_priority_replication_standby_names</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_low_priority_replication_standby_names</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<comment type="block">/* POLAR: xact split */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_xact_split_xids"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"xact id of current split transaction."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_xact_split_xids</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>polar_check_xact_split_xids</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_xact_split_wait_lsn"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"xact id of current split transaction."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_xact_split_wait_lsn_str</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>polar_assign_xact_split_wait_lsn</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_partition_recursive_reloptions"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Reloptions to be recursively set on partitioned tables."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_partition_recursive_reloptions</name></expr>,
		<expr><literal type="string">"px_workers"</literal></expr>,
		<expr><name>polar_check_recursive_reloptions</name></expr>, <expr><name>polar_assign_recursive_reloptions</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/* End-of-list marker */</comment>
	<expr><block>{
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_enum</name></name></type> <name><name>ConfigureNamesEnum</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><block>{<expr><literal type="string">"backslash_quote"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets whether \"\\'\" is allowed in string literals."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>backslash_quote</name></expr>,
		<expr><name>BACKSLASH_QUOTE_SAFE_ENCODING</name></expr>, <expr><name>backslash_quote_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bytea_output"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the output format for bytea."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>bytea_output</name></expr>,
		<expr><name>BYTEA_OUTPUT_HEX</name></expr>, <expr><name>bytea_output_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"client_min_messages"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the message levels that are sent to the client."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Each level includes all the levels that follow it. The later"</literal>
						 <literal type="string">" the level, the fewer messages are sent."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>client_min_messages</name></expr>,
		<expr><name>NOTICE</name></expr>, <expr><name>client_message_level_options</name></expr>,
		<expr><name>check_client_min_messages</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"constraint_exclusion"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner to use constraints to optimize queries."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Table scans will be skipped if their constraints"</literal>
						 <literal type="string">" guarantee that no rows match the query."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>constraint_exclusion</name></expr>,
		<expr><name>CONSTRAINT_EXCLUSION_PARTITION</name></expr>, <expr><name>constraint_exclusion_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_transaction_isolation"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the transaction isolation level of each new transaction."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>DefaultXactIsoLevel</name></expr>,
		<expr><name>XACT_READ_COMMITTED</name></expr>, <expr><name>isolation_level_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"IntervalStyle"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the display format for interval values."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>IntervalStyle</name></expr>,
		<expr><name>INTSTYLE_POSTGRES</name></expr>, <expr><name>intervalstyle_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_error_verbosity"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the verbosity of logged messages."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_error_verbosity</name></expr>,
		<expr><name>PGERROR_DEFAULT</name></expr>, <expr><name>log_error_verbosity_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_min_messages"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHEN</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the message levels that are logged."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Each level includes all the levels that follow it. The later"</literal>
						 <literal type="string">" the level, the fewer messages are sent."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_min_messages</name></expr>,
		<expr><name>WARNING</name></expr>, <expr><name>server_message_level_options</name></expr>,
		<expr><name>NULL</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_DMA</name></cpp:ifdef>
		<expr><name>assign_dma_log_level</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><name>NULL</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_min_error_statement"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHEN</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Causes all statements generating error at or above this level to be logged."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Each level includes all the levels that follow it. The later"</literal>
						 <literal type="string">" the level, the fewer messages are sent."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_min_error_statement</name></expr>,
		<expr><name>ERROR</name></expr>, <expr><name>server_message_level_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_statement"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the type of statements logged."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_statement</name></expr>,
		<expr><name>LOGSTMT_NONE</name></expr>, <expr><name>log_statement_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"syslog_facility"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the syslog \"facility\" to be used when syslog enabled."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>syslog_facility</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
		<expr><name>LOG_LOCAL0</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><literal type="number">0</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>syslog_facility_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_syslog_facility</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* POLAR: many users want to change it, let no-super to do it */</comment>
		<expr><block>{<expr><literal type="string">"session_replication_role"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the session's behavior for triggers and rewrite rules."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>SessionReplicationRole</name></expr>,
		<expr><name>SESSION_REPLICATION_ROLE_ORIGIN</name></expr>, <expr><name>session_replication_role_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_session_replication_role</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"synchronous_commit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the current transaction's synchronization level."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>synchronous_commit</name></expr>,
		<expr><name>SYNCHRONOUS_COMMIT_ON</name></expr>, <expr><name>synchronous_commit_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_synchronous_commit</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"archive_mode"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_ARCHIVING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allows archiving of WAL files using archive_command."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XLogArchiveMode</name></expr>,
		<expr><name>ARCHIVE_MODE_OFF</name></expr>, <expr><name>archive_mode_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_recovery_messages"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables logging of recovery-related debugging information."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Each level includes all the levels that follow it. The later"</literal>
						 <literal type="string">" the level, the fewer messages are sent."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>trace_recovery_messages</name></expr>,

		<comment type="block">/*
		 * client_message_level_options allows too many values, really, but
		 * it's not worth having a separate options array for this.
		 */</comment>
		<expr><name>LOG</name></expr>, <expr><name>client_message_level_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_functions"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collects function-level statistics on database activity."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pgstat_track_functions</name></expr>,
		<expr><name>TRACK_FUNC_OFF</name></expr>, <expr><name>track_function_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_level"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the level of information written to the WAL."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_level</name></expr>,
		<expr><name>WAL_LEVEL_REPLICA</name></expr>, <expr><name>wal_level_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"dynamic_shared_memory_type"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Selects the dynamic shared memory implementation used."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>dynamic_shared_memory_type</name></expr>,
		<expr><name>DEFAULT_DYNAMIC_SHARED_MEMORY_TYPE</name></expr>, <expr><name>dynamic_shared_memory_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_sync_method"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Selects the method used for forcing WAL updates to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>sync_method</name></expr>,
		<expr><name>DEFAULT_SYNC_METHOD</name></expr>, <expr><name>sync_method_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_xlog_sync_method</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"xmlbinary"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets how binary values are to be encoded in XML."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>xmlbinary</name></expr>,
		<expr><name>XMLBINARY_BASE64</name></expr>, <expr><name>xmlbinary_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"xmloption"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets whether XML data in implicit parsing and serialization "</literal>
						 <literal type="string">"operations is to be considered as documents or content fragments."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>xmloption</name></expr>,
		<expr><name>XMLOPTION_CONTENT</name></expr>, <expr><name>xmloption_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"huge_pages"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Use of huge pages on Linux or Windows."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>huge_pages</name></expr>,
		<expr><name>HUGE_PAGES_TRY</name></expr>, <expr><name>huge_pages_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"force_parallel_mode"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Forces use of parallel query facilities."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"If possible, run query using a parallel worker and with parallel restrictions."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>force_parallel_mode</name></expr>,
		<expr><name>FORCE_PARALLEL_OFF</name></expr>, <expr><name>force_parallel_mode_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"password_encryption"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CONN_AUTH_AUTH</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Chooses the algorithm for encrypting passwords."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Password_encryption</name></expr>,
		<expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>password_encryption_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* POLAR */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_enable_coredump_handler"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable print coredump info and clear coredump"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_enable_coredump_handler</name></expr>,
		<expr><name>POLAR_CORE_DUMP_ALL</name></expr>, <expr><name>coredump_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* POLAR */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_delay_dml_option"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Delay DML for once or each tuple"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_delay_dml_option</name></expr>,
		<expr><name>POLAR_DELAY_DML_OFF</name></expr>, <expr><name>delay_dml_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_data_encryption_cipher"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Specify encryption algorithms to use."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>data_encryption_cipher</name></expr>,
		<expr><name>TDE_ENCRYPTION_OFF</name></expr>, <expr><name>data_encryption_cipher_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_data_encryption_cipher</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_shutdown_walsnd_wait_replication_kind"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Wait walsender whose replication type is polar_shutdown_walsnd_wait_replication_kind during shutdown."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_shutdown_walsnd_wait_replication_kind</name></expr>,
		<expr><name>REPLICATION_KIND_PHYSICAL</name></expr>, <expr><name>polar_shutdown_walsnd_wait_replication_kind_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_priority_replication_mode"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets priority replication mode."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_priority_replication_mode</name></expr>,
		<expr><name>POLAR_PRI_REP_ANY</name></expr>, <expr><name>polar_priority_replication_mode_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_save_stack_info_level"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHEN</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"print stack info if error level is above stack info level."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_save_stack_info_level</name></expr>,
		<expr><name>FATAL</name></expr>, <expr><name>polar_save_stack_info_level_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_nblocks_cache_mode"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of Blocks cache mode"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_nblocks_cache_mode</name></expr>,
		<expr><name>POLAR_NBLOCKS_CACHE_SCAN_MODE</name></expr>, <expr><name>polar_block_cache_options</name></expr>,
		<expr><name>polar_check_nblocks_cache_mode</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"polar_trace_logindex_messages"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables logging of logindex-related debugging information."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Each level includes all the levels that follow it. The later"</literal>
						 <literal type="string">" the level, the fewer messages are sent."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>polar_trace_logindex_messages</name></expr>,

		<comment type="block">/*
		 * client_message_level_options allows too many values, really, but
		 * it's not worth having a separate options array for this.
		 */</comment>
		<expr><name>LOG</name></expr>, <expr><name>client_message_level_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* End-of-list marker */</comment>
	<expr><block>{
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/******** end of options list ********/</comment>


<comment type="block">/*
 * To allow continued support of obsolete names for GUC variables, we apply
 * the following mappings to any unrecognized name.  Note that an old name
 * should be mapped to a new one only if the new variable has very similar
 * semantics to the old.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>map_old_guc_names</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"sort_mem"</literal></expr>, <expr><literal type="string">"work_mem"</literal></expr>,
	<expr><literal type="string">"vacuum_mem"</literal></expr>, <expr><literal type="string">"maintenance_work_mem"</literal></expr>,
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Actual lookup of variables is done through this single, sorted array.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>guc_variables</name></decl>;</decl_stmt>

<comment type="block">/* Current number of variables contained in the vector */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_guc_variables</name></decl>;</decl_stmt>

<comment type="block">/* Vector capacity */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>size_guc_variables</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>guc_dirty</name></decl>;</decl_stmt>			<comment type="block">/* true if need to do commit/abort work */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>reporting_enabled</name></decl>;</decl_stmt>	<comment type="block">/* true to enable GUC_REPORT */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>GUCNestLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 1 when in main transaction */</comment>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>guc_var_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeGUCOptionsFromEnvironment</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeOneGUCOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>push_old_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>GucAction</name></type> <name>action</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReportGUCOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reapply_stacked_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>variable</name></decl></parameter>,
					   <parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>pHolder</name></decl></parameter>,
					   <parameter><decl><type><name>GucStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>curvalue</name></decl></parameter>,
					   <parameter><decl><type><name>GucContext</name></type> <name>curscontext</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>cursource</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShowGUCConfigOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShowAllGUCConfig</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>_ShowOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_units</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>validate_option_array_item</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>skipIfNoPermissions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_auto_conf_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>head_p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>replace_auto_config_value</name><parameter_list>(<parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>head_p</name></decl></parameter>, <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>tail_p</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Some infrastructure for checking malloc/strdup/realloc calls
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>guc_malloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

	<comment type="block">/* Avoid unportable behavior of malloc(0) */</comment>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>guc_realloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

	<comment type="block">/* Avoid unportable behavior of realloc(NULL, 0) */</comment>
	<if_stmt><if>if <condition>(<expr><name>old</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>guc_strdup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Detect whether strval is referenced anywhere in a GUC string item
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>string_field_used</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>strval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>strval</name> <operator>==</operator> <operator>*</operator><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator> <operator>||</operator>
		<name>strval</name> <operator>==</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>||</operator>
		<name>strval</name> <operator>==</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>strval</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name> <operator>||</operator>
			<name>strval</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Support for assigning to a field of a string GUC item.  Free the prior
 * value if it's not referenced anywhere else in the item (including stacked
 * states).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_string_field</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldval</name> <init>= <expr><operator>*</operator><name>field</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do the assignment */</comment>
	<expr_stmt><expr><operator>*</operator><name>field</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>

	<comment type="block">/* Free old value if it's not NULL and isn't referenced anymore */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldval</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>string_field_used</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether an "extra" struct is referenced anywhere in a GUC item
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extra_field_used</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <name><name>gconf</name><operator>-&gt;</operator><name>extra</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name> <operator>||</operator>
			<name>extra</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>extra</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Support for assigning to an "extra" field of a GUC item.  Free the prior
 * value if it's not referenced anywhere else in the item (including stacked
 * states).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_extra_field</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>oldval</name> <init>= <expr><operator>*</operator><name>field</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do the assignment */</comment>
	<expr_stmt><expr><operator>*</operator><name>field</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>

	<comment type="block">/* Free old value if it's not NULL and isn't referenced anymore */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldval</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Support for copying a variable's active value into a stack entry.
 * The "extra" field associated with the active value is copied, too.
 *
 * NB: be sure stringval and extra fields of a new stack entry are
 * initialized to NULL before this is used, else we'll try to free() them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_stack_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>config_var_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolval</name></name> <operator>=</operator>
				<operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>intval</name></name> <operator>=</operator>
				<operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>realval</name></name> <operator>=</operator>
				<operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>stringval</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>enumval</name></name> <operator>=</operator>
				<operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>extra</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Support for discarding a no-longer-needed value in a stack entry.
 * The "extra" field associated with the stack entry is cleared, too.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>discard_stack_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>config_var_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<comment type="block">/* no need to do anything */</comment>
			<break>break;</break>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>stringval</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>extra</name></name><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Fetch the sorted array pointer (exported for help_config.c's use ONLY)
 */</comment>
<function><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type>
<name>get_guc_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>guc_variables</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Build the sorted array.  This is split out so that it could be
 * re-executed after startup (e.g., we could allow loadable modules to
 * add vars, and then we'd need to re-sort).
 */</comment>
<function><type><name>void</name></type>
<name>build_guc_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>size_vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_vars</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>guc_vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Rather than requiring vartype to be filled in by hand, do this: */</comment>
		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_BOOL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* POLAR px */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesBool_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesBool_px</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_BOOL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* POLAR end */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_INT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* POLAR px */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesInt_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesInt_px</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_INT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* POLAR end */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_REAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* POLAR px */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesReal_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesReal_px</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_REAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* POLAR end */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_STRING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* POLAR px */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesString_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesString_px</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_STRING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* POLAR end */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_ENUM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* POLAR px */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesEnum_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesEnum_px</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_ENUM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * Create table with 20% slack
	 */</comment>
	<expr_stmt><expr><name>size_vars</name> <operator>=</operator> <name>num_vars</name> <operator>+</operator> <name>num_vars</name> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>guc_vars</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>size_vars</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_vars</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* POLAR px */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesBool_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesBool_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>
	<comment type="block">/* POLAR end */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* POLAR px */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesInt_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesInt_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>
	<comment type="block">/* POLAR end */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* POLAR px */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesReal_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesReal_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>
	<comment type="block">/* POLAR end */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* POLAR px */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesString_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesString_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>
	<comment type="block">/* POLAR end */</comment>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* POLAR px */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesEnum_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesEnum_px</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>
	<comment type="block">/* POLAR end */</comment>

	<if_stmt><if>if <condition>(<expr><name>guc_variables</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>guc_variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>guc_variables</name> <operator>=</operator> <name>guc_vars</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_guc_variables</name> <operator>=</operator> <name>num_vars</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>size_guc_variables</name> <operator>=</operator> <name>size_vars</name></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><call><name>px_assign_sync_flag</name><argument_list>(<argument><expr><name>guc_variables</name></expr></argument>, <argument><expr><name>num_guc_variables</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* predefine */</comment>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>guc_variables</name></expr></argument>, <argument><expr><name>num_guc_variables</name></expr></argument>,
		  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>guc_var_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a new GUC variable to the list of known variables. The
 * list is expanded if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>add_guc_variable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>num_guc_variables</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>size_guc_variables</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Increase the vector by 25%
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>size_vars</name> <init>= <expr><name>size_guc_variables</name> <operator>+</operator> <name>size_guc_variables</name> <operator>/</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>guc_vars</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>size_vars</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>size_vars</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>guc_vars</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>guc_malloc</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>size_vars</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>guc_vars</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>guc_realloc</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>guc_variables</name></expr></argument>, <argument><expr><name>size_vars</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>guc_vars</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* out of memory */</comment>

		<expr_stmt><expr><name>guc_variables</name> <operator>=</operator> <name>guc_vars</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>size_guc_variables</name> <operator>=</operator> <name>size_vars</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>guc_variables</name><index>[<expr><name>num_guc_variables</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>var</name></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><call><name>px_assign_sync_flag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>var</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* predefine */</comment>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>guc_variables</name></expr></argument>, <argument><expr><name>num_guc_variables</name></expr></argument>,
		  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>guc_var_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create and add a placeholder variable for a custom variable name.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type>
<name>add_placeholder_variable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_string</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>gen</name> <operator>=</operator> <operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>gen</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>PGC_USERSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>CUSTOM_OPTIONS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>short_desc</name></name> <operator>=</operator> <literal type="string">"GUC placeholder variable"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_CUSTOM_PLACEHOLDER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_STRING</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The char* is allocated at the end of the struct since we have no
	 * 'static' place to point to.  Note that the current value, as well as
	 * the boot and reset values, start out NULL.
	 */</comment>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name>var</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>add_guc_variable</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>gen</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>gen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Look up option NAME.  If it exists, return a pointer to its record,
 * else return NULL.  If create_placeholders is true, we'll create a
 * placeholder record for a valid-looking custom variable name.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type>
<name>find_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_placeholders</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>key</name> <init>= <expr><operator>&amp;</operator><name>name</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * By equating const char ** with struct config_generic *, we are assuming
	 * the name field is first in config_generic.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>guc_variables</name></expr></argument>,
											 <argument><expr><name>num_guc_variables</name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
											 <argument><expr><name>guc_var_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>*</operator><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * See if the name is an obsolete name for a variable.  We assume that the
	 * set of supported old names is short enough that a brute-force search is
	 * the best way.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>map_old_guc_names</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>guc_name_compare</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>map_old_guc_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>find_option</name><argument_list>(<argument><expr><name><name>map_old_guc_names</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>create_placeholders</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check if the name is qualified, and if so, add a placeholder.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>GUC_QUALIFIER_SEPARATOR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>add_placeholder_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Unknown name */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * comparator for qsorting and bsearching guc_variables array
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>guc_var_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>confa</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>confb</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>guc_name_compare</name><argument_list>(<argument><expr><name><name>confa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>confb</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * the bare comparison function for GUC names
 */</comment>
<function><type><name>int</name></type>
<name>guc_name_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namea</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The temptation to use strcasecmp() here must be resisted, because the
	 * array ordering has to remain stable across setlocale() calls. So, build
	 * our own with a simple ASCII-only downcasing.
	 */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>namea</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nameb</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>cha</name> <init>= <expr><operator>*</operator><name>namea</name><operator>++</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>chb</name> <init>= <expr><operator>*</operator><name>nameb</name><operator>++</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>cha</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>cha</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cha</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>chb</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>chb</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>chb</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>cha</name> <operator>!=</operator> <name>chb</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cha</name> <operator>-</operator> <name>chb</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>namea</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* a is longer */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nameb</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* b is longer */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Initialize GUC options during program startup.
 *
 * Note that we cannot read the config file yet, since we have not yet
 * processed command-line switches.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeGUCOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Before log_line_prefix could possibly receive a nonempty setting, make
	 * sure that timezone processing is minimally alive (see elog.c).
	 */</comment>
	<expr_stmt><expr><call><name>pg_timezone_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build sorted array of all GUC variables.
	 */</comment>
	<expr_stmt><expr><call><name>build_guc_variables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Load all variables with their compiled-in defaults, and initialize
	 * status fields as needed.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InitializeOneGUCOption</name><argument_list>(<argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>guc_dirty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>reporting_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prevent any attempt to override the transaction modes from
	 * non-interactive sources.
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>,
					<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>, <argument><expr><literal type="string">"no"</literal></expr></argument>,
					<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>, <argument><expr><literal type="string">"no"</literal></expr></argument>,
					<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For historical reasons, some GUC parameters can receive defaults from
	 * environment variables.  Process those settings.
	 */</comment>
	<expr_stmt><expr><call><name>InitializeGUCOptionsFromEnvironment</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assign any GUC values that can come from the server's environment.
 *
 * This is called from InitializeGUCOptions, and also from ProcessConfigFile
 * to deal with the possibility that a setting has been removed from
 * postgresql.conf and should now get a value from the environment.
 * (The latter is a kludge that should probably go away someday; if so,
 * fold this back into InitializeGUCOptions.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeGUCOptionsFromEnvironment</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>stack_rlimit</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGPORT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>env</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"port"</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ENV_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATESTYLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>env</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"datestyle"</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ENV_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGCLIENTENCODING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>env</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"client_encoding"</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ENV_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * rlimit isn't exactly an "environment variable", but it behaves about
	 * the same.  If we can identify the platform stack depth rlimit, increase
	 * default stack depth setting up to whatever is safe (but at most 2MB).
	 */</comment>
	<expr_stmt><expr><name>stack_rlimit</name> <operator>=</operator> <call><name>get_stack_depth_rlimit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>stack_rlimit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>new_limit</name> <init>= <expr><operator>(</operator><name>stack_rlimit</name> <operator>-</operator> <name>STACK_DEPTH_SLOP</name><operator>)</operator> <operator>/</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>new_limit</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>limbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><name>new_limit</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>new_limit</name></expr></argument>, <argument><expr><literal type="number">2048</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>limbuf</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><name>new_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"max_stack_depth"</literal></expr></argument>, <argument><expr><name>limbuf</name></expr></argument>,
							<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ENV_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize one GUC option variable to its compiled-in default.
 *
 * Note: the reason for calling check_hooks is not that we think the boot_val
 * might fail, but that the hooks might wish to compute an "extra" struct.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeOneGUCOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>PGC_S_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>reset_source</name></name> <operator>=</operator> <name>PGC_S_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>PGC_INTERNAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>reset_scontext</name></name> <operator>=</operator> <name>PGC_INTERNAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>extra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>        <name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_bool_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>,
										  <argument><expr><name>PGC_S_DEFAULT</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize %s to %d"</literal></expr></argument>,
						 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>        <name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&gt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>( <expr><name>newval</name> <operator>&gt;</operator> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"xlc failed to initialize %s to %d, %d, %d"</literal></expr></argument>,
							 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&lt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_int_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>,
										 <argument><expr><name>PGC_S_DEFAULT</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize %s to %d"</literal></expr></argument>,
						 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>double</name></type>		<name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&gt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&lt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_real_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>,
										  <argument><expr><name>PGC_S_DEFAULT</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize %s to %g"</literal></expr></argument>,
						 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* non-NULL boot_val must always get strdup'd */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_string_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>,
											<argument><expr><name>PGC_S_DEFAULT</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize %s to \"%s\""</literal></expr></argument>,
						 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>newval</name></expr> ?</condition><then> <expr><name>newval</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>        <name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_enum_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>,
										  <argument><expr><name>PGC_S_DEFAULT</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize %s to %d"</literal></expr></argument>,
						 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * Select the configuration files and data directory to be used, and
 * do the initial read of postgresql.conf.
 *
 * This is called after processing command-line switches.
 *		userDoption is the -D switch value if any (NULL if unspecified).
 *		progname is just for use in error messages.
 *
 * Returns true on success; on failure, prints a suitable error message
 * to stderr and returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>SelectConfigFiles</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userDoption</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>configdir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<comment type="block">/* configdir is -D option, or $PGDATA if no -D */</comment>
	<if_stmt><if>if <condition>(<expr><name>userDoption</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>configdir</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>userDoption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>configdir</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATA"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>configdir</name> <operator>&amp;&amp;</operator> <call><name>stat</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: could not access directory \"%s\": %s\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>,
					 <argument><expr><name>configdir</name></expr></argument>,
					 <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Run initdb or pg_basebackup to initialize a PostgreSQL data directory.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find the configuration file: if config_file was specified on the
	 * command line, use it, else use configdir/postgresql.conf.  In any case
	 * ensure the result is an absolute path, so that it will be interpreted
	 * the same way by future backends.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ConfigFileName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>ConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>configdir</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>CONFIG_FILENAME</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>configdir</name></expr></argument>, <argument><expr><name>CONFIG_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s does not know where to find the server configuration file.\n"</literal>
					 <literal type="string">"You must specify the --config-file or -D invocation "</literal>
					 <literal type="string">"option or set the PGDATA environment variable.\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Set the ConfigFileName GUC variable to its final value, ensuring that
	 * it can't be overridden later.
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"config_file"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Figure out where pg_hba.conf is, and make sure the path is absolute.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PolarDMAFileName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>PolarDMAFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>configdir</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>POLAR_DMA_FILENAME</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>configdir</name></expr></argument>, <argument><expr><name>POLAR_DMA_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s does not know where to find the \"polar_dma\" configuration file.\n"</literal>
					 <literal type="string">"This can be specified as \"polar_dma_file\" in \"%s\", "</literal>
					 <literal type="string">"or by the -D invocation option, or by the "</literal>
					 <literal type="string">"PGDATA environment variable.\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"polar_dma_file"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now read the config file for the first time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>ConfigFileName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: could not access the server configuration file \"%s\": %s\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ConfigFileName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Read the configuration file for the first time.  This time only the
	 * data_directory parameter is picked up to determine the data directory,
	 * so that we can read the PG_AUTOCONF_FILENAME file next time.
	 */</comment>
	<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_POSTMASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the data_directory GUC variable has been set, use that as DataDir;
	 * otherwise use configdir if set; else punt.
	 *
	 * Note: SetDataDir will copy and absolute-ize its argument, so we don't
	 * have to.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>data_directory</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetDataDir</name><argument_list>(<argument><expr><name>data_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>configdir</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetDataDir</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s does not know where to find the database system data.\n"</literal>
					 <literal type="string">"This can be specified as \"data_directory\" in \"%s\", "</literal>
					 <literal type="string">"or by the -D invocation option, or by the "</literal>
					 <literal type="string">"PGDATA environment variable.\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Reflect the final DataDir value back into the data_directory GUC var.
	 * (If you are wondering why we don't just make them a single variable,
	 * it's because the EXEC_BACKEND case needs DataDir to be transmitted to
	 * child backends specially.  XXX is that still true?  Given that we now
	 * chdir to DataDir, EXEC_BACKEND can read the config file without knowing
	 * DataDir in advance.)
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"data_directory"</literal></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now read the config file a second time, allowing any settings in the
	 * PG_AUTOCONF_FILENAME file to take effect.  (This is pretty ugly, but
	 * since we have to determine the DataDir before we can find the autoconf
	 * file, the alternatives seem worse.)
	 */</comment>
	<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_POSTMASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If timezone_abbreviations wasn't set in the configuration file, install
	 * the default value.  We do it this way because we can't safely install a
	 * "real" value until my_exec_path is set, which may not have happened
	 * when InitializeGUCOptions runs, so the bootstrap default value cannot
	 * be the real desired default.
	 */</comment>
	<expr_stmt><expr><call><name>pg_timezone_abbrev_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Figure out where pg_hba.conf is, and make sure the path is absolute.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>HbaFileName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>configdir</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>HBA_FILENAME</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>configdir</name></expr></argument>, <argument><expr><name>HBA_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s does not know where to find the \"hba\" configuration file.\n"</literal>
					 <literal type="string">"This can be specified as \"hba_file\" in \"%s\", "</literal>
					 <literal type="string">"or by the -D invocation option, or by the "</literal>
					 <literal type="string">"PGDATA environment variable.\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"hba_file"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Likewise for pg_ident.conf.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IdentFileName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>IdentFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>configdir</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>IDENT_FILENAME</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>configdir</name></expr></argument>, <argument><expr><name>IDENT_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s does not know where to find the \"ident\" configuration file.\n"</literal>
					 <literal type="string">"This can be specified as \"ident_file\" in \"%s\", "</literal>
					 <literal type="string">"or by the -D invocation option, or by the "</literal>
					 <literal type="string">"PGDATA environment variable.\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ident_file"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Reset all options to their saved default values (implements RESET ALL)
 */</comment>
<function><type><name>void</name></type>
<name>ResetAllOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Don't reset non-SET-able values */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>!=</operator> <name>PGC_SUSET</name> <operator>&amp;&amp;</operator>
			<name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>!=</operator> <name>PGC_USERSET</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Don't reset if special exclusion from RESET ALL */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_NO_RESET_ALL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* No need to reset if wasn't SET */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>PGC_S_OVERRIDE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Save old value to support transaction abort */</comment>
		<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><name>GUC_ACTION_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PGC_BOOL</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
										  <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>PGC_INT</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
										  <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>PGC_REAL</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
										  <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>PGC_STRING</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
										  <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>PGC_ENUM</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
										  <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
		</block_content>}</block></switch>

		<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>reset_source</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>reset_scontext</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_REPORT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReportGUCOption</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * push_old_value
 *		Push previous state during transactional assignment to a GUC variable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_old_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>GucAction</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

	<comment type="block">/* If we're not inside a nest level, do nothing */</comment>
	<if_stmt><if>if <condition>(<expr><name>GUCNestLevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Do we already have a stack entry of the current nest level? */</comment>
	<expr_stmt><expr><name>stack</name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>stack</name> <operator>&amp;&amp;</operator> <name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>&gt;=</operator> <name>GUCNestLevel</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Yes, so adjust its state if necessary */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>==</operator> <name>GUCNestLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>action</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>GUC_ACTION_SET</name></expr>:</case>
				<comment type="block">/* SET overrides any prior action at same nest level */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET_LOCAL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* must discard old masked value */</comment>
					<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>masked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GUC_ACTION_LOCAL</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* SET followed by SET LOCAL, remember SET's value */</comment>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>masked_scontext</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>masked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET_LOCAL</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* in all other cases, no change to stack entry */</comment>
				<break>break;</break>
			<case>case <expr><name>GUC_ACTION_SAVE</name></expr>:</case>
				<comment type="block">/* Could only have a prior SAVE of same variable */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>guc_dirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* must be set already */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Push a new stack entry
	 *
	 * We keep all the stack entries in TopTransactionContext for simplicity.
	 */</comment>
	<expr_stmt><expr><name>stack</name> <operator>=</operator> <operator>(</operator><name>GucStack</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
												<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GucStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>=</operator> <name>GUCNestLevel</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>action</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GUC_ACTION_SET</name></expr>:</case>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GUC_ACTION_LOCAL</name></expr>:</case>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_LOCAL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GUC_ACTION_SAVE</name></expr>:</case>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SAVE</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt>

	<comment type="block">/* Ensure we remember to pop at end of xact */</comment>
	<expr_stmt><expr><name>guc_dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Do GUC processing at main transaction start.
 */</comment>
<function><type><name>void</name></type>
<name>AtStart_GUC</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The nest level should be 0 between transactions; if it isn't, somebody
	 * didn't call AtEOXact_GUC, or called it with the wrong nestLevel.  We
	 * throw a warning but make no other effort to clean up.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>GUCNestLevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"GUC nest level = %d at transaction start"</literal></expr></argument>,
			 <argument><expr><name>GUCNestLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>GUCNestLevel</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Enter a new nesting level for GUC values.  This is called at subtransaction
 * start, and when entering a function that has proconfig settings, and in
 * some other places where we want to set GUC variables transiently.
 * NOTE we must not risk error here, else subtransaction start will be unhappy.
 */</comment>
<function><type><name>int</name></type>
<name>NewGUCNestLevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>++</operator><name>GUCNestLevel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do GUC processing at transaction or subtransaction commit or abort, or
 * when exiting a function that has proconfig settings, or when undoing a
 * transient assignment to some GUC variables.  (The name is thus a bit of
 * a misnomer; perhaps it should be ExitGUCNestLevel or some such.)
 * During abort, we discard all GUC settings that were applied at nesting
 * levels &gt;= nestLevel.  nestLevel == 1 corresponds to the main transaction.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_GUC</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nestLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>still_dirty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: it's possible to get here with GUCNestLevel == nestLevel-1 during
	 * abort, if there is a failure during transaction start before
	 * AtStart_GUC is called.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nestLevel</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <operator>(</operator><name>nestLevel</name> <operator>&lt;=</operator> <name>GUCNestLevel</name> <operator>||</operator>
			<operator>(</operator><name>nestLevel</name> <operator>==</operator> <name>GUCNestLevel</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>isCommit</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Quick exit if nothing's changed in this transaction */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>guc_dirty</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>GUCNestLevel</name> <operator>=</operator> <name>nestLevel</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>still_dirty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Process and pop each stack entry within the nest level. To simplify
		 * fmgr_security_definer() and other places that use GUC_ACTION_SAVE,
		 * we allow failure exit from code that uses a local nest level to be
		 * recovered at the surrounding transaction or subtransaction abort;
		 * so there could be more than one stack entry to pop.
		 */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>stack</name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			   <name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>&gt;=</operator> <name>nestLevel</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>restorePrior</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>restoreMasked</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>changed</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * In this next bit, if we don't set either restorePrior or
			 * restoreMasked, we must "discard" any unwanted fields of the
			 * stack entries to avoid leaking memory.  If we do set one of
			 * those flags, unused fields will be cleaned up after restoring.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* if abort, always restore prior value */</comment>
				<expr_stmt><expr><name>restorePrior</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SAVE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>restorePrior</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* transaction commit */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>restoreMasked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* we keep the current active value */</comment>
					<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>			<comment type="block">/* must be GUC_LOCAL */</comment>
					<expr_stmt><expr><name>restorePrior</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>prev</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
					 <name><name>prev</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>&lt;</operator> <name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* decrement entry's level and do not pop it */</comment>
				<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name><operator>--</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We have to merge this stack entry into prev. See README for
				 * discussion of this bit.
				 */</comment>
				<switch>switch <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>GUC_SAVE</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* can't get here */</comment>
						<break>break;</break>

					<case>case <expr><name>GUC_SET</name></expr>:</case>
						<comment type="block">/* next level always becomes SET */</comment>
						<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prev</name><operator>-&gt;</operator><name>masked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>GUC_LOCAL</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* LOCAL migrates down */</comment>
							<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>masked_scontext</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>masked</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET_LOCAL</name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* else just forget this stack level */</comment>
							<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<break>break;</break>

					<case>case <expr><name>GUC_SET_LOCAL</name></expr>:</case>
						<comment type="block">/* prior state at this level no longer wanted */</comment>
						<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* copy down the masked state */</comment>
						<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>masked_scontext</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked_scontext</name></name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prev</name><operator>-&gt;</operator><name>masked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>masked</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET_LOCAL</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>restorePrior</name> <operator>||</operator> <name>restoreMasked</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Perform appropriate restoration of the stacked value */</comment>
				<decl_stmt><decl><type><name>config_var_value</name></type> <name>newvalue</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>GucSource</name></type>	<name>newsource</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>GucContext</name></type>	<name>newscontext</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>restoreMasked</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newsource</name> <operator>=</operator> <name>PGC_S_SESSION</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newscontext</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newsource</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newscontext</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>PGC_BOOL</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>newval</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>val</name><operator>.</operator><name>boolval</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>extra</name></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name> <operator>||</operator>
								<name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>!=</operator> <name>newextra</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
												<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>
						</block_content>}</block>
					<case>case <expr><name>PGC_INT</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>int</name></type>			<name>newval</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>val</name><operator>.</operator><name>intval</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>extra</name></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name> <operator>||</operator>
								<name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>!=</operator> <name>newextra</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
												<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>
						</block_content>}</block>
					<case>case <expr><name>PGC_REAL</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>double</name></type>		<name>newval</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>val</name><operator>.</operator><name>realval</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>extra</name></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name> <operator>||</operator>
								<name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>!=</operator> <name>newextra</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
												<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>
						</block_content>}</block>
					<case>case <expr><name>PGC_STRING</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newval</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>extra</name></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name> <operator>||</operator>
								<name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>!=</operator> <name>newextra</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
												<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<comment type="block">/*
							 * Release stacked values if not used anymore. We
							 * could use discard_stack_value() here, but since
							 * we have type-specific code anyway, might as
							 * well inline it.
							 */</comment>
							<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block>
					<case>case <expr><name>PGC_ENUM</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>int</name></type>			<name>newval</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>val</name><operator>.</operator><name>enumval</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>extra</name></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name> <operator>||</operator>
								<name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>!=</operator> <name>newextra</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
												<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>
						</block_content>}</block>
				</block_content>}</block></switch>

				<comment type="block">/*
				 * Release stacked extra values if not used anymore.
				 */</comment>
				<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>extra</name></name><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* And restore source information */</comment>
				<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>newsource</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>newscontext</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Finish popping the state stack */</comment>
			<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Report new value if we changed it */</comment>
			<if_stmt><if>if <condition>(<expr><name>changed</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>gconf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_REPORT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ReportGUCOption</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>						<comment type="block">/* end of stack-popping loop */</comment>

		<if_stmt><if>if <condition>(<expr><name>stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>still_dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If there are no remaining stack entries, we can reset guc_dirty */</comment>
	<expr_stmt><expr><name>guc_dirty</name> <operator>=</operator> <name>still_dirty</name></expr>;</expr_stmt>

	<comment type="block">/* Update nesting level */</comment>
	<expr_stmt><expr><name>GUCNestLevel</name> <operator>=</operator> <name>nestLevel</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Start up automatic reporting of changes to variables marked GUC_REPORT.
 * This is executed at completion of backend startup.
 */</comment>
<function><type><name>void</name></type>
<name>BeginReportingGUCOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Don't do anything unless talking to an interactive frontend of protocol
	 * 3.0 or later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name> <operator>||</operator>
		<call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reporting_enabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Transmit initial values of interesting variables */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_REPORT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReportGUCOption</name><argument_list>(<argument><expr><name>conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * ReportGUCOption: if appropriate, transmit option value to frontend
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReportGUCOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>reporting_enabled</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_REPORT</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>_ShowOption</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>msgbuf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a value from one of the human-friendly units ("kB", "min" etc.)
 * to the given base unit.  'value' and 'unit' are the input value and unit
 * to convert from.  The converted value is stored in *base_value.
 *
 * Returns true on success, false if the input unit is not recognized.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>convert_to_base_unit</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>base_unit</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>base_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unit_conversion</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>base_unit</name> <operator>&amp;</operator> <name>GUC_UNIT_MEMORY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <name>memory_unit_conversion_table</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <name>time_unit_conversion_table</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>base_unit</name> <operator>==</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base_unit</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>unit</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unit</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>base_value</name> <operator>=</operator> <name>value</name> <operator>/</operator> <operator>(</operator><operator>-</operator><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>base_value</name> <operator>=</operator> <name>value</name> <operator>*</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a value in some base unit to a human-friendly unit.  The output
 * unit is chosen so that it's the greatest unit that can represent the value
 * without loss.  For example, if the base unit is GUC_UNIT_KB, 1024 is
 * converted to 1 MB, but 1025 is represented as 1025 kB.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_from_base_unit</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>base_value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base_unit</name></decl></parameter>,
					   <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>unit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unit_conversion</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>unit</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>base_unit</name> <operator>&amp;</operator> <name>GUC_UNIT_MEMORY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <name>memory_unit_conversion_table</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <name>time_unit_conversion_table</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>base_unit</name> <operator>==</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base_unit</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Accept the first conversion that divides the value evenly. We
			 * assume that the conversions for each base unit are ordered from
			 * greatest unit to the smallest!
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>base_value</name> <operator>*</operator> <operator>(</operator><operator>-</operator><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>unit</name> <operator>=</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unit</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>base_value</name> <operator>%</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>base_value</name> <operator>/</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>unit</name> <operator>=</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unit</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>unit</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Try to parse value as an integer.  The accepted formats are the
 * usual decimal, octal, or hexadecimal formats, optionally followed by
 * a unit name if "flags" indicates a unit is allowed.
 *
 * If the string parses okay, return true, else false.
 * If okay and result is not NULL, return the value in *result.
 * If not okay and hintmsg is not NULL, *hintmsg is set to a suitable
 *	HINT message, or NULL if no hint provided.
 */</comment>
<function><type><name>bool</name></type>
<name>parse_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>hintmsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<comment type="block">/* To suppress compiler warnings, always set output params */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We assume here that int64 is at least as wide as long */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no HINT for integer syntax error */</comment>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator> <name>val</name> <operator>!=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int32</name><operator>)</operator> <name>val</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Value exceeds integer range."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* allow whitespace between integer and unit */</comment>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Handle possible unit */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>unit</name><index>[<expr><name>MAX_UNIT_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>unitlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>converted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GUC_UNIT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* this setting does not accept a unit */</comment>

		<expr_stmt><expr><name>unitlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			   <name>unitlen</name> <operator>&lt;</operator> <name>MAX_UNIT_LEN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>unit</name><index>[<expr><name>unitlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>endptr</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name><name>unit</name><index>[<expr><name>unitlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<comment type="block">/* allow whitespace after unit */</comment>
		<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>converted</name> <operator>=</operator> <call><name>convert_to_base_unit</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>, <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GUC_UNIT</name><operator>)</operator></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>converted</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* invalid unit, or garbage after the unit; set hint and fail. */</comment>
			<if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GUC_UNIT_MEMORY</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <name>memory_units_hint</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <name>time_units_hint</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check for overflow due to units conversion */</comment>
		<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int32</name><operator>)</operator> <name>val</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Value exceeds integer range."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * Try to parse value as a floating point number in the usual format.
 * If the string parses okay, return true, else false.
 * If okay and result is not NULL, return the value in *result.
 */</comment>
<function><type><name>bool</name></type>
<name>parse_real</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* suppress compiler warning */</comment>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>value</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* reject NaN (infinities will fail range checks later) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* allow whitespace after number */</comment>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Lookup the name for an enum option with the selected value.
 * Should only ever be called with known-valid values, so throws
 * an elog(ERROR) if the enum option is not found.
 *
 * The returned string is a pointer to static data and not
 * allocated for modification.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>config_enum_lookup_by_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>entry</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>entry</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find enum option %d for %s"</literal></expr></argument>,
		 <argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* silence compiler */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Lookup the value for an enum option with the selected name
 * (case-insensitive).
 * If the enum option is found, sets the retval value and returns
 * true. If it's not found, return false and retval is set to 0.
 */</comment>
<function><type><name>bool</name></type>
<name>config_enum_lookup_by_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>retval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>entry</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>entry</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Return a list of all available options for an enum, excluding
 * hidden ones, separated by the given separator.
 * If prefix is non-NULL, it is added before the first enum value.
 * If suffix is non-NULL, it is added to the end of the string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>config_enum_get_options</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>separator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>retstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>seplen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seplen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>entry</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>entry</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>hidden</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * All the entries may have been hidden, leaving the string empty if no
	 * prefix was given. This indicates a broken GUC setup, since there is no
	 * use for an enum without any values, so we just check to make sure we
	 * don't write to invalid memory instead of actually trying to do
	 * something smart with it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>retstr</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <name>seplen</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Replace final separator */</comment>
		<expr_stmt><expr><name><name>retstr</name><operator>.</operator><name>data</name><index>[<expr><name><name>retstr</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>seplen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>retstr</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <name>seplen</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>retstr</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse and validate a proposed value for the specified configuration
 * parameter.
 *
 * This does built-in checks (such as range limits for an integer parameter)
 * and also calls any check hook the parameter may have.
 *
 * record: GUC variable's info record
 * name: variable name (should match the record of course)
 * value: proposed value, as a string
 * source: identifies source of value (check hooks may need this)
 * elevel: level to log any error reports at
 * newval: on success, converted parameter value is returned here
 * newextra: on success, receives any "extra" data returned by check hook
 *	(caller must initialize *newextra to NULL)
 *
 * Returns true if OK, false if not (or throws error, if elevel &gt;= ERROR)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parse_and_validate_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						 <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
						 <parameter><decl><type><name><name>union</name> <name>config_var_val</name></name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>newextra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>boolval</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a Boolean value"</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_bool_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>boolval</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>,
										  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hintmsg</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>intval</name></name></expr></argument>,
							   <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hintmsg</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <ternary><condition><expr><name>hintmsg</name></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>newval</name><operator>-&gt;</operator><name>intval</name></name> <operator>&lt;</operator> <name><name>conf</name><operator>-&gt;</operator><name>min</name></name> <operator>||</operator> <name><name>newval</name><operator>-&gt;</operator><name>intval</name></name> <operator>&gt;</operator> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%d is outside the valid range for parameter \"%s\" (%d .. %d)"</literal></expr></argument>,
									<argument><expr><name><name>newval</name><operator>-&gt;</operator><name>intval</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_int_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>intval</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>,
										 <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_real</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>realval</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a numeric value"</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>newval</name><operator>-&gt;</operator><name>realval</name></name> <operator>&lt;</operator> <name><name>conf</name><operator>-&gt;</operator><name>min</name></name> <operator>||</operator> <name><name>newval</name><operator>-&gt;</operator><name>realval</name></name> <operator>&gt;</operator> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%g is outside the valid range for parameter \"%s\" (%g .. %g)"</literal></expr></argument>,
									<argument><expr><name><name>newval</name><operator>-&gt;</operator><name>realval</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_real_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>realval</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>,
										  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * The value passed by the caller could be transient, so we
				 * always strdup it.
				 */</comment>
				<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * The only built-in "parsing" check we have is to apply
				 * truncation if GUC_IS_NAME.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_IS_NAME</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>truncate_identifier</name><argument_list>(<argument><expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name></expr></argument>,
										<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_string_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>,
											<argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>config_enum_lookup_by_name</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>enumval</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hintmsg</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>hintmsg</name> <operator>=</operator> <call><name>config_enum_get_options</name><argument_list>(<argument><expr><name>conf</name></expr></argument>,
													  <argument><expr><literal type="string">"Available values: "</literal></expr></argument>,
													  <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <ternary><condition><expr><name>hintmsg</name></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_enum_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>enumval</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>,
										  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Sets option `name' to given value.
 *
 * The value should be a string, which will be parsed and converted to
 * the appropriate data type.  The context and source parameters indicate
 * in which context this function is being called, so that it can apply the
 * access restrictions properly.
 *
 * If value is NULL, set the option to its default value (normally the
 * reset_val, but if source == PGC_S_DEFAULT we instead use the boot_val).
 *
 * action indicates whether to set the value globally in the session, locally
 * to the current top transaction, or just for the duration of a function call.
 *
 * If changeVal is false then don't really set the option but do all
 * the checks to see if it would work.
 *
 * elevel should normally be passed as zero, allowing this function to make
 * its standard choice of ereport level.  However some callers need to be
 * able to override that choice; they should pass the ereport level to use.
 *
 * Return value:
 *	+1: the value is valid and was successfully applied.
 *	0:	the name or value is invalid (but see below).
 *	-1: the value was not applied because of context, priority, or changeVal.
 *
 * If there is an error (non-existing option, invalid value) then an
 * ereport(ERROR) is thrown *unless* this is called for a source for which
 * we don't want an ERROR (currently, those are defaults, the config file,
 * and per-database or per-user settings, as well as callers who specify
 * a less-than-ERROR elevel).  In those cases we write a suitable error
 * message via ereport() and return 0.
 *
 * See also SetConfigOption for an external interface.
 */</comment>
<function><type><name>int</name></type>
<name>set_config_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
				  <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>,
				  <parameter><decl><type><name>GucAction</name></type> <name>action</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changeVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_reload</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>union</name> <name>config_var_val</name></name></type> <name>newval_union</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>prohibitValueChange</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>makeDefault</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name> <operator>||</operator> <name>source</name> <operator>==</operator> <name>PGC_S_FILE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * To avoid cluttering the log, only the postmaster bleats loudly
			 * about problems with the config file.
			 */</comment>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <ternary><condition><expr><name>IsUnderPostmaster</name></expr> ?</condition><then> <expr><name>DEBUG3</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_GLOBAL</name> <operator>||</operator>
				 <name>source</name> <operator>==</operator> <name>PGC_S_DATABASE</name> <operator>||</operator>
				 <name>source</name> <operator>==</operator> <name>PGC_S_USER</name> <operator>||</operator>
				 <name>source</name> <operator>==</operator> <name>PGC_S_DATABASE_USER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>WARNING</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * GUC_ACTION_SAVE changes are acceptable during a parallel operation,
	 * because the current worker will also pop the change.  We're probably
	 * dealing with a function having a proconfig entry.  Only the function's
	 * body should observe the change, and peer workers do not share in the
	 * execution of a function call started by this worker.
	 *
	 * Other changes might need to affect other workers, so forbid them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>changeVal</name> <operator>&amp;&amp;</operator> <name>action</name> <operator>!=</operator> <name>GUC_ACTION_SAVE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set parameters during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if the option can be set at this time. See guc.h for the precise
	 * rules.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_INTERNAL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>!=</operator> <name>PGC_INTERNAL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed"</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_POSTMASTER</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_SIGHUP</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We are re-reading a PGC_POSTMASTER variable from
				 * postgresql.conf.  We can't change the setting, so we should
				 * give a warning if the DBA tries to change it.  However,
				 * because of variant formats, canonicalization by check
				 * hooks, etc, we can't just compare the given string directly
				 * to what's stored.  Set a flag to check below after we have
				 * the final storable value.
				 */</comment>
				<expr_stmt><expr><name>prohibitValueChange</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>context</name> <operator>!=</operator> <name>PGC_POSTMASTER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_SIGHUP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>!=</operator> <name>PGC_SIGHUP</name> <operator>&amp;&amp;</operator> <name>context</name> <operator>!=</operator> <name>PGC_POSTMASTER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed now"</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Hmm, the idea of the SIGHUP context is "ought to be global, but
			 * can be changed after postmaster start". But there's nothing
			 * that prevents a crafty administrator from sending SIGHUP
			 * signals to individual backends only.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>PGC_SU_BACKEND</name></expr>:</case>
			<comment type="block">/* Reject if we're connecting but user is not superuser */</comment>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_BACKEND</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to set parameter \"%s\""</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* fall through to process the same as PGC_BACKEND */</comment>
			<comment type="block">/* FALLTHROUGH */</comment>
		<case>case <expr><name>PGC_BACKEND</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_SIGHUP</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If a PGC_BACKEND or PGC_SU_BACKEND parameter is changed in
				 * the config file, we want to accept the new value in the
				 * postmaster (whence it will propagate to
				 * subsequently-started backends), but ignore it in existing
				 * backends.  This is a tad klugy, but necessary because we
				 * don't re-read the config file during backend start.
				 *
				 * In EXEC_BACKEND builds, this works differently: we load all
				 * non-default settings from the CONFIG_EXEC_PARAMS file
				 * during backend start.  In that case we must accept
				 * PGC_SIGHUP settings, so as to have the same value as if
				 * we'd forked from the postmaster.  This can also happen when
				 * using RestoreGUCState() within a background worker that
				 * needs to have the same settings as the user backend that
				 * started it. is_reload will be true when either situation
				 * applies.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_reload</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>context</name> <operator>!=</operator> <name>PGC_POSTMASTER</name> <operator>&amp;&amp;</operator>
					 <name>context</name> <operator>!=</operator> <name>PGC_BACKEND</name> <operator>&amp;&amp;</operator>
					 <name>context</name> <operator>!=</operator> <name>PGC_SU_BACKEND</name> <operator>&amp;&amp;</operator>
					 <name>source</name> <operator>!=</operator> <name>PGC_S_CLIENT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be set after connection start"</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_SUSET</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_USERSET</name> <operator>||</operator> <name>context</name> <operator>==</operator> <name>PGC_BACKEND</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to set parameter \"%s\""</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_USERSET</name></expr>:</case>
			<comment type="block">/* always okay */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Disallow changing GUC_NOT_WHILE_SEC_REST values if we are inside a
	 * security restriction context.  We can reject this regardless of the GUC
	 * context or source, mainly because sources that it might be reasonable
	 * to override for won't be seen while inside a function.
	 *
	 * Note: variables marked GUC_NOT_WHILE_SEC_REST should usually be marked
	 * GUC_NO_RESET_ALL as well, because ResetAllOptions() doesn't check this.
	 * An exception might be made if the reset value is assumed to be "safe".
	 *
	 * Note: this flag is currently used for "session_authorization" and
	 * "role".  We need to prohibit changing these inside a local userid
	 * context because when we exit it, GUC won't be notified, leaving things
	 * out of sync.  (This could be fixed by forcing a new GUC nesting level,
	 * but that would change behavior in possibly-undesirable ways.)  Also, we
	 * prohibit changing these in a security-restricted operation because
	 * otherwise RESET could be used to regain the session user's privileges.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>InLocalUserIdChange</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Phrasing of this error message is historical, but it's the most
			 * common case.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set parameter \"%s\" within security-definer function"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>InSecurityRestrictedOperation</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set parameter \"%s\" within security-restricted operation"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Should we set reset/stacked values?	(If so, the behavior is not
	 * transactional.)	This is done either when we get a default value from
	 * the database's/user's/client's default settings or when we reset a
	 * value to its default.
	 */</comment>
	<expr_stmt><expr><name>makeDefault</name> <operator>=</operator> <name>changeVal</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>source</name> <operator>&lt;=</operator> <name>PGC_S_OVERRIDE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>value</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ignore attempted set if overridden by previously processed setting.
	 * However, if changeVal is false then plow ahead anyway since we are
	 * trying to find out if the value is potentially good, not actually use
	 * it. Also keep going if makeDefault is true, since we may want to set
	 * the reset/stacked values even if we can't set the variable itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>source</name></name> <operator>&gt;</operator> <name>source</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>changeVal</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>makeDefault</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"\"%s\": setting ignored because previous source is higher priority"</literal></expr></argument>,
				 <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>changeVal</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Evaluate value and set variable.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>newval</name></cpp:macro> <cpp:value>(newval_union.boolval)</cpp:value></cpp:define>

				<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
												  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>newval_union</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_bool_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>,
											  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;=</operator> <operator>~</operator><name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Save old value to support transaction abort */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
										<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>boolval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
											<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>newval</name></cpp:undef>
			</block_content>}</block>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>newval</name></cpp:macro> <cpp:value>(newval_union.intval)</cpp:value></cpp:define>

				<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
												  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>newval_union</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_int_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>,
											 <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;=</operator> <operator>~</operator><name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Save old value to support transaction abort */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
										<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>intval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
											<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>newval</name></cpp:undef>
			</block_content>}</block>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>newval</name></cpp:macro> <cpp:value>(newval_union.realval)</cpp:value></cpp:define>

				<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
												  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>newval_union</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_real_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>,
											  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;=</operator> <operator>~</operator><name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Save old value to support transaction abort */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
										<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>realval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
											<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>newval</name></cpp:undef>
			</block_content>}</block>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>newval</name></cpp:macro> <cpp:value>(newval_union.stringval)</cpp:value></cpp:define>

				<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
												  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>newval_union</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* non-NULL boot_val must always get strdup'd */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>newval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_string_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>,
												<argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * strdup not needed, since reset_val is already under
					 * guc.c's control
					 */</comment>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* newval shouldn't be NULL, so we're a bit sloppy here */</comment>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>newval</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
						<call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;=</operator> <operator>~</operator><name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Save old value to support transaction abort */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
										<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></argument>,
											 <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
											<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Perhaps we didn't install newval anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>string_field_used</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>newval</name></cpp:undef>
			</block_content>}</block>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>newval</name></cpp:macro> <cpp:value>(newval_union.enumval)</cpp:value></cpp:define>

				<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
												  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>newval_union</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_enum_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>,
											  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;=</operator> <operator>~</operator><name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Save old value to support transaction abort */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
										<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>enumval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
											<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>newval</name></cpp:undef>
			</block_content>}</block>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>changeVal</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_REPORT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReportGUCOption</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><ternary><condition><expr><name>changeVal</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Set the fields for source file and line number the setting came from.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_config_sourcefile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourcefile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To avoid cluttering the log, only the postmaster bleats loudly about
	 * problems with the config file.
	 */</comment>
	<expr_stmt><expr><name>elevel</name> <operator>=</operator> <ternary><condition><expr><name>IsUnderPostmaster</name></expr> ?</condition><then> <expr><name>DEBUG3</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* should not happen */</comment>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sourcefile</name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>sourcefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>sourcefile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>sourcefile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>sourcefile</name></name> <operator>=</operator> <name>sourcefile</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>sourceline</name></name> <operator>=</operator> <name>sourceline</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set a config option to the given value.
 *
 * See also set_config_option; this is just the wrapper to be called from
 * outside GUC.  (This function should be used when possible, because its API
 * is more stable than set_config_option's.)
 *
 * Note: there is no support here for setting source file/line, as it
 * is currently not needed.
 */</comment>
<function><type><name>void</name></type>
<name>SetConfigOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
				<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>,
							 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
 * Fetch the current value of the option `name', as a string.
 *
 * If the option doesn't exist, return NULL if missing_ok is true (NOTE that
 * this cannot be distinguished from a string variable with a NULL value!),
 * otherwise throw an ereport and don't return.
 *
 * If restrict_privileged is true, we also enforce that only superusers and
 * members of the pg_read_all_settings role can see GUC_SUPERUSER_ONLY
 * variables.  This should only be passed as true in user-driven calls.
 *
 * The string is *not* allocated for modification and is really only
 * valid until the next call to configuration related functions.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetConfigOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>restrict_privileged</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>restrict_privileged</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_SUPERUSER_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or a member of pg_read_all_settings to examine \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<return>return <expr><ternary><condition><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr>;</return>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
					 <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>buffer</name></expr>;</return>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>,
					 <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>buffer</name></expr>;</return>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</return>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<return>return <expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>,
											   <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the RESET value associated with the given option.
 *
 * Note: this is not re-entrant, due to use of static result buffer;
 * not to mention that a string variable could have its reset_val changed.
 * Beware of assuming the result value is good for very long.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetConfigOptionResetString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_SUPERUSER_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or a member of pg_read_all_settings to examine \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<return>return <expr><ternary><condition><expr><operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr>;</return>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>buffer</name></expr>;</return>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>buffer</name></expr>;</return>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr>;</return>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<return>return <expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>,
											   <argument><expr><operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the GUC flags associated with the given option.
 *
 * If the option doesn't exist, return 0 if missing_ok is true,
 * otherwise throw an ereport and don't return.
 */</comment>
<function><type><name>int</name></type>
<name>GetConfigOptionFlags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * flatten_set_variable_args
 *		Given a parsenode List as emitted by the grammar for SET,
 *		convert to the flat string representation used by GUC.
 *
 * We need to be told the name of the variable the args are for, because
 * the flattening rules vary (ugh).
 *
 * The result is NULL if args is NIL (i.e., SET ... TO DEFAULT), otherwise
 * a palloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>flatten_set_variable_args</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Fast path if just DEFAULT */</comment>
	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get flags for the variable; if it's not known, use default flags.
	 * (Caller might throw error later, but not our business to do so here.)
	 */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Complain if list input and non-list variable */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GUC_LIST_INPUT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET %s takes only one argument"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Each list member may be a plain A_Const node, or an A_Const within a
	 * TypeCast; the latter case is supported only for ConstInterval arguments
	 * (for SET TIME ZONE).
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>tc</name> <init>= <expr><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>typeName</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>typeName</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_Integer</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>intVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Float</name></expr>:</case>
				<comment type="block">/* represented as a string, so just copy it */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_String</name></expr>:</case>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>typeName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Must be a ConstInterval argument for TIME ZONE. Coerce
					 * to interval and back to normalize the value and account
					 * for any typmod.
					 */</comment>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>typoid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name></type>		<name>interval</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>intervalout</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typoid</name> <operator>==</operator> <name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>interval</name> <operator>=</operator>
						<call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>interval_in</name></expr></argument>,
											<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>intervalout</name> <operator>=</operator>
						<call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>interval_out</name></expr></argument>,
															<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INTERVAL '%s'"</literal></expr></argument>, <argument><expr><name>intervalout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Plain string literal or identifier.  For quote mode,
					 * quote it if it's not a vanilla identifier.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GUC_LIST_QUOTE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write updated configuration parameter values into a temporary file.
 * This function traverses the list of parameters and quotes the string
 * values before writing them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_auto_conf_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Emit file header containing warning comment */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"# Do not edit this file manually!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"# It will be overwritten by the ALTER SYSTEM command.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Emit each parameter, properly quoting the value */</comment>
	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>head</name></expr>;</init> <condition><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>escaped</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" = '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>escaped</name> <operator>=</operator> <call><name>escape_single_quotes_ascii</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>escaped</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* fsync before considering the write to be successful */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update the given list of configuration parameters, adding, replacing
 * or deleting the entry for item "name" (delete if "value" == NULL).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>replace_auto_config_value</name><parameter_list>(<parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>head_p</name></decl></parameter>, <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>tail_p</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>item</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Remove any existing match(es) for "name".  Normally there'd be at most
	 * one, but if external tools have modified the config file, there could
	 * be more.
	 */</comment>
	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <operator>*</operator><name>head_p</name></expr>;</init> <condition><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>guc_name_compare</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* found a match, delete it */</comment>
			<if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>head_p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>tail_p</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Done if we're trying to delete it */</comment>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* OK, append a new entry */</comment>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>errmsg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* new item has no location */</comment>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>sourceline</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>ignore</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>applied</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>head_p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>head_p</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>tail_p</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>tail_p</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Execute ALTER SYSTEM statement.
 *
 * Read the old PG_AUTOCONF_FILENAME file, merge in the new variable value,
 * and write out an updated file.  If the command is ALTER SYSTEM RESET ALL,
 * we can skip reading the old file and just write an empty file.
 *
 * An LWLock is used to serialize updates of the configuration file.
 *
 * In case of an error, we leave the original automatic
 * configuration file (PG_AUTOCONF_FILENAME) intact.
 */</comment>
<function><type><name>void</name></type>
<name>AlterSystemSetConfigFile</name><parameter_list>(<parameter><decl><type><name>AlterSystemStmt</name> <modifier>*</modifier></type><name>altersysstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>resetall</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>Tmpfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>AutoConfFileName</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>AutoConfTmpFileName</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to execute ALTER SYSTEM command"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Extract statement arguments
	 */</comment>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>altersysstmt</name><operator>-&gt;</operator><name>setstmt</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>altersysstmt</name><operator>-&gt;</operator><name>setstmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>VAR_SET_VALUE</name></expr>:</case>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ExtractSetVariableArgs</name><argument_list>(<argument><expr><name><name>altersysstmt</name><operator>-&gt;</operator><name>setstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>VAR_SET_DEFAULT</name></expr>:</case>
		<case>case <expr><name>VAR_RESET</name></expr>:</case>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>VAR_RESET_ALL</name></expr>:</case>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>resetall</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter system stmt type: %d"</literal></expr></argument>,
				 <argument><expr><name><name>altersysstmt</name><operator>-&gt;</operator><name>setstmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Unless it's RESET_ALL, validate the target variable and value
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>resetall</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Don't allow parameters that can't be set in configuration files to
		 * be set in PG_AUTOCONF_FILENAME file.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_INTERNAL</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_DISALLOW_IN_FILE</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If a value is specified, verify that it's sane.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>union</name> <name>config_var_val</name></name></type> <name>newval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Check that it's acceptable for the indicated parameter */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
										  <argument><expr><name>PGC_S_FILE</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>PGC_STRING</name> <operator>&amp;&amp;</operator> <name><name>newval</name><operator>.</operator><name>stringval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>newval</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>newextra</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We must also reject values containing newlines, because the
			 * grammar for config files doesn't support embedded newlines in
			 * string literals.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter value for ALTER SYSTEM must not contain a newline"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * PG_AUTOCONF_FILENAME and its corresponding temporary file are always in
	 * the data directory, so we can reference them by simple relative paths.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AutoConfFileName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AutoConfFileName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
			 <argument><expr><name>PG_AUTOCONF_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AutoConfTmpFileName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AutoConfTmpFileName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>,
			 <argument><expr><name>AutoConfFileName</name></expr></argument>,
			 <argument><expr><literal type="string">"tmp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only one backend is allowed to operate on PG_AUTOCONF_FILENAME at a
	 * time.  Use AutoFileLock to ensure that.  We must hold the lock while
	 * reading the old file contents.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutoFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're going to reset everything, then no need to open or parse the
	 * old file.  We'll just write out an empty list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>resetall</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>AutoConfFileName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* open old file PG_AUTOCONF_FILENAME */</comment>
			<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>infile</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>infile</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>AutoConfFileName</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>infile</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>AutoConfFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* parse it */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseConfigFp</name><argument_list>(<argument><expr><name>infile</name></expr></argument>, <argument><expr><name>AutoConfFileName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse contents of file \"%s\""</literal></expr></argument>,
								<argument><expr><name>AutoConfFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now, replace any existing entry with the new value, or add it if
		 * not present.
		 */</comment>
		<expr_stmt><expr><call><name>replace_auto_config_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * To ensure crash safety, first write the new file data to a temp file,
	 * then atomically rename it into place.
	 *
	 * If there is a temp file left over due to a previous crash, it's okay to
	 * truncate and reuse it.
	 */</comment>
	<expr_stmt><expr><name>Tmpfd</name> <operator>=</operator> <call><name>BasicOpenFileForConfigFile</name><argument_list>(<argument><expr><name>AutoConfTmpFileName</name></expr></argument>,
						  <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_RDWR</name> <operator>|</operator> <name>O_TRUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>Tmpfd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>AutoConfTmpFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Use a TRY block to clean up the file if we fail.  Since we need a TRY
	 * block anyway, OK to use BasicOpenFile rather than OpenTransientFile.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Write and sync the new contents to the temporary file */</comment>
		<expr_stmt><expr><call><name>write_auto_conf_file</name><argument_list>(<argument><expr><name>Tmpfd</name></expr></argument>, <argument><expr><name>AutoConfTmpFileName</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Close before renaming; may be required on some platforms */</comment>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>Tmpfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>Tmpfd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * As the rename is atomic operation, if any problem occurs after this
		 * at worst it can lose the parameters set by last ALTER SYSTEM
		 * command.
		 */</comment>
		<expr_stmt><expr><call><name>durable_rename</name><argument_list>(<argument><expr><name>AutoConfTmpFileName</name></expr></argument>, <argument><expr><name>AutoConfFileName</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Close file first, else unlink might fail on some platforms */</comment>
		<if_stmt><if>if <condition>(<expr><name>Tmpfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>Tmpfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Unlink, but ignore any error */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>AutoConfTmpFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeConfigVariables</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutoFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SET command
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetVariableStmt</name><parameter_list>(<parameter><decl><type><name>VariableSetStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GucAction</name></type>	<name>action</name> <init>= <expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr> ?</condition><then> <expr><name>GUC_ACTION_LOCAL</name></expr> </then><else>: <expr><name>GUC_ACTION_SET</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Workers synchronize these parameters at the start of the parallel
	 * operation; then, we block SET during the operation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set parameters during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>VAR_SET_VALUE</name></expr>:</case>
		<case>case <expr><name>VAR_SET_CURRENT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SET LOCAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									 <argument><expr><call><name>ExtractSetVariableArgs</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>,
									 <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
									 <argument><expr><name>action</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>VAR_SET_MULTI</name></expr>:</case>

			<comment type="block">/*
			 * Special-case SQL syntaxes.  The TRANSACTION and SESSION
			 * CHARACTERISTICS cases effectively set more than one variable
			 * per statement.  TRANSACTION SNAPSHOT only takes one argument,
			 * but we put it here anyway since it's a special case and not
			 * related to any GUC variable.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"TRANSACTION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SET TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<macro><name>foreach</name><argument_list>(<argument>head</argument>, <argument>stmt-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SET TRANSACTION element: %s"</literal></expr></argument>,
							 <argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"SESSION CHARACTERISTICS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>head</argument>, <argument>stmt-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"default_transaction_isolation"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"default_transaction_read_only"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"default_transaction_deferrable"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SET SESSION element: %s"</literal></expr></argument>,
							 <argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"TRANSACTION SNAPSHOT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET LOCAL TRANSACTION SNAPSHOT is not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SET TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_String</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ImportSnapshot</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SET MULTI element: %s"</literal></expr></argument>,
					 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>VAR_SET_DEFAULT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SET LOCAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* fall through */</comment>
		<case>case <expr><name>VAR_RESET</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"RESET TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>,
									 <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
									 <argument><expr><name>action</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>VAR_RESET_ALL</name></expr>:</case>
			<expr_stmt><expr><call><name>ResetAllOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Get the value to assign for a VariableSetStmt, or NULL if it's RESET.
 * The result is palloc'd.
 *
 * This is exported for use by actions such as ALTER ROLE SET.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>ExtractSetVariableArgs</name><parameter_list>(<parameter><decl><type><name>VariableSetStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>VAR_SET_VALUE</name></expr>:</case>
			<return>return <expr><call><name>flatten_set_variable_args</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>VAR_SET_CURRENT</name></expr>:</case>
			<return>return <expr><call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * SetPGVariable - SET command exported as an easily-C-callable function.
 *
 * This provides access to SET TO value, as well as SET TO DEFAULT (expressed
 * by passing args == NIL), but not SET FROM CURRENT functionality.
 */</comment>
<function><type><name>void</name></type>
<name>SetPGVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_local</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argstring</name> <init>= <expr><call><name>flatten_set_variable_args</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Note SET DEFAULT (argstring == NULL) is equivalent to RESET */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
							 <argument><expr><name>argstring</name></expr></argument>,
							 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>,
							 <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>is_local</name></expr> ?</condition><then> <expr><name>GUC_ACTION_LOCAL</name></expr> </then><else>: <expr><name>GUC_ACTION_SET</name></expr></else></ternary></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SET command wrapped as a SQL callable function.
 */</comment>
<function><type><name>Datum</name></type>
<name>set_config_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>new_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_local</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET requires parameter name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the GUC variable name */</comment>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the desired value or set to NULL for a reset request */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Get the desired state of is_local. Default to false if provided value
	 * is NULL
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>is_local</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>is_local</name> <operator>=</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Note SET DEFAULT (argstring == NULL) is equivalent to RESET */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
							 <argument><expr><name>value</name></expr></argument>,
							 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>,
							 <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>is_local</name></expr> ?</condition><then> <expr><name>GUC_ACTION_LOCAL</name></expr> </then><else>: <expr><name>GUC_ACTION_SET</name></expr></else></ternary></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the new current value */</comment>
	<expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert return string to text */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Common code for DefineCustomXXXVariable subroutines: allocate the
 * new variable's config struct and fill in generic fields.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type>
<name>init_custom_variable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
					 <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
					 <parameter><decl><type><name><name>enum</name> <name>config_type</name></name></type> <name>type</name></decl></parameter>,
					 <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only allow custom PGC_POSTMASTER variables to be created during shared
	 * library preload; any later than that, we can't ensure that the value
	 * doesn't change after startup.  This is a fatal elog if it happens; just
	 * erroring out isn't safe because we don't know what the calling loadable
	 * module might already have hooked into.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_POSTMASTER</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>process_shared_preload_libraries_in_progress</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"cannot create PGC_POSTMASTER variables after startup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can't support custom GUC_LIST_QUOTE variables, because the wrong
	 * things would happen if such a variable were set or pg_dump'd when the
	 * defining extension isn't loaded.  Again, treat this as fatal because
	 * the loadable module may be partly initialized already.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GUC_LIST_QUOTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"extensions cannot define GUC_LIST_QUOTE variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Before pljava commit 398f3b876ed402bdaec8bc804f29e2be95c75139
	 * (2015-12-15), two of that module's PGC_USERSET variables facilitated
	 * trivial escalation to superuser privileges.  Restrict the variables to
	 * protect sites that have yet to upgrade pljava.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_USERSET</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"pljava.classpath"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"pljava.vmoptions"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>context</name> <operator>=</operator> <name>PGC_SUSET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>gen</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>)</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>gen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>CUSTOM_OPTIONS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>short_desc</name></name> <operator>=</operator> <name>short_desc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>long_desc</name></name> <operator>=</operator> <name>long_desc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

	<return>return <expr><name>gen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Common code for DefineCustomXXXVariable subroutines: insert the new
 * variable into the GUC variable array, replacing any placeholder.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>define_custom_variable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>variable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nameAddr</name> <init>= <expr><operator>&amp;</operator><name>name</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>pHolder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * See if there's a placeholder by the same name.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>nameAddr</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>guc_variables</name></expr></argument>,
											 <argument><expr><name>num_guc_variables</name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
											 <argument><expr><name>guc_var_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No placeholder to replace, so we can just add it ... but first,
		 * make sure it's initialized to its default value.
		 */</comment>
		<expr_stmt><expr><call><name>InitializeOneGUCOption</name><argument_list>(<argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_guc_variable</name><argument_list>(<argument><expr><name>variable</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This better be a placeholder
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>res</name><operator>)</operator><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_CUSTOM_PLACEHOLDER</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attempt to redefine parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>res</name><operator>)</operator><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>PGC_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pHolder</name> <operator>=</operator> <operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>*</operator><name>res</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, set the variable to its default value.  We must do this even
	 * though we intend to immediately apply a new value, since it's possible
	 * that the new value is invalid.
	 */</comment>
	<expr_stmt><expr><call><name>InitializeOneGUCOption</name><argument_list>(<argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace the placeholder. We aren't changing the name, so no re-sorting
	 * is necessary
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>variable</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assign the string value(s) stored in the placeholder to the real
	 * variable.  Essentially, we need to duplicate all the active and stacked
	 * values, but with appropriate validation and datatype adjustment.
	 *
	 * If an assignment fails, we report a WARNING and keep going.  We don't
	 * want to throw ERROR for bad values, because it'd bollix the add-on
	 * module that's presumably halfway through getting loaded.  In such cases
	 * the default or previous state will become active instead.
	 */</comment>

	<comment type="block">/* First, apply the reset value if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pHolder</name><operator>-&gt;</operator><name>reset_val</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
								 <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr></argument>,
								 <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr></argument>,
								 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* That should not have resulted in stacking anything */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>variable</name><operator>-&gt;</operator><name>stack</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now, apply current and stacked values, in the order they were stacked */</comment>
	<expr_stmt><expr><call><name>reapply_stacked_values</name><argument_list>(<argument><expr><name>variable</name></expr></argument>, <argument><expr><name>pHolder</name></expr></argument>, <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr></argument>,
						   <argument><expr><operator>*</operator><operator>(</operator><name><name>pHolder</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator></expr></argument>,
						   <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name></expr></argument>, <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also copy over any saved source-location information */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>sourcefile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_config_sourcefile</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>sourcefile</name></name></expr></argument>,
							  <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>sourceline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Free up as much as we conveniently can of the placeholder structure.
	 * (This neglects any stack items, so it's possible for some memory to be
	 * leaked.  Since this can only happen once per session per variable, it
	 * doesn't seem worth spending much code on.)
	 */</comment>
	<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>pHolder</name></expr></argument>, <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>pHolder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHolder</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pHolder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recursive subroutine for define_custom_variable: reapply non-reset values
 *
 * We recurse so that the values are applied in the same order as originally.
 * At each recursion level, apply the upper-level value (passed in) in the
 * fashion implied by the stack entry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reapply_stacked_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>variable</name></decl></parameter>,
					   <parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>pHolder</name></decl></parameter>,
					   <parameter><decl><type><name>GucStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>curvalue</name></decl></parameter>,
					   <parameter><decl><type><name>GucContext</name></type> <name>curscontext</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>cursource</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>oldvarstack</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First, recurse, so that stack items are processed bottom to top */</comment>
		<expr_stmt><expr><call><name>reapply_stacked_values</name><argument_list>(<argument><expr><name>variable</name></expr></argument>, <argument><expr><name>pHolder</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>,
							   <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></argument>,
							   <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* See how to apply the passed-in value */</comment>
		<switch>switch <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>GUC_SAVE</name></expr>:</case>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>curvalue</name></expr></argument>,
										 <argument><expr><name>curscontext</name></expr></argument>, <argument><expr><name>cursource</name></expr></argument>,
										 <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>GUC_SET</name></expr>:</case>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>curvalue</name></expr></argument>,
										 <argument><expr><name>curscontext</name></expr></argument>, <argument><expr><name>cursource</name></expr></argument>,
										 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>GUC_LOCAL</name></expr>:</case>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>curvalue</name></expr></argument>,
										 <argument><expr><name>curscontext</name></expr></argument>, <argument><expr><name>cursource</name></expr></argument>,
										 <argument><expr><name>GUC_ACTION_LOCAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>GUC_SET_LOCAL</name></expr>:</case>
				<comment type="block">/* first, apply the masked value as SET */</comment>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></argument>,
										 <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>masked_scontext</name></name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
										 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* then apply the current value as LOCAL */</comment>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>curvalue</name></expr></argument>,
										 <argument><expr><name>curscontext</name></expr></argument>, <argument><expr><name>cursource</name></expr></argument>,
										 <argument><expr><name>GUC_ACTION_LOCAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* If we successfully made a stack entry, adjust its nest level */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>stack</name></name> <operator>!=</operator> <name>oldvarstack</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>variable</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We are at the end of the stack.  If the active/previous value is
		 * different from the reset value, it must represent a previously
		 * committed session value.  Apply it, and then drop the stack entry
		 * that set_config_option will have created under the impression that
		 * this is to be just a transactional assignment.  (We leak the stack
		 * entry.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>curvalue</name> <operator>!=</operator> <name><name>pHolder</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>||</operator>
			<name>curscontext</name> <operator>!=</operator> <name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>||</operator>
			<name>cursource</name> <operator>!=</operator> <name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>curvalue</name></expr></argument>,
									 <argument><expr><name>curscontext</name></expr></argument>, <argument><expr><name>cursource</name></expr></argument>,
									 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>variable</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DefineCustomBoolVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>valueAddr</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>bootValue</name></decl></parameter>,
						 <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
						 <parameter><decl><type><name>GucBoolCheckHook</name></type> <name>check_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucBoolAssignHook</name></type> <name>assign_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucShowHook</name></type> <name>show_hook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator>
		<call><name>init_custom_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>short_desc</name></expr></argument>, <argument><expr><name>long_desc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
							 <argument><expr><name>PGC_BOOL</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>valueAddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>check_hook</name></name> <operator>=</operator> <name>check_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>assign_hook</name></name> <operator>=</operator> <name>assign_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>show_hook</name></name> <operator>=</operator> <name>show_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>define_custom_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DefineCustomIntVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
						<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>valueAddr</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>bootValue</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>minValue</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>maxValue</name></decl></parameter>,
						<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
						<parameter><decl><type><name>GucIntCheckHook</name></type> <name>check_hook</name></decl></parameter>,
						<parameter><decl><type><name>GucIntAssignHook</name></type> <name>assign_hook</name></decl></parameter>,
						<parameter><decl><type><name>GucShowHook</name></type> <name>show_hook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator>
		<call><name>init_custom_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>short_desc</name></expr></argument>, <argument><expr><name>long_desc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
							 <argument><expr><name>PGC_INT</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>valueAddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name>minValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>maxValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>check_hook</name></name> <operator>=</operator> <name>check_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>assign_hook</name></name> <operator>=</operator> <name>assign_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>show_hook</name></name> <operator>=</operator> <name>show_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>define_custom_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DefineCustomRealVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
						 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>valueAddr</name></decl></parameter>,
						 <parameter><decl><type><name>double</name></type> <name>bootValue</name></decl></parameter>,
						 <parameter><decl><type><name>double</name></type> <name>minValue</name></decl></parameter>,
						 <parameter><decl><type><name>double</name></type> <name>maxValue</name></decl></parameter>,
						 <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
						 <parameter><decl><type><name>GucRealCheckHook</name></type> <name>check_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucRealAssignHook</name></type> <name>assign_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucShowHook</name></type> <name>show_hook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator>
		<call><name>init_custom_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>short_desc</name></expr></argument>, <argument><expr><name>long_desc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
							 <argument><expr><name>PGC_REAL</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_real</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>valueAddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name>minValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>maxValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>check_hook</name></name> <operator>=</operator> <name>check_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>assign_hook</name></name> <operator>=</operator> <name>assign_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>show_hook</name></name> <operator>=</operator> <name>show_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>define_custom_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DefineCustomStringVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
						   <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>valueAddr</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bootValue</name></decl></parameter>,
						   <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
						   <parameter><decl><type><name>GucStringCheckHook</name></type> <name>check_hook</name></decl></parameter>,
						   <parameter><decl><type><name>GucStringAssignHook</name></type> <name>assign_hook</name></decl></parameter>,
						   <parameter><decl><type><name>GucShowHook</name></type> <name>show_hook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator>
		<call><name>init_custom_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>short_desc</name></expr></argument>, <argument><expr><name>long_desc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
							 <argument><expr><name>PGC_STRING</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_string</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>valueAddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>check_hook</name></name> <operator>=</operator> <name>check_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>assign_hook</name></name> <operator>=</operator> <name>assign_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>show_hook</name></name> <operator>=</operator> <name>show_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>define_custom_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DefineCustomEnumVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>valueAddr</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>bootValue</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
						 <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
						 <parameter><decl><type><name>GucEnumCheckHook</name></type> <name>check_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucEnumAssignHook</name></type> <name>assign_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucShowHook</name></type> <name>show_hook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator>
		<call><name>init_custom_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>short_desc</name></expr></argument>, <argument><expr><name>long_desc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
							 <argument><expr><name>PGC_ENUM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_enum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>valueAddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>check_hook</name></name> <operator>=</operator> <name>check_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>assign_hook</name></name> <operator>=</operator> <name>assign_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>show_hook</name></name> <operator>=</operator> <name>show_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>define_custom_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>EmitWarningsOnPlaceholders</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>className</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>classLen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_CUSTOM_PLACEHOLDER</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><name>className</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>classLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>classLen</name></expr>]</index></name> <operator>==</operator> <name>GUC_QUALIFIER_SEPARATOR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * SHOW command
 */</comment>
<function><type><name>void</name></type>
<name>GetPGVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>guc_name_compare</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowAllGUCConfig</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowGUCConfigOption</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>TupleDesc</name></type>
<name>GetPGVariableResultDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>guc_name_compare</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* need a tuple descriptor representing three TEXT columns */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"setting"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"description"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>

		<comment type="block">/* Get the canonical spelling of name */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* need a tuple descriptor representing a single TEXT column */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>tupdesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: For non-superuser, show max_connections will return the polar_max_non_super_conns. However,
 * 1. If the polar_max_non_super_conns is not set, means polar_max_non_super_conns=-1, just return 
 * max_connections;
 * 2. If the polar_max_non_super_conns is larger than max_connections, just return max_connections;
 * 3. Only if the polar_max_non_super_conns is less than max_connections, and it is not -1, return
 * polar_max_non_super_conns instead of max_connections.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>polar_show_max_connections</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>nbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>issuper</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>MaxConnections</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>polar_max_non_super_conns</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>MaxConnections</name> <operator>&lt;</operator> <name>polar_max_non_super_conns</name><operator>)</operator><operator>)</operator></expr> ?</condition><then>
					<expr><name>MaxConnections</name></expr> </then><else>: <expr><name>polar_max_non_super_conns</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nbuf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SHOW command
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShowGUCConfigOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

	<comment type="block">/* Get the value and canonical spelling of name */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* need a tuple descriptor representing a single TEXT column */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* prepare for projection of tuples */</comment>
	<expr_stmt><expr><name>tstate</name> <operator>=</operator> <call><name>begin_tup_output_tupdesc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send it */</comment>
	<expr_stmt><expr><call><name>do_text_output_oneline</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>end_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SHOW ALL command
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShowAllGUCConfig</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* need a tuple descriptor representing three TEXT columns */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"setting"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"description"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* prepare for projection of tuples */</comment>
	<expr_stmt><expr><name>tstate</name> <operator>=</operator> <call><name>begin_tup_output_tupdesc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>setting</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_NO_SHOW_ALL</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_SUPERUSER_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* assign to the values array */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>setting</name> <operator>=</operator> <call><name>_ShowOption</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>setting</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>setting</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>short_desc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* send it to dest */</comment>
		<expr_stmt><expr><call><name>do_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* clean up */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>setting</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>setting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>end_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return GUC variable value by name; optionally return canonical form of
 * name.  If the GUC is unset, then throw an error unless missing_ok is true,
 * in which case return NULL.  Return value is palloc'd (but *varname isn't).
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetConfigOptionByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>varname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>varname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>varname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_SUPERUSER_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or a member of pg_read_all_settings to examine \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>varname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>varname</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>_ShowOption</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return GUC variable value by variable number; optionally return canonical
 * form of name.  Return value is palloc'd.
 */</comment>
<function><type><name>void</name></type>
<name>GetConfigOptionByNum</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>varnum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>noshow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>conf</name></decl>;</decl_stmt>

	<comment type="block">/* check requested variable number valid */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>varnum</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>varnum</name> <operator>&lt;</operator> <name>num_guc_variables</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conf</name> <operator>=</operator> <name><name>guc_variables</name><index>[<expr><name>varnum</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>noshow</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_NO_SHOW_ALL</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_SUPERUSER_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>noshow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>noshow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* first get the generic attributes */</comment>

	<comment type="block">/* name */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

	<comment type="block">/* setting : use _ShowOption in order to avoid duplicating the logic */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>_ShowOption</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unit */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>PGC_INT</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>GUC_UNIT_MEMORY</name> <operator>|</operator> <name>GUC_UNIT_TIME</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>GUC_UNIT_BYTE</name></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"B"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GUC_UNIT_KB</name></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"kB"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GUC_UNIT_MB</name></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"MB"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GUC_UNIT_BLOCKS</name></expr>:</case>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%dkB"</literal></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GUC_UNIT_XBLOCKS</name></expr>:</case>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%dkB"</literal></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GUC_UNIT_MS</name></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"ms"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GUC_UNIT_S</name></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"s"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GUC_UNIT_MIN</name></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"min"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">0</literal></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized GUC units value: %d"</literal></expr></argument>,
					 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>GUC_UNIT_MEMORY</name> <operator>|</operator> <name>GUC_UNIT_TIME</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* group */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>config_group_names</name><index>[<expr><name><name>conf</name><operator>-&gt;</operator><name>group</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* short_desc */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>short_desc</name></name></expr>;</expr_stmt>

	<comment type="block">/* extra_desc */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>long_desc</name></name></expr>;</expr_stmt>

	<comment type="block">/* context */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>GucContext_Names</name><index>[<expr><name><name>conf</name><operator>-&gt;</operator><name>context</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* vartype */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>config_type_names</name><index>[<expr><name><name>conf</name><operator>-&gt;</operator><name>vartype</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* source */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name><name>GucSource_Names</name><index>[<expr><name><name>conf</name><operator>-&gt;</operator><name>source</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* now get the type specific attributes */</comment>
	<switch>switch <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* reset_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* reset_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* reset_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/* reset_val */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>

				<comment type="block">/*
				 * NOTE! enumvals with double quotes in them are not
				 * supported!
				 */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>config_enum_get_options</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></argument>,
													 <argument><expr><literal type="string">"{\""</literal></expr></argument>, <argument><expr><literal type="string">"\"}"</literal></expr></argument>, <argument><expr><literal type="string">"\",\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>lconf</name></expr></argument>,
																 <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* reset_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>lconf</name></expr></argument>,
																 <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<block>{<block_content>
				<comment type="block">/*
				 * should never get here, but in case we do, set 'em to NULL
				 */</comment>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* reset_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If the setting came from a config file, set the source location. For
	 * security reasons, we don't show source file/line number for
	 * insufficiently-privileged users.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>source</name></name> <operator>==</operator> <name>PGC_S_FILE</name> <operator>&amp;&amp;</operator>
		<call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;</operator> <name>GUC_PENDING_RESTART</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"t"</literal></expr> </then><else>: <expr><literal type="string">"f"</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the total number of GUC variables
 */</comment>
<function><type><name>int</name></type>
<name>GetNumConfigOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>num_guc_variables</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * show_config_by_name - equiv to SHOW X command but implemented as
 * a function.
 */</comment>
<function><type><name>Datum</name></type>
<name>show_config_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varval</name></decl>;</decl_stmt>

	<comment type="block">/* Get the value */</comment>
	<expr_stmt><expr><name>varval</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert to text */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>varval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * show_config_by_name_missing_ok - equiv to SHOW X command but implemented as
 * a function.  If X does not exist, suppress the error and just return NULL
 * if missing_ok is true.
 */</comment>
<function><type><name>Datum</name></type>
<name>show_config_by_name_missing_ok</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>missing_ok</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varval</name></decl>;</decl_stmt>

	<comment type="block">/* Get the value */</comment>
	<expr_stmt><expr><name>varval</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* return NULL if no such variable */</comment>
	<if_stmt><if>if <condition>(<expr><name>varval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert to text */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>varval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * show_all_settings - equiv to SHOW ALL command but implemented as
 * a Table Function.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_PG_SETTINGS_ATTS</name></cpp:macro>	<cpp:value>17</cpp:value></cpp:define>

<function><type><name>Datum</name></type>
<name>show_all_settings</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>call_cntr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_calls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * switch to memory context appropriate for multiple function calls
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * need a tuple descriptor representing NUM_PG_SETTINGS_ATTS columns
		 * of the appropriate types
		 */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>NUM_PG_SETTINGS_ATTS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"setting"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"unit"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"category"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"short_desc"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"extra_desc"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"context"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"vartype"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">"source"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"min_val"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">11</literal></expr></argument>, <argument><expr><literal type="string">"max_val"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><literal type="string">"enumvals"</literal></expr></argument>,
						   <argument><expr><name>TEXTARRAYOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">13</literal></expr></argument>, <argument><expr><literal type="string">"boot_val"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">14</literal></expr></argument>, <argument><expr><literal type="string">"reset_val"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">15</literal></expr></argument>, <argument><expr><literal type="string">"sourcefile"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><literal type="string">"sourceline"</literal></expr></argument>,
						   <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">17</literal></expr></argument>, <argument><expr><literal type="string">"pending_restart"</literal></expr></argument>,
						   <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Generate attribute metadata needed later to produce tuples from raw
		 * C strings
		 */</comment>
		<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <name>attinmeta</name></expr>;</expr_stmt>

		<comment type="block">/* total number of tuples to be returned */</comment>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <call><name>GetNumConfigOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>call_cntr</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_calls</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>attinmeta</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>call_cntr</name> <operator>&lt;</operator> <name>max_calls</name></expr>)</condition>	<comment type="block">/* do when there is more left to send */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>values</name><index>[<expr><name>NUM_PG_SETTINGS_ATTS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>noshow</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get the next visible GUC variable name and value
		 */</comment>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><call><name>GetConfigOptionByNum</name><argument_list>(<argument><expr><name>call_cntr</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>noshow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>noshow</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* bump the counter and get the next config setting */</comment>
				<expr_stmt><expr><name>call_cntr</name> <operator>=</operator> <operator>++</operator><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr>;</expr_stmt>

				<comment type="block">/* make sure we haven't gone too far now */</comment>
				<if_stmt><if>if <condition>(<expr><name>call_cntr</name> <operator>&gt;=</operator> <name>max_calls</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block> while <condition>(<expr><name>noshow</name></expr>)</condition>;</do>

		<comment type="block">/* build a tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make the tuple into a datum */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* do when there is no more left */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * show_all_file_settings
 *
 * Returns a table of all parameter settings in all configuration files
 * which includes the config file pathname, the line number, a sequence number
 * indicating the order in which the settings were encountered, the parameter
 * name and value, a bool showing if the value could be applied, and possibly
 * an associated error message.  (For problems such as syntax errors, the
 * parameter name/value might be NULL.)
 *
 * Note: no filtering is done here, instead we depend on the GRANT system
 * to prevent unprivileged users from accessing this function or the view
 * built on top of it.
 */</comment>
<function><type><name>Datum</name></type>
<name>show_all_file_settings</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_PG_FILE_SETTINGS_ATTS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>conf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>seqno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Scan the config files using current context as workspace */</comment>
	<expr_stmt><expr><name>conf</name> <operator>=</operator> <call><name>ProcessConfigFileInternal</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Switch into long-lived context to construct returned data structures */</comment>
	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>NUM_PG_FILE_SETTINGS_ATTS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"sourcefile"</literal></expr></argument>,
					   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"sourceline"</literal></expr></argument>,
					   <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"seqno"</literal></expr></argument>,
					   <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>,
					   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"setting"</literal></expr></argument>,
					   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"applied"</literal></expr></argument>,
					   <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>,
					   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuplestore to return our results in */</comment>
	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<comment type="block">/* The rest can be done in short-lived context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process the results and create a tuplestore */</comment>
	<for>for <control>(<init><expr><name>seqno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>conf</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>conf</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>seqno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>NUM_PG_FILE_SETTINGS_ATTS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>NUM_PG_FILE_SETTINGS_ATTS</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* sourcefile */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* sourceline (not meaningful if no sourcefile) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* seqno */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>seqno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* name */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* setting */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* applied */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>applied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* error */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>errmsg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>errmsg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* shove row into tuplestore */</comment>
		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>_ShowOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_units</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Use int64 arithmetic to avoid overflows in units
					 * conversion.
					 */</comment>
					<decl_stmt><decl><type><name>int64</name></type>		<name>result</name> <init>= <expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>use_units</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_UNIT</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>convert_from_base_unit</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_UNIT</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name> <literal type="string">"%s"</literal></expr></argument>,
							 <argument><expr><name>result</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>,
							 <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* just to keep compiler quiet */</comment>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

<comment type="block">/*
 *	These routines dump out all non-default GUC options into a binary
 *	file that is read by all exec'ed backends.  The format is:
 *
 *		variable name, string, null terminated
 *		variable value, string, null terminated
 *		variable sourcefile, string, null terminated (empty if none)
 *		variable sourceline, integer
 *		variable source, integer
 *		variable scontext, integer
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_one_nondefault_variable</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%.17g"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
						<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>write_nondefault_variables</name><parameter_list>(<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name> <operator>==</operator> <name>PGC_POSTMASTER</name> <operator>||</operator> <name>context</name> <operator>==</operator> <name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>elevel</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>context</name> <operator>==</operator> <name>PGC_SIGHUP</name><operator>)</operator></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>ERROR</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open file
	 */</comment>
	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>CONFIG_EXEC_PARAMS_NEW</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>CONFIG_EXEC_PARAMS_NEW</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_one_nondefault_variable</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>CONFIG_EXEC_PARAMS_NEW</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Put new file in place.  This could delay on Win32, but we don't hold
	 * any exclusive locks.
	 */</comment>
	<expr_stmt><expr><call><name>rename</name><argument_list>(<argument><expr><name>CONFIG_EXEC_PARAMS_NEW</name></expr></argument>, <argument><expr><name>CONFIG_EXEC_PARAMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	Read string, including null byte from file
 *
 *	Return NULL on EOF and nothing read
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>read_string_with_null</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>ch</name></decl>,
				<decl><type ref="prev"/><name>maxlen</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>EOF</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>maxlen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>guc_realloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>maxlen</name> <operator>*=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>ch</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	This routine loads a previous postmaster dump of its non-default
 *	settings.
 */</comment>
<function><type><name>void</name></type>
<name>read_nondefault_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>varvalue</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>varsourcefile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varsourceline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucSource</name></type>	<name>varsource</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucContext</name></type>	<name>varscontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Assert that PGC_BACKEND/PGC_SU_BACKEND case in set_config_option() will
	 * do the right thing.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsInitProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open file
	 */</comment>
	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>CONFIG_EXEC_PARAMS</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* File not found is fine */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>CONFIG_EXEC_PARAMS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>varname</name> <operator>=</operator> <call><name>read_string_with_null</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to locate variable \"%s\" in exec config params file"</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>varvalue</name> <operator>=</operator> <call><name>read_string_with_null</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>varsourcefile</name> <operator>=</operator> <call><name>read_string_with_null</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varsourceline</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varsourceline</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>varsourceline</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varsource</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varsource</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>varsource</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varscontext</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varscontext</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>varscontext</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>varvalue</name></expr></argument>,
								 <argument><expr><name>varscontext</name></expr></argument>, <argument><expr><name>varsource</name></expr></argument>,
								 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>varsourcefile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_config_sourcefile</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>varsourcefile</name></expr></argument>, <argument><expr><name>varsourceline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>varvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>varsourcefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>

<comment type="block">/*
 * can_skip_gucvar:
 * When serializing, determine whether to skip this GUC.  When restoring, the
 * negation of this test determines whether to restore the compiled-in default
 * value before processing serialized values.
 *
 * A PGC_S_DEFAULT setting on the serialize side will typically match new
 * postmaster children, but that can be false when got_SIGHUP == true and the
 * pending configuration change modifies this setting.  Nonetheless, we omit
 * PGC_S_DEFAULT settings from serialization and make up for that by restoring
 * defaults before applying serialized values.
 *
 * PGC_POSTMASTER variables always have the same value in every child of a
 * particular postmaster.  Most PGC_INTERNAL variables are compile-time
 * constants; a few, like server_encoding and lc_ctype, are handled specially
 * outside the serialize/restore procedure.  Therefore, SerializeGUCState()
 * never sends these, and RestoreGUCState() never changes them.
 *
 * Role is a special variable in the sense that its current value can be an
 * invalid value and there are multiple ways by which that can happen (like
 * after setting the role, someone drops it).  So we handle it outside of
 * serialize/restore machinery.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_skip_gucvar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_POSTMASTER</name> <operator>||</operator>
		<name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_INTERNAL</name> <operator>||</operator> <name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>==</operator> <name>PGC_S_DEFAULT</name> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"role"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * estimate_variable_size:
 *		Compute space needed for dumping the given GUC variable.
 *
 * It's OK to overestimate, but not to underestimate.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>estimate_variable_size</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>valsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>can_skip_gucvar</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Name, plus trailing zero byte. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Get the maximum display length of the GUC value. */</comment>
	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>valsize</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>	<comment type="block">/* max(strlen('true'), strlen('false')) */</comment>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Instead of getting the exact display length, use max
				 * length.  Also reduce the max length for typical ranges of
				 * small values.  Maximum value is 2147483647, i.e. 10 chars.
				 * Include one byte for sign.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>valsize</name> <operator>=</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>valsize</name> <operator>=</operator> <literal type="number">10</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * We are going to print it with %e with REALTYPE_PRECISION
				 * fractional digits.  Account for sign, leading digit,
				 * decimal point, and exponent with up to 3 digits.  E.g.
				 * -3.99329042340000021e+110
				 */</comment>
				<expr_stmt><expr><name>valsize</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>REALTYPE_PRECISION</name> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If the value is NULL, we transmit it as an empty string.
				 * Although this is not physically the same value, GUC
				 * generally treats a NULL the same as empty string.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>valsize</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>valsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>valsize</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Allow space for terminating zero-byte for value */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>valsize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Allow space for terminating zero-byte for sourcefile */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Include line whenever file is nonempty. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name> <operator>&amp;&amp;</operator> <name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EstimateGUCStateSpace:
 * Returns the size needed to store the GUC state for the current process
 */</comment>
<function><type><name>Size</name></type>
<name>EstimateGUCStateSpace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Add space reqd for saving the data size of the guc state */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Add up the space needed for each GUC variable */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
						<argument><expr><call><name>estimate_variable_size</name><argument_list>(<argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * do_serialize:
 * Copies the formatted string into the destination.  Moves ahead the
 * destination pointer, and decrements the maxbytes by that many bytes. If
 * maxbytes is not sufficient to copy the string, error out.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_serialize</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>destptr</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>maxbytes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>vargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>maxbytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not enough space to serialize GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><operator>*</operator><name>destptr</name></expr></argument>, <argument><expr><operator>*</operator><name>maxbytes</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cater to portability hazards in the vsnprintf() return value just like
	 * appendPQExpBufferVA() does.  Note that this requires an extra byte of
	 * slack at the end of the buffer.  Since serialize_variable() ends with a
	 * do_serialize_binary() rather than a do_serialize(), we'll always have
	 * that slack; estimate_variable_size() need not add a byte for it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <operator>*</operator><name>maxbytes</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOMEM</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* Shouldn't happen. Better show errno description. */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"vsnprintf failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not enough space to serialize GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Shift the destptr ahead of the null terminator */</comment>
	<expr_stmt><expr><operator>*</operator><name>destptr</name> <operator>+=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>maxbytes</name> <operator>-=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Binary copy version of do_serialize() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_serialize_binary</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>destptr</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>maxbytes</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>valsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>valsize</name> <operator>&gt;</operator> <operator>*</operator><name>maxbytes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not enough space to serialize GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>destptr</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>valsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>destptr</name> <operator>+=</operator> <name>valsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>maxbytes</name> <operator>-=</operator> <name>valsize</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * serialize_variable:
 * Dumps name, value and other information of a GUC variable into destptr.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>serialize_variable</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>destptr</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>maxbytes</name></decl></parameter>,
				   <parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>can_skip_gucvar</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>,
							 <argument><expr><operator>(</operator><ternary><condition><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%.*e"</literal></expr></argument>,
							 <argument><expr><name>REALTYPE_PRECISION</name></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* NULL becomes empty string, see estimate_variable_size() */</comment>
				<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
							 <argument><expr><ternary><condition><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr> ?</condition><then> <expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
							 <argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr> ?</condition><then> <expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name> <operator>&amp;&amp;</operator> <name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_serialize_binary</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>,
							<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>do_serialize_binary</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr></argument>,
						<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>do_serialize_binary</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>,
						<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SerializeGUCState:
 * Dumps the complete GUC state onto the memory location at start_address.
 */</comment>
<function><type><name>void</name></type>
<name>SerializeGUCState</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>actual_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>bytes_left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Reserve space for saving the actual size of the guc state */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxsize</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curptr</name> <operator>=</operator> <name>start_address</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytes_left</name> <operator>=</operator> <name>maxsize</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>serialize_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_left</name></expr></argument>, <argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Store actual size without assuming alignment of start_address. */</comment>
	<expr_stmt><expr><name>actual_size</name> <operator>=</operator> <name>maxsize</name> <operator>-</operator> <name>bytes_left</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>start_address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>actual_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * read_gucstate:
 * Actually it does not read anything, just returns the srcptr. But it does
 * move the srcptr past the terminating zero byte, so that the caller is ready
 * to read the next string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>read_gucstate</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>srcptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>srcend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>retptr</name> <init>= <expr><operator>*</operator><name>srcptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>srcptr</name> <operator>&gt;=</operator> <name>srcend</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incomplete GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* The string variables are all null terminated */</comment>
	<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <operator>*</operator><name>srcptr</name></expr>;</init> <condition><expr><name>ptr</name> <operator>&lt;</operator> <name>srcend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>srcend</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find null terminator in GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set the new position to the byte following the terminating NUL */</comment>
	<expr_stmt><expr><operator>*</operator><name>srcptr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>retptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Binary read version of read_gucstate(). Copies into dest */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_gucstate_binary</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>srcptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>srcend</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>srcptr</name> <operator>+</operator> <name>size</name> <operator>&gt;</operator> <name>srcend</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incomplete GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>*</operator><name>srcptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>srcptr</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback used to add a context message when reporting errors that occur
 * while trying to restore GUCs in parallel workers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>guc_restore_error_context_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>error_context_name_and_value</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>error_context_name_and_value</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while setting parameter \"%s\" to \"%s\""</literal></expr></argument>,
				   <argument><expr><name><name>error_context_name_and_value</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				   <argument><expr><name><name>error_context_name_and_value</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RestoreGUCState:
 * Reads the GUC state at the specified address and updates the GUCs with the
 * values read from the GUC state.
 */</comment>
<function><type><name>void</name></type>
<name>RestoreGUCState</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>gucstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>varvalue</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>varsourcefile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varsourceline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucSource</name></type>	<name>varsource</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucContext</name></type>	<name>varscontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srcptr</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>gucstate</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srcend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>error_context_callback</name></decl>;</decl_stmt>

	<comment type="block">/* See comment at can_skip_gucvar(). */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_skip_gucvar</name><argument_list>(<argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>InitializeOneGUCOption</name><argument_list>(<argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

	<comment type="block">/* First item is the length of the subsequent data */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>gucstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>srcptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>srcend</name> <operator>=</operator> <name>srcptr</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

	<comment type="block">/* If the GUC value check fails, we want errors to show useful context. */</comment>
	<expr_stmt><expr><name><name>error_context_callback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>guc_restore_error_context_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>error_context_callback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>error_context_callback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>error_context_callback</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>srcptr</name> <operator>&lt;</operator> <name>srcend</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>error_context_name_and_value</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>read_gucstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>varvalue</name> <operator>=</operator> <call><name>read_gucstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>varsourcefile</name> <operator>=</operator> <call><name>read_gucstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>varsourcefile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>read_gucstate_binary</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>varsourceline</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varsourceline</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>varsourceline</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>read_gucstate_binary</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>varsource</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varsource</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>read_gucstate_binary</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>varscontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varscontext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>error_context_name_and_value</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>varname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>error_context_name_and_value</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>varvalue</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>error_context_callback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>error_context_name_and_value</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>varvalue</name></expr></argument>, <argument><expr><name>varscontext</name></expr></argument>, <argument><expr><name>varsource</name></expr></argument>,
								   <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" could not be set"</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>varsourcefile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_config_sourcefile</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>varsourcefile</name></expr></argument>, <argument><expr><name>varsourceline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>error_context_callback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>error_context_callback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A little "long argument" simulation, although not quite GNU
 * compliant. Takes a string of the form "some-option=some value" and
 * returns name = "some_option" and value = "some value" in malloc'ed
 * storage. Note that '-' is converted to '_' in the option name. If
 * there is no '=' in the input string then value will be NULL.
 */</comment>
<function><type><name>void</name></type>
<name>ParseLongOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>equal_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>equal_pos</name> <operator>=</operator> <call><name>strcspn</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>string</name><index>[<expr><name>equal_pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>equal_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>equal_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>string</name><index>[<expr><name>equal_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no equal sign in string */</comment>
		<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <operator>*</operator><name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Handle options fetched from pg_db_role_setting.setconfig,
 * pg_proc.proconfig, etc.  Caller must specify proper context/source/action.
 *
 * The array parameter must be an array of TEXT (it must not be NULL).
 */</comment>
<function><type><name>void</name></type>
<name>ProcessGUCArray</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
				<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>GucAction</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>array</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>array_ref</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
					  <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
					  <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> ,
					  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ParseLongOption</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse setting for parameter \"%s\""</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
								 <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>,
								 <argument><expr><name>action</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Add an entry to an option array.  The array parameter may be NULL
 * to indicate the current table entry is NULL.
 */</comment>
<function><type><name>ArrayType</name> <modifier>*</modifier></type>
<name>GUCArrayAdd</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* test if the option is valid and we're allowed to set it */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>validate_option_array_item</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* normalize name (converts obsolete GUC names to modern spellings) */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* build new item for array */</comment>
	<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>array</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* add after end */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>current</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>array_ref</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
						  <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
						  <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> ,
						  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* check for match up through and including '=' */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>array_set</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>,
					  <argument><expr><name>datum</name></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlena array */</comment> ,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
					  <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
					  <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> )</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>datum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
							<argument><expr><name>TEXTOID</name></expr></argument>,
							<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Delete an entry from an option array.  The array parameter may be NULL
 * to indicate the current table entry is NULL.  Also, if the return value
 * is NULL then a null should be stored.
 */</comment>
<function><type><name>ArrayType</name> <modifier>*</modifier></type>
<name>GUCArrayDelete</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>newarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* test if the option is valid and we're allowed to set it */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>validate_option_array_item</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* normalize name (converts obsolete GUC names to modern spellings) */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if array is currently null, then surely nothing to delete */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>array</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newarray</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>array_ref</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
					  <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
					  <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> ,
					  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ignore entry if it's what we want to delete */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <name><name>val</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* else add it to the output array */</comment>
		<if_stmt><if>if <condition>(<expr><name>newarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newarray</name> <operator>=</operator> <call><name>array_set</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>,
								 <argument><expr><name>d</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
								 <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
								 <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> )</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newarray</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
									   <argument><expr><name>TEXTOID</name></expr></argument>,
									   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>newarray</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Given a GUC array, delete all settings from it that our permission
 * level allows: if superuser, delete them all; if regular user, only
 * those that are PGC_USERSET
 */</comment>
<function><type><name>ArrayType</name> <modifier>*</modifier></type>
<name>GUCArrayReset</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>newarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>

	<comment type="block">/* if array is currently null, nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>array</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* if we're superuser, we can delete everything, so just do it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newarray</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>eqsgn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>array_ref</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
					  <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
					  <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> ,
					  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>eqsgn</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>eqsgn</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* skip if we have permission to delete it */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>validate_option_array_item</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* else add it to the output array */</comment>
		<if_stmt><if>if <condition>(<expr><name>newarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newarray</name> <operator>=</operator> <call><name>array_set</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>,
								 <argument><expr><name>d</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
								 <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
								 <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> )</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newarray</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
									   <argument><expr><name>TEXTOID</name></expr></argument>,
									   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>newarray</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate a proposed option setting for GUCArrayAdd/Delete/Reset.
 *
 * name is the option name.  value is the proposed value for the Add case,
 * or NULL for the Delete/Reset cases.  If skipIfNoPermissions is true, it's
 * not an error to have no permissions to set the option.
 *
 * Returns true if OK, false if skipIfNoPermissions is true and user does not
 * have permission to change this option (all other error cases result in an
 * error being thrown).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>validate_option_array_item</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>skipIfNoPermissions</name></decl></parameter>)</parameter_list>

<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * There are three cases to consider:
	 *
	 * name is a known GUC variable.  Check the value normally, check
	 * permissions normally (i.e., allow if variable is USERSET, or if it's
	 * SUSET and user is superuser).
	 *
	 * name is not known, but exists or can be created as a placeholder (i.e.,
	 * it has a prefixed name).  We allow this case if you're a superuser,
	 * otherwise not.  Superusers are assumed to know what they're doing. We
	 * can't allow it for other users, because when the placeholder is
	 * resolved it might turn out to be a SUSET variable;
	 * define_custom_variable assumes we checked that.
	 *
	 * name is not known and can't be created as a placeholder.  Throw error,
	 * unless skipIfNoPermissions is true, in which case return false.
	 */</comment>
	<expr_stmt><expr><name>gconf</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gconf</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not known, failed to make a placeholder */</comment>
		<if_stmt><if>if <condition>(<expr><name>skipIfNoPermissions</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_CUSTOM_PLACEHOLDER</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We cannot do any meaningful check on the value, so only permissions
		 * are useful to check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>skipIfNoPermissions</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to set parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* manual permissions check so we can avoid an error being thrown */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_USERSET</name></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* ok */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_SUSET</name> <operator>&amp;&amp;</operator> <call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* ok */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>skipIfNoPermissions</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* if a permissions error should be thrown, let set_config_option do it */</comment>

	<comment type="block">/* test for permissions and valid option value */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary></expr></argument>,
							 <argument><expr><name>PGC_S_TEST</name></expr></argument>, <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Called by check_hooks that want to override the normal
 * ERRCODE_INVALID_PARAMETER_VALUE SQLSTATE for check hook failures.
 *
 * Note that GUC_check_errmsg() etc are just macros that result in a direct
 * assignment to the associated variables.  That is ugly, but forced by the
 * limitations of C's macro mechanisms.
 */</comment>
<function><type><name>void</name></type>
<name>GUC_check_errcode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sqlerrcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>sqlerrcode</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Convenience functions to manage calling a variable's check_hook.
 * These mostly take care of the protocol for letting check hooks supply
 * portions of the error report on failure.
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>call_bool_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
					 <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick success if no hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reset variables that might be set by hook */</comment>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errmsg_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errdetail_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errhint_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>GUC_check_errcode_value</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errmsg_string</name></expr> ?</condition><then>
				 <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errmsg_string</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": %d"</literal></expr></argument>,
						<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errdetail_string</name></expr> ?</condition><then>
				 <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errdetail_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errhint_string</name></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errhint_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush any strings created in ErrorContext */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>call_int_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
					<parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick success if no hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reset variables that might be set by hook */</comment>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errmsg_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errdetail_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errhint_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>GUC_check_errcode_value</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errmsg_string</name></expr> ?</condition><then>
				 <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errmsg_string</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": %d"</literal></expr></argument>,
						<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errdetail_string</name></expr> ?</condition><then>
				 <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errdetail_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errhint_string</name></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errhint_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush any strings created in ErrorContext */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>call_real_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
					 <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick success if no hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reset variables that might be set by hook */</comment>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errmsg_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errdetail_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errhint_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>GUC_check_errcode_value</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errmsg_string</name></expr> ?</condition><then>
				 <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errmsg_string</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": %g"</literal></expr></argument>,
						<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errdetail_string</name></expr> ?</condition><then>
				 <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errdetail_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errhint_string</name></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errhint_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush any strings created in ErrorContext */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>call_string_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
					   <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick success if no hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reset variables that might be set by hook */</comment>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errmsg_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errdetail_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errhint_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>GUC_check_errcode_value</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errmsg_string</name></expr> ?</condition><then>
				 <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errmsg_string</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name>newval</name></expr> ?</condition><then> <expr><operator>*</operator><name>newval</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errdetail_string</name></expr> ?</condition><then>
				 <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errdetail_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errhint_string</name></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errhint_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush any strings created in ErrorContext */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>call_enum_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
					 <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick success if no hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reset variables that might be set by hook */</comment>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errmsg_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errdetail_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errhint_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>GUC_check_errcode_value</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errmsg_string</name></expr> ?</condition><then>
				 <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errmsg_string</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>,
						<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errdetail_string</name></expr> ?</condition><then>
				 <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errdetail_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errhint_string</name></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errhint_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush any strings created in ErrorContext */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_hook, assign_hook and show_hook subroutines
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_wal_consistency_checking</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>newwalconsistency</name><index>[<expr><name>RM_MAX_ID</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Initialize the array */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>newwalconsistency</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>RM_MAX_ID</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in list */</comment>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"List syntax is invalid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tok</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RmgrId</name></type>		<name>rmid</name></decl>;</decl_stmt>

		<comment type="block">/* Check for 'all'. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>rmid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rmid</name> <operator>&lt;=</operator> <name>RM_MAX_ID</name></expr>;</condition> <incr><expr><name>rmid</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_mask</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>newwalconsistency</name><index>[<expr><name>rmid</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Check if the token matches with any individual resource
			 * manager.
			 */</comment>
			<for>for <control>(<init><expr><name>rmid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rmid</name> <operator>&lt;=</operator> <name>RM_MAX_ID</name></expr>;</condition> <incr><expr><name>rmid</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_mask</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>newwalconsistency</name><index>[<expr><name>rmid</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* If a valid resource manager is found, check for the next one. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Unrecognized key word: \"%s\"."</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* assign new value */</comment>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><name>RM_MAX_ID</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>extra</name></expr></argument>, <argument><expr><name>newwalconsistency</name></expr></argument>, <argument><expr><operator>(</operator><name>RM_MAX_ID</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_wal_consistency_checking</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>wal_consistency_checking</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <name>extra</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_log_destination</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newlogdest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>myextra</name></decl>;</decl_stmt>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in list */</comment>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"List syntax is invalid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tok</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"stderr"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newlogdest</name> <operator>|=</operator> <name>LOG_DESTINATION_STDERR</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"csvlog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newlogdest</name> <operator>|=</operator> <name>LOG_DESTINATION_CSVLOG</name></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"syslog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newlogdest</name> <operator>|=</operator> <name>LOG_DESTINATION_SYSLOG</name></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"eventlog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newlogdest</name> <operator>|=</operator> <name>LOG_DESTINATION_EVENTLOG</name></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* POLAR */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"polar_multi_dest"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newlogdest</name> <operator>|=</operator> <name>LOG_DESTINATION_STDERR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newlogdest</name> <operator>|=</operator> <name>LOG_DESTINATION_POLAR_SLOWLOG</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newlogdest</name> <operator>|=</operator> <name>LOG_DESTINATION_POLAR_AUDITLOG</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* POLAR end */</comment>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Unrecognized key word: \"%s\"."</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>myextra</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>myextra</name> <operator>=</operator> <name>newlogdest</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>myextra</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_log_destination</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>Log_destination</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>extra</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_syslog_facility</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>set_syslog_parameters</name><argument_list>(<argument><expr><ternary><condition><expr><name>syslog_ident_str</name></expr> ?</condition><then> <expr><name>syslog_ident_str</name></expr> </then><else>: <expr><literal type="string">"postgres"</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Without syslog support, just ignore it */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_syslog_ident</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>set_syslog_parameters</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>syslog_facility</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Without syslog support, it will always be set to "none", so ignore */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_session_replication_role</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Must flush the plan cache when changing replication role; but don't
	 * flush unnecessarily.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>SessionReplicationRole</name> <operator>!=</operator> <name>newval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetPlanCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_client_min_messages</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We disallow setting client_min_messages above ERROR, because not
	 * sending an ErrorResponse message for an error breaks the FE/BE
	 * protocol.  However, for backwards compatibility, we still accept FATAL
	 * or PANIC as input values, and then adjust here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>&gt;</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>newval</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_temp_buffers</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Once local buffers have been initialized, it's too late to change this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>NLocBuffer</name> <operator>&amp;&amp;</operator> <name>NLocBuffer</name> <operator>!=</operator> <operator>*</operator><name>newval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"\"temp_buffers\" cannot be changed after any temporary tables have been accessed in the session."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_bonjour</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_BONJOUR</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"Bonjour is not supported by this build"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_ssl</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_SSL</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"SSL is not supported by this build"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_stage_log_stats</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>&amp;&amp;</operator> <name>log_statement_stats</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot enable parameter when \"log_statement_stats\" is true."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_log_stats</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>log_parser_stats</name> <operator>||</operator> <name>log_planner_stats</name> <operator>||</operator> <name>log_executor_stats</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot enable \"log_statement_stats\" when "</literal>
							<literal type="string">"\"log_parser_stats\", \"log_planner_stats\", "</literal>
							<literal type="string">"or \"log_executor_stats\" is true."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_canonical_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Since canonicalize_path never enlarges the string, we can just modify
	 * newval in-place.  But watch out for NULL, which is the default value
	 * for external_pid_file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_timezone_abbreviations</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The boot_val given above for timezone_abbreviations is NULL. When we
	 * see this we just do nothing.  If this value isn't overridden from the
	 * config file then pg_timezone_abbrev_initialize() will eventually
	 * replace it with "Default".  This hack has two purposes: to avoid
	 * wasting cycles loading values that might soon be overridden from the
	 * config file, and to avoid trying to read the timezone abbrev files
	 * during InitializeGUCOptions().  The latter doesn't work in an
	 * EXEC_BACKEND subprocess because my_exec_path hasn't been set yet and so
	 * we can't locate PGSHAREDIR.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* OK, load the file and produce a malloc'd TimeZoneAbbrevTable */</comment>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <call><name>load_tzoffsets</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* tzparser.c returns NULL on failure, reporting via GUC_check_errmsg */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>extra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_timezone_abbreviations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Do nothing for the boot_val default of NULL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>InstallTimeZoneAbbrevs</name><argument_list>(<argument><expr><operator>(</operator><name>TimeZoneAbbrevTable</name> <operator>*</operator><operator>)</operator> <name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_timezone_abbrev_initialize --- set default value if not done already
 *
 * This is called after initial loading of postgresql.conf.  If no
 * timezone_abbreviations setting was found therein, select default.
 * If a non-default value is already installed, nothing will happen.
 *
 * This can also be called from ProcessConfigFile to establish the default
 * value after a postgresql.conf entry for it is removed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pg_timezone_abbrev_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"timezone_abbreviations"</literal></expr></argument>, <argument><expr><literal type="string">"Default"</literal></expr></argument>,
					<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_DYNAMIC_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_archive_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XLogArchivingActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>XLogArchiveCommand</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"(disabled)"</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_tcp_keepalives_idle</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The kernel API provides no way to test a value without setting it; and
	 * once we set it we might fail to unset it.  So there seems little point
	 * in fully implementing the check-then-assign GUC API for these
	 * variables.  Instead we just do the assignment on demand.  pqcomm.c
	 * reports any problems via elog(LOG).
	 *
	 * This approach means that the GUC value might have little to do with the
	 * actual kernel value, so we use a show_hook that retrieves the kernel
	 * value rather than trusting GUC's copy.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_setkeepalivesidle</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_tcp_keepalives_idle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>nbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>pq_getkeepalivesidle</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nbuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_tcp_keepalives_interval</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_setkeepalivesinterval</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_tcp_keepalives_interval</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>nbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>pq_getkeepalivesinterval</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nbuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_tcp_keepalives_count</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_setkeepalivescount</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_tcp_keepalives_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>nbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>pq_getkeepalivescount</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nbuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_maxconnections</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>+</operator> <name>autovacuum_max_workers</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>
		<name>max_worker_processes</name> <operator>&gt;</operator> <name>MAX_BACKENDS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_autovacuum_max_workers</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MaxConnections</name> <operator>+</operator> <operator>*</operator><name>newval</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>max_worker_processes</name> <operator>&gt;</operator> <name>MAX_BACKENDS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_autovacuum_work_mem</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * -1 indicates fallback.
	 *
	 * If we haven't yet changed the boot_val default of -1, just let it be.
	 * Autovacuum will look to maintenance_work_mem instead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We clamp manually-set values to at least 1MB.  Since
	 * maintenance_work_mem is always set to at least this value, do the same
	 * here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>newval</name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_max_worker_processes</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MaxConnections</name> <operator>+</operator> <name>autovacuum_max_workers</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>*</operator><name>newval</name> <operator>&gt;</operator> <name>MAX_BACKENDS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_effective_io_concurrency</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
	<decl_stmt><decl><type><name>double</name></type>		<name>new_prefetch_pages</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ComputeIoConcurrency</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_prefetch_pages</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>myextra</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>myextra</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>new_prefetch_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>myextra</name></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"effective_io_concurrency must be set to 0 on platforms that lack posix_fadvise()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_effective_io_concurrency</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
	<expr_stmt><expr><name>target_prefetch_pages</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>extra</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_pgstat_temp_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* check_canonical_path already canonicalized newval for us */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>

	<comment type="block">/* directory */</comment>
	<expr_stmt><expr><name>dname</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* runtime dir */</comment>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>dname</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* global stats */</comment>
	<expr_stmt><expr><name>tname</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* /global.tmp */</comment>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>tname</name></expr></argument>, <argument><expr><literal type="string">"%s/global.tmp"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* /global.stat */</comment>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"%s/global.stat"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgstat_stat_directory</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pgstat_stat_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pgstat_stat_directory</name> <operator>=</operator> <name>dname</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pgstat_stat_tmpname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pgstat_stat_tmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pgstat_stat_tmpname</name> <operator>=</operator> <name>tname</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pgstat_stat_filename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pgstat_stat_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pgstat_stat_filename</name> <operator>=</operator> <name>fname</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_application_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Only allow clean ASCII chars in the application name */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>newval</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>p</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">32</literal> <operator>||</operator> <operator>*</operator><name>p</name></expr></argument> &gt;</argument_list></name> <literal type="number">126</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_application_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Update the pg_stat_activity view */</comment>
	<expr_stmt><expr><call><name>pgstat_report_appname</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_cluster_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Only allow clean ASCII chars in the cluster name */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>newval</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>p</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">32</literal> <operator>||</operator> <operator>*</operator><name>p</name></expr></argument> &gt;</argument_list></name> <literal type="number">126</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if items in a string list exists in a list
 *
 * 'list1_str': a comma-separated list of items to check
 * 'list2_str': a comma-separated list of items
 *
 * Note that, if either of list1_str or list2_str is NULL or empty, false will
 * be returned.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>find_list_in_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>list1_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>list2_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>list1_str_copy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>list2_str_copy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>list1_str</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>list1_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator>
		<name>list2_str</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>list2_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* no cover line */</comment>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* nothing to do */</comment>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>list1_str_copy</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>list1_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>list1_str_copy</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>list1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no cover begin */</comment>
		<comment type="block">/* syntax error in list */</comment>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list1_str_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
		  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid list syntax in parsing allowed list string \"%s\""</literal></expr></argument>,
				 <argument><expr><name>list1_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/* no cover end */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>list2_str_copy</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>list2_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>list2_str_copy</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>list2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no cover begin */</comment>
		<comment type="block">/* syntax error in list */</comment>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list1_str_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list2_str_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
		  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid list syntax in parsing allowed list string \"%s\""</literal></expr></argument>,
				 <argument><expr><name>list2_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/* no cover end */</comment>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l1</argument>, <argument>list1</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>list2</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list1_str_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>list2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>list2_str_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_unix_socket_permissions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%04o"</literal></expr></argument>, <argument><expr><name>Unix_socket_permissions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_log_file_mode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%04o"</literal></expr></argument>, <argument><expr><name>Log_file_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_data_directory_mode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%04o"</literal></expr></argument>, <argument><expr><name>data_directory_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR: check is valid list ? */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_verify_list_syntax</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>liststring</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>liststring</name> <operator>||</operator> <name><name>liststring</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>liststring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in name list */</comment>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"List syntax is invalid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_polar_forbidden_functions</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>polar_verify_list_syntax</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * polar_check_is_forbidden_funcs()
 * check function name is forbidden due to security problem
 * e.g.
 * When creating rule, no-super user can put system functions into
 * rule view, so when superuser select this rule view, that will execute
 * system functions, it is unsafe, so we must filter so functions.
 *
 */</comment>
<function><type><name>bool</name></type>
<name>polar_check_is_forbidden_funcs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>funcname</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>strVal</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>polar_forbidden_functions</name></expr></argument>, <argument><expr><name>num_forbidden_functions</name></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pg_qsort_strcmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_polar_forbidden_functions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawstring</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemlist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* first, we must free polar_forbidden_functions memory */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_forbidden_functions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Must free before malloc */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>polar_forbidden_functions</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>polar_forbidden_functions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>polar_forbidden_functions</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>polar_forbidden_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>num_forbidden_functions</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* second, we should count the num of forbidden funcs */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* this is num of fixed forbidden functions */</comment>
	<while>while <condition>(<expr><name><name>polar_forbidden_funcnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><name>num_forbidden_functions</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no cover begin */</comment>
		<comment type="block">/* syntax error in list */</comment>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * we have check syntax in check_polar_forbidden_functions,
		 * so we can not be here
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid list syntax in parsing forbidden functions string \"%s\""</literal></expr></argument>,
						<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* no cover end */</comment>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* this is num of postgresql.conf forbidden functions */</comment>
	<if_stmt><if>if <condition>(<expr><name>elemlist</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_forbidden_functions</name> <operator>+=</operator> <name><name>elemlist</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * we must use guc_malloc instead of palloc,
	 * because palloc memory is valid only one statement,
	 * it will free next PostgresMain() loop
	 */</comment>
	<expr_stmt><expr><name>polar_forbidden_functions</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>num_forbidden_functions</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* save fixed forbidden functions */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>polar_forbidden_funcnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>polar_forbidden_functions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name><name>polar_forbidden_funcnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* save postgresql.conf forbidden functions */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>polar_forbidden_functions</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>polar_forbidden_functions</name></expr></argument>, <argument><expr><name>num_forbidden_functions</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pg_qsort_strcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
  * Check if preload libs are allowed. Note this can only be called AFTER postmaster startup,
  * since we will check against other GUC (polar_available_exstensions). So the routine can only
  * be used for session preload libs (not for shared_preload_libs)!
  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_session_preload_libs</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Note the default value is actuall "", so return true in case of '\0' */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name><name>newval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in list */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tok</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>find_list_in_list</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>polar_available_extensions</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		    <operator>!</operator><call><name>find_list_in_list</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>polar_internal_allowed_extensions</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_polar_available_extensions</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>polar_verify_list_syntax</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_polar_allowed_roles</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>polar_verify_list_syntax</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: check function for priority replication 
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_high_priority_replication_standby_names</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_verify_list_syntax</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>!</operator><call><name>find_list_in_list</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><name>polar_low_priority_replication_standby_names</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_low_priority_replication_standby_names</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_verify_list_syntax</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	
	<return>return <expr><operator>!</operator><call><name>find_list_in_list</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><name>polar_high_priority_replication_standby_names</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_polar_supported_extensions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>len</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_internal_allowed_extensions</name> <operator>&amp;&amp;</operator> <name>polar_available_extensions</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s\n%s"</literal></expr></argument>, <argument><expr><name>polar_available_extensions</name></expr></argument>, <argument><expr><name>polar_internal_allowed_extensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>polar_available_extensions</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>polar_available_extensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>polar_internal_allowed_extensions</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>polar_internal_allowed_extensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_polar_rename_wal_ready_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>old_filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>new_filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>archive_status_dir</name><index>[]</index></name> <init>= <expr><literal type="string">"/pg_wal/archive_status/"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>total_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_datadir</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>polar_enable_shared_storage_mode</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could only run under shared storage mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could only run on RW/master node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could only rename file under /pfs-disk/data/pg_wal/archive_status"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>total_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>polar_datadir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>archive_status_dir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>&gt;</operator> <name>MAXPGPATH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too long wal ready file path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>old_filename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s"</literal></expr></argument>, <argument><expr><name>polar_datadir</name></expr></argument>, <argument><expr><name>archive_status_dir</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">".ready"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_filename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s"</literal></expr></argument>, <argument><expr><name>polar_datadir</name></expr></argument>, <argument><expr><name>archive_status_dir</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><literal type="string">".done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>polar_durable_rename</name><argument_list>(<argument><expr><name>old_filename</name></expr></argument>, <argument><expr><name>new_filename</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: check polar_internal_shared_preload_libraries string format,
 * e.g: "x,y,z"
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_check_internal_shared_preload_libraries</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>polar_verify_list_syntax</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_assign_virtual_pid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_pgstat_set_virtual_pid</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_assign_cancel_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_pgstat_set_cancel_key</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: check parameter name valid.
 */</comment>

<function><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type>
<name>polar_parameter_check_name_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>guc_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name>	<name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

	<comment type="block">/* find the record of the guc parameter */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* case: find, return directly */</comment>
		<return>return <expr><name>record</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>, <argument><expr><literal type="string">"rds_"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strlen</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* case: rds_xx, find xx again */</comment>
		<expr_stmt><expr><name>opt_name</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>opt_name</name></expr></argument>, <argument><expr><name>guc_name</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opt_name</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>opt_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>record</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>, <argument><expr><literal type="string">"polar_"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strlen</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* case: polar_xx, find xx again */</comment>
		<expr_stmt><expr><name>opt_name</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">6</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>opt_name</name></expr></argument>, <argument><expr><name>guc_name</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opt_name</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>opt_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>record</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: check parameter value valid.
 */</comment>

<function><type><name>bool</name></type>
<name>polar_parameter_check_value_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>guc_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>guc_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	<modifier>*</modifier></type><name>newextra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name>	<name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>union</name>	<name>config_var_val</name></name></type> <name>newval</name></decl>;</decl_stmt>

	<comment type="block">/* first: find the record of the guc parameter */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>polar_parameter_check_name_internal</name><argument_list>(<argument><expr><name>guc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
						<argument><expr><name>guc_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* second: check that it's acceptable for the indicated parameter */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>guc_name</name></expr></argument>, <argument><expr><name>guc_value</name></expr></argument>, <argument><expr><name>PGC_S_DEFAULT</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* third: free possible memory allocate in function */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name><name>record</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>PGC_STRING</name> <operator>&amp;&amp;</operator> <name><name>newval</name><operator>.</operator><name>stringval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>newval</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name>newextra</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>px_get_num_guc_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>num_guc_variables</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR: don't allow polar_xact_split_xids be set in RW or Standby */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_check_xact_split_xids</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>polar_verify_list_syntax</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_assign_xact_split_wait_lsn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>polar_xact_split_wait_lsn</name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>polar_xact_split_wait_lsn</name> <operator>=</operator> <call><name>polar_strtouint64</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"lsn"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: polar_nblocks_cache_mode can be changed to off without restart,
 * but can not be changed to on without restart.
 * In Parallel Workers, it will init polar_nblocks_cache_mode to off, and
 * set it to postgresql.conf settings, set check will ignore this.
*/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_check_nblocks_cache_mode</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsParallelWorker</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>polar_nblocks_cache_mode</name> <operator>==</operator> <name>POLAR_NBLOCKS_CACHE_OFF_MODE</name><operator>)</operator> <operator>&amp;&amp;</operator> 
		<operator>(</operator><operator>*</operator><name>newval</name> <operator>!=</operator> <name>POLAR_NBLOCKS_CACHE_OFF_MODE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"polar_nblocks_cache_mode can not be used without restart"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"add polar_nblocks_cache_mode=xxx in postgres.conf to use it"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_assign_crash_recovery_rto</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>PolarGlobalIOReadStats</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>PolarGlobalIOReadStats</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <operator>(</operator><name>newval</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
									  <name>polar_crash_recovery_rto_threshold</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
									  <name>polar_crash_recovery_rto_delay_count</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_assign_crash_recovery_rto_threshold</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>PolarGlobalIOReadStats</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>PolarGlobalIOReadStats</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <operator>(</operator><name>newval</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
									  <name>polar_crash_recovery_rto</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
									  <name>polar_crash_recovery_rto_delay_count</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_assign_crash_recovery_rto_delay_time</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>PolarGlobalIOReadStats</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>PolarGlobalIOReadStats</name><operator>-&gt;</operator><name>enabled</name></name> <operator>=</operator> <operator>(</operator><name>newval</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
									  <name>polar_crash_recovery_rto_threshold</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
									  <name>polar_crash_recovery_rto</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_check_enable_lazy_checkpoint</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsParallelWorker</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>source</name> <operator>!=</operator> <name>PGC_S_DEFAULT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>newval</name> <operator>&amp;&amp;</operator> <name>fullPageWrites</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot enable parameter when \"full_page_writes\" is true."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_check_enable_full_page_writes</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsParallelWorker</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>source</name> <operator>!=</operator> <name>PGC_S_DEFAULT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>newval</name> <operator>&amp;&amp;</operator> <name>polar_enable_lazy_checkpoint</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*no cover begin*/</comment>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot enable parameter when \"polar_enable_lazy_checkpoint\" is true."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
		<comment type="block">/*no cover end*/</comment>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: util routine for check/assign polar_partition_recursive_reloptions.
 *        Parse the xxx,xxx,... format array of reloption names to check 
 *        syntax. If it is an assign operation, store the names to a global
 *        string list, which resides in TopMemoryContext - otherwise, the
 *        list cells will be freed after this routine exits.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_recursive_reloptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>assign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>			<modifier>*</modifier></type><name>rawstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>			<modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>		<modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>current_ctx</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newval</name> <operator>||</operator> <name><name>newval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawstr</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawstr</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in name list */</comment>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"List syntax is invalid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>assign</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Switch to top memory context */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>recursive_relopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>recursive_relopts</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>namelist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>recurse_opt</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>recurse_opt</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* not null string */</comment>
				<expr_stmt><expr><name>recursive_relopts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>recursive_relopts</name></expr></argument>,
											<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>recurse_opt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>current_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Switch back to current */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* No need for namelist anymore, so free it. */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR: assign hook for polar_partition_recursive_reloptions */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_assign_recursive_reloptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>polar_recursive_reloptions</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR: check hook for polar_partition_recursive_reloptions */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_check_recursive_reloptions</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>polar_recursive_reloptions</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_assign_max_normal_backends</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>MaxNormalBackends</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>floor</name><argument_list>(<argument><expr><name>newval</name> <operator>*</operator> <name>MaxConnections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR end */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc-file.c"</cpp:file></cpp:include>
</unit>
