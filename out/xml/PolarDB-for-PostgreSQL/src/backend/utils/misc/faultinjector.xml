<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/misc/faultinjector.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * faultinjector.c
 *
 * Fault injectors are used for fine control during testing. They allow a
 * developer to create deterministic tests for scenarios that are hard to
 * reproduce. This is done by programming actions at certain key areas to
 * suspend, skip, or even panic the process. Fault injectors are set in shared
 * memory so they are accessible to all segment processes.
 *
 * IDENTIFICATION
 *		src/backend/utils/misc/faultinjector.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_RESOURCE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>

<comment type="block">/*
 * gettext() can't be used in a static initializer... This breaks nls builds.
 * So, to work around this issue, I've made _() be a no-op.
 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAULT_INJECTOR_LOG</name><parameter_list>(<parameter><type><name>elevel</name></type></parameter>, <parameter><type><name>format</name></type></parameter>, <parameter><type><name>args</name><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>InjectorLOG(elevel, __FILE__, __LINE__, format, ##args)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>FaultInjectorShmem_s</name>
<block>{
	<decl_stmt><decl><type><name>slock_t</name></type>		<name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>faultInjectorSlots</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>hash</name></decl>;</decl_stmt>
}</block></struct></type>			<name>FaultInjectorShmem_s</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>FaultInjectorShmem_s</name> <modifier>*</modifier></type> <name>faultInjectorShmem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FiLockAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FiLockRelease</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>FaultInjectorEntry_s</name> <modifier>*</modifier></type> <name>FaultInjector_LookupHashEntry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>faultName</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>FaultInjectorEntry_s</name> <modifier>*</modifier></type> <name>FaultInjector_InsertHashEntry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>faultName</name></decl></parameter>,
															<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>exists</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>FaultInjector_NewHashEntry</name><parameter_list>(<parameter><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>FaultInjector_MarkEntryAsResume</name><parameter_list>(<parameter><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FaultInjector_RemoveHashEntry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>faultName</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>FaultInjector_SetFaultInjection</name><parameter_list>(<parameter><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>FaultInjectorType_e</name></type> <name>FaultInjectorTypeStringToEnum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>faultType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>InjectorLOG</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> 
		__attribute__ <parameter_list>(<parameter/></parameter_list>(format <parameter_list>(<parameter><decl><type><name>printf</name></type></decl></parameter>, <parameter/></parameter_list>4<operator>,</operator> 5</function_decl>)))<empty_stmt>;</empty_stmt>

<comment type="block">/* Arrays to map between enum values and strings */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>FaultInjectorTypeEnumToString</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FI_TYPE</name><parameter_list>(<parameter><type><name>id</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>str,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector_lists.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FI_TYPE</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>FaultInjectorStateEnumToString</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FI_STATE</name><parameter_list>(<parameter><type><name>id</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>str,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector_lists.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FI_STATE</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>FaultInjectorType_e</name></type>
<name>FaultInjectorTypeStringToEnum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>faultTypeString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FaultInjectorType_e</name></type> <name>faultTypeEnum</name> <init>= <expr><name>FaultInjectorTypeMax</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ii</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <name>FaultInjectorTypeNotSpecified</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>FaultInjectorTypeMax</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><name>faultTypeString</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>faultTypeEnum</name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>faultTypeEnum</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FiLockAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FiLockRelease</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>InjectorLOG</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORMATTED_TS_LEN</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>stamp_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>time_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> 			<name><name>formatted_log_time</name><index>[<expr><name>FORMATTED_TS_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>			<name><name>msbuf</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> 			<modifier>*</modifier></type><name>outfile</name> <init>= <expr><ternary><condition><expr><name>elevel</name> <operator>&gt;</operator> <name>ERROR</name></expr> ?</condition><then> <expr><name>stderr</name></expr> </then><else>: <expr><name>stdout</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>stamp_time</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <name><name>time_val</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>formatted_log_time</name></expr></argument>, <argument><expr><name>FORMATTED_TS_LEN</name></expr></argument>,
				<argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S     %Z"</literal></expr></argument>,
				<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stamp_time</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>msbuf</name></expr></argument>, <argument><expr><literal type="string">".%03d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>time_val</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>formatted_log_time</name> <operator>+</operator> <literal type="number">19</literal></expr></argument>, <argument><expr><name>msbuf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>formatted_log_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>FATAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"FATAL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"ERROR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>WARNING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"WARNING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> 
	<if type="elseif">else if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>LOG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"LOG "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>DEBUG1</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"DEBUG "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>elevel</name> <operator>&lt;</operator> <name>DEBUG1</name> <operator>&amp;&amp;</operator> <name>elevel</name> <operator>&gt;=</operator> <name>DEBUG5</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"DEBUG "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"WARNING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Fault injector at %s:%d "</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>vfprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************
 * FAULT INJECTOR routines
 ****************************************************************/</comment>
<function><type><name>Size</name></type>
<name>FaultInjector_ShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>hash_estimate_size</name><argument_list>(
							  <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>FAULTINJECTOR_MAX_SLOTS</name></expr></argument>,
							  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorEntry_s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorShmem_s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Hash table contains fault injection that are set on the system waiting to be injected.
 * FaultInjector identifier is the key in the hash table.
 * Hash table in shared memory is initialized only on primary and mirror segment.
 * It is not initialized on master host.
 */</comment>
<function><type><name>void</name></type>
<name>FaultInjector_ShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>foundPtr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>faultInjectorShmem</name> <operator>=</operator> <operator>(</operator><name>FaultInjectorShmem_s</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"fault injector"</literal></expr></argument>,
																  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorShmem_s</name></expr></argument>)</argument_list></sizeof></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>foundPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>faultInjectorShmem</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not enough shared memory for fault injector"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foundPtr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>faultInjectorShmem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorShmem_s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>faultInjectorSlots</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>FAULT_NAME_MAX_LENGTH</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorEntry_s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>string_hash</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"fault injector hash"</literal></expr></argument>,
											 <argument><expr><name>FAULTINJECTOR_MAX_SLOTS</name></expr></argument>,
											 <argument><expr><name>FAULTINJECTOR_MAX_SLOTS</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
											 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not enough shared memory for fault injector"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"initialized faultinjector shmem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<function><type><name>FaultInjectorType_e</name></type>
<name>FaultInjector_TriggerFaultIfSet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>faultName</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>databaseName</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tableName</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type><name>entryShared</name></decl>,
				<decl><type ref="prev"/><name>localEntry</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>entryLocal</name> <init>= <expr><operator>&amp;</operator><name>localEntry</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>databaseNameLocal</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tableNameLocal</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cnt</name> <init>= <expr><literal type="number">3600</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>faultName</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>FAULT_NAME_MAX_LENGTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FAULT_INJECTOR_LOG</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"fault name too long: '%s'"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>FaultInjectorTypeNotSpecified</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>faultName</name></expr></argument>, <argument><expr><name>FaultInjectorNameAll</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FAULT_INJECTOR_LOG</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Fault injector error: invalid fault name '%s'"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>FaultInjectorTypeNotSpecified</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>databaseName</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FAULT_INJECTOR_LOG</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"database name too long:'%s'"</literal></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>FaultInjectorTypeNotSpecified</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FAULT_INJECTOR_LOG</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table name too long: '%s'"</literal></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>FaultInjectorTypeNotSpecified</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Return immediately if no fault has been injected ever.  It is important
	 * to not touch the spinlock, especially if this is the postmaster
	 * process.  If one of the backend processes dies while holding the spin
	 * lock, and postmaster comes here before resetting the shared memory, it
	 * waits without holder process and eventually goes into PANIC.  Also this
	 * saves a few cycles to acquire the spin lock and look into the shared
	 * hash table.
	 *
	 * Although this is a race condition without lock, a false negative is ok
	 * given this framework is purely for dev/testing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>faultInjectorSlots</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>FaultInjectorTypeNotSpecified</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>databaseNameLocal</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>databaseNameLocal</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tableNameLocal</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tableNameLocal</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name> <operator>=</operator> <name>FaultInjectorTypeNotSpecified</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entryShared</name> <operator>=</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name>faultName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>entryShared</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* fault injection is not set */</comment>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>entryShared</name><operator>-&gt;</operator><name>databaseName</name></name></expr></argument>, <argument><expr><name>databaseNameLocal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* fault injection is not set for the specified database name */</comment>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>entryShared</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>, <argument><expr><name>tableNameLocal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* fault injection is not set for the specified table name */</comment>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entryShared</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>==</operator> <name>FaultInjectorStateCompleted</name> <operator>||</operator>
			<name><name>entryShared</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>==</operator> <name>FaultInjectorStateFailed</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* fault injection was already executed */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>entryShared</name><operator>-&gt;</operator><name>numTimesTriggered</name></name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entryShared</name><operator>-&gt;</operator><name>numTimesTriggered</name></name> <operator>&lt;</operator> <name><name>entryShared</name><operator>-&gt;</operator><name>startOccurrence</name></name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update the injection fault entry in hash table */</comment>
		<expr_stmt><expr><name><name>entryShared</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>=</operator> <name>FaultInjectorStateTriggered</name></expr>;</expr_stmt>

		<comment type="block">/* Mark fault injector to completed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entryShared</name><operator>-&gt;</operator><name>endOccurrence</name></name> <operator>!=</operator> <name>INFINITE_END_OCCURRENCE</name> <operator>&amp;&amp;</operator>
			<name><name>entryShared</name><operator>-&gt;</operator><name>numTimesTriggered</name></name> <operator>&gt;=</operator> <name><name>entryShared</name><operator>-&gt;</operator><name>endOccurrence</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>entryShared</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>=</operator> <name>FaultInjectorStateCompleted</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>entryLocal</name></expr></argument>, <argument><expr><name>entryShared</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorEntry_s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Inject fault */</comment>
	<switch>switch <condition>(<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FaultInjectorTypeNotSpecified</name></expr>:</case>
		<case>case <expr><name>FaultInjectorTypeEnable</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeSleep</name></expr>:</case>
			<comment type="block">/* Sleep for the specified amount of time. */</comment>

			<expr_stmt><expr><call><name>FAULT_INJECTOR_LOG</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
					<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
					<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>extraArg</name></name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeFatal</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
									<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
									<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypePanic</name></expr>:</case>

			<comment type="block">/*
			 * Avoid core file generation for this PANIC. It helps to avoid
			 * filling up disks during tests and also saves time.
			 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>lim</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lim</name><operator>.</operator><name>rlim_cur</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>setrlimit</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lim</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
							<argument><expr><literal type="string">"setrlimit failed for RLIMIT_CORE soft limit to zero (%m)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
									<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
									<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeError</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
									<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
									<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeInfiniteLoop</name></expr>:</case>
			<comment type="block">/* Loop until the fault is reset or an interrupt occurs. */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
									<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
									<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
				 <condition><expr><name>ii</name> <operator>&lt;</operator> <name>cnt</name> <operator>&amp;&amp;</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</condition>
				 <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeSuspend</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Suspend until the fault is resumed or reset */</comment>
				<decl_stmt><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FAULT_INJECTOR_LOG</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
								<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
								<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					   <name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name> <operator>!=</operator> <name>FaultInjectorTypeResume</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* 1 sec */</comment>
					<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>
				<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>FAULT_INJECTOR_LOG</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
							<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
									<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
									<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>FAULT_INJECTOR_LOG</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
							<argument><expr><literal type="string">"fault name:'%s' removed"</literal></expr></argument>, <argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Since the entry is gone already, we should NOT update
					 * the entry below.  (There could be other places in this
					 * function that are under the same situation, but I'm too
					 * tired to look for them...)
					 */</comment>
					<return>return <expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>;</return>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>FaultInjectorTypeSkip</name></expr>:</case>
			<comment type="block">/* Do nothing.  The caller is expected to take some action. */</comment>
			<expr_stmt><expr><call><name>FAULT_INJECTOR_LOG</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeResume</name></expr>:</case>

			<comment type="block">/*
			 * This fault is resumed after suspension but has not been reset
			 * yet.  Ignore.
			 */</comment>
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeSegv</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Avoid core file generation for this PANIC. It helps to
				 * avoid filling up disks during tests and also saves time.
				 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
				<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>lim</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lim</name><operator>.</operator><name>rlim_cur</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>setrlimit</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lim</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						 <argument><expr><literal type="string">"setrlimit failed for RLIMIT_CORE soft limit to zero (%m)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<expr_stmt><expr><operator>*</operator><operator>(</operator><specifier>volatile</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <literal type="number">0</literal> <operator>=</operator> <literal type="number">1234</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>FaultInjectorTypeInterrupt</name></expr>:</case>

			<comment type="block">/*
			 * XXX: check if the following comment is valid.
			 *
			 * The place where this type of fault is injected must have has
			 * HOLD_INTERRUPTS() .. RESUME_INTERRUPTS() around it, otherwise
			 * the interrupt could be handled inside the fault injector itself
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid fault type %d, fault name:'%s'"</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr></argument>, <argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><operator>(</operator><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lookup if fault injection is set
 */</comment>
<function><type><specifier>static</specifier> <name>FaultInjectorEntry_s</name> <modifier>*</modifier></type>
<name>FaultInjector_LookupHashEntry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>faultName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>FaultInjectorEntry_s</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
												 <argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>,
												 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>faultName</name></expr></argument>, <comment type="line">//key</comment>
												 <argument><expr><name>HASH_FIND</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FaultInjector_LookupHashEntry() could not find fault injection hash entry:'%s' "</literal></expr></argument>,
						<argument><expr><name>faultName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * insert fault injection in hash table
 */</comment>
<function><type><specifier>static</specifier> <name>FaultInjectorEntry_s</name> <modifier>*</modifier></type>
<name>FaultInjector_InsertHashEntry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>faultName</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>exists</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>bool</name></type>		<name>foundPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>FaultInjectorEntry_s</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
												 <argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>,
												 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>faultName</name></expr></argument>, <comment type="line">//key</comment>
												 <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>foundPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>exists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>entry</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"FaultInjector_InsertHashEntry() entry_key:%s"</literal></expr></argument>,
		 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>foundPtr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>exists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>exists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FaultInjector_RemoveHashEntry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>faultName</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isRemoved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>FaultInjectorEntry_s</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
												 <argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>,
												 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>faultName</name></expr></argument>, <comment type="line">//key</comment>
												 <argument><expr><name>HASH_REMOVE</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault removed, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
						<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
						<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>isRemoved</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>isRemoved</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>FaultInjector_NewHashEntry</name><parameter_list>(<parameter><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type><name>entryLocal</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>exists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name> <init>= <expr><name>STATUS_OK</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>faultInjectorSlots</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>FAULTINJECTOR_MAX_SLOTS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert fault injection, no slots available"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fault name:'%s' fault type:'%s'"</literal></expr></argument>,
						   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
						   <argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"could not insert fault injection, max slots:'%d' reached"</literal></expr></argument>,
				 <argument><expr><name>FAULTINJECTOR_MAX_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<goto>goto <name>exit</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>entryLocal</name> <operator>=</operator> <call><name>FaultInjector_InsertHashEntry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>entryLocal</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert fault injection entry into table, no memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fault name:'%s' fault type:'%s'"</literal></expr></argument>,
						   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
						   <argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"could not insert fault injection, no memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<goto>goto <name>exit</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>exists</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert fault injection entry into table, entry already exists"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fault name:'%s' fault type:'%s' "</literal></expr></argument>,
						   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
						   <argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"could not insert fault injection, entry already exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<goto>goto <name>exit</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>extraArg</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>extraArg</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>startOccurrence</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>startOccurrence</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>endOccurrence</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>endOccurrence</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>numTimesTriggered</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>databaseName</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>databaseName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>=</operator> <name>FaultInjectorStateWaiting</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>faultInjectorSlots</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"FaultInjector_NewHashEntry(): '%s'"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit</name>:</label>

	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * update hash entry with state
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>FaultInjector_MarkEntryAsResume</name><parameter_list>(<parameter><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type><name>entryLocal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name> <init>= <expr><name>STATUS_OK</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name> <operator>==</operator> <name>FaultInjectorTypeResume</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entryLocal</name> <operator>=</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>entryLocal</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot update fault injection hash entry with fault injection status, no entry found"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fault name:'%s' fault type:'%s'"</literal></expr></argument>,
						   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
						   <argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>exit</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name> <operator>!=</operator> <name>FaultInjectorTypeSuspend</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only suspend fault can be resumed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name> <operator>=</operator> <name>FaultInjectorTypeResume</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LOG(fault injector): update fault injection hash entry identifier:'%s' state:'%s'"</literal></expr></argument>,
					<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
					<argument><expr><name><name>FaultInjectorStateEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorState</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit</name>:</label>

	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Inject fault according to its type.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>FaultInjector_SetFaultInjection</name><parameter_list>(<parameter><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name> <init>= <expr><name>STATUS_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isRemoved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FaultInjectorTypeReset</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>hash_status</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type><name>entryLocal</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>, <argument><expr><name>FaultInjectorNameAll</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_status</name></expr></argument>, <argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

					<while>while <condition>(<expr><operator>(</operator><name>entryLocal</name> <operator>=</operator> <operator>(</operator><name>FaultInjectorEntry_s</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>isRemoved</name> <operator>=</operator> <call><name>FaultInjector_RemoveHashEntry</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>isRemoved</name> <operator>==</operator> <name>true</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>faultInjectorSlots</name></name><operator>--</operator></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></while>
					<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>faultInjectorSlots</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>isRemoved</name> <operator>=</operator> <call><name>FaultInjector_RemoveHashEntry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>isRemoved</name> <operator>==</operator> <name>true</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>faultInjectorSlots</name></name><operator>--</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>isRemoved</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LOG(fault injector): could not remove fault injection from hash identifier:'%s'"</literal></expr></argument>,
									<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>FaultInjectorTypeWaitUntilTriggered</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type><name>entryLocal</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>retry_count</name> <init>= <expr><literal type="number">600</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 10 minutes */</comment>

				<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<while>while <condition>(<expr><operator>(</operator><name>entryLocal</name> <operator>=</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					   <name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>!=</operator> <name>FaultInjectorStateCompleted</name> <operator>&amp;&amp;</operator>
					   <name><name>entryLocal</name><operator>-&gt;</operator><name>numTimesTriggered</name></name> <operator>-</operator> <name><name>entryLocal</name><operator>-&gt;</operator><name>startOccurrence</name></name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>extraArg</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* 1 sec */</comment>
					<expr_stmt><expr><name>retry_count</name><operator>--</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>retry_count</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault not triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
										<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
										<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Timed-out as 10 minutes max wait happens until triggered."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>
				<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>entryLocal</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered %d times, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
									<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>numTimesTriggered</name></name></expr></argument>,
									<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
									<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_OK</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault not set, fault name:'%s'  "</literal></expr></argument>,
									<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>FaultInjectorTypeStatus</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type><name>entryLocal</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>length</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Success: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


				<expr_stmt><expr><name>entryLocal</name> <operator>=</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>entryLocal</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(
									  <argument><expr><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name> <operator>+</operator> <name>length</name><operator>)</operator></expr></argument>,
									  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>length</name></expr></argument>,
									  <argument><expr><literal type="string">"fault name:'%s' "</literal>
									  <literal type="string">"fault type:'%s' "</literal>
									  <literal type="string">"database name:'%s' "</literal>
									  <literal type="string">"table name:'%s' "</literal>
									  <literal type="string">"start occurrence:'%d' "</literal>
									  <literal type="string">"end occurrence:'%d' "</literal>
									  <literal type="string">"extra arg:'%d' "</literal>
									  <literal type="string">"fault injection state:'%s' "</literal>
									  <literal type="string">"num times hit:'%d' \n"</literal></expr></argument>,
									  <argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
									  <argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>databaseName</name></name></expr></argument>,
									  <argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>,
									  <argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>startOccurrence</name></name></expr></argument>,
									  <argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>endOccurrence</name></name></expr></argument>,
									  <argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>extraArg</name></name></expr></argument>,
									  <argument><expr><name><name>FaultInjectorStateEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorState</name></name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>numTimesTriggered</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
									  <argument><expr><literal type="string">"Failure: fault name:'%s' not set"</literal></expr></argument>,
									  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"fault status truncated from %d to %lu characters"</literal></expr></argument>,
						 <argument><expr><name>length</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>FaultInjectorTypeResume</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
								<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
								<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>FaultInjector_MarkEntryAsResume</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>

			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FaultInjector_NewHashEntry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>InjectFault</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>faultName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tableName</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>startOccurrence</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endOccurrence</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>extraArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name></type> <name>faultEntry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"injecting fault: name %s, type %s, db %s, table %s, startOccurrence %d, endOccurrence %d, extraArg %d"</literal></expr></argument>,
		 <argument><expr><name>faultName</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>,
		 <argument><expr><name>startOccurrence</name></expr></argument>, <argument><expr><name>endOccurrence</name></expr></argument>, <argument><expr><name>extraArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>faultName</name></name></expr></argument>, <argument><expr><name>faultName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>faultName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>faultName</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault name too long: '%s'"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fault name should be no more than %d characters."</literal></expr></argument>,
						   <argument><expr><name>FAULT_NAME_MAX_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>faultEntry</name><operator>.</operator><name>faultInjectorType</name></name> <operator>=</operator> <call><name>FaultInjectorTypeStringToEnum</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>faultEntry</name><operator>.</operator><name>faultInjectorType</name></name> <operator>==</operator> <name>FaultInjectorTypeMax</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not recognize fault type '%s'"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Special fault name "all" is only used to reset all faults */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>faultEntry</name><operator>.</operator><name>faultInjectorType</name></name> <operator>!=</operator> <name>FaultInjectorTypeReset</name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>faultName</name></name></expr></argument>, <argument><expr><name>FaultInjectorNameAll</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid fault name '%s'"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>faultEntry</name><operator>.</operator><name>extraArg</name></name> <operator>=</operator> <name>extraArg</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>faultEntry</name><operator>.</operator><name>faultInjectorType</name></name> <operator>==</operator> <name>FaultInjectorTypeSleep</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>extraArg</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>extraArg</name></expr></argument> &gt;</argument_list></name> <literal type="number">7200</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid sleep time, allowed range [0, 7200 sec]"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>databaseName</name></name></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>databaseName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>databaseName</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database name too long: '%s'"</literal></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Database name should be no more than %d characters."</literal></expr></argument>,
						   <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>tableName</name></name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>tableName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>tableName</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table name too long: '%s'"</literal></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table name should be no more than %d characters."</literal></expr></argument>,
						   <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>startOccurrence</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>startOccurrence</name></expr></argument> &gt;</argument_list></name> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid start occurrence number, allowed range [1, 1000]"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><name>endOccurrence</name> <operator>!=</operator> <name>INFINITE_END_OCCURRENCE</name> <operator>&amp;&amp;</operator> <name>endOccurrence</name> <operator>&lt;</operator> <name>startOccurrence</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid end occurrence number, allowed range [startOccurrence, ] or -1"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>faultEntry</name><operator>.</operator><name>startOccurrence</name></name> <operator>=</operator> <name>startOccurrence</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>faultEntry</name><operator>.</operator><name>endOccurrence</name></name> <operator>=</operator> <name>endOccurrence</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FaultInjector_SetFaultInjection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>faultEntry</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>faultEntry</name><operator>.</operator><name>faultInjectorType</name></name> <operator>==</operator> <name>FaultInjectorTypeStatus</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>faultEntry</name><operator>.</operator><name>bufOutput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Success:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"injected fault '%s' type '%s'"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Failure: %s"</literal></expr></argument>, <argument><expr><name><name>faultEntry</name><operator>.</operator><name>bufOutput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
