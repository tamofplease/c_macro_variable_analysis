<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/sort/sharedtuplestore.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * sharedtuplestore.c
 *	  Simple mechanism for sharing tuples between backends.
 *
 * This module contains a shared temporary tuple storage mechanism providing
 * a parallel-aware subset of the features of tuplestore.c.  Multiple backends
 * can write to a SharedTuplestore, and then multiple backends can later scan
 * the stored tuples.  Currently, the only scan type supported is a parallel
 * scan where each backend reads an arbitrary subset of the tuples that were
 * written.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/util/sort/sharedtuplestore.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buffile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sharedfileset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sharedtuplestore.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
 * The size of chunks, in pages.  This is somewhat arbitrarily set to match
 * the size of HASH_CHUNK, so that Parallel Hash obtains new chunks of tuples
 * at approximately the same rate as it allocates new chunks of memory to
 * insert them into.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STS_CHUNK_PAGES</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STS_CHUNK_HEADER_SIZE</name></cpp:macro> <cpp:value>offsetof(SharedTuplestoreChunk, data)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STS_CHUNK_DATA_SIZE</name></cpp:macro> <cpp:value>(STS_CHUNK_PAGES * BLCKSZ - STS_CHUNK_HEADER_SIZE)</cpp:value></cpp:define>

<comment type="block">/* Chunk written to disk. */</comment>
<typedef>typedef <type><struct>struct <name>SharedTuplestoreChunk</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>ntuples</name></decl>;</decl_stmt>		<comment type="block">/* Number of tuples in this chunk. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>overflow</name></decl>;</decl_stmt>		<comment type="block">/* If overflow, how many including this one? */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>data</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>SharedTuplestoreChunk</name>;</typedef>

<comment type="block">/* Per-participant shared state. */</comment>
<typedef>typedef <type><struct>struct <name>SharedTuplestoreParticipant</name>
<block>{
	<decl_stmt><decl><type><name>LWLock</name></type>		<name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>read_page</name></decl>;</decl_stmt>		<comment type="block">/* Page number for next read. */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>npages</name></decl>;</decl_stmt>			<comment type="block">/* Number of pages written. */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>writing</name></decl>;</decl_stmt>		<comment type="block">/* Used only for assertions. */</comment>
}</block></struct></type> <name>SharedTuplestoreParticipant</name>;</typedef>

<comment type="block">/* The control object that lives in shared memory. */</comment>
<struct>struct <name>SharedTuplestore</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nparticipants</name></decl>;</decl_stmt>	<comment type="block">/* Number of participants that can write. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>			<comment type="block">/* Flag bits from SHARED_TUPLESTORE_XXX */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>meta_data_size</name></decl>;</decl_stmt> <comment type="block">/* Size of per-tuple header. */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* A name for this tuplestore. */</comment>

	<comment type="block">/* Followed by per-participant shared state. */</comment>
	<decl_stmt><decl><type><name>SharedTuplestoreParticipant</name></type> <name><name>participants</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Per-participant state that lives in backend-local memory. */</comment>
<struct>struct <name>SharedTuplestoreAccessor</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>participant</name></decl>;</decl_stmt>	<comment type="block">/* My participant number. */</comment>
	<decl_stmt><decl><type><name>SharedTuplestore</name> <modifier>*</modifier></type><name>sts</name></decl>;</decl_stmt>		<comment type="block">/* The shared state. */</comment>
	<decl_stmt><decl><type><name>SharedFileSet</name> <modifier>*</modifier></type><name>fileset</name></decl>;</decl_stmt>		<comment type="block">/* The SharedFileSet holding files. */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name></decl>;</decl_stmt>		<comment type="block">/* Memory context for buffers. */</comment>

	<comment type="block">/* State for reading. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>read_participant</name></decl>;</decl_stmt>	<comment type="block">/* The current participant to read from. */</comment>
	<decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>read_file</name></decl>;</decl_stmt>		<comment type="block">/* The current file to read from. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>read_ntuples_available</name></decl>;</decl_stmt> <comment type="block">/* The number of tuples in chunk. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>read_ntuples</name></decl>;</decl_stmt>	<comment type="block">/* How many tuples have we read from chunk? */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>read_bytes</name></decl>;</decl_stmt>		<comment type="block">/* How many bytes have we read from chunk? */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>read_buffer</name></decl>;</decl_stmt>	<comment type="block">/* A buffer for loading tuples. */</comment>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>read_buffer_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>read_next_page</name></decl>;</decl_stmt> <comment type="block">/* Lowest block we'll consider reading. */</comment>

	<comment type="block">/* State for writing. */</comment>
	<decl_stmt><decl><type><name>SharedTuplestoreChunk</name> <modifier>*</modifier></type><name>write_chunk</name></decl>;</decl_stmt> <comment type="block">/* Buffer for writing. */</comment>
	<decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>write_file</name></decl>;</decl_stmt>		<comment type="block">/* The current file to write to. */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>write_page</name></decl>;</decl_stmt>		<comment type="block">/* The next page to write to. */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>write_pointer</name></decl>;</decl_stmt>	<comment type="block">/* Current write pointer within chunk. */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>write_end</name></decl>;</decl_stmt>		<comment type="block">/* One past the end of the current chunk. */</comment>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sts_filename</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>participant</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Return the amount of shared memory required to hold SharedTuplestore for a
 * given number of participants.
 */</comment>
<function><type><name>size_t</name></type>
<name>sts_estimate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>participants</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SharedTuplestore</name></expr></argument>, <argument><expr><name>participants</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>SharedTuplestoreParticipant</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>participants</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a SharedTuplestore in existing shared memory.  There must be
 * space for sts_estimate(participants) bytes.  If flags includes the value
 * SHARED_TUPLESTORE_SINGLE_PASS, the files may in future be removed more
 * eagerly (but this isn't yet implemented).
 *
 * Tuples that are stored may optionally carry a piece of fixed sized
 * meta-data which will be retrieved along with the tuple.  This is useful for
 * the hash values used in multi-batch hash joins, but could have other
 * applications.
 *
 * The caller must supply a SharedFileSet, which is essentially a directory
 * that will be cleaned up automatically, and a name which must be unique
 * across all SharedTuplestores created in the same SharedFileSet.
 */</comment>
<function><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type>
<name>sts_initialize</name><parameter_list>(<parameter><decl><type><name>SharedTuplestore</name> <modifier>*</modifier></type><name>sts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>participants</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>my_participant_number</name></decl></parameter>,
			   <parameter><decl><type><name>size_t</name></type> <name>meta_data_size</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
			   <parameter><decl><type><name>SharedFileSet</name> <modifier>*</modifier></type><name>fileset</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>my_participant_number</name> <operator>&lt;</operator> <name>participants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sts</name><operator>-&gt;</operator><name>nparticipants</name></name> <operator>=</operator> <name>participants</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name> <operator>=</operator> <name>meta_data_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sts</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>sts</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SharedTuplestore name too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>sts</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Limit meta-data so it + tuple size always fits into a single chunk.
	 * sts_puttuple() and sts_read_tuple() could be made to support scenarios
	 * where that's not the case, but it's not currently required. If so,
	 * meta-data size probably should be made variable, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>meta_data_size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name>STS_CHUNK_DATA_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"meta-data too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>participants</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sts</name><operator>-&gt;</operator><name>participants</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>,
						 <argument><expr><name>LWTRANCHE_SHARED_TUPLESTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sts</name><operator>-&gt;</operator><name>participants</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>read_page</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sts</name><operator>-&gt;</operator><name>participants</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>writing</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>accessor</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedTuplestoreAccessor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>participant</name></name> <operator>=</operator> <name>my_participant_number</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name></name> <operator>=</operator> <name>sts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>fileset</name></name> <operator>=</operator> <name>fileset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<return>return <expr><name>accessor</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Attach to a SharedTupleStore that has been initialized by another backend,
 * so that this backend can read and write tuples.
 */</comment>
<function><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type>
<name>sts_attach</name><parameter_list>(<parameter><decl><type><name>SharedTuplestore</name> <modifier>*</modifier></type><name>sts</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>my_participant_number</name></decl></parameter>,
		   <parameter><decl><type><name>SharedFileSet</name> <modifier>*</modifier></type><name>fileset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>my_participant_number</name> <operator>&lt;</operator> <name><name>sts</name><operator>-&gt;</operator><name>nparticipants</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>accessor</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedTuplestoreAccessor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>participant</name></name> <operator>=</operator> <name>my_participant_number</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name></name> <operator>=</operator> <name>sts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>fileset</name></name> <operator>=</operator> <name>fileset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<return>return <expr><name>accessor</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sts_flush_chunk</name><parameter_list>(<parameter><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <name>STS_CHUNK_PAGES</name> <operator>*</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_file</name></name></expr></argument>, <argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>participants</name><index>[<expr><name><name>accessor</name><operator>-&gt;</operator><name>participant</name></name></expr>]</index></name><operator>.</operator><name>npages</name> <operator>+=</operator>
		<name>STS_CHUNK_PAGES</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finish writing tuples.  This must be called by all backends that have
 * written data before any backend begins reading it.
 */</comment>
<function><type><name>void</name></type>
<name>sts_end_write</name><parameter_list>(<parameter><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>write_file</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sts_flush_chunk</name><argument_list>(<argument><expr><name>accessor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>participants</name><index>[<expr><name><name>accessor</name><operator>-&gt;</operator><name>participant</name></name></expr>]</index></name><operator>.</operator><name>writing</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare to rescan.  Only one participant must call this.  After it returns,
 * all participants may call sts_begin_parallel_scan() and then loop over
 * sts_parallel_scan_next().  This function must not be called concurrently
 * with a scan, and synchronization to avoid that is the caller's
 * responsibility.
 */</comment>
<function><type><name>void</name></type>
<name>sts_reinitialize</name><parameter_list>(<parameter><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reset the shared read head for all participants' files.  Also set the
	 * initial chunk size to the minimum (any increases from that size will be
	 * recorded in chunk_expansion_log).
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>nparticipants</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>participants</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>read_page</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Begin scanning the contents in parallel.
 */</comment>
<function><type><name>void</name></type>
<name>sts_begin_parallel_scan</name><parameter_list>(<parameter><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name>			<name>i</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<comment type="block">/* End any existing scan that was in progress. */</comment>
	<expr_stmt><expr><call><name>sts_end_parallel_scan</name><argument_list>(<argument><expr><name>accessor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Any backend that might have written into this shared tuplestore must
	 * have called sts_end_write(), so that all buffers are flushed and the
	 * files have stopped growing.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>nparticipants</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>participants</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>writing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * We will start out reading the file that THIS backend wrote.  There may
	 * be some caching locality advantage to that.
	 */</comment>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_participant</name></name> <operator>=</operator> <name><name>accessor</name><operator>-&gt;</operator><name>participant</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_next_page</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finish a parallel scan, freeing associated backend-local resources.
 */</comment>
<function><type><name>void</name></type>
<name>sts_end_parallel_scan</name><parameter_list>(<parameter><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Here we could delete all files if SHARED_TUPLESTORE_SINGLE_PASS, but
	 * we'd probably need a reference count of current parallel scanners so we
	 * could safely do it only when the reference count reaches zero.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write a tuple.  If a meta-data size was provided to sts_initialize, then a
 * pointer to meta data of that size must be provided.
 */</comment>
<function><type><name>void</name></type>
<name>sts_puttuple</name><parameter_list>(<parameter><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>meta_data</name></decl></parameter>,
			 <parameter><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* Do we have our own file yet? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>write_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SharedTuplestoreParticipant</name> <modifier>*</modifier></type><name>participant</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* Create one.  Only this backend will write into it. */</comment>
		<expr_stmt><expr><call><name>sts_filename</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>accessor</name></expr></argument>, <argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>participant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_file</name></name> <operator>=</operator> <call><name>BufFileCreateShared</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>fileset</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up the shared state for this backend's file. */</comment>
		<expr_stmt><expr><name>participant</name> <operator>=</operator> <operator>&amp;</operator><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>participants</name><index>[<expr><name><name>accessor</name><operator>-&gt;</operator><name>participant</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>participant</name><operator>-&gt;</operator><name>writing</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* for assertions only */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Do we have space? */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name> <operator>+</operator> <name>size</name> <operator>&gt;=</operator> <name><name>accessor</name><operator>-&gt;</operator><name>write_end</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* First time through.  Allocate chunk. */</comment>
			<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name></name> <operator>=</operator> <operator>(</operator><name>SharedTuplestoreChunk</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>context</name></name></expr></argument>,
									   <argument><expr><name>STS_CHUNK_PAGES</name> <operator>*</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_end</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator>
				<name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name></name> <operator>+</operator> <name>STS_CHUNK_PAGES</name> <operator>*</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* See if flushing helps. */</comment>
			<expr_stmt><expr><call><name>sts_flush_chunk</name><argument_list>(<argument><expr><name>accessor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* It may still not be enough in the case of a gigantic tuple. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name> <operator>+</operator> <name>size</name> <operator>&gt;=</operator> <name><name>accessor</name><operator>-&gt;</operator><name>write_end</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>written</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We'll write the beginning of the oversized tuple, and then
			 * write the rest in some number of 'overflow' chunks.
			 *
			 * sts_initialize() verifies that the size of the tuple +
			 * meta-data always fits into a chunk. Because the chunk has been
			 * flushed above, we can be sure to have all of a chunk's usable
			 * space available.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name> <operator>+</operator> <name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name> <operator>+</operator>
				   <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name><name>accessor</name><operator>-&gt;</operator><name>write_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Write the meta-data as one chunk. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name></expr></argument>, <argument><expr><name>meta_data</name></expr></argument>,
					   <argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Write as much of the tuple as we can fit. This includes the
			 * tuple's size at the start.
			 */</comment>
			<expr_stmt><expr><name>written</name> <operator>=</operator> <name><name>accessor</name><operator>-&gt;</operator><name>write_end</name></name> <operator>-</operator> <name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name> <operator>-</operator>
				<name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name> <operator>+</operator> <name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name></expr></argument>,
				   <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>size</name> <operator>-=</operator> <name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>written</name></expr>;</expr_stmt>
			<comment type="block">/* Now write as many overflow chunks as we need for the rest. */</comment>
			<while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>size_t</name></type>		<name>written_this_chunk</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>sts_flush_chunk</name><argument_list>(<argument><expr><name>accessor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * How many overflow chunks to go?  This will allow readers to
				 * skip all of them at once instead of reading each one.
				 */</comment>
				<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name><operator>-&gt;</operator><name>overflow</name></name> <operator>=</operator> <operator>(</operator><name>size</name> <operator>+</operator> <name>STS_CHUNK_DATA_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator>
					<name>STS_CHUNK_DATA_SIZE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>written_this_chunk</name> <operator>=</operator>
					<call><name>Min</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_end</name></name> <operator>-</operator> <name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <name>written</name></expr></argument>,
					   <argument><expr><name>written_this_chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name> <operator>+=</operator> <name>written_this_chunk</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>written_this_chunk</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>written_this_chunk</name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Copy meta-data and tuple into buffer. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name></expr></argument>, <argument><expr><name>meta_data</name></expr></argument>,
			   <argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name> <operator>+</operator> <name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
		   <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>write_pointer</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>++</operator><name><name>accessor</name><operator>-&gt;</operator><name>write_chunk</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MinimalTuple</name></type>
<name>sts_read_tuple</name><parameter_list>(<parameter><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>meta_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>remaining_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>this_chunk_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>destination</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We'll keep track of bytes read from this chunk so that we can detect an
	 * overflowing tuple and switch to reading overflow pages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name></expr></argument>,
						<argument><expr><name>meta_data</name></expr></argument>,
						<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>
			<name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from shared tuplestore temporary file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Short read while reading meta-data."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_bytes</name></name> <operator>+=</operator> <name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>meta_data_size</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from shared tuplestore temporary file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Short read while reading size."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_bytes</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name><name>accessor</name><operator>-&gt;</operator><name>read_buffer_size</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>new_read_buffer_size</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>read_buffer</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>new_read_buffer_size</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_buffer_size</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_buffer</name></name> <operator>=</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>new_read_buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_buffer_size</name></name> <operator>=</operator> <name>new_read_buffer_size</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>remaining_size</name> <operator>=</operator> <name>size</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>this_chunk_size</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>remaining_size</name></expr></argument>,
						  <argument><expr><name>BLCKSZ</name> <operator>*</operator> <name>STS_CHUNK_PAGES</name> <operator>-</operator> <name><name>accessor</name><operator>-&gt;</operator><name>read_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>destination</name> <operator>=</operator> <name><name>accessor</name><operator>-&gt;</operator><name>read_buffer</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name></expr></argument>,
					<argument><expr><name>destination</name></expr></argument>,
					<argument><expr><name>this_chunk_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>this_chunk_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from shared tuplestore temporary file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Short read while reading tuple."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_bytes</name></name> <operator>+=</operator> <name>this_chunk_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>remaining_size</name> <operator>-=</operator> <name>this_chunk_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>destination</name> <operator>+=</operator> <name>this_chunk_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>++</operator><name><name>accessor</name><operator>-&gt;</operator><name>read_ntuples</name></name></expr>;</expr_stmt>

	<comment type="block">/* Check if we need to read any overflow chunks. */</comment>
	<while>while <condition>(<expr><name>remaining_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We are now positioned at the start of an overflow chunk. */</comment>
		<decl_stmt><decl><type><name>SharedTuplestoreChunk</name></type> <name>chunk_header</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>chunk_header</name></expr></argument>, <argument><expr><name>STS_CHUNK_HEADER_SIZE</name></expr></argument>)</argument_list></call> <operator>!=</operator>
			<name>STS_CHUNK_HEADER_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from shared tuplestore temporary file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Short read while reading overflow chunk header."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_bytes</name></name> <operator>=</operator> <name>STS_CHUNK_HEADER_SIZE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>chunk_header</name><operator>.</operator><name>overflow</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected chunk in shared tuplestore temporary file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Expected overflow chunk."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_next_page</name></name> <operator>+=</operator> <name>STS_CHUNK_PAGES</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>this_chunk_size</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>remaining_size</name></expr></argument>,
							  <argument><expr><name>BLCKSZ</name> <operator>*</operator> <name>STS_CHUNK_PAGES</name> <operator>-</operator>
							  <name>STS_CHUNK_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name></expr></argument>,
						<argument><expr><name>destination</name></expr></argument>,
						<argument><expr><name>this_chunk_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>this_chunk_size</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from shared tuplestore temporary file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"Short read while reading tuple."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_bytes</name></name> <operator>+=</operator> <name>this_chunk_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>remaining_size</name> <operator>-=</operator> <name>this_chunk_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>destination</name> <operator>+=</operator> <name>this_chunk_size</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * These will be used to count regular tuples following the oversized
		 * tuple that spilled into this overflow chunk.
		 */</comment>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_ntuples_available</name></name> <operator>=</operator> <name><name>chunk_header</name><operator>.</operator><name>ntuples</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <name><name>accessor</name><operator>-&gt;</operator><name>read_buffer</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the next tuple in the current parallel scan.
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>sts_parallel_scan_next</name><parameter_list>(<parameter><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>meta_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedTuplestoreParticipant</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>read_page</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>eof</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Can we read more tuples from the current chunk? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>read_ntuples</name></name> <operator>&lt;</operator> <name><name>accessor</name><operator>-&gt;</operator><name>read_ntuples_available</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>sts_read_tuple</name><argument_list>(<argument><expr><name>accessor</name></expr></argument>, <argument><expr><name>meta_data</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Find the location of a new chunk to read. */</comment>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>participants</name><index>[<expr><name><name>accessor</name><operator>-&gt;</operator><name>read_participant</name></name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We can skip directly past overflow pages we know about. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>read_page</name></name> <operator>&lt;</operator> <name><name>accessor</name><operator>-&gt;</operator><name>read_next_page</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>read_page</name></name> <operator>=</operator> <name><name>accessor</name><operator>-&gt;</operator><name>read_next_page</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>eof</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>read_page</name></name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>npages</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eof</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Claim the next chunk. */</comment>
			<expr_stmt><expr><name>read_page</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>read_page</name></name></expr>;</expr_stmt>
			<comment type="block">/* Advance the read head for the next reader. */</comment>
			<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>read_page</name></name> <operator>+=</operator> <name>STS_CHUNK_PAGES</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_next_page</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>read_page</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eof</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SharedTuplestoreChunk</name></type> <name>chunk_header</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>nread</name></decl>;</decl_stmt>

			<comment type="block">/* Make sure we have the file open. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>sts_filename</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>accessor</name></expr></argument>, <argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_participant</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name> <operator>=</operator>
					<call><name>BufFileOpenShared</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>fileset</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Seek and load the chunk header. */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>BufFileSeekBlock</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name></expr></argument>, <argument><expr><name>read_page</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek block %u in shared tuplestore temporary file"</literal></expr></argument>,
								<argument><expr><name>read_page</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>chunk_header</name></expr></argument>,
								<argument><expr><name>STS_CHUNK_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>!=</operator> <name>STS_CHUNK_HEADER_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from shared tuplestore temporary file: read only %zu of %zu bytes"</literal></expr></argument>,
								<argument><expr><name>nread</name></expr></argument>, <argument><expr><name>STS_CHUNK_HEADER_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If this is an overflow chunk, we skip it and any following
			 * overflow chunks all at once.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>chunk_header</name><operator>.</operator><name>overflow</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_next_page</name></name> <operator>=</operator> <name>read_page</name> <operator>+</operator>
					<name><name>chunk_header</name><operator>.</operator><name>overflow</name></name> <operator>*</operator> <name>STS_CHUNK_PAGES</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_ntuples_available</name></name> <operator>=</operator> <name><name>chunk_header</name><operator>.</operator><name>ntuples</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_bytes</name></name> <operator>=</operator> <name>STS_CHUNK_HEADER_SIZE</name></expr>;</expr_stmt>

			<comment type="block">/* Go around again, so we can get a tuple from this chunk. */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Try the next participant's file.  If we've gone full circle,
			 * we're done.
			 */</comment>
			<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_participant</name></name> <operator>=</operator> <operator>(</operator><name><name>accessor</name><operator>-&gt;</operator><name>read_participant</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator>
				<name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>nparticipants</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>accessor</name><operator>-&gt;</operator><name>read_participant</name></name> <operator>==</operator> <name><name>accessor</name><operator>-&gt;</operator><name>participant</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>accessor</name><operator>-&gt;</operator><name>read_next_page</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* Go around again, so we can get a chunk from this file. */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create the name used for the BufFile that a given participant will write.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sts_filename</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>SharedTuplestoreAccessor</name> <modifier>*</modifier></type><name>accessor</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>participant</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s.p%d"</literal></expr></argument>, <argument><expr><name><name>accessor</name><operator>-&gt;</operator><name>sts</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>participant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
