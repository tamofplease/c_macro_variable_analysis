<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/adt/numeric.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * numeric.c
 *	  An exact numeric data type for the Postgres database system
 *
 * Original coding 1998, Jan Wieck.  Heavily revised 2003, Tom Lane.
 *
 * Many of the algorithmic ideas are borrowed from David M. Smith's "FM"
 * multiple-precision math library, most recently published as Algorithm
 * 786: Multiple-Precision Complex Arithmetic and Functions, ACM
 * Transactions on Mathematical Software, Vol. 24, No. 4, December 1998,
 * pages 359-367.
 *
 * Copyright (c) 1998-2018, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/numeric.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/hyperloglog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/int8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/numeric.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sortsupport.h"</cpp:file></cpp:include>

<comment type="block">/* ----------
 * Uncomment the following to enable compilation of dump_numeric()
 * and dump_var() and to get a dump of any result produced by make_result().
 * ----------
#define NUMERIC_DEBUG
 */</comment>


<comment type="block">/* ----------
 * Local data types
 *
 * Numeric values are represented in a base-NBASE floating point format.
 * Each "digit" ranges from 0 to NBASE-1.  The type NumericDigit is signed
 * and wide enough to store a digit.  We assume that NBASE*NBASE can fit in
 * an int.  Although the purely calculational routines could handle any even
 * NBASE that's less than sqrt(INT_MAX), in practice we are only interested
 * in NBASE a power of ten, so that I/O conversions and decimal rounding
 * are easy.  Also, it's actually more efficient if NBASE is rather less than
 * sqrt(INT_MAX), so that there is "headroom" for mul_var and div_var_fast to
 * postpone processing carries.
 *
 * Values of NBASE other than 10000 are considered of historical interest only
 * and are no longer supported in any sense; no mechanism exists for the client
 * to discover the base, so every client supporting binary mode expects the
 * base-10000 format.  If you plan to change this, also note the numeric
 * abbreviation code, which assumes NBASE=10000.
 * ----------
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBASE</name></cpp:macro>		<cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HALF_NBASE</name></cpp:macro>	<cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEC_DIGITS</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>			<comment type="block">/* decimal digits per NBASE digit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUL_GUARD_DIGITS</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>	<comment type="block">/* these are measured in NBASE digits */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIV_GUARD_DIGITS</name></cpp:macro>	<cpp:value>8</cpp:value></cpp:define>

typedef signed char NumericDigit;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBASE</name></cpp:macro>		<cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HALF_NBASE</name></cpp:macro>	<cpp:value>50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEC_DIGITS</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>			<comment type="block">/* decimal digits per NBASE digit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUL_GUARD_DIGITS</name></cpp:macro>	<cpp:value>3</cpp:value></cpp:define>	<comment type="block">/* these are measured in NBASE digits */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIV_GUARD_DIGITS</name></cpp:macro>	<cpp:value>6</cpp:value></cpp:define>

typedef signed char NumericDigit;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBASE</name></cpp:macro>		<cpp:value>10000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HALF_NBASE</name></cpp:macro>	<cpp:value>5000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEC_DIGITS</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>			<comment type="block">/* decimal digits per NBASE digit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUL_GUARD_DIGITS</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>	<comment type="block">/* these are measured in NBASE digits */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIV_GUARD_DIGITS</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>

<typedef>typedef <type><name>int16</name></type> <name>NumericDigit</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * The Numeric type as stored on disk.
 *
 * If the high bits of the first word of a NumericChoice (n_header, or
 * n_short.n_header, or n_long.n_sign_dscale) are NUMERIC_SHORT, then the
 * numeric follows the NumericShort format; if they are NUMERIC_POS or
 * NUMERIC_NEG, it follows the NumericLong format.  If they are NUMERIC_NAN,
 * it is a NaN.  We currently always store a NaN using just two bytes (i.e.
 * only n_header), but previous releases used only the NumericLong format,
 * so we might find 4-byte NaNs on disk if a database has been migrated using
 * pg_upgrade.  In either case, when the high bits indicate a NaN, the
 * remaining bits are never examined.  Currently, we always initialize these
 * to zero, but it might be possible to use them for some other purpose in
 * the future.
 *
 * In the NumericShort format, the remaining 14 bits of the header word
 * (n_short.n_header) are allocated as follows: 1 for sign (positive or
 * negative), 6 for dynamic scale, and 7 for weight.  In practice, most
 * commonly-encountered values can be represented this way.
 *
 * In the NumericLong format, the remaining 14 bits of the header word
 * (n_long.n_sign_dscale) represent the display scale; and the weight is
 * stored separately in n_weight.
 *
 * NOTE: by convention, values in the packed form have been stripped of
 * all leading and trailing zero digits (where a "digit" is of base NBASE).
 * In particular, if the value is zero, there will be no digits at all!
 * The weight is arbitrary in that case, but we normally set it to zero.
 */</comment>

<struct>struct <name>NumericShort</name>
<block>{
	<decl_stmt><decl><type><name>uint16</name></type>		<name>n_header</name></decl>;</decl_stmt>		<comment type="block">/* Sign + display scale + weight */</comment>
	<decl_stmt><decl><type><name>NumericDigit</name></type> <name><name>n_data</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Digits */</comment>
}</block>;</struct>

<struct>struct <name>NumericLong</name>
<block>{
	<decl_stmt><decl><type><name>uint16</name></type>		<name>n_sign_dscale</name></decl>;</decl_stmt>	<comment type="block">/* Sign + display scale */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>n_weight</name></decl>;</decl_stmt>		<comment type="block">/* Weight of 1st digit	*/</comment>
	<decl_stmt><decl><type><name>NumericDigit</name></type> <name><name>n_data</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Digits */</comment>
}</block>;</struct>

<union>union <name>NumericChoice</name>
<block>{
	<decl_stmt><decl><type><name>uint16</name></type>		<name>n_header</name></decl>;</decl_stmt>		<comment type="block">/* Header word */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>NumericLong</name></name></type> <name>n_long</name></decl>;</decl_stmt>	<comment type="block">/* Long form (4-byte header) */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>NumericShort</name></name></type> <name>n_short</name></decl>;</decl_stmt>	<comment type="block">/* Short form (2-byte header) */</comment>
}</block>;</union>

<struct>struct <name>NumericData</name>
<block>{
	<decl_stmt><decl><type><name>int32</name></type>		<name>vl_len_</name></decl>;</decl_stmt>		<comment type="block">/* varlena header (do not touch directly!) */</comment>
	<decl_stmt><decl><type><name><name>union</name> <name>NumericChoice</name></name></type> <name>choice</name></decl>;</decl_stmt> <comment type="block">/* choice of format */</comment>
}</block>;</struct>


<comment type="block">/*
 * Interpretation of high bits.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_SIGN_MASK</name></cpp:macro>	<cpp:value>0xC000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_POS</name></cpp:macro>			<cpp:value>0x0000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_NEG</name></cpp:macro>			<cpp:value>0x4000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_SHORT</name></cpp:macro>		<cpp:value>0x8000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_NAN</name></cpp:macro>			<cpp:value>0xC000</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_FLAGBITS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((n)-&gt;choice.n_header &amp; NUMERIC_SIGN_MASK)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_IS_NAN</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(NUMERIC_FLAGBITS(n) == NUMERIC_NAN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_IS_SHORT</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(NUMERIC_FLAGBITS(n) == NUMERIC_SHORT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_HDRSZ</name></cpp:macro>	<cpp:value>(VARHDRSZ + sizeof(uint16) + sizeof(int16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_HDRSZ_SHORT</name></cpp:macro> <cpp:value>(VARHDRSZ + sizeof(uint16))</cpp:value></cpp:define>

<comment type="block">/*
 * If the flag bits are NUMERIC_SHORT or NUMERIC_NAN, we want the short header;
 * otherwise, we want the long one.  Instead of testing against each value, we
 * can just look at the high bit, for a slight efficiency gain.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_HEADER_IS_SHORT</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((n)-&gt;choice.n_header &amp; 0x8000) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_HEADER_SIZE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(VARHDRSZ + sizeof(uint16) + \
	 (NUMERIC_HEADER_IS_SHORT(n) ? 0 : sizeof(int16)))</cpp:value></cpp:define>

<comment type="block">/*
 * Short format definitions.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_SHORT_SIGN_MASK</name></cpp:macro>			<cpp:value>0x2000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_SHORT_DSCALE_MASK</name></cpp:macro>		<cpp:value>0x1F80</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_SHORT_DSCALE_SHIFT</name></cpp:macro>		<cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_SHORT_DSCALE_MAX</name></cpp:macro>		\
	<cpp:value>(NUMERIC_SHORT_DSCALE_MASK &gt;&gt; NUMERIC_SHORT_DSCALE_SHIFT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_SHORT_WEIGHT_SIGN_MASK</name></cpp:macro>	<cpp:value>0x0040</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_SHORT_WEIGHT_MASK</name></cpp:macro>		<cpp:value>0x003F</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_SHORT_WEIGHT_MAX</name></cpp:macro>		<cpp:value>NUMERIC_SHORT_WEIGHT_MASK</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_SHORT_WEIGHT_MIN</name></cpp:macro>		<cpp:value>(-(NUMERIC_SHORT_WEIGHT_MASK+1))</cpp:value></cpp:define>

<comment type="block">/*
 * Extract sign, display scale, weight.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_DSCALE_MASK</name></cpp:macro>			<cpp:value>0x3FFF</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_SIGN</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(NUMERIC_IS_SHORT(n) ? \
		(((n)-&gt;choice.n_short.n_header &amp; NUMERIC_SHORT_SIGN_MASK) ? \
		NUMERIC_NEG : NUMERIC_POS) : NUMERIC_FLAGBITS(n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_DSCALE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(NUMERIC_HEADER_IS_SHORT((n)) ? \
	((n)-&gt;choice.n_short.n_header &amp; NUMERIC_SHORT_DSCALE_MASK) \
		&gt;&gt; NUMERIC_SHORT_DSCALE_SHIFT \
	: ((n)-&gt;choice.n_long.n_sign_dscale &amp; NUMERIC_DSCALE_MASK))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_WEIGHT</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(NUMERIC_HEADER_IS_SHORT((n)) ? \
	(((n)-&gt;choice.n_short.n_header &amp; NUMERIC_SHORT_WEIGHT_SIGN_MASK ? \
		~NUMERIC_SHORT_WEIGHT_MASK : 0) \
	 | ((n)-&gt;choice.n_short.n_header &amp; NUMERIC_SHORT_WEIGHT_MASK)) \
	: ((n)-&gt;choice.n_long.n_weight))</cpp:value></cpp:define>

<comment type="block">/* ----------
 * NumericVar is the format we use for arithmetic.  The digit-array part
 * is the same as the NumericData storage format, but the header is more
 * complex.
 *
 * The value represented by a NumericVar is determined by the sign, weight,
 * ndigits, and digits[] array.
 *
 * Note: the first digit of a NumericVar's value is assumed to be multiplied
 * by NBASE ** weight.  Another way to say it is that there are weight+1
 * digits before the decimal point.  It is possible to have weight &lt; 0.
 *
 * buf points at the physical start of the palloc'd digit buffer for the
 * NumericVar.  digits points at the first digit in actual use (the one
 * with the specified weight).  We normally leave an unused digit or two
 * (preset to zeroes) between buf and digits, so that there is room to store
 * a carry out of the top digit without reallocating space.  We just need to
 * decrement digits (and increment weight) to make room for the carry digit.
 * (There is no such extra space in a numeric value stored in the database,
 * only in a NumericVar in memory.)
 *
 * If buf is NULL then the digit buffer isn't actually palloc'd and should
 * not be freed --- see the constants below for an example.
 *
 * dscale, or display scale, is the nominal precision expressed as number
 * of digits after the decimal point (it must always be &gt;= 0 at present).
 * dscale may be more than the number of physically stored fractional digits,
 * implying that we have suppressed storage of significant trailing zeroes.
 * It should never be less than the number of stored digits, since that would
 * imply hiding digits that are present.  NOTE that dscale is always expressed
 * in *decimal* digits, and so it may correspond to a fractional number of
 * base-NBASE digits --- divide by DEC_DIGITS to convert to NBASE digits.
 *
 * rscale, or result scale, is the target precision for a computation.
 * Like dscale it is expressed as number of *decimal* digits after the decimal
 * point, and is always &gt;= 0 at present.
 * Note that rscale is not stored in variables --- it's figured on-the-fly
 * from the dscales of the inputs.
 *
 * While we consistently use "weight" to refer to the base-NBASE weight of
 * a numeric value, it is convenient in some scale-related calculations to
 * make use of the base-10 weight (ie, the approximate log10 of the value).
 * To avoid confusion, such a decimal-units weight is called a "dweight".
 *
 * NB: All the variable-level functions are written in a style that makes it
 * possible to give one and the same variable as argument and destination.
 * This is feasible because the digit buffer is separate from the variable.
 * ----------
 */</comment>
<typedef>typedef <type><struct>struct <name>NumericVar</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>		<comment type="block">/* # of digits in digits[] - can be 0! */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name></decl>;</decl_stmt>			<comment type="block">/* weight of first digit */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sign</name></decl>;</decl_stmt>			<comment type="block">/* NUMERIC_POS, NUMERIC_NEG, or NUMERIC_NAN */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>dscale</name></decl>;</decl_stmt>			<comment type="block">/* display scale */</comment>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>			<comment type="block">/* start of palloc'd space for digits[] */</comment>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>digits</name></decl>;</decl_stmt>		<comment type="block">/* base-NBASE digits */</comment>
}</block></struct></type> <name>NumericVar</name>;</typedef>


<comment type="block">/* ----------
 * Data for generate_series
 * ----------
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>current</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>stop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>step</name></decl>;</decl_stmt>
}</block></struct></type> <name>generate_series_numeric_fctx</name>;</typedef>


<comment type="block">/* ----------
 * Sort support.
 * ----------
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>			<comment type="block">/* buffer for short varlenas */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>input_count</name></decl>;</decl_stmt>	<comment type="block">/* number of non-null values seen */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>estimating</name></decl>;</decl_stmt>		<comment type="block">/* true if estimating cardinality */</comment>

	<decl_stmt><decl><type><name>hyperLogLogState</name></type> <name>abbr_card</name></decl>;</decl_stmt> <comment type="block">/* cardinality estimator */</comment>
}</block></struct></type> <name>NumericSortSupport</name>;</typedef>


<comment type="block">/* ----------
 * Fast sum accumulator.
 *
 * NumericSumAccum is used to implement SUM(), and other standard aggregates
 * that track the sum of input values.  It uses 32-bit integers to store the
 * digits, instead of the normal 16-bit integers (with NBASE=10000).  This
 * way, we can safely accumulate up to NBASE - 1 values without propagating
 * carry, before risking overflow of any of the digits.  'num_uncarried'
 * tracks how many values have been accumulated without propagating carry.
 *
 * Positive and negative values are accumulated separately, in 'pos_digits'
 * and 'neg_digits'.  This is simpler and faster than deciding whether to add
 * or subtract from the current value, for each new value (see sub_var() for
 * the logic we avoid by doing this).  Both buffers are of same size, and
 * have the same weight and scale.  In accum_sum_final(), the positive and
 * negative sums are added together to produce the final result.
 *
 * When a new value has a larger ndigits or weight than the accumulator
 * currently does, the accumulator is enlarged to accommodate the new value.
 * We normally have one zero digit reserved for carry propagation, and that
 * is indicated by the 'have_carry_space' flag.  When accum_sum_carry() uses
 * up the reserved digit, it clears the 'have_carry_space' flag.  The next
 * call to accum_sum_add() will enlarge the buffer, to make room for the
 * extra digit, and set the flag again.
 *
 * To initialize a new accumulator, simply reset all fields to zeros.
 *
 * The accumulator does not handle NaNs.
 * ----------
 */</comment>
<typedef>typedef <type><struct>struct <name>NumericSumAccum</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_uncarried</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_carry_space</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>pos_digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>neg_digits</name></decl>;</decl_stmt>
}</block></struct></type> <name>NumericSumAccum</name>;</typedef>


<comment type="block">/*
 * We define our own macros for packing and unpacking abbreviated-key
 * representations for numeric values in order to avoid depending on
 * USE_FLOAT8_BYVAL.  The type of abbreviation we use is based only on
 * the size of a datum, not the argument-passing convention for float8.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_ABBREV_BITS</name></cpp:macro> <cpp:value>(SIZEOF_DATUM * BITS_PER_BYTE)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_DATUM</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NumericAbbrevGetDatum</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((Datum) (X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DatumGetNumericAbbrev</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((int64) (X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_ABBREV_NAN</name></cpp:macro>		 <cpp:value>NumericAbbrevGetDatum(PG_INT64_MIN)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NumericAbbrevGetDatum</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((Datum) (X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DatumGetNumericAbbrev</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((int32) (X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_ABBREV_NAN</name></cpp:macro>		 <cpp:value>NumericAbbrevGetDatum(PG_INT32_MIN)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* ----------
 * Some preinitialized constants
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_zero_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericVar</name></type> <name>const_zero</name> <init>=
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NUMERIC_POS</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><operator>(</operator><name>NumericDigit</name> <operator>*</operator><operator>)</operator> <name>const_zero_data</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_one_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericVar</name></type> <name>const_one</name> <init>=
<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NUMERIC_POS</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><operator>(</operator><name>NumericDigit</name> <operator>*</operator><operator>)</operator> <name>const_one_data</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_two_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">2</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericVar</name></type> <name>const_two</name> <init>=
<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NUMERIC_POS</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><operator>(</operator><name>NumericDigit</name> <operator>*</operator><operator>)</operator> <name>const_two_data</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_ten_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">10</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericVar</name></type> <name>const_ten</name> <init>=
<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NUMERIC_POS</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><operator>(</operator><name>NumericDigit</name> <operator>*</operator><operator>)</operator> <name>const_ten_data</name></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:elif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_ten_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericVar</name></type> <name>const_ten</name> <init>=
<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUMERIC_POS</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><operator>(</operator><name>NumericDigit</name> <operator>*</operator><operator>)</operator> <name>const_ten_data</name></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_zero_point_five_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">5000</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:elif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_zero_point_five_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">50</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:elif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_zero_point_five_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">5</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericVar</name></type> <name>const_zero_point_five</name> <init>=
<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUMERIC_POS</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NULL</name></expr>, <expr><operator>(</operator><name>NumericDigit</name> <operator>*</operator><operator>)</operator> <name>const_zero_point_five_data</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_zero_point_nine_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">9000</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:elif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_zero_point_nine_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">90</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:elif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_zero_point_nine_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">9</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericVar</name></type> <name>const_zero_point_nine</name> <init>=
<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUMERIC_POS</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NULL</name></expr>, <expr><operator>(</operator><name>NumericDigit</name> <operator>*</operator><operator>)</operator> <name>const_zero_point_nine_data</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_one_point_one_data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1000</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:elif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_one_point_one_data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">10</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:elif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericDigit</name></type> <name><name>const_one_point_one_data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericVar</name></type> <name>const_one_point_one</name> <init>=
<expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NUMERIC_POS</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NULL</name></expr>, <expr><operator>(</operator><name>NumericDigit</name> <operator>*</operator><operator>)</operator> <name>const_one_point_one_data</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NumericVar</name></type> <name>const_nan</name> <init>=
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NUMERIC_NAN</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>round_powers</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><literal type="number">10</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* ----------
 * Local functions
 * ----------
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NUMERIC_DEBUG</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_numeric</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>Numeric</name></type> <name>num</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dump_numeric</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dump_var</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>digitbuf_alloc</name><parameter_list>(<parameter><type><name>ndigits</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>((NumericDigit *) palloc((ndigits) * sizeof(NumericDigit)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>digitbuf_free</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>do { \
		 if ((buf) != NULL) \
			 pfree(buf); \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>init_var</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>MemSetAligned(v, 0, sizeof(NumericVar))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_DIGITS</name><parameter_list>(<parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(NUMERIC_HEADER_IS_SHORT(num) ? \
	(num)-&gt;choice.n_short.n_data : (num)-&gt;choice.n_long.n_data)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_NDIGITS</name><parameter_list>(<parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((VARSIZE(num) - NUMERIC_HEADER_SIZE(num)) / sizeof(NumericDigit))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMERIC_CAN_BE_SHORT</name><parameter_list>(<parameter><type><name>scale</name></type></parameter>,<parameter><type><name>weight</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((scale) &lt;= NUMERIC_SHORT_DSCALE_MAX &amp;&amp; \
	(weight) &lt;= NUMERIC_SHORT_WEIGHT_MAX &amp;&amp; \
	(weight) &gt;= NUMERIC_SHORT_WEIGHT_MIN)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>alloc_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndigits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>zero_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>set_var_from_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>,
				 <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_var_from_num</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_var_from_num</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_var_from_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_str_from_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_str_from_var_sci</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Numeric</name></type> <name>make_result</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>apply_typmod</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>numericvar_to_int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>numericvar_to_int64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>int64_to_numericvar</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>numericvar_to_int128</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int128</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>int128_to_numericvar</name><parameter_list>(<parameter><decl><type><name>int128</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>numericvar_to_double_no_overflow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>numeric_abbrev_convert</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>original_datum</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>numeric_abbrev_abort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>memtupcount</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>numeric_fast_cmp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>numeric_cmp_abbrev</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>numeric_abbrev_convert_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
						   <parameter><decl><type><name>NumericSortSupport</name> <modifier>*</modifier></type><name>nss</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>cmp_numerics</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>num1</name></decl></parameter>, <parameter><decl><type><name>Numeric</name></type> <name>num2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>cmp_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cmp_var_common</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericDigit</name> <modifier>*</modifier></type><name>var1digits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var1ndigits</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>var1weight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var1sign</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>NumericDigit</name> <modifier>*</modifier></type><name>var2digits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var2ndigits</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>var2weight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var2sign</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>,
		<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sub_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>,
		<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mul_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>,
		<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>div_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>,
		<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>round</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>div_var_fast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>,
			 <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>round</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>select_div_scale</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mod_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>,
		<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ceil_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>floor_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sqrt_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exp_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>estimate_ln_dweight</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ln_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>log_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>num</name></decl></parameter>,
		<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>power_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>,
		  <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>power_var_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exp</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>cmp_abs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cmp_abs_common</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericDigit</name> <modifier>*</modifier></type><name>var1digits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var1ndigits</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>var1weight</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>NumericDigit</name> <modifier>*</modifier></type><name>var2digits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var2ndigits</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>var2weight</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_abs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>,
		<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sub_abs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>,
		<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>round_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>trunc_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>strip_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_bucket</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>operand</name></decl></parameter>, <parameter><decl><type><name>Numeric</name></type> <name>bound1</name></decl></parameter>, <parameter><decl><type><name>Numeric</name></type> <name>bound2</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>count_var</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result_var</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>accum_sum_add</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>accum_sum_rescale</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>accum_sum_carry</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>accum_sum_reset</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>accum_sum_final</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>accum_sum_copy</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>accum_sum_combine</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>, <parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum2</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------------
 *
 * Input-, output- and rounding-functions
 *
 * ----------------------------------------------------------------------
 */</comment>


<comment type="block">/*
 * numeric_in() -
 *
 *	Input function for numeric data type
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

	<comment type="block">/* Skip leading spaces */</comment>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Check for NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"NaN"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Should be nothing left but spaces */</comment>
		<expr_stmt><expr><name>cp</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
								<argument><expr><literal type="string">"numeric"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Use set_var_from_str() to parse a normal numeric value
		 */</comment>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>value</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>set_var_from_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We duplicate a few lines of code here because we would like to
		 * throw any trailing-junk syntax error before any semantic error
		 * resulting from apply_typmod.  We can't easily fold the two cases
		 * together because we mustn't apply apply_typmod to a NaN.
		 */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
								<argument><expr><literal type="string">"numeric"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>apply_typmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_out() -
 *
 *	Output function for numeric data type
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the number in the variable format.
	 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>get_str_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_is_nan() -
 *
 *	Is Numeric value a NaN?
 */</comment>
<function><type><name>bool</name></type>
<name>numeric_is_nan</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_maximum_size() -
 *
 *	Maximum size of a numeric with given typmod, or -1 if unlimited/unknown.
 */</comment>
<function><type><name>int32</name></type>
<name>numeric_maximum_size</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>precision</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numeric_digits</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>VARHDRSZ</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* precision (ie, max # of digits) is in upper bits of typmod */</comment>
	<expr_stmt><expr><name>precision</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * This formula computes the maximum number of NumericDigits we could need
	 * in order to store the specified number of decimal digits. Because the
	 * weight is stored as a number of NumericDigits rather than a number of
	 * decimal digits, it's possible that the first NumericDigit will contain
	 * only a single decimal digit.  Thus, the first two decimal digits can
	 * require two NumericDigits to store, but it isn't until we reach
	 * DEC_DIGITS + 2 decimal digits that we potentially need a third
	 * NumericDigit.
	 */</comment>
	<expr_stmt><expr><name>numeric_digits</name> <operator>=</operator> <operator>(</operator><name>precision</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>DEC_DIGITS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * In most cases, the size of a numeric will be smaller than the value
	 * computed below, because the varlena header will typically get toasted
	 * down to a single byte before being stored on disk, and it may also be
	 * possible to use a short numeric header.  But our job here is to compute
	 * the worst case.
	 */</comment>
	<return>return <expr><name>NUMERIC_HDRSZ</name> <operator>+</operator> <operator>(</operator><name>numeric_digits</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_out_sci() -
 *
 *	Output function for numeric data type in scientific notation.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>numeric_out_sci</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>get_str_from_var_sci</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_normalize() -
 *
 *	Output function for numeric data type, suppressing insignificant trailing
 *	zeroes and then any trailing decimal point.  The intent of this is to
 *	produce strings that are equal if and only if the input numeric values
 *	compare equal.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>numeric_normalize</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>last</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>get_str_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If there's no decimal point, there's certainly nothing to remove. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Back up over trailing fractional zeroes.  Since there is a decimal
		 * point, this loop will terminate safely.
		 */</comment>
		<expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>str</name><index>[<expr><name>last</name></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>last</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/* We want to get rid of the decimal point too, if it's now last. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>last</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>last</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Delete whatever we backed up over. */</comment>
		<expr_stmt><expr><name><name>str</name><index>[<expr><name>last</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		numeric_recv			- converts external binary format to numeric
 *
 * External format is a sequence of int16's:
 * ndigits, weight, sign, dscale, NumericDigits.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>alloc_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>value</name><operator>.</operator><name>weight</name></name> <operator>=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we allow any int16 for weight --- OK? */</comment>

	<expr_stmt><expr><name><name>value</name><operator>.</operator><name>sign</name></name> <operator>=</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>value</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_POS</name> <operator>||</operator>
		  <name><name>value</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_NEG</name> <operator>||</operator>
		  <name><name>value</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_NAN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid sign in external \"numeric\" value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>value</name><operator>.</operator><name>dscale</name></name> <operator>=</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>value</name><operator>.</operator><name>dscale</name></name> <operator>&amp;</operator> <name>NUMERIC_DSCALE_MASK</name><operator>)</operator> <operator>!=</operator> <name><name>value</name><operator>.</operator><name>dscale</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid scale in external \"numeric\" value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NumericDigit</name></type> <name>d</name> <init>= <expr><call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>d</name> <operator>&gt;=</operator> <name>NBASE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid digit in external \"numeric\" value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>value</name><operator>.</operator><name>digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If the given dscale would hide any digits, truncate those digits away.
	 * We could alternatively throw an error, but that would take a bunch of
	 * extra code (about as much as trunc_var involves), and it might cause
	 * client compatibility issues.
	 */</comment>
	<expr_stmt><expr><call><name>trunc_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>apply_typmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		numeric_send			- converts numeric to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>ndigits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>weight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>x</name><operator>.</operator><name>ndigits</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_transform() -
 *
 * Flatten calls to numeric's length coercion function that solely represent
 * increases in allowable precision.  Scale changes mutate every datum, so
 * they are unoptimizable.  Some values, e.g. 1E-1001, can only fit into an
 * unconstrained numeric, so a change from an unconstrained numeric to any
 * constrained numeric is also unoptimizable.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_transform</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>typmod</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>typmod</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>source</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>old_typmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>new_typmod</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>typmod</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>old_scale</name> <init>= <expr><operator>(</operator><name>old_typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>new_scale</name> <init>= <expr><operator>(</operator><name>new_typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>old_precision</name> <init>= <expr><operator>(</operator><name>old_typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>new_precision</name> <init>= <expr><operator>(</operator><name>new_typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If new_typmod &lt; VARHDRSZ, the destination is unconstrained; that's
		 * always OK.  If old_typmod &gt;= VARHDRSZ, the source is constrained,
		 * and we're OK if the scale is unchanged and the precision is not
		 * decreasing.  See further notes in function header comment.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_typmod</name> <operator>&lt;</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>VARHDRSZ</name> <operator>||</operator>
			<operator>(</operator><name>old_typmod</name> <operator>&gt;=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>VARHDRSZ</name> <operator>&amp;&amp;</operator>
			 <name>new_scale</name> <operator>==</operator> <name>old_scale</name> <operator>&amp;&amp;</operator> <name>new_precision</name> <operator>&gt;=</operator> <name>old_precision</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>relabel_to_typmod</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>new_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * numeric() -
 *
 *	This is a special function called by the Postgres database system
 *	before a value is stored in a tuple's attribute. The precision and
 *	scale of the attribute have to be applied on the value.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric</name>		<parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>new</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tmp_typmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>precision</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>scale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ddigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxdigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>var</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the value isn't a valid type modifier, simply return a copy of the
	 * input value
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>VARHDRSZ</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>new</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the precision and scale out of the typmod value
	 */</comment>
	<expr_stmt><expr><name>tmp_typmod</name> <operator>=</operator> <name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>precision</name> <operator>=</operator> <operator>(</operator><name>tmp_typmod</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>scale</name> <operator>=</operator> <name>tmp_typmod</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxdigits</name> <operator>=</operator> <name>precision</name> <operator>-</operator> <name>scale</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the number is certainly in bounds and due to the target scale no
	 * rounding could be necessary, just make a copy of the input and modify
	 * its scale fields, unless the larger scale forces us to abandon the
	 * short representation.  (Note we assume the existing dscale is
	 * honest...)
	 */</comment>
	<expr_stmt><expr><name>ddigits</name> <operator>=</operator> <operator>(</operator><call><name>NUMERIC_WEIGHT</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ddigits</name> <operator>&lt;=</operator> <name>maxdigits</name> <operator>&amp;&amp;</operator> <name>scale</name> <operator>&gt;=</operator> <call><name>NUMERIC_DSCALE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call>
		<operator>&amp;&amp;</operator> <operator>(</operator><call><name>NUMERIC_CAN_BE_SHORT</name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><call><name>NUMERIC_WEIGHT</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
			<operator>||</operator> <operator>!</operator><call><name>NUMERIC_IS_SHORT</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>new</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_SHORT</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_short</name><operator>.</operator><name>n_header</name></name> <operator>=</operator>
				<operator>(</operator><name><name>num</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_short</name><operator>.</operator><name>n_header</name></name> <operator>&amp;</operator> <operator>~</operator><name>NUMERIC_SHORT_DSCALE_MASK</name><operator>)</operator>
				<operator>|</operator> <operator>(</operator><name>scale</name> <operator>&lt;&lt;</operator> <name>NUMERIC_SHORT_DSCALE_SHIFT</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_long</name><operator>.</operator><name>n_sign_dscale</name></name> <operator>=</operator> <call><name>NUMERIC_SIGN</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call> <operator>|</operator>
				<operator>(</operator><operator>(</operator><name>uint16</name><operator>)</operator> <name>scale</name> <operator>&amp;</operator> <name>NUMERIC_DSCALE_MASK</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We really need to fiddle with things - unpack the number into a
	 * variable and let apply_typmod() do it.
	 */</comment>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>apply_typmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>var</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numerictypmodin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ta</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>ArrayGetIntegerTypmods</name><argument_list>(<argument><expr><name>ta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name>NUMERIC_MAX_PRECISION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NUMERIC precision %d must be between 1 and %d"</literal></expr></argument>,
							<argument><expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NUMERIC_MAX_PRECISION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NUMERIC scale %d must be between 0 and precision %d"</literal></expr></argument>,
							<argument><expr><name><name>tl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name><name>tl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name>NUMERIC_MAX_PRECISION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NUMERIC precision %d must be between 1 and %d"</literal></expr></argument>,
							<argument><expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NUMERIC_MAX_PRECISION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* scale defaults to zero */</comment>
		<expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>(</operator><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid NUMERIC type modifier"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typmod</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numerictypmodout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"(%d,%d)"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><operator>(</operator><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------------
 *
 * Sign manipulation, rounding and the like
 *
 * ----------------------------------------------------------------------
 */</comment>

<function><type><name>Datum</name></type>
<name>numeric_abs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do it the easy way directly on the packed format
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_SHORT</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_short</name><operator>.</operator><name>n_header</name></name> <operator>=</operator>
			<name><name>num</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_short</name><operator>.</operator><name>n_header</name></name> <operator>&amp;</operator> <operator>~</operator><name>NUMERIC_SHORT_SIGN_MASK</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_long</name><operator>.</operator><name>n_sign_dscale</name></name> <operator>=</operator> <name>NUMERIC_POS</name> <operator>|</operator> <call><name>NUMERIC_DSCALE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>numeric_uminus</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do it the easy way directly on the packed format
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The packed format is known to be totally zero digit trimmed always. So
	 * we can identify a ZERO by the fact that there are no digits at all.  Do
	 * nothing to a zero.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Else, flip the sign */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_SHORT</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_short</name><operator>.</operator><name>n_header</name></name> <operator>=</operator>
				<name><name>num</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_short</name><operator>.</operator><name>n_header</name></name> <operator>^</operator> <name>NUMERIC_SHORT_SIGN_MASK</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>NUMERIC_SIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NUMERIC_POS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_long</name><operator>.</operator><name>n_sign_dscale</name></name> <operator>=</operator>
				<name>NUMERIC_NEG</name> <operator>|</operator> <call><name>NUMERIC_DSCALE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_long</name><operator>.</operator><name>n_sign_dscale</name></name> <operator>=</operator>
				<name>NUMERIC_POS</name> <operator>|</operator> <call><name>NUMERIC_DSCALE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>numeric_uplus</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_sign() -
 *
 * returns -1 if the argument is less than 0, 0 if the argument is equal
 * to 0, and 1 if the argument is greater than zero.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_sign</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The packed format is known to be totally zero digit trimmed always. So
	 * we can identify a ZERO by the fact that there are no digits at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * And if there are some, we return a copy of ONE with the sign of our
		 * argument
		 */</comment>
		<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>sign</name></name> <operator>=</operator> <call><name>NUMERIC_SIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_round() -
 *
 *	Round a value to have 'scale' digits after the decimal point.
 *	We allow negative 'scale', implying rounding before the decimal
 *	point --- Oracle interprets rounding that way.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_round</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>scale</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Limit the scale value to avoid possible overflow in calculations
	 */</comment>
	<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><operator>-</operator><name>NUMERIC_MAX_RESULT_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><name>NUMERIC_MAX_RESULT_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unpack the argument and round it at the proper digit position
	 */</comment>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>round_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We don't allow negative output dscale */</comment>
	<if_stmt><if>if <condition>(<expr><name>scale</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>dscale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Return the rounded result
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_trunc() -
 *
 *	Truncate a value to have 'scale' digits after the decimal point.
 *	We allow negative 'scale', implying a truncation before the decimal
 *	point --- Oracle interprets truncation that way.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_trunc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>scale</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Limit the scale value to avoid possible overflow in calculations
	 */</comment>
	<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><operator>-</operator><name>NUMERIC_MAX_RESULT_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><name>NUMERIC_MAX_RESULT_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unpack the argument and truncate it at the proper digit position
	 */</comment>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>trunc_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We don't allow negative output dscale */</comment>
	<if_stmt><if>if <condition>(<expr><name>scale</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>dscale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Return the truncated result
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_ceil() -
 *
 *	Return the smallest integer greater than or equal to the argument
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_ceil</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ceil_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_floor() -
 *
 *	Return the largest integer equal to or less than the argument
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_floor</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>floor_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * generate_series_numeric() -
 *
 *	Generate series of numeric.
 */</comment>
<function><type><name>Datum</name></type>
<name>generate_series_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>generate_series_step_numeric</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>generate_series_step_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>generate_series_numeric_fctx</name> <modifier>*</modifier></type><name>fctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>start_num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>stop_num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>steploc</name> <init>= <expr><name>const_one</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* handle NaN in start and stop values */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>start_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"start value cannot be NaN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>stop_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"stop value cannot be NaN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* see if we were given an explicit step size */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Numeric</name></type>		<name>step_num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>step_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"step size cannot be NaN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>step_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>steploc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>steploc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"step size cannot equal zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Switch to memory context appropriate for multiple function calls.
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* allocate memory for user context */</comment>
		<expr_stmt><expr><name>fctx</name> <operator>=</operator> <operator>(</operator><name>generate_series_numeric_fctx</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>generate_series_numeric_fctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Use fctx to keep state from call to call. Seed current with the
		 * original start value. We must copy the start_num and stop_num
		 * values rather than pointing to them, since we may have detoasted
		 * them in the per-call context.
		 */</comment>
		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>step</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>set_var_from_num</name><argument_list>(<argument><expr><name>start_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_var_from_num</name><argument_list>(<argument><expr><name>stop_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>steploc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>step</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>fctx</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the saved state and use current state as the result of this
	 * iteration.
	 */</comment>
	<expr_stmt><expr><name>fctx</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fctx</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_POS</name> <operator>&amp;&amp;</operator>
		 <call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name><name>fctx</name><operator>-&gt;</operator><name>step</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_NEG</name> <operator>&amp;&amp;</operator>
		 <call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>stop</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>result</name> <init>= <expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* switch to memory context appropriate for iteration calculation */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* increment current in preparation for next iteration */</comment>
		<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>step</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* do when there is more left to send */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* do when there is no more left */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Implements the numeric version of the width_bucket() function
 * defined by SQL2003. See also width_bucket_float8().
 *
 * 'bound1' and 'bound2' are the lower and upper bounds of the
 * histogram's range, respectively. 'count' is the number of buckets
 * in the histogram. width_bucket() returns an integer indicating the
 * bucket number that 'operand' belongs to in an equiwidth histogram
 * with the specified characteristics. An operand smaller than the
 * lower bound is assigned to bucket 0. An operand greater than the
 * upper bound is assigned to an additional bucket (with number
 * count+1). We don't allow "NaN" for any of the numeric arguments.
 */</comment>
<function><type><name>Datum</name></type>
<name>width_bucket_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>operand</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>bound1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>bound2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>count</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>count_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"count must be greater than zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>operand</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>bound1</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>bound2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operand, lower bound, and upper bound cannot be NaN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>count_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert 'count' to a numeric, for ease of use later */</comment>
	<expr_stmt><expr><call><name>int64_to_numericvar</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>cmp_numerics</name><argument_list>(<argument><expr><name>bound1</name></expr></argument>, <argument><expr><name>bound2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lower bound cannot equal upper bound"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* bound1 &lt; bound2 */</comment>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>cmp_numerics</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>bound1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>cmp_numerics</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>bound2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>count_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>compute_bucket</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>bound1</name></expr></argument>, <argument><expr><name>bound2</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>count_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

			<comment type="block">/* bound1 &gt; bound2 */</comment>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>cmp_numerics</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>bound1</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>cmp_numerics</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>bound2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>count_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>compute_bucket</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>bound1</name></expr></argument>, <argument><expr><name>bound2</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>count_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* if result exceeds the range of a legal int4, we ereport here */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>numericvar_to_int32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>count_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If 'operand' is not outside the bucket range, determine the correct
 * bucket for it to go. The calculations performed by this function
 * are derived directly from the SQL2003 spec.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_bucket</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>operand</name></decl></parameter>, <parameter><decl><type><name>Numeric</name></type> <name>bound1</name></decl></parameter>, <parameter><decl><type><name>Numeric</name></type> <name>bound2</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>count_var</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result_var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>bound1_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>bound2_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>operand_var</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>bound1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound1_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>bound2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound2_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>operand_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bound1_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound2_var</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>operand_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound1_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>operand_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bound2_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound1_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound2_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>div_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>operand_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound2_var</name></expr></argument>, <argument><expr><name>result_var</name></expr></argument>,
				<argument><expr><call><name>select_div_scale</name><argument_list>(<argument><expr><operator>&amp;</operator><name>operand_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound2_var</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bound1_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>operand_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>operand_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bound1_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound2_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound1_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>div_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>operand_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound1_var</name></expr></argument>, <argument><expr><name>result_var</name></expr></argument>,
				<argument><expr><call><name>select_div_scale</name><argument_list>(<argument><expr><operator>&amp;</operator><name>operand_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound1_var</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><name>result_var</name></expr></argument>, <argument><expr><name>count_var</name></expr></argument>, <argument><expr><name>result_var</name></expr></argument>,
			<argument><expr><name><name>result_var</name><operator>-&gt;</operator><name>dscale</name></name> <operator>+</operator> <name><name>count_var</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><name>result_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><name>result_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>floor_var</name><argument_list>(<argument><expr><name>result_var</name></expr></argument>, <argument><expr><name>result_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bound1_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bound2_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>operand_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------
 *
 * Comparison functions
 *
 * Note: btree indexes need these routines not to leak memory; therefore,
 * be careful to free working copies of toasted datums.  Most places don't
 * need to be so careful.
 *
 * Sort support:
 *
 * We implement the sortsupport strategy routine in order to get the benefit of
 * abbreviation. The ordinary numeric comparison can be quite slow as a result
 * of palloc/pfree cycles (due to detoasting packed values for alignment);
 * while this could be worked on itself, the abbreviation strategy gives more
 * speedup in many common cases.
 *
 * Two different representations are used for the abbreviated form, one in
 * int32 and one in int64, whichever fits into a by-value Datum.  In both cases
 * the representation is negated relative to the original value, because we use
 * the largest negative value for NaN, which sorts higher than other values. We
 * convert the absolute value of the numeric to a 31-bit or 63-bit positive
 * value, and then negate it if the original number was positive.
 *
 * We abort the abbreviation process if the abbreviation cardinality is below
 * 0.01% of the row count (1 per 10k non-null rows).  The actual break-even
 * point is somewhat below that, perhaps 1 per 30k (at 1 per 100k there's a
 * very small penalty), but we don't want to build up too many abbreviated
 * values before first testing for abort, so we take the slightly pessimistic
 * number.  We make no attempt to estimate the cardinality of the real values,
 * since it plays no part in the cost model here (if the abbreviation is equal,
 * the cost of comparing equal and unequal underlying values is comparable).
 * We discontinue even checking for abort (saving us the hashing overhead) if
 * the estimated cardinality gets to 100k; that would be enough to support many
 * billions of rows while doing no worse than breaking even.
 *
 * ----------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Sort support strategy routine.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_sortsupport</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name> <init>= <expr><operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>numeric_fast_cmp</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ssup</name><operator>-&gt;</operator><name>abbreviate</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NumericSortSupport</name> <modifier>*</modifier></type><name>nss</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_cxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>nss</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NumericSortSupport</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * palloc a buffer for handling unaligned packed values in addition to
		 * the support struct
		 */</comment>
		<expr_stmt><expr><name><name>nss</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARATT_SHORT_MAX</name> <operator>+</operator> <name>VARHDRSZ</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>nss</name><operator>-&gt;</operator><name>input_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nss</name><operator>-&gt;</operator><name>estimating</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nss</name><operator>-&gt;</operator><name>abbr_card</name></name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_extra</name></name> <operator>=</operator> <name>nss</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>abbrev_full_comparator</name></name> <operator>=</operator> <name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>numeric_cmp_abbrev</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>=</operator> <name>numeric_abbrev_convert</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>abbrev_abort</name></name> <operator>=</operator> <name>numeric_abbrev_abort</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Abbreviate a numeric datum, handling NaNs and detoasting
 * (must not leak memory!)
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>numeric_abbrev_convert</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>original_datum</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericSortSupport</name> <modifier>*</modifier></type><name>nss</name> <init>= <expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_extra</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>original_varatt</name> <init>= <expr><call><name>PG_DETOAST_DATUM_PACKED</name><argument_list>(<argument><expr><name>original_datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>nss</name><operator>-&gt;</operator><name>input_count</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is to handle packed datums without needing a palloc/pfree cycle;
	 * we keep and reuse a buffer large enough to handle any short datum.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_SHORT</name><argument_list>(<argument><expr><name>original_varatt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name><name>nss</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name> <init>= <expr><call><name>VARSIZE_SHORT</name><argument_list>(<argument><expr><name>original_varatt</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sz</name> <operator>&lt;=</operator> <name>VARATT_SHORT_MAX</name> <operator>-</operator> <name>VARHDRSZ_SHORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_SHORT</name><argument_list>(<argument><expr><name>original_varatt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <name>original_varatt</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NUMERIC_ABBREV_NAN</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>var</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>numeric_abbrev_convert_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>var</name></expr></argument>, <argument><expr><name>nss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* should happen only for external/compressed toasts */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>original_varatt</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>original_datum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>original_varatt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Consider whether to abort abbreviation.
 *
 * We pay no attention to the cardinality of the non-abbreviated data. There is
 * no reason to do so: unlike text, we have no fast check for equal values, so
 * we pay the full overhead whenever the abbreviations are equal regardless of
 * whether the underlying values are also equal.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>numeric_abbrev_abort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>memtupcount</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericSortSupport</name> <modifier>*</modifier></type><name>nss</name> <init>= <expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_extra</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>abbr_card</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>memtupcount</name> <operator>&lt;</operator> <literal type="number">10000</literal> <operator>||</operator> <name><name>nss</name><operator>-&gt;</operator><name>input_count</name></name> <operator>&lt;</operator> <literal type="number">10000</literal> <operator>||</operator> <operator>!</operator><name><name>nss</name><operator>-&gt;</operator><name>estimating</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>abbr_card</name> <operator>=</operator> <call><name>estimateHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nss</name><operator>-&gt;</operator><name>abbr_card</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have &gt;100k distinct values, then even if we were sorting many
	 * billion rows we'd likely still break even, and the penalty of undoing
	 * that many rows of abbrevs would probably not be worth it. Stop even
	 * counting at that point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>abbr_card</name> <operator>&gt;</operator> <literal type="number">100000.0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				 <argument><expr><literal type="string">"numeric_abbrev: estimation ends at cardinality %f"</literal>
				 <literal type="string">" after "</literal> <name>INT64_FORMAT</name> <literal type="string">" values (%d rows)"</literal></expr></argument>,
				 <argument><expr><name>abbr_card</name></expr></argument>, <argument><expr><name><name>nss</name><operator>-&gt;</operator><name>input_count</name></name></expr></argument>, <argument><expr><name>memtupcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>nss</name><operator>-&gt;</operator><name>estimating</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Target minimum cardinality is 1 per ~10k of non-null inputs.  (The
	 * break even point is somewhere between one per 100k rows, where
	 * abbreviation has a very slight penalty, and 1 per 10k where it wins by
	 * a measurable percentage.)  We use the relatively pessimistic 10k
	 * threshold, and add a 0.5 row fudge factor, because it allows us to
	 * abort earlier on genuinely pathological data where we've had exactly
	 * one abbreviated value in the first 10k (non-null) rows.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>abbr_card</name> <operator>&lt;</operator> <name><name>nss</name><operator>-&gt;</operator><name>input_count</name></name> <operator>/</operator> <literal type="number">10000.0</literal> <operator>+</operator> <literal type="number">0.5</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				 <argument><expr><literal type="string">"numeric_abbrev: aborting abbreviation at cardinality %f"</literal>
				 <literal type="string">" below threshold %f after "</literal> <name>INT64_FORMAT</name> <literal type="string">" values (%d rows)"</literal></expr></argument>,
				 <argument><expr><name>abbr_card</name></expr></argument>, <argument><expr><name><name>nss</name><operator>-&gt;</operator><name>input_count</name></name> <operator>/</operator> <literal type="number">10000.0</literal> <operator>+</operator> <literal type="number">0.5</literal></expr></argument>,
				 <argument><expr><name><name>nss</name><operator>-&gt;</operator><name>input_count</name></name></expr></argument>, <argument><expr><name>memtupcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			 <argument><expr><literal type="string">"numeric_abbrev: cardinality %f"</literal>
			 <literal type="string">" after "</literal> <name>INT64_FORMAT</name> <literal type="string">" values (%d rows)"</literal></expr></argument>,
			 <argument><expr><name>abbr_card</name></expr></argument>, <argument><expr><name><name>nss</name><operator>-&gt;</operator><name>input_count</name></name></expr></argument>, <argument><expr><name>memtupcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Non-fmgr interface to the comparison routine to allow sortsupport to elide
 * the fmgr call.  The saving here is small given how slow numeric comparisons
 * are, but it is a required part of the sort support API when abbreviations
 * are performed.
 *
 * Two palloc/pfree cycles could be saved here by using persistent buffers for
 * aligning short-varlena inputs, but this has not so far been considered to
 * be worth the effort.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>numeric_fast_cmp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>nx</name> <init>= <expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>ny</name> <init>= <expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cmp_numerics</name><argument_list>(<argument><expr><name>nx</name></expr></argument>, <argument><expr><name>ny</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>nx</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>ny</name> <operator>!=</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ny</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare abbreviations of values. (Abbreviations may be equal where the true
 * values differ, but if the abbreviations differ, they must reflect the
 * ordering of the true values.)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>numeric_cmp_abbrev</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * NOTE WELL: this is intentionally backwards, because the abbreviation is
	 * negated relative to the original value, to handle NaN.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DatumGetNumericAbbrev</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>DatumGetNumericAbbrev</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>DatumGetNumericAbbrev</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>DatumGetNumericAbbrev</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Abbreviate a NumericVar according to the available bit size.
 *
 * The 31-bit value is constructed as:
 *
 *	0 + 7bits digit weight + 24 bits digit value
 *
 * where the digit weight is in single decimal digits, not digit words, and
 * stored in excess-44 representation[1]. The 24-bit digit value is the 7 most
 * significant decimal digits of the value converted to binary. Values whose
 * weights would fall outside the representable range are rounded off to zero
 * (which is also used to represent actual zeros) or to 0x7FFFFFFF (which
 * otherwise cannot occur). Abbreviation therefore fails to gain any advantage
 * where values are outside the range 10^-44 to 10^83, which is not considered
 * to be a serious limitation, or when values are of the same magnitude and
 * equal in the first 7 decimal digits, which is considered to be an
 * unavoidable limitation given the available bits. (Stealing three more bits
 * to compare another digit would narrow the range of representable weights by
 * a factor of 8, which starts to look like a real limiting factor.)
 *
 * (The value 44 for the excess is essentially arbitrary)
 *
 * The 63-bit value is constructed as:
 *
 *	0 + 7bits weight + 4 x 14-bit packed digit words
 *
 * The weight in this case is again stored in excess-44, but this time it is
 * the original weight in digit words (i.e. powers of 10000). The first four
 * digit words of the value (if present; trailing zeros are assumed as needed)
 * are packed into 14 bits each to form the rest of the value. Again,
 * out-of-range values are rounded off to 0 or 0x7FFFFFFFFFFFFFFF. The
 * representable range in this case is 10^-176 to 10^332, which is considered
 * to be good enough for all practical purposes, and comparison of 4 words
 * means that at least 13 decimal digits are compared, which is considered to
 * be a reasonable compromise between effectiveness and efficiency in computing
 * the abbreviation.
 *
 * (The value 44 for the excess is even more arbitrary here, it was chosen just
 * to match the value used in the 31-bit case)
 *
 * [1] - Excess-k representation means that the value is offset by adding 'k'
 * and then treated as unsigned, so the smallest representable value is stored
 * with all bits zero. This allows simple comparisons to work on the composite
 * value.
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NUMERIC_ABBREV_BITS</name> <operator>==</operator> <literal type="number">64</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>numeric_abbrev_convert_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>NumericSortSupport</name> <modifier>*</modifier></type><name>nss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndigits</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>weight</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">44</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>weight</name> <operator>&gt;</operator> <literal type="number">83</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>PG_INT64_MAX</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><name>weight</name> <operator>+</operator> <literal type="number">44</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">56</literal><operator>)</operator></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>ndigits</name></expr>)</condition>
		<block>{<block_content>
			<default>default:</default>
				<expr_stmt><expr><name>result</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
				<comment type="block">/* FALLTHROUGH */</comment>
			<case>case <expr><literal type="number">3</literal></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr>;</expr_stmt>
				<comment type="block">/* FALLTHROUGH */</comment>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">28</literal></expr>;</expr_stmt>
				<comment type="block">/* FALLTHROUGH */</comment>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">42</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* the abbrev is negated relative to the original */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_POS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>result</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nss</name><operator>-&gt;</operator><name>estimating</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>tmp</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint32</name><operator>)</operator> <name>result</name>
						   <operator>^</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>result</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>addHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nss</name><operator>-&gt;</operator><name>abbr_card</name></name></expr></argument>, <argument><expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>NumericAbbrevGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* NUMERIC_ABBREV_BITS == 64 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NUMERIC_ABBREV_BITS</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>numeric_abbrev_convert_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>NumericSortSupport</name> <modifier>*</modifier></type><name>nss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndigits</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>weight</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">11</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>weight</name> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>PG_INT32_MAX</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>NumericDigit</name></type> <name>nxt1</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>ndigits</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>weight</name> <operator>=</operator> <operator>(</operator><name>weight</name> <operator>+</operator> <literal type="number">11</literal><operator>)</operator> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * "result" now has 1 to 4 nonzero decimal digits. We pack in more
		 * digits to make 7 in total (largest we can fit in 24 bits)
		 */</comment>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;</operator> <literal type="number">999</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* already have 4 digits, add 3 more */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>nxt1</name> <operator>/</operator> <literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>weight</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>result</name> <operator>&gt;</operator> <literal type="number">99</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* already have 3 digits, add 4 more */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>*</operator> <literal type="number">10000</literal><operator>)</operator> <operator>+</operator> <name>nxt1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>weight</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>result</name> <operator>&gt;</operator> <literal type="number">9</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NumericDigit</name></type> <name>nxt2</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>ndigits</name> <operator>&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<comment type="block">/* already have 2 digits, add 5 more */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>*</operator> <literal type="number">100000</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>nxt1</name> <operator>*</operator> <literal type="number">10</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>nxt2</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>weight</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>NumericDigit</name></type> <name>nxt2</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>ndigits</name> <operator>&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<comment type="block">/* already have 1 digit, add 6 more */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>*</operator> <literal type="number">1000000</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>nxt1</name> <operator>*</operator> <literal type="number">100</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>nxt2</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>result</name> <operator>|</operator> <operator>(</operator><name>weight</name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* the abbrev is negated relative to the original */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_POS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>result</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>nss</name><operator>-&gt;</operator><name>estimating</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>tmp</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>result</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>addHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nss</name><operator>-&gt;</operator><name>abbr_card</name></name></expr></argument>, <argument><expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>NumericAbbrevGetDatum</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* NUMERIC_ABBREV_BITS == 32 */</comment>

<comment type="block">/*
 * Ordinary (non-sortsupport) comparisons follow.
 */</comment>

<function><type><name>Datum</name></type>
<name>numeric_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cmp_numerics</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>numeric_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cmp_numerics</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cmp_numerics</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cmp_numerics</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cmp_numerics</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cmp_numerics</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cmp_numerics</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_numerics</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>num1</name></decl></parameter>, <parameter><decl><type><name>Numeric</name></type> <name>num2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We consider all NANs to be equal and larger than any non-NAN. This is
	 * somewhat arbitrary; the important thing is to have a consistent sort
	 * order.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>			<comment type="block">/* NAN = NAN */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>			<comment type="block">/* NAN &gt; non-NAN */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>			<comment type="block">/* non-NAN &lt; NAN */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cmp_var_common</name><argument_list>(<argument><expr><call><name>NUMERIC_DIGITS</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NUMERIC_WEIGHT</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NUMERIC_SIGN</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NUMERIC_DIGITS</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>NUMERIC_WEIGHT</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NUMERIC_SIGN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * in_range support function for numeric.
 */</comment>
<function><type><name>Datum</name></type>
<name>in_range_numeric_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>base</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>offset</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sub</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>less</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reject negative or NaN offset.  Negative is per spec, and NaN is
	 * because appropriate semantics for that seem non-obvious.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NUMERIC_SIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NUMERIC_NEG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid preceding or following size in window function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Deal with cases where val and/or base is NaN, following the rule that
	 * NaN sorts after non-NaN (cf cmp_numerics).  The offset cannot affect
	 * the conclusion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* NAN = NAN */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>!</operator><name>less</name></expr>;</expr_stmt></block_content></block></else></if_stmt>		<comment type="block">/* NAN &gt; non-NAN */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>less</name></expr>;</expr_stmt>			<comment type="block">/* non-NAN &lt; NAN */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Otherwise go ahead and compute base +/- offset.  While it's
		 * possible for this to overflow the numeric format, it's unlikely
		 * enough that we don't take measures to prevent it.
		 */</comment>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>valv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>basev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>offsetv</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>sum</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>basev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offsetv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>basev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offsetv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>basev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offsetv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>less</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>valv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>valv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>hash_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>digit_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>start_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>end_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hash_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>digits</name></decl>;</decl_stmt>

	<comment type="block">/* If it's NaN, don't try to hash the rest of the fields */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_UINT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>weight</name> <operator>=</operator> <call><name>NUMERIC_WEIGHT</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Omit any leading or trailing zeros from the input to the hash. The
	 * numeric implementation *should* guarantee that leading and trailing
	 * zeros are suppressed, but we're paranoid. Note that we measure the
	 * starting and ending offsets in units of NumericDigits, not bytes.
	 */</comment>
	<expr_stmt><expr><name>digits</name> <operator>=</operator> <call><name>NUMERIC_DIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <operator>(</operator><name>NumericDigit</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>start_offset</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * The weight is effectively the # of digits before the decimal point,
		 * so decrement it for each leading zero we skip.
		 */</comment>
		<expr_stmt><expr><name>weight</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If there are no non-zero digits, then the value of the number is zero,
	 * regardless of any other fields.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>start_offset</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_UINT32</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <operator>(</operator><name>NumericDigit</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>end_offset</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If we get here, there should be at least one non-zero digit */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start_offset</name> <operator>+</operator> <name>end_offset</name> <operator>&lt;</operator> <call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that we don't hash on the Numeric's scale, since two numerics can
	 * compare equal but have different scales. We also don't hash on the
	 * sign, although we could: since a sign difference implies inequality,
	 * this shouldn't affect correctness.
	 */</comment>
	<expr_stmt><expr><name>hash_len</name> <operator>=</operator> <call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>start_offset</name> <operator>-</operator> <name>end_offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>digit_hash</name> <operator>=</operator> <call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><call><name>NUMERIC_DIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>start_offset</name><operator>)</operator></expr></argument>,
						  <argument><expr><name>hash_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mix in the weight, via XOR */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>digit_hash</name> <operator>^</operator> <name>weight</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns 64-bit value by hashing a value to a 64-bit value, with a seed.
 * Otherwise, similar to hash_numeric.
 */</comment>
<function><type><name>Datum</name></type>
<name>hash_numeric_extended</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>key</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>seed</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>digit_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>start_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>end_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hash_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>digits</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_UINT64</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>weight</name> <operator>=</operator> <call><name>NUMERIC_WEIGHT</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>digits</name> <operator>=</operator> <call><name>NUMERIC_DIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <operator>(</operator><name>NumericDigit</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>start_offset</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>weight</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>start_offset</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_UINT64</name><argument_list>(<argument><expr><name>seed</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <operator>(</operator><name>NumericDigit</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>end_offset</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start_offset</name> <operator>+</operator> <name>end_offset</name> <operator>&lt;</operator> <call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hash_len</name> <operator>=</operator> <call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>start_offset</name> <operator>-</operator> <name>end_offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>digit_hash</name> <operator>=</operator> <call><name>hash_any_extended</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><call><name>NUMERIC_DIGITS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call>
													  <operator>+</operator> <name>start_offset</name><operator>)</operator></expr></argument>,
								   <argument><expr><name>hash_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								   <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>digit_hash</name></expr></argument>)</argument_list></call> <operator>^</operator> <name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------------
 *
 * Basic arithmetic functions
 *
 * ----------------------------------------------------------------------
 */</comment>


<comment type="block">/*
 * numeric_add() -
 *
 *	Add two numerics
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_add</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unpack the values, let add_var() compute the result and return it.
	 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_sub() -
 *
 *	Subtract one numeric from another
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_sub</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unpack the values, let sub_var() compute the result and return it.
	 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_mul() -
 *
 *	Calculate the product of two numerics
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_mul</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unpack the values, let mul_var() compute the result and return it.
	 * Unlike add_var() and sub_var(), mul_var() will round its result. In the
	 * case of numeric_mul(), which is invoked for the * operator on numerics,
	 * we request exact representation for the product (rscale = sum(dscale of
	 * arg1, dscale of arg2)).
	 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name><name>arg1</name><operator>.</operator><name>dscale</name></name> <operator>+</operator> <name><name>arg2</name><operator>.</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_div() -
 *
 *	Divide one numeric into another
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rscale</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unpack the arguments
	 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Select scale for division result
	 */</comment>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>select_div_scale</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the divide and return the result
	 */</comment>
	<expr_stmt><expr><call><name>div_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_div_trunc() -
 *
 *	Divide one numeric into another, truncating the result to an integer
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_div_trunc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unpack the arguments
	 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the divide and return the result
	 */</comment>
	<expr_stmt><expr><call><name>div_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_mod() -
 *
 *	Calculate the modulo of two numerics
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_mod</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mod_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_inc() -
 *
 *	Increment a number by one
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_inc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute the result and return it
	 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_smaller() -
 *
 *	Return the smaller of two numbers
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_smaller</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use cmp_numerics so that this will agree with the comparison operators,
	 * particularly as regards comparisons involving NaN.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>cmp_numerics</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_larger() -
 *
 *	Return the larger of two numbers
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_larger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use cmp_numerics so that this will agree with the comparison operators,
	 * particularly as regards comparisons involving NaN.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>cmp_numerics</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------------
 *
 * Advanced math functions
 *
 * ----------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * numeric_fac()
 *
 * Compute factorial
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_fac</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>fact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Fail immediately if the result would overflow */</comment>
	<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <literal type="number">32177</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value overflows numeric format"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>int64_to_numericvar</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>num</name> <operator>=</operator> <name>num</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>num</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>num</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* this loop can take awhile, so allow it to be interrupted */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>int64_to_numericvar</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_sqrt() -
 *
 *	Compute the square root of a numeric.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_sqrt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sweight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rscale</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unpack the argument and determine the result scale.  We choose a scale
	 * to give at least NUMERIC_MIN_SIG_DIGITS significant digits; but in any
	 * case not less than the input's dscale.
	 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assume the input was normalized, so arg.weight is accurate */</comment>
	<expr_stmt><expr><name>sweight</name> <operator>=</operator> <operator>(</operator><name><name>arg</name><operator>.</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>DEC_DIGITS</name> <operator>/</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <name>NUMERIC_MIN_SIG_DIGITS</name> <operator>-</operator> <name>sweight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MAX_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let sqrt_var() do the calculation and return the result.
	 */</comment>
	<expr_stmt><expr><call><name>sqrt_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_exp() -
 *
 *	Raise e to the power of x
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_exp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unpack the argument and determine the result scale.  We choose a scale
	 * to give at least NUMERIC_MIN_SIG_DIGITS significant digits; but in any
	 * case not less than the input's dscale.
	 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* convert input to float8, ignoring overflow */</comment>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>numericvar_to_double_no_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * log10(result) = num * log10(e), so this is approximately the decimal
	 * weight of the result:
	 */</comment>
	<expr_stmt><expr><name>val</name> <operator>*=</operator> <literal type="number">0.434294481903252</literal></expr>;</expr_stmt>

	<comment type="block">/* limit to something that won't cause integer overflow */</comment>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>-</operator><name>NUMERIC_MAX_RESULT_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>NUMERIC_MAX_RESULT_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <name>NUMERIC_MIN_SIG_DIGITS</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>val</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MAX_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let exp_var() do the calculation and return the result.
	 */</comment>
	<expr_stmt><expr><call><name>exp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_ln() -
 *
 *	Compute the natural logarithm of x
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_ln</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ln_dweight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rscale</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimated dweight of logarithm */</comment>
	<expr_stmt><expr><name>ln_dweight</name> <operator>=</operator> <call><name>estimate_ln_dweight</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <name>NUMERIC_MIN_SIG_DIGITS</name> <operator>-</operator> <name>ln_dweight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MAX_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ln_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_log() -
 *
 *	Compute the logarithm of x in a given base
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_log</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initialize things
	 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call log_var() to compute and return the result; note it handles scale
	 * selection itself.
	 */</comment>
	<expr_stmt><expr><call><name>log_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_power() -
 *
 *	Raise b to the power of x
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_power</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num1</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num2</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>arg2_trunc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Handle NaN cases.  We follow the POSIX spec for pow(3), which says that
	 * NaN ^ 0 = 1, and 1 ^ NaN = 1, while all other cases with NaN inputs
	 * yield NaN (with no error).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize things
	 */</comment>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg2_trunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2_trunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>trunc_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg2_trunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The SQL spec requires that we emit a particular SQLSTATE error code for
	 * certain error conditions.  Specifically, we don't return a
	 * divide-by-zero error code for 0 ^ -1.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"zero raised to a negative power is undefined"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2_trunc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a negative number raised to a non-integer power yields a complex result"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Call power_var() to compute and return the result; note it handles
	 * scale selection itself.
	 */</comment>
	<expr_stmt><expr><call><name>power_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg2_trunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_scale() -
 *
 *	Returns the scale, i.e. the count of decimal digits in the fractional part
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_scale</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>NUMERIC_DSCALE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/* ----------------------------------------------------------------------
 *
 * Type conversion functions
 *
 * ----------------------------------------------------------------------
 */</comment>


<function><type><name>Datum</name></type>
<name>int4_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>int64_to_numericvar</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>numeric_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* XXX would it be better to return NULL? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert NaN to integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert to variable format, then convert to int4 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>numericvar_to_int32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a NumericVar, convert it to an int32. If the NumericVar
 * exceeds the range of an int32, raise the appropriate error via
 * ereport(). The input NumericVar is *not* free'd.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>numericvar_to_int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>val</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>numericvar_to_int64</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Down-convert to int4 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>val</name></expr>;</expr_stmt>

	<comment type="block">/* Test for overflow by reverse-conversion. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int64</name><operator>)</operator> <name>result</name> <operator>!=</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int8_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>int64_to_numericvar</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>numeric_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* XXX would it be better to return NULL? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert NaN to bigint"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert to variable format and thence to int8 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>numericvar_to_int64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bigint out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>int2_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>int64_to_numericvar</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>numeric_int2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* XXX would it be better to return NULL? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert NaN to smallint"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert to variable format and thence to int8 */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>numericvar_to_int64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"smallint out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Down-convert to int2 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <name>val</name></expr>;</expr_stmt>

	<comment type="block">/* Test for overflow by reverse-conversion. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int64</name><operator>)</operator> <name>result</name> <operator>!=</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"smallint out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>float8_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>DBL_DIG</name> <operator>+</operator> <literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert infinity to numeric"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%.*g"</literal></expr></argument>, <argument><expr><name>DBL_DIG</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assume we need not worry about leading/trailing spaces */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_var_from_str</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>numeric_float8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_out</name></expr></argument>,
											  <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8in</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Convert numeric to float8; if out of range, return +/- HUGE_VAL
 *
 * (internal helper function, not directly callable from SQL)
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_float8_no_overflow</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>numeric_to_double_no_overflow</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>FLT_DIG</name> <operator>+</operator> <literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert infinity to numeric"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%.*g"</literal></expr></argument>, <argument><expr><name>FLT_DIG</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assume we need not worry about leading/trailing spaces */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_var_from_str</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>numeric_float4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><call><name>get_float4_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_out</name></expr></argument>,
											  <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float4in</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------------
 *
 * Aggregate functions
 *
 * The transition datatype for all these aggregates is declared as INTERNAL.
 * Actually, it's a pointer to a NumericAggState allocated in the aggregate
 * context.  The digit buffers for the NumericVars will be there too.
 *
 * On platforms which support 128-bit integers some aggregates instead use a
 * 128-bit integer based transition datatype to speed up calculations.
 *
 * ----------------------------------------------------------------------
 */</comment>

<typedef>typedef <type><struct>struct <name>NumericAggState</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>calcSumX2</name></decl>;</decl_stmt>		<comment type="block">/* if true, calculate sumX2 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>agg_context</name></decl>;</decl_stmt>	<comment type="block">/* context we're calculating in */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>N</name></decl>;</decl_stmt>				<comment type="block">/* count of processed numbers */</comment>
	<decl_stmt><decl><type><name>NumericSumAccum</name></type> <name>sumX</name></decl>;</decl_stmt>		<comment type="block">/* sum of processed numbers */</comment>
	<decl_stmt><decl><type><name>NumericSumAccum</name></type> <name>sumX2</name></decl>;</decl_stmt>		<comment type="block">/* sum of squares of processed numbers */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxScale</name></decl>;</decl_stmt>		<comment type="block">/* maximum scale seen so far */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>maxScaleCount</name></decl>;</decl_stmt>	<comment type="block">/* number of values seen with maximum scale */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>NaNcount</name></decl>;</decl_stmt>		<comment type="block">/* count of NaN values (not included in N!) */</comment>
}</block></struct></type> <name>NumericAggState</name>;</typedef>

<comment type="block">/*
 * Prepare state data for a numeric aggregate function that needs to compute
 * sum, count and optionally sum of squares of the input.
 */</comment>
<function><type><specifier>static</specifier> <name>NumericAggState</name> <modifier>*</modifier></type>
<name>makeNumericAggState</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>calcSumX2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>agg_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg_context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>agg_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NumericAggState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>calcSumX2</name></name> <operator>=</operator> <name>calcSumX2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>agg_context</name></name> <operator>=</operator> <name>agg_context</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like makeNumericAggState(), but allocate the state in the current memory
 * context.
 */</comment>
<function><type><specifier>static</specifier> <name>NumericAggState</name> <modifier>*</modifier></type>
<name>makeNumericAggStateCurrentContext</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>calcSumX2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NumericAggState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>calcSumX2</name></name> <operator>=</operator> <name>calcSumX2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>agg_context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Accumulate a new input value for numeric aggregate functions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_numeric_accum</name><parameter_list>(<parameter><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Numeric</name></type> <name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>X</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>X2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<comment type="block">/* Count NaN inputs separately from all else */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>NaNcount</name></name><operator>++</operator></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* load processed number in short-lived context */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Track the highest input dscale that we've seen, to support inverse
	 * transitions (see do_numeric_discard).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>X</name><operator>.</operator><name>dscale</name></name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>maxScale</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>=</operator> <name><name>X</name><operator>.</operator><name>dscale</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>maxScaleCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>X</name><operator>.</operator><name>dscale</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>maxScale</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>maxScaleCount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if we need X^2, calculate that in short-lived context */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>calcSumX2</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>X2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>X</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>X2</name></expr></argument>, <argument><expr><name><name>X</name><operator>.</operator><name>dscale</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The rest of this needs to work in the aggregate context */</comment>
	<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>agg_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Accumulate sums */</comment>
	<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>calcSumX2</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>sumX2</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>X2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to remove an input value from the aggregated state.
 *
 * If the value cannot be removed then the function will return false; the
 * possible reasons for failing are described below.
 *
 * If we aggregate the values 1.01 and 2 then the result will be 3.01.
 * If we are then asked to un-aggregate the 1.01 then we must fail as we
 * won't be able to tell what the new aggregated value's dscale should be.
 * We don't want to return 2.00 (dscale = 2), since the sum's dscale would
 * have been zero if we'd really aggregated only 2.
 *
 * Note: alternatively, we could count the number of inputs with each possible
 * dscale (up to some sane limit).  Not yet clear if it's worth the trouble.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>do_numeric_discard</name><parameter_list>(<parameter><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Numeric</name></type> <name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>X</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>X2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<comment type="block">/* Count NaN inputs separately from all else */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_IS_NAN</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>NaNcount</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* load processed number in short-lived context */</comment>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * state-&gt;sumX's dscale is the maximum dscale of any of the inputs.
	 * Removing the last input with that dscale would require us to recompute
	 * the maximum dscale of the *remaining* inputs, which we cannot do unless
	 * no more non-NaN inputs remain at all.  So we report a failure instead,
	 * and force the aggregation to be redone from scratch.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>X</name><operator>.</operator><name>dscale</name></name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>maxScale</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>maxScaleCount</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Some remaining inputs have same dscale, or dscale hasn't gotten
			 * above zero anyway
			 */</comment>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>maxScaleCount</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No remaining non-NaN inputs at all, so reset maxScale */</comment>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>maxScaleCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Correct new maxScale is uncertain, must fail */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if we need X^2, calculate that in short-lived context */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>calcSumX2</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>X2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>X</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>X2</name></expr></argument>, <argument><expr><name><name>X</name><operator>.</operator><name>dscale</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The rest of this needs to work in the aggregate context */</comment>
	<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>agg_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name><operator>--</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Negate X, to subtract it from the sum */</comment>
		<expr_stmt><expr><name><name>X</name><operator>.</operator><name>sign</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>X</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_POS</name></expr> ?</condition><then> <expr><name>NUMERIC_NEG</name></expr> </then><else>: <expr><name>NUMERIC_POS</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>calcSumX2</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Negate X^2. X^2 is always positive */</comment>
			<expr_stmt><expr><name><name>X2</name><operator>.</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>sumX2</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>X2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Zero the sums */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>accum_sum_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>calcSumX2</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>accum_sum_reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generic transition function for numeric aggregates that require sumX2.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Create the state data on the first call */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makeNumericAggState</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_numeric_accum</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generic combine function for numeric aggregates which require sumX2
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_combine</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>agg_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg_context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>state1</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>state2</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>state2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* manually copy all fields from state2 to state1 */</comment>
	<if_stmt><if>if <condition>(<expr><name>state1</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>agg_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>state1</name> <operator>=</operator> <call><name>makeNumericAggStateCurrentContext</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>N</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>N</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>NaNcount</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>NaNcount</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>maxScale</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>maxScaleCount</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>maxScaleCount</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>accum_sum_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>accum_sum_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>N</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>N</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>NaNcount</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>NaNcount</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state2</name><operator>-&gt;</operator><name>N</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * These are currently only needed for moving aggregates, but let's do
		 * the right thing anyway...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state2</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>&gt;</operator> <name><name>state1</name><operator>-&gt;</operator><name>maxScale</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>maxScale</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>maxScaleCount</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>maxScaleCount</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>state2</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>==</operator> <name><name>state1</name><operator>-&gt;</operator><name>maxScale</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>maxScaleCount</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>maxScaleCount</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* The rest of this needs to work in the aggregate context */</comment>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>agg_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Accumulate sums */</comment>
		<expr_stmt><expr><call><name>accum_sum_combine</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>accum_sum_combine</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generic transition function for numeric aggregates that don't require sumX2.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_avg_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Create the state data on the first call */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makeNumericAggState</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_numeric_accum</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Combine function for numeric aggregates which don't require sumX2
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_avg_combine</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>agg_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg_context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>state1</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>state2</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>state2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* manually copy all fields from state2 to state1 */</comment>
	<if_stmt><if>if <condition>(<expr><name>state1</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>agg_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>state1</name> <operator>=</operator> <call><name>makeNumericAggStateCurrentContext</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>N</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>N</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>NaNcount</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>NaNcount</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>maxScale</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>maxScaleCount</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>maxScaleCount</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>accum_sum_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>N</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>N</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>NaNcount</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>NaNcount</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state2</name><operator>-&gt;</operator><name>N</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * These are currently only needed for moving aggregates, but let's do
		 * the right thing anyway...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state2</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>&gt;</operator> <name><name>state1</name><operator>-&gt;</operator><name>maxScale</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>maxScale</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>maxScaleCount</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>maxScaleCount</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>state2</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>==</operator> <name><name>state1</name><operator>-&gt;</operator><name>maxScale</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>maxScaleCount</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>maxScaleCount</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* The rest of this needs to work in the aggregate context */</comment>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>agg_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Accumulate sums */</comment>
		<expr_stmt><expr><call><name>accum_sum_combine</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_avg_serialize
 *		Serialize NumericAggState for numeric aggregates that don't require
 *		sumX2.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_avg_serialize</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>temp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>sumX</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>tmp_var</name></decl>;</decl_stmt>

	<comment type="block">/* Ensure we disallow calling when not in aggregate context */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is a little wasteful since make_result converts the NumericVar
	 * into a Numeric and numeric_send converts it back again. Is it worth
	 * splitting the tasks in numeric_send into separate functions to stop
	 * this? Doing so would also remove the fmgr call overhead.
	 */</comment>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>accum_sum_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_send</name></expr></argument>,
							   <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* N */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX */</comment>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* maxScale */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>maxScale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* maxScaleCount */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>maxScaleCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NaNcount */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>NaNcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_avg_deserialize
 *		Deserialize bytea into NumericAggState for numeric aggregates that
 *		don't require sumX2.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_avg_deserialize</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>sstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>temp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>tmp_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the bytea into a StringInfo so that we can "receive" it using the
	 * standard recv-function infrastructure.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNumericAggStateCurrentContext</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* N */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>N</name></name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX */</comment>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_recv</name></expr></argument>,
							   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>sumX</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* maxScale */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* maxScaleCount */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>maxScaleCount</name></name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NaNcount */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>NaNcount</name></name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_serialize
 *		Serialization function for NumericAggState for numeric aggregates that
 *		require sumX2.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_serialize</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>temp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>sumX</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>tmp_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>sumX2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Ensure we disallow calling when not in aggregate context */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is a little wasteful since make_result converts the NumericVar
	 * into a Numeric and numeric_send converts it back again. Is it worth
	 * splitting the tasks in numeric_send into separate functions to stop
	 * this? Doing so would also remove the fmgr call overhead.
	 */</comment>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>accum_sum_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_send</name></expr></argument>,
							   <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>accum_sum_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_send</name></expr></argument>,
							   <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* N */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX */</comment>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX2 */</comment>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* maxScale */</comment>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>maxScale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* maxScaleCount */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>maxScaleCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NaNcount */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>NaNcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_deserialize
 *		Deserialization function for NumericAggState for numeric aggregates that
 *		require sumX2.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_deserialize</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>sstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>temp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>sumX_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>sumX2_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the bytea into a StringInfo so that we can "receive" it using the
	 * standard recv-function infrastructure.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNumericAggStateCurrentContext</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* N */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>N</name></name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX */</comment>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_recv</name></expr></argument>,
							   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>sumX</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX2 */</comment>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_recv</name></expr></argument>,
							   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sumX2_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>sumX2</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>sumX2_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* maxScale */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>maxScale</name></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* maxScaleCount */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>maxScaleCount</name></name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NaNcount */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>NaNcount</name></name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generic inverse transition function for numeric aggregates
 * (with or without requirement for X^2).
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_accum_inv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Should not get here with no state */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"numeric_accum_inv called with NULL state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If we fail to perform the inverse transition, return NULL */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>do_numeric_discard</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Integer data types in general use Numeric accumulators to share code
 * and avoid risk of overflow.
 *
 * However for performance reasons optimized special-purpose accumulator
 * routines are used when possible.
 *
 * On platforms with 128-bit integer support, the 128-bit routines will be
 * used when sum(X) or sum(X*X) fit into 128-bit.
 *
 * For 16 and 32 bit inputs, the N and sum(X) fit into 64-bit so the 64-bit
 * accumulators will be used for SUM and AVG of these data types.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
<typedef>typedef <type><struct>struct <name>Int128AggState</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>calcSumX2</name></decl>;</decl_stmt>		<comment type="block">/* if true, calculate sumX2 */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>N</name></decl>;</decl_stmt>				<comment type="block">/* count of processed numbers */</comment>
	<decl_stmt><decl><type><name>int128</name></type>		<name>sumX</name></decl>;</decl_stmt>			<comment type="block">/* sum of processed numbers */</comment>
	<decl_stmt><decl><type><name>int128</name></type>		<name>sumX2</name></decl>;</decl_stmt>			<comment type="block">/* sum of squares of processed numbers */</comment>
}</block></struct></type> <name>Int128AggState</name>;</typedef>

<comment type="block">/*
 * Prepare state data for a 128-bit aggregate function that needs to compute
 * sum, count and optionally sum of squares of the input.
 */</comment>
<function><type><specifier>static</specifier> <name>Int128AggState</name> <modifier>*</modifier></type>
<name>makeInt128AggState</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>calcSumX2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Int128AggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>agg_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg_context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>agg_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>Int128AggState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Int128AggState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>calcSumX2</name></name> <operator>=</operator> <name>calcSumX2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like makeInt128AggState(), but allocate the state in the current memory
 * context.
 */</comment>
<function><type><specifier>static</specifier> <name>Int128AggState</name> <modifier>*</modifier></type>
<name>makeInt128AggStateCurrentContext</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>calcSumX2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Int128AggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>Int128AggState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Int128AggState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>calcSumX2</name></name> <operator>=</operator> <name>calcSumX2</name></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Accumulate a new input value for 128-bit aggregate functions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_int128_accum</name><parameter_list>(<parameter><decl><type><name>Int128AggState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int128</name></type> <name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>calcSumX2</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sumX2</name></name> <operator>+=</operator> <name>newval</name> <operator>*</operator> <name>newval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name> <operator>+=</operator> <name>newval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove an input value from the aggregated state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_int128_discard</name><parameter_list>(<parameter><decl><type><name>Int128AggState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int128</name></type> <name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>calcSumX2</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sumX2</name></name> <operator>-=</operator> <name>newval</name> <operator>*</operator> <name>newval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name> <operator>-=</operator> <name>newval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><name>Int128AggState</name></type> <name>PolyNumAggState</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>makePolyNumAggState</name></cpp:macro> <cpp:value>makeInt128AggState</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>makePolyNumAggStateCurrentContext</name></cpp:macro> <cpp:value>makeInt128AggStateCurrentContext</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>NumericAggState</name></type> <name>PolyNumAggState</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>makePolyNumAggState</name></cpp:macro> <cpp:value>makeNumericAggState</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>makePolyNumAggStateCurrentContext</name></cpp:macro> <cpp:value>makeNumericAggStateCurrentContext</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>Datum</name></type>
<name>int2_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Create the state data on the first call */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makePolyNumAggState</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><call><name>do_int128_accum</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>int128</name><operator>)</operator> <call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>newval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int2_numeric</name></expr></argument>,
													 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_numeric_accum</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int4_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Create the state data on the first call */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makePolyNumAggState</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><call><name>do_int128_accum</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>int128</name><operator>)</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>newval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4_numeric</name></expr></argument>,
													 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_numeric_accum</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int8_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Create the state data on the first call */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makeNumericAggState</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>newval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>,
													 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_numeric_accum</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Combine function for numeric aggregates which require sumX2
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_poly_combine</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>agg_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg_context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>state1</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>state2</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>state2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* manually copy all fields from state2 to state1 */</comment>
	<if_stmt><if>if <condition>(<expr><name>state1</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>agg_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>state1</name> <operator>=</operator> <call><name>makePolyNumAggState</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>N</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>N</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>sumX2</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>sumX2</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>accum_sum_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>accum_sum_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state2</name><operator>-&gt;</operator><name>N</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>N</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>N</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>sumX2</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>sumX2</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<comment type="block">/* The rest of this needs to work in the aggregate context */</comment>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>agg_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Accumulate sums */</comment>
		<expr_stmt><expr><call><name>accum_sum_combine</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>accum_sum_combine</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_poly_serialize
 *		Serialize PolyNumAggState into bytea for aggregate functions which
 *		require sumX2.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_poly_serialize</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>sumX</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>sumX2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Ensure we disallow calling when not in aggregate context */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the platform supports int128 then sumX and sumX2 will be a 128 bit
	 * integer type. Here we'll convert that into a numeric type so that the
	 * combine state is in the same format for both int128 enabled machines
	 * and machines which don't support that type. The logic here is that one
	 * day we might like to send these over to another server for further
	 * processing and we want a standard format to work with.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>temp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>num</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><call><name>int128_to_numericvar</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>accum_sum_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_send</name></expr></argument>,
								   <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sumX</name> <operator>=</operator> <call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><call><name>int128_to_numericvar</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>accum_sum_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_send</name></expr></argument>,
								   <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* N */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX */</comment>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX2 */</comment>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * numeric_poly_deserialize
 *		Deserialize PolyNumAggState from bytea for aggregate functions which
 *		require sumX2.
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_poly_deserialize</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>sstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>sumX</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>sumX_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>sumX2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>sumX2_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the bytea into a StringInfo so that we can "receive" it using the
	 * standard recv-function infrastructure.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makePolyNumAggStateCurrentContext</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* N */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>N</name></name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX */</comment>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_recv</name></expr></argument>,
							   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX2 */</comment>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_recv</name></expr></argument>,
								<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
	<expr_stmt><expr><call><name>numericvar_to_int128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sumX2_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
	<expr_stmt><expr><call><name>numericvar_to_int128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sumX2_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sumX2_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transition function for int8 input when we don't need sumX2.
 */</comment>
<function><type><name>Datum</name></type>
<name>int8_avg_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Create the state data on the first call */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makePolyNumAggState</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><call><name>do_int128_accum</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>int128</name><operator>)</operator> <call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>newval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>,
													 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>do_numeric_accum</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Combine function for PolyNumAggState for aggregates which don't require
 * sumX2
 */</comment>
<function><type><name>Datum</name></type>
<name>int8_avg_combine</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>agg_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg_context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>state1</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>state2</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>state2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* manually copy all fields from state2 to state1 */</comment>
	<if_stmt><if>if <condition>(<expr><name>state1</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>agg_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>state1</name> <operator>=</operator> <call><name>makePolyNumAggState</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>N</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>N</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name> <operator>=</operator> <name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>accum_sum_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state2</name><operator>-&gt;</operator><name>N</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>N</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>N</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<comment type="block">/* The rest of this needs to work in the aggregate context */</comment>
		<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>agg_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Accumulate sums */</comment>
		<expr_stmt><expr><call><name>accum_sum_combine</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state1</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state2</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * int8_avg_serialize
 *		Serialize PolyNumAggState into bytea using the standard
 *		recv-function infrastructure.
 */</comment>
<function><type><name>Datum</name></type>
<name>int8_avg_serialize</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>sumX</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Ensure we disallow calling when not in aggregate context */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the platform supports int128 then sumX will be a 128 integer type.
	 * Here we'll convert that into a numeric type so that the combine state
	 * is in the same format for both int128 enabled machines and machines
	 * which don't support that type. The logic here is that one day we might
	 * like to send these over to another server for further processing and we
	 * want a standard format to work with.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>temp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>num</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><call><name>int128_to_numericvar</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>accum_sum_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_send</name></expr></argument>,
								   <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sumX</name> <operator>=</operator> <call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* N */</comment>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX */</comment>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * int8_avg_deserialize
 *		Deserialize bytea back into PolyNumAggState.
 */</comment>
<function><type><name>Datum</name></type>
<name>int8_avg_deserialize</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>sstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>temp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>num</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the bytea into a StringInfo so that we can "receive" it using the
	 * standard recv-function infrastructure.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makePolyNumAggStateCurrentContext</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* N */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>N</name></name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sumX */</comment>
	<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_recv</name></expr></argument>,
							   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var_from_num</name><argument_list>(<argument><expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
	<expr_stmt><expr><call><name>numericvar_to_int128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>pq_getmsgend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Inverse transition functions to go with the above.
 */</comment>

<function><type><name>Datum</name></type>
<name>int2_accum_inv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Should not get here with no state */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"int2_accum_inv called with NULL state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><call><name>do_int128_discard</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>int128</name><operator>)</operator> <call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>newval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int2_numeric</name></expr></argument>,
													 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Should never fail, all inputs have dscale 0 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>do_numeric_discard</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"do_numeric_discard failed unexpectedly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int4_accum_inv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Should not get here with no state */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"int4_accum_inv called with NULL state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><call><name>do_int128_discard</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>int128</name><operator>)</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>newval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4_numeric</name></expr></argument>,
													 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Should never fail, all inputs have dscale 0 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>do_numeric_discard</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"do_numeric_discard failed unexpectedly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int8_accum_inv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Should not get here with no state */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"int8_accum_inv called with NULL state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>newval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>,
													 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Should never fail, all inputs have dscale 0 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>do_numeric_discard</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"do_numeric_discard failed unexpectedly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int8_avg_accum_inv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Should not get here with no state */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"int8_avg_accum_inv called with NULL state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
		<expr_stmt><expr><call><name>do_int128_discard</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>int128</name><operator>)</operator> <call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>newval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>,
													 <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Should never fail, all inputs have dscale 0 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>do_numeric_discard</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"do_numeric_discard failed unexpectedly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_poly_sum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* If there were no non-null inputs, return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>N</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>int128_to_numericvar</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>numeric_sum</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_poly_avg</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>countd</name></decl>,
				<decl><type ref="prev"/><name>sumd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* If there were no non-null inputs, return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>N</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>int128_to_numericvar</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>countd</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>,
								 <argument><expr><call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumd</name> <operator>=</operator> <call><name>NumericGetDatum</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_div</name></expr></argument>, <argument><expr><name>sumd</name></expr></argument>, <argument><expr><name>countd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>numeric_avg</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_avg</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>N_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>sumX_datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>sumX_var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* If there were no non-null inputs, return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>N</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>NaNcount</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>NaNcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* there was at least one NaN input */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>N_datum</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>accum_sum_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX_datum</name> <operator>=</operator> <call><name>NumericGetDatum</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_div</name></expr></argument>, <argument><expr><name>sumX_datum</name></expr></argument>, <argument><expr><name>N_datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_sum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>sumX_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* If there were no non-null inputs, return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>N</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>NaNcount</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>NaNcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* there was at least one NaN input */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>accum_sum_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sumX_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Workhorse routine for the standard deviance and variance
 * aggregates. 'state' is aggregate's transition state.
 * 'variance' specifies whether we should calculate the
 * variance or the standard deviation. 'sample' indicates whether the
 * caller is interested in the sample or the population
 * variance/stddev.
 *
 * If appropriate variance statistic is undefined for the input,
 * *is_null is set to true and NULL is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>Numeric</name></type>
<name>numeric_stddev_internal</name><parameter_list>(<parameter><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>variance</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sample</name></decl></parameter>,
						<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_null</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>vN</name></decl>,
				<decl><type ref="prev"/><name>vsumX</name></decl>,
				<decl><type ref="prev"/><name>vsumX2</name></decl>,
				<decl><type ref="prev"/><name>vNminus1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>comp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rscale</name></decl>;</decl_stmt>

	<comment type="block">/* Deal with empty input and NaN-input cases */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>N</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>NaNcount</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>is_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>is_null</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>NaNcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_nan</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsumX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsumX2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>int64_to_numericvar</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>N</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>accum_sum_final</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsumX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>accum_sum_final</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>sumX2</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsumX2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sample stddev and variance are undefined when N &lt;= 1; population stddev
	 * is undefined when N == 0. Return NULL in either case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sample</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>comp</name> <operator>=</operator> <operator>&amp;</operator><name>const_one</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>comp</name> <operator>=</operator> <operator>&amp;</operator><name>const_zero</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vN</name></expr></argument>, <argument><expr><name>comp</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>is_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vNminus1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vNminus1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* compute rscale for mul_var calls */</comment>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <name><name>vsumX</name><operator>.</operator><name>dscale</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsumX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsumX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsumX</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* vsumX = sumX * sumX */</comment>
	<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsumX2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsumX2</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* vsumX2 = N * sumX2 */</comment>
	<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsumX2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsumX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsumX2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* N * sumX2 - sumX * sumX */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsumX2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Watch out for roundoff error producing a negative numerator */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>sample</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vNminus1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vNminus1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* N * (N - 1) */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vNminus1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* N * N */</comment>
		<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>select_div_scale</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsumX2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vNminus1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>div_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsumX2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vNminus1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsumX</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* variance */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>variance</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sqrt_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsumX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vsumX</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* stddev */</comment>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsumX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vNminus1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsumX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsumX2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_var_samp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>numeric_stddev_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_stddev_samp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>numeric_stddev_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_var_pop</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>numeric_stddev_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_stddev_pop</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>NumericAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>numeric_stddev_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>Numeric</name></type>
<name>numeric_poly_stddev_internal</name><parameter_list>(<parameter><decl><type><name>Int128AggState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>variance</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sample</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_null</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericAggState</name></type> <name>numstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize an empty agg state */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>numstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NumericAggState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>tmp_var</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>numstate</name><operator>.</operator><name>N</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>N</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>int128_to_numericvar</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>numstate</name><operator>.</operator><name>sumX</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>int128_to_numericvar</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>sumX2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>numstate</name><operator>.</operator><name>sumX2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>numeric_stddev_internal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>numstate</name></expr></argument>, <argument><expr><name>variance</name></expr></argument>, <argument><expr><name>sample</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>numstate</name><operator>.</operator><name>sumX</name><operator>.</operator><name>ndigits</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>numstate</name><operator>.</operator><name>sumX</name><operator>.</operator><name>pos_digits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>numstate</name><operator>.</operator><name>sumX</name><operator>.</operator><name>neg_digits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>numstate</name><operator>.</operator><name>sumX2</name><operator>.</operator><name>ndigits</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>numstate</name><operator>.</operator><name>sumX2</name><operator>.</operator><name>pos_digits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>numstate</name><operator>.</operator><name>sumX2</name><operator>.</operator><name>neg_digits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>Datum</name></type>
<name>numeric_poly_var_samp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>numeric_poly_stddev_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>numeric_var_samp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_poly_stddev_samp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>numeric_poly_stddev_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>numeric_stddev_samp</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_poly_var_pop</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>numeric_poly_stddev_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>numeric_var_pop</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric_poly_stddev_pop</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PolyNumAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>PolyNumAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>numeric_poly_stddev_internal</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>numeric_stddev_pop</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * SUM transition functions for integer datatypes.
 *
 * To avoid overflow, we use accumulators wider than the input datatype.
 * A Numeric accumulator is needed for int8 input; for int4 and int2
 * inputs, we use int8 accumulators which should be sufficient for practical
 * purposes.  (The latter two therefore don't really belong in this file,
 * but we keep them here anyway.)
 *
 * Because SQL defines the SUM() of no values to be NULL, not zero,
 * the initial condition of the transition data value needs to be NULL. This
 * means we can't rely on ExecAgg to automatically insert the first non-null
 * data value into the transition data: it doesn't know how to do the type
 * conversion.  The upshot is that these routines have to be marked non-strict
 * and handle substitution of the first non-null input themselves.
 *
 * Note: these functions are used only in plain aggregation mode.
 * In moving-aggregate mode, we use intX_avg_accum and intX_avg_accum_inv.
 */</comment>

<function><type><name>Datum</name></type>
<name>int2_sum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>newval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No non-null input seen so far... */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* still no non-null */</comment>
		<comment type="block">/* This is the first non-null input. */</comment>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're invoked as an aggregate, we can cheat and modify our first
	 * parameter in-place to avoid palloc overhead. If not, we need to return
	 * the new value of the transition variable. (If int8 is pass-by-value,
	 * then of course this is useless as well as incorrect, so just ifdef it
	 * out.)
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_FLOAT8_BYVAL</name></cpp:ifndef>		<comment type="block">/* controls int8 too */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name>	   <modifier>*</modifier></type><name>oldsum</name> <init>= <expr><operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Leave the running sum unchanged in the new input is null */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>oldsum</name> <operator>=</operator> <operator>*</operator><name>oldsum</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>oldsum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>oldsum</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Leave sum unchanged if new input is null. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>oldsum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* OK to do the addition. */</comment>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <name>oldsum</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int4_sum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>newval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No non-null input seen so far... */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* still no non-null */</comment>
		<comment type="block">/* This is the first non-null input. */</comment>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're invoked as an aggregate, we can cheat and modify our first
	 * parameter in-place to avoid palloc overhead. If not, we need to return
	 * the new value of the transition variable. (If int8 is pass-by-value,
	 * then of course this is useless as well as incorrect, so just ifdef it
	 * out.)
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_FLOAT8_BYVAL</name></cpp:ifndef>		<comment type="block">/* controls int8 too */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name>	   <modifier>*</modifier></type><name>oldsum</name> <init>= <expr><operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Leave the running sum unchanged in the new input is null */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>oldsum</name> <operator>=</operator> <operator>*</operator><name>oldsum</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>oldsum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>oldsum</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Leave sum unchanged if new input is null. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>oldsum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* OK to do the addition. */</comment>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <name>oldsum</name> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Note: this function is obsolete, it's no longer used for SUM(int8).
 */</comment>
<function><type><name>Datum</name></type>
<name>int8_sum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>oldsum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>newval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No non-null input seen so far... */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* still no non-null */</comment>
		<comment type="block">/* This is the first non-null input. */</comment>
		<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Note that we cannot special-case the aggregate case here, as we do for
	 * int2_sum and int4_sum: numeric is of variable size, so we cannot modify
	 * our first parameter in-place.
	 */</comment>

	<expr_stmt><expr><name>oldsum</name> <operator>=</operator> <call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Leave sum unchanged if new input is null. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NUMERIC</name><argument_list>(<argument><expr><name>oldsum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK to do the addition. */</comment>
	<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_add</name></expr></argument>,
										<argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>oldsum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Routines for avg(int2) and avg(int4).  The transition datatype
 * is a two-element int8 array, holding count and sum.
 *
 * These functions are also used for sum(int2) and sum(int4) when
 * operating in moving-aggregate mode, since for correct inverse transitions
 * we need to count the inputs.
 */</comment>

<typedef>typedef <type><struct>struct <name>Int8TransTypeData</name>
<block>{
	<decl_stmt><decl><type><name>int64</name></type>		<name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>sum</name></decl>;</decl_stmt>
}</block></struct></type> <name>Int8TransTypeData</name>;</typedef>

<function><type><name>Datum</name></type>
<name>int2_avg_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>newval</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Int8TransTypeData</name> <modifier>*</modifier></type><name>transdata</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're invoked as an aggregate, we can cheat and modify our first
	 * parameter in-place to reduce palloc overhead. Otherwise we need to make
	 * a copy of it before scribbling on it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>transarray</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>transarray</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Int8TransTypeData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element int8 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>transdata</name> <operator>=</operator> <operator>(</operator><name>Int8TransTypeData</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transdata</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transdata</name><operator>-&gt;</operator><name>sum</name></name> <operator>+=</operator> <name>newval</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int4_avg_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>newval</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Int8TransTypeData</name> <modifier>*</modifier></type><name>transdata</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're invoked as an aggregate, we can cheat and modify our first
	 * parameter in-place to reduce palloc overhead. Otherwise we need to make
	 * a copy of it before scribbling on it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>transarray</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>transarray</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Int8TransTypeData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element int8 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>transdata</name> <operator>=</operator> <operator>(</operator><name>Int8TransTypeData</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transdata</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transdata</name><operator>-&gt;</operator><name>sum</name></name> <operator>+=</operator> <name>newval</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int4_avg_combine</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Int8TransTypeData</name> <modifier>*</modifier></type><name>state1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Int8TransTypeData</name> <modifier>*</modifier></type><name>state2</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>transarray1</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>transarray2</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>transarray1</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>transarray1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Int8TransTypeData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element int8 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>transarray2</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>transarray2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Int8TransTypeData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element int8 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>state1</name> <operator>=</operator> <operator>(</operator><name>Int8TransTypeData</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>transarray1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state2</name> <operator>=</operator> <operator>(</operator><name>Int8TransTypeData</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>transarray2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state1</name><operator>-&gt;</operator><name>sum</name></name> <operator>+=</operator> <name><name>state2</name><operator>-&gt;</operator><name>sum</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>transarray1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int2_avg_accum_inv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>newval</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Int8TransTypeData</name> <modifier>*</modifier></type><name>transdata</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're invoked as an aggregate, we can cheat and modify our first
	 * parameter in-place to reduce palloc overhead. Otherwise we need to make
	 * a copy of it before scribbling on it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>transarray</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>transarray</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Int8TransTypeData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element int8 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>transdata</name> <operator>=</operator> <operator>(</operator><name>Int8TransTypeData</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transdata</name><operator>-&gt;</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transdata</name><operator>-&gt;</operator><name>sum</name></name> <operator>-=</operator> <name>newval</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int4_avg_accum_inv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>newval</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Int8TransTypeData</name> <modifier>*</modifier></type><name>transdata</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're invoked as an aggregate, we can cheat and modify our first
	 * parameter in-place to reduce palloc overhead. Otherwise we need to make
	 * a copy of it before scribbling on it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>transarray</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>transarray</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Int8TransTypeData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element int8 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>transdata</name> <operator>=</operator> <operator>(</operator><name>Int8TransTypeData</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transdata</name><operator>-&gt;</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transdata</name><operator>-&gt;</operator><name>sum</name></name> <operator>-=</operator> <name>newval</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int8_avg</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Int8TransTypeData</name> <modifier>*</modifier></type><name>transdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>countd</name></decl>,
				<decl><type ref="prev"/><name>sumd</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Int8TransTypeData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element int8 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>transdata</name> <operator>=</operator> <operator>(</operator><name>Int8TransTypeData</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* SQL defines AVG of no values to be NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>transdata</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>countd</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>,
								 <argument><expr><call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>transdata</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumd</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>,
							   <argument><expr><call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>transdata</name><operator>-&gt;</operator><name>sum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_div</name></expr></argument>, <argument><expr><name>sumd</name></expr></argument>, <argument><expr><name>countd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SUM(int2) and SUM(int4) both return int8, so we can use this
 * final function for both.
 */</comment>
<function><type><name>Datum</name></type>
<name>int2int4_sum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Int8TransTypeData</name> <modifier>*</modifier></type><name>transdata</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Int8TransTypeData</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected 2-element int8 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>transdata</name> <operator>=</operator> <operator>(</operator><name>Int8TransTypeData</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* SQL defines SUM of no values to be NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>transdata</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>transdata</name><operator>-&gt;</operator><name>sum</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------------
 *
 * Debug support
 *
 * ----------------------------------------------------------------------
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NUMERIC_DEBUG</name></cpp:ifdef>

<comment type="block">/*
 * dump_numeric() - Dump a value in the db storage format for debugging
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_numeric</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>Numeric</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><call><name>NUMERIC_DIGITS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ndigits</name> <operator>=</operator> <call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: NUMERIC w=%d d=%d "</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>,
		   <argument><expr><call><name>NUMERIC_WEIGHT</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NUMERIC_DSCALE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><call><name>NUMERIC_SIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>NUMERIC_POS</name></expr>:</case>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"POS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NUMERIC_NEG</name></expr>:</case>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"NEG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NUMERIC_NAN</name></expr>:</case>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SIGN=0x%x"</literal></expr></argument>, <argument><expr><call><name>NUMERIC_SIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndigits</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %0*d"</literal></expr></argument>, <argument><expr><name>DEC_DIGITS</name></expr></argument>, <argument><expr><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * dump_var() - Dump a value in the variable format for debugging
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: VAR w=%d d=%d "</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>NUMERIC_POS</name></expr>:</case>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"POS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NUMERIC_NEG</name></expr>:</case>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"NEG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NUMERIC_NAN</name></expr>:</case>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SIGN=0x%x"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %0*d"</literal></expr></argument>, <argument><expr><name>DEC_DIGITS</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* NUMERIC_DEBUG */</comment>


<comment type="block">/* ----------------------------------------------------------------------
 *
 * Local functions follow
 *
 * In general, these do not support NaNs --- callers must eliminate
 * the possibility of NaN first.  (make_result() is an exception.)
 *
 * ----------------------------------------------------------------------
 */</comment>


<comment type="block">/*
 * alloc_var() -
 *
 *	Allocate a digit buffer of ndigits digits (plus a spare digit for rounding)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>alloc_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndigits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>digitbuf_free</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <call><name>digitbuf_alloc</name><argument_list>(<argument><expr><name>ndigits</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* spare digit for rounding */</comment>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <name>ndigits</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * free_var() -
 *
 *	Return the digit buffer of a variable to the free pool
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>digitbuf_free</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_NAN</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * zero_var() -
 *
 *	Set a variable to ZERO.
 *	Note: its dscale is not touched.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>zero_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>digitbuf_free</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* by convention; doesn't really matter */</comment>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>	<comment type="block">/* anything but NAN... */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * set_var_from_str()
 *
 *	Parse a string and put the number into a variable
 *
 * This function does not handle leading or trailing spaces, and it doesn't
 * accept "NaN" either.  It returns the end+1 position so that caller can
 * check for trailing spaces/garbage if deemed necessary.
 *
 * cp is the place to actually start parsing; str is what to use in error
 * reports.  (Typically cp would be the same except advanced over spaces.)
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>set_var_from_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_dp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>decdigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sign</name> <init>= <expr><name>NUMERIC_POS</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dweight</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ddigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dscale</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>digits</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We first parse the string to extract decimal digits and determine the
	 * correct decimal weight.  Then convert to NBASE representation.
	 */</comment>
	<switch>switch <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'+'</literal></expr>:</case>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'-'</literal></expr>:</case>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>have_dp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><literal type="string">"numeric"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>decdigits</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>DEC_DIGITS</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* leading padding for digit alignment later */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>decdigits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DEC_DIGITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>decdigits</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>cp</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_dp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dweight</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>dscale</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>have_dp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
								<argument><expr><literal type="string">"numeric"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>have_dp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>ddigits</name> <operator>=</operator> <name>i</name> <operator>-</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
	<comment type="block">/* trailing padding for digit alignment later */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>decdigits</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DEC_DIGITS</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle exponent, if any */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>exponent</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>exponent</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>cp</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
							<argument><expr><literal type="string">"numeric"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>endptr</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * At this point, dweight and dscale can't be more than about
		 * INT_MAX/2 due to the MaxAllocSize limit on string length, so
		 * constraining the exponent similarly should be enough to prevent
		 * integer overflow in this function.  If the value is too large to
		 * fit in storage format, make_result() will complain about it later;
		 * for consistency use the same ereport errcode/text as make_result().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>exponent</name> <operator>&gt;=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal> <operator>||</operator> <name>exponent</name> <operator>&lt;=</operator> <operator>-</operator><operator>(</operator><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value overflows numeric format"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>dweight</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>exponent</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dscale</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>exponent</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dscale</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dscale</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Okay, convert pure-decimal representation to base NBASE.  First we need
	 * to determine the converted weight and ndigits.  offset is the number of
	 * decimal zeroes to insert before the first given digit to have a
	 * correctly aligned first NBASE digit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dweight</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>weight</name> <operator>=</operator> <operator>(</operator><name>dweight</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>DEC_DIGITS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEC_DIGITS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>weight</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><operator>-</operator><name>dweight</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEC_DIGITS</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>weight</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>DEC_DIGITS</name> <operator>-</operator> <operator>(</operator><name>dweight</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndigits</name> <operator>=</operator> <operator>(</operator><name>ddigits</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <name>DEC_DIGITS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>alloc_var</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>sign</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>weight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>dscale</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>DEC_DIGITS</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>digits</name> <operator>=</operator> <name><name>dest</name><operator>-&gt;</operator><name>digits</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>ndigits</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>
		<expr_stmt><expr><operator>*</operator><name>digits</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>decdigits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name><name>decdigits</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator>
					 <name><name>decdigits</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name><name>decdigits</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:elif>
		<expr_stmt><expr><operator>*</operator><name>digits</name><operator>++</operator> <operator>=</operator> <name><name>decdigits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name><name>decdigits</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:elif>
		<expr_stmt><expr><operator>*</operator><name>digits</name><operator>++</operator> <operator>=</operator> <name><name>decdigits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> unsupported NBASE</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>decdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Strip any leading/trailing zeroes, and normalize weight if zero */</comment>
	<expr_stmt><expr><call><name>strip_var</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return end+1 position for caller */</comment>
	<return>return <expr><name>cp</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * set_var_from_num() -
 *
 *	Convert the packed db format into a variable
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_var_from_num</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ndigits</name> <operator>=</operator> <call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>alloc_var</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <call><name>NUMERIC_WEIGHT</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <call><name>NUMERIC_SIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <call><name>NUMERIC_DSCALE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>digits</name></name></expr></argument>, <argument><expr><call><name>NUMERIC_DIGITS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ndigits</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * init_var_from_num() -
 *
 *	Initialize a variable from packed db format. The digits array is not
 *	copied, which saves some cycles when the resulting var is not modified.
 *	Also, there's no need to call free_var(), as long as you don't assign any
 *	other value to it (with set_var_* functions, or by using the var as the
 *	destination of a function like add_var())
 *
 *	CAUTION: Do not modify the digits buffer of a var initialized with this
 *	function, e.g by calling round_var() or trunc_var(), as the changes will
 *	propagate to the original Numeric! It's OK to use it as the destination
 *	argument of one of the calculational functions, though.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_var_from_num</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <call><name>NUMERIC_WEIGHT</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <call><name>NUMERIC_SIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <call><name>NUMERIC_DSCALE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <call><name>NUMERIC_DIGITS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* digits array is not palloc'd */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * set_var_from_var() -
 *
 *	Copy one variable into another
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_var_from_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>newbuf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>digitbuf_alloc</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* spare digit for rounding */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* else value-&gt;digits might be null */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newbuf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>digits</name></name></expr></argument>,
			   <argument><expr><name><name>value</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>digitbuf_free</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NumericVar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>newbuf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>newbuf</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_str_from_var() -
 *
 *	Convert a var to text representation (guts of numeric_out).
 *	The var is displayed to the number of digits indicated by its dscale.
 *	Returns a palloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_str_from_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endcp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>d</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name></type> <name>dig</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></cpp:if>
	<decl_stmt><decl><type><name>NumericDigit</name></type> <name>d1</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>dscale</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>dscale</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate space for the result.
	 *
	 * i is set to the # of decimal digits before decimal point. dscale is the
	 * # of decimal digits we will print after decimal point. We may generate
	 * as many as DEC_DIGITS-1 excess digits at the end, and in addition we
	 * need room for sign, decimal point, null terminator.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <name>dscale</name> <operator>+</operator> <name>DEC_DIGITS</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Output a dash for negative values
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_NEG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Output all digits before the decimal point
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>d</name> <operator>&lt;=</operator> <name><name>var</name><operator>-&gt;</operator><name>weight</name></name></expr>;</condition> <incr><expr><name>d</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>dig</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>d</name> <operator>&lt;</operator> <name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>d</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
			<comment type="block">/* In the first digit, suppress extra leading decimal zeroes */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>putit</name> <init>= <expr><operator>(</operator><name>d</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>d1</name> <operator>=</operator> <name>dig</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>dig</name> <operator>-=</operator> <name>d1</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>putit</name> <operator>|=</operator> <operator>(</operator><name>d1</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>putit</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>d1</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>d1</name> <operator>=</operator> <name>dig</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>dig</name> <operator>-=</operator> <name>d1</name> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>putit</name> <operator>|=</operator> <operator>(</operator><name>d1</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>putit</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>d1</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>d1</name> <operator>=</operator> <name>dig</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>dig</name> <operator>-=</operator> <name>d1</name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>putit</name> <operator>|=</operator> <operator>(</operator><name>d1</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>putit</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>d1</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>dig</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
			</block_content>}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:elif>
			<expr_stmt><expr><name>d1</name> <operator>=</operator> <name>dig</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dig</name> <operator>-=</operator> <name>d1</name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>d1</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>d</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>d1</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>dig</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:elif>
			<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>dig</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> unsupported NBASE</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If requested, output a decimal point and all the digits that follow it.
	 * We initially put out a multiple of DEC_DIGITS digits, then truncate if
	 * needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dscale</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>endcp</name> <operator>=</operator> <name>cp</name> <operator>+</operator> <name>dscale</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dscale</name></expr>;</condition> <incr><expr><name>d</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name> <operator>+=</operator> <name>DEC_DIGITS</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>dig</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>d</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>d</name> <operator>&lt;</operator> <name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>d</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>
			<expr_stmt><expr><name>d1</name> <operator>=</operator> <name>dig</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dig</name> <operator>-=</operator> <name>d1</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>d1</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>d1</name> <operator>=</operator> <name>dig</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dig</name> <operator>-=</operator> <name>d1</name> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>d1</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>d1</name> <operator>=</operator> <name>dig</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dig</name> <operator>-=</operator> <name>d1</name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>d1</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>dig</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:elif>
			<expr_stmt><expr><name>d1</name> <operator>=</operator> <name>dig</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>dig</name> <operator>-=</operator> <name>d1</name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>d1</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>dig</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:elif>
			<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>dig</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> unsupported NBASE</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></for>
		<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>endcp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * terminate the string and return it
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_str_from_var_sci() -
 *
 *	Convert a var to a normalised scientific notation text representation.
 *	This function does the heavy lifting for numeric_out_sci().
 *
 *	This notation has the general form a * 10^b, where a is known as the
 *	"significand" and b is known as the "exponent".
 *
 *	Because we can't do superscript in ASCII (and because we want to copy
 *	printf's behaviour) we display the exponent using E notation, with a
 *	minimum of two exponent digits.
 *
 *	For example, the value 1234 could be output as 1.2e+03.
 *
 *	We assume that the exponent can fit into an int32.
 *
 *	rscale is the number of decimal digits desired after the decimal point in
 *	the output, negative values will be treated as meaning zero.
 *
 *	Returns a palloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_str_from_var_sci</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>exponent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>denominator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>significand</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>denom_scale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sig_out</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rscale</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rscale</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Determine the exponent of this number in normalised form.
	 *
	 * This is the exponent required to represent the number with only one
	 * significant digit before the decimal place.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>exponent</name> <operator>=</operator> <operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compensate for leading decimal zeroes in the first numeric digit by
		 * decrementing the exponent.
		 */</comment>
		<expr_stmt><expr><name>exponent</name> <operator>-=</operator> <name>DEC_DIGITS</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>log10</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If var has no digits, then it must be zero.
		 *
		 * Zero doesn't technically have a meaningful exponent in normalised
		 * notation, but we just display the exponent as zero for consistency
		 * of output.
		 */</comment>
		<expr_stmt><expr><name>exponent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The denominator is set to 10 raised to the power of the exponent.
	 *
	 * We then divide var by the denominator to get the significand, rounding
	 * to rscale decimal digits in the process.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>exponent</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>denom_scale</name> <operator>=</operator> <operator>-</operator><name>exponent</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>denom_scale</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>denominator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>significand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>power_var_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_ten</name></expr></argument>, <argument><expr><name>exponent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>denominator</name></expr></argument>, <argument><expr><name>denom_scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>div_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>denominator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>significand</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sig_out</name> <operator>=</operator> <call><name>get_str_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>significand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>denominator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>significand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate space for the result.
	 *
	 * In addition to the significand, we need room for the exponent
	 * decoration ("e"), the sign of the exponent, up to 10 digits for the
	 * exponent itself, and of course the null terminator.
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>sig_out</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">13</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%se%+03d"</literal></expr></argument>, <argument><expr><name>sig_out</name></expr></argument>, <argument><expr><name>exponent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sig_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * make_result() -
 *
 *	Create the packed db numeric format in palloc()'d memory from
 *	a variable.
 */</comment>
<function><type><specifier>static</specifier> <name>Numeric</name></type>
<name>make_result</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sign</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>==</operator> <name>NUMERIC_NAN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NUMERIC_HDRSZ_SHORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NUMERIC_HDRSZ_SHORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_header</name></name> <operator>=</operator> <name>NUMERIC_NAN</name></expr>;</expr_stmt>
		<comment type="block">/* the header word is all we need */</comment>

		<expr_stmt><expr><call><name>dump_numeric</name><argument_list>(<argument><expr><literal type="string">"make_result()"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</expr_stmt>

	<comment type="block">/* truncate leading zeroes */</comment>
	<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>digits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>digits</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>weight</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<comment type="block">/* truncate trailing zeroes */</comment>
	<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>digits</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* If zero result, force to weight=0 and positive sign */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>weight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Build the result */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_CAN_BE_SHORT</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>, <argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name>NUMERIC_HDRSZ_SHORT</name> <operator>+</operator> <name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_short</name><operator>.</operator><name>n_header</name></name> <operator>=</operator>
			<operator>(</operator><ternary><condition><expr><name>sign</name> <operator>==</operator> <name>NUMERIC_NEG</name></expr> ?</condition><then> <expr><operator>(</operator><name>NUMERIC_SHORT</name> <operator>|</operator> <name>NUMERIC_SHORT_SIGN_MASK</name><operator>)</operator></expr>
			 </then><else>: <expr><name>NUMERIC_SHORT</name></expr></else></ternary><operator>)</operator>
			<operator>|</operator> <operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>dscale</name></name> <operator>&lt;&lt;</operator> <name>NUMERIC_SHORT_DSCALE_SHIFT</name><operator>)</operator>
			<operator>|</operator> <operator>(</operator><ternary><condition><expr><name>weight</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>NUMERIC_SHORT_WEIGHT_SIGN_MASK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
			<operator>|</operator> <operator>(</operator><name>weight</name> <operator>&amp;</operator> <name>NUMERIC_SHORT_WEIGHT_MASK</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name>NUMERIC_HDRSZ</name> <operator>+</operator> <name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_long</name><operator>.</operator><name>n_sign_dscale</name></name> <operator>=</operator>
			<name>sign</name> <operator>|</operator> <operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>dscale</name></name> <operator>&amp;</operator> <name>NUMERIC_DSCALE_MASK</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>choice</name><operator>.</operator><name>n_long</name><operator>.</operator><name>n_weight</name></name> <operator>=</operator> <name>weight</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>NUMERIC_NDIGITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>NUMERIC_DIGITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>digits</name></expr></argument>, <argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check for overflow of int16 fields */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>NUMERIC_WEIGHT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>weight</name> <operator>||</operator>
		<call><name>NUMERIC_DSCALE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>var</name><operator>-&gt;</operator><name>dscale</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value overflows numeric format"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>dump_numeric</name><argument_list>(<argument><expr><literal type="string">"make_result()"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * apply_typmod() -
 *
 *	Do bounds checking and rounding according to the attributes
 *	typmod field.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>apply_typmod</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>precision</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>scale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxdigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ddigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing if we have a default typmod (-1) */</comment>
	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>VARHDRSZ</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>typmod</name> <operator>-=</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>precision</name> <operator>=</operator> <operator>(</operator><name>typmod</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>scale</name> <operator>=</operator> <name>typmod</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxdigits</name> <operator>=</operator> <name>precision</name> <operator>-</operator> <name>scale</name></expr>;</expr_stmt>

	<comment type="block">/* Round to target scale (and set var-&gt;dscale) */</comment>
	<expr_stmt><expr><call><name>round_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for overflow - note we can't do this before rounding, because
	 * rounding could raise the weight.  Also note that the var's weight could
	 * be inflated by leading zeroes, which will be stripped before storage
	 * but perhaps might not have been yet. In any case, we must recognize a
	 * true zero, whose weight doesn't mean anything.
	 */</comment>
	<expr_stmt><expr><name>ddigits</name> <operator>=</operator> <operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ddigits</name> <operator>&gt;</operator> <name>maxdigits</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Determine true weight; and check for all-zero result */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>NumericDigit</name></type> <name>dig</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>dig</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Adjust for any high-order decimal zero digits */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>
				<if_stmt><if>if <condition>(<expr><name>dig</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>ddigits</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>dig</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>ddigits</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>dig</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>ddigits</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:elif>
				<if_stmt><if>if <condition>(<expr><name>dig</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>ddigits</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:elif>
				<comment type="block">/* no adjustment */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> unsupported NBASE</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<if_stmt><if>if <condition>(<expr><name>ddigits</name> <operator>&gt;</operator> <name>maxdigits</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"numeric field overflow"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"A field with precision %d, scale %d must round to an absolute value less than %s%d."</literal></expr></argument>,
									   <argument><expr><name>precision</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>,
					<comment type="block">/* Display 10^0 as 1 */</comment>
									   <argument><expr><ternary><condition><expr><name>maxdigits</name></expr> ?</condition><then> <expr><literal type="string">"10^"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
									   <argument><expr><ternary><condition><expr><name>maxdigits</name></expr> ?</condition><then> <expr><name>maxdigits</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>
									   )</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>ddigits</name> <operator>-=</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert numeric to int8, rounding if needed.
 *
 * If overflow, return false (no error is raised).  Return true if okay.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>numericvar_to_int64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>neg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>rounded</name></decl>;</decl_stmt>

	<comment type="block">/* Round to nearest integer */</comment>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>round_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for zero input */</comment>
	<expr_stmt><expr><call><name>strip_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndigits</name> <operator>=</operator> <name><name>rounded</name><operator>.</operator><name>ndigits</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndigits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For input like 10000000000, we must treat stripped digits as real. So
	 * the loop assumes there are weight+1 digits before the decimal point.
	 */</comment>
	<expr_stmt><expr><name>weight</name> <operator>=</operator> <name><name>rounded</name><operator>.</operator><name>weight</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>weight</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ndigits</name> <operator>&lt;=</operator> <name>weight</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Construct the result. To avoid issues with converting a value
	 * corresponding to INT64_MIN (which can't be represented as a positive 64
	 * bit two's complement integer), accumulate value as a negative number.
	 */</comment>
	<expr_stmt><expr><name>digits</name> <operator>=</operator> <name><name>rounded</name><operator>.</operator><name>digits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>neg</name> <operator>=</operator> <operator>(</operator><name><name>rounded</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_NEG</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><name><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>weight</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>pg_mul_s64_overflow</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>NBASE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>ndigits</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>pg_sub_s64_overflow</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>neg</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>val</name> <operator>==</operator> <name>PG_INT64_MIN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><name>val</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert int8 value to numeric.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>int64_to_numericvar</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>uval</name></decl>,
				<decl><type ref="prev"/><name>newuval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>

	<comment type="block">/* int64 can require at most 19 decimal digits; add one for safety */</comment>
	<expr_stmt><expr><call><name>alloc_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">20</literal> <operator>/</operator> <name>DEC_DIGITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>-</operator><name>val</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>uval</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>digits</name></name> <operator>+</operator> <name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndigits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndigits</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>newuval</name> <operator>=</operator> <name>uval</name> <operator>/</operator> <name>NBASE</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>uval</name> <operator>-</operator> <name>newuval</name> <operator>*</operator> <name>NBASE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>uval</name> <operator>=</operator> <name>newuval</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>uval</name></expr>)</condition>;</do>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <name>ndigits</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>ndigits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT128</name></cpp:ifdef>
<comment type="block">/*
 * Convert numeric to int128, rounding if needed.
 *
 * If overflow, return false (no error is raised).  Return true if okay.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>numericvar_to_int128</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int128</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int128</name></type>		<name>val</name></decl>,
				<decl><type ref="prev"/><name>oldval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>neg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>rounded</name></decl>;</decl_stmt>

	<comment type="block">/* Round to nearest integer */</comment>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>round_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for zero input */</comment>
	<expr_stmt><expr><call><name>strip_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndigits</name> <operator>=</operator> <name><name>rounded</name><operator>.</operator><name>ndigits</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ndigits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For input like 10000000000, we must treat stripped digits as real. So
	 * the loop assumes there are weight+1 digits before the decimal point.
	 */</comment>
	<expr_stmt><expr><name>weight</name> <operator>=</operator> <name><name>rounded</name><operator>.</operator><name>weight</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>weight</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ndigits</name> <operator>&lt;=</operator> <name>weight</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct the result */</comment>
	<expr_stmt><expr><name>digits</name> <operator>=</operator> <name><name>rounded</name><operator>.</operator><name>digits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>neg</name> <operator>=</operator> <operator>(</operator><name><name>rounded</name><operator>.</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_NEG</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>weight</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>oldval</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>*=</operator> <name>NBASE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>ndigits</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>val</name> <operator>+=</operator> <name><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The overflow check is a bit tricky because we want to accept
		 * INT128_MIN, which will overflow the positive accumulator.  We can
		 * detect this case easily though because INT128_MIN is the only
		 * nonzero value for which -val == val (on a two's complement machine,
		 * anyway).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>val</name> <operator>/</operator> <name>NBASE</name><operator>)</operator> <operator>!=</operator> <name>oldval</name></expr>)</condition>	<comment type="block">/* possible overflow? */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>neg</name> <operator>||</operator> <operator>(</operator><operator>-</operator><name>val</name><operator>)</operator> <operator>!=</operator> <name>val</name> <operator>||</operator> <name>val</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>oldval</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rounded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><name>val</name></expr> </then><else>: <expr><name>val</name></expr></else></ternary></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert 128 bit integer to numeric.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>int128_to_numericvar</name><parameter_list>(<parameter><decl><type><name>int128</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint128</name></type>		<name>uval</name></decl>,
				<decl><type ref="prev"/><name>newuval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>

	<comment type="block">/* int128 can require at most 39 decimal digits; add one for safety */</comment>
	<expr_stmt><expr><call><name>alloc_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">40</literal> <operator>/</operator> <name>DEC_DIGITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>-</operator><name>val</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>uval</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>digits</name></name> <operator>+</operator> <name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndigits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndigits</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>newuval</name> <operator>=</operator> <name>uval</name> <operator>/</operator> <name>NBASE</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>uval</name> <operator>-</operator> <name>newuval</name> <operator>*</operator> <name>NBASE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>uval</name> <operator>=</operator> <name>newuval</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>uval</name></expr>)</condition>;</do>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <name>ndigits</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>ndigits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Convert numeric to float8; if out of range, return +/- HUGE_VAL
 */</comment>
<function><type><name>double</name></type>
<name>numeric_to_double_no_overflow</name><parameter_list>(<parameter><decl><type><name>Numeric</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_out</name></expr></argument>,
											  <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unlike float8in, we ignore ERANGE from strtod */</comment>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* shouldn't happen ... */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><literal type="string">"double precision"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* As above, but work from a NumericVar */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>numericvar_to_double_no_overflow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>get_str_from_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unlike float8in, we ignore ERANGE from strtod */</comment>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* shouldn't happen ... */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><literal type="string">"double precision"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * cmp_var() -
 *
 *	Compare two values on variable level.  We assume zeroes have been
 *	truncated to no digits.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>cmp_var_common</name><argument_list>(<argument><expr><name><name>var1</name><operator>-&gt;</operator><name>digits</name></name></expr></argument>, <argument><expr><name><name>var1</name><operator>-&gt;</operator><name>ndigits</name></name></expr></argument>,
						  <argument><expr><name><name>var1</name><operator>-&gt;</operator><name>weight</name></name></expr></argument>, <argument><expr><name><name>var1</name><operator>-&gt;</operator><name>sign</name></name></expr></argument>,
						  <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>digits</name></name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>ndigits</name></name></expr></argument>,
						  <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>weight</name></name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>sign</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cmp_var_common() -
 *
 *	Main routine of cmp_var(). This function can be used by both
 *	NumericVar and Numeric.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_var_common</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericDigit</name> <modifier>*</modifier></type><name>var1digits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var1ndigits</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>var1weight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var1sign</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>NumericDigit</name> <modifier>*</modifier></type><name>var2digits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var2ndigits</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>var2weight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var2sign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>var1ndigits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>var2ndigits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>var2sign</name> <operator>==</operator> <name>NUMERIC_NEG</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>var2ndigits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>var1sign</name> <operator>==</operator> <name>NUMERIC_POS</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>var1sign</name> <operator>==</operator> <name>NUMERIC_POS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>var2sign</name> <operator>==</operator> <name>NUMERIC_NEG</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><call><name>cmp_abs_common</name><argument_list>(<argument><expr><name>var1digits</name></expr></argument>, <argument><expr><name>var1ndigits</name></expr></argument>, <argument><expr><name>var1weight</name></expr></argument>,
							  <argument><expr><name>var2digits</name></expr></argument>, <argument><expr><name>var2ndigits</name></expr></argument>, <argument><expr><name>var2weight</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>var2sign</name> <operator>==</operator> <name>NUMERIC_POS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>cmp_abs_common</name><argument_list>(<argument><expr><name>var2digits</name></expr></argument>, <argument><expr><name>var2ndigits</name></expr></argument>, <argument><expr><name>var2weight</name></expr></argument>,
						  <argument><expr><name>var1digits</name></expr></argument>, <argument><expr><name>var1ndigits</name></expr></argument>, <argument><expr><name>var1weight</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * add_var() -
 *
 *	Full version of add functionality on variable level (handling signs).
 *	result might point to one of the operands too without danger.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Decide on the signs of the two variables what to do
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var1</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_POS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>var2</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_POS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Both are positive result = +(ABS(var1) + ABS(var2))
			 */</comment>
			<expr_stmt><expr><call><name>add_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * var1 is positive, var2 is negative Must compare absolute values
			 */</comment>
			<switch>switch <condition>(<expr><call><name>cmp_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="number">0</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) == ABS(var2)
					 * result = ZERO
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>var1</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><literal type="number">1</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) &gt; ABS(var2)
					 * result = +(ABS(var1) - ABS(var2))
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>sub_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) &lt; ABS(var2)
					 * result = -(ABS(var2) - ABS(var1))
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>sub_abs</name><argument_list>(<argument><expr><name>var2</name></expr></argument>, <argument><expr><name>var1</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>var2</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_POS</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ----------
			 * var1 is negative, var2 is positive
			 * Must compare absolute values
			 * ----------
			 */</comment>
			<switch>switch <condition>(<expr><call><name>cmp_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="number">0</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) == ABS(var2)
					 * result = ZERO
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>var1</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><literal type="number">1</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) &gt; ABS(var2)
					 * result = -(ABS(var1) - ABS(var2))
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>sub_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) &lt; ABS(var2)
					 * result = +(ABS(var2) - ABS(var1))
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>sub_abs</name><argument_list>(<argument><expr><name>var2</name></expr></argument>, <argument><expr><name>var1</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* ----------
			 * Both are negative
			 * result = -(ABS(var1) + ABS(var2))
			 * ----------
			 */</comment>
			<expr_stmt><expr><call><name>add_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * sub_var() -
 *
 *	Full version of sub functionality on variable level (handling signs).
 *	result might point to one of the operands too without danger.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sub_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Decide on the signs of the two variables what to do
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var1</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_POS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>var2</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_NEG</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ----------
			 * var1 is positive, var2 is negative
			 * result = +(ABS(var1) + ABS(var2))
			 * ----------
			 */</comment>
			<expr_stmt><expr><call><name>add_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* ----------
			 * Both are positive
			 * Must compare absolute values
			 * ----------
			 */</comment>
			<switch>switch <condition>(<expr><call><name>cmp_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="number">0</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) == ABS(var2)
					 * result = ZERO
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>var1</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><literal type="number">1</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) &gt; ABS(var2)
					 * result = +(ABS(var1) - ABS(var2))
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>sub_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) &lt; ABS(var2)
					 * result = -(ABS(var2) - ABS(var1))
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>sub_abs</name><argument_list>(<argument><expr><name>var2</name></expr></argument>, <argument><expr><name>var1</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>var2</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_NEG</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ----------
			 * Both are negative
			 * Must compare absolute values
			 * ----------
			 */</comment>
			<switch>switch <condition>(<expr><call><name>cmp_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="number">0</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) == ABS(var2)
					 * result = ZERO
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>var1</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><literal type="number">1</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) &gt; ABS(var2)
					 * result = -(ABS(var1) - ABS(var2))
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>sub_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
					<comment type="block">/* ----------
					 * ABS(var1) &lt; ABS(var2)
					 * result = +(ABS(var2) - ABS(var1))
					 * ----------
					 */</comment>
					<expr_stmt><expr><call><name>sub_abs</name><argument_list>(<argument><expr><name>var2</name></expr></argument>, <argument><expr><name>var1</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* ----------
			 * var1 is negative, var2 is positive
			 * result = -(ABS(var1) + ABS(var2))
			 * ----------
			 */</comment>
			<expr_stmt><expr><call><name>add_abs</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * mul_var() -
 *
 *	Multiplication on variable level. Product of var1 * var2 is stored
 *	in result.  Result is rounded to no more than rscale fractional digits.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mul_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_sign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxdigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>carry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxdig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newdig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>var1ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>var2ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>var1digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>var2digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>res_digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>i1</name></decl>,
				<decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Arrange for var1 to be the shorter of the two numbers.  This improves
	 * performance because the inner multiplication loop is much simpler than
	 * the outer loop, so it's better to have a smaller number of iterations
	 * of the outer loop.  This also reduces the number of times that the
	 * accumulator array needs to be normalized.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var1</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>&gt;</operator> <name><name>var2</name><operator>-&gt;</operator><name>ndigits</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>var1</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>var1</name> <operator>=</operator> <name>var2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>var2</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* copy these values into local vars for speed in inner loop */</comment>
	<expr_stmt><expr><name>var1ndigits</name> <operator>=</operator> <name><name>var1</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>var2ndigits</name> <operator>=</operator> <name><name>var2</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>var1digits</name> <operator>=</operator> <name><name>var1</name><operator>-&gt;</operator><name>digits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>var2digits</name> <operator>=</operator> <name><name>var2</name><operator>-&gt;</operator><name>digits</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>var1ndigits</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>var2ndigits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* one or both inputs is zero; so is result */</comment>
		<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>rscale</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Determine result sign and (maximum possible) weight */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var1</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name><name>var2</name><operator>-&gt;</operator><name>sign</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res_sign</name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res_sign</name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>res_weight</name> <operator>=</operator> <name><name>var1</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <name><name>var2</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the number of result digits to compute.  If the exact result
	 * would have more than rscale fractional digits, truncate the computation
	 * with MUL_GUARD_DIGITS guard digits, i.e., ignore input digits that
	 * would only contribute to the right of that.  (This will give the exact
	 * rounded-to-rscale answer unless carries out of the ignored positions
	 * would have propagated through more than MUL_GUARD_DIGITS digits.)
	 *
	 * Note: an exact computation could not produce more than var1ndigits +
	 * var2ndigits digits, but we allocate one extra output digit in case
	 * rscale-driven rounding produces a carry out of the highest exact digit.
	 */</comment>
	<expr_stmt><expr><name>res_ndigits</name> <operator>=</operator> <name>var1ndigits</name> <operator>+</operator> <name>var2ndigits</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxdigits</name> <operator>=</operator> <name>res_weight</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>rscale</name> <operator>+</operator> <name>DEC_DIGITS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEC_DIGITS</name> <operator>+</operator>
		<name>MUL_GUARD_DIGITS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>res_ndigits</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>res_ndigits</name></expr></argument>, <argument><expr><name>maxdigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res_ndigits</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* All input digits will be ignored; so result is zero */</comment>
		<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>rscale</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We do the arithmetic in an array "dig[]" of signed int's.  Since
	 * INT_MAX is noticeably larger than NBASE*NBASE, this gives us headroom
	 * to avoid normalizing carries immediately.
	 *
	 * maxdig tracks the maximum possible value of any dig[] entry; when this
	 * threatens to exceed INT_MAX, we take the time to propagate carries.
	 * Furthermore, we need to ensure that overflow doesn't occur during the
	 * carry propagation passes either.  The carry values could be as much as
	 * INT_MAX/NBASE, so really we must normalize when digits threaten to
	 * exceed INT_MAX - INT_MAX/NBASE.
	 *
	 * To avoid overflow in maxdig itself, it actually represents the max
	 * possible value divided by NBASE-1, ie, at the top of the loop it is
	 * known that no dig[] entry exceeds maxdig * (NBASE-1).
	 */</comment>
	<expr_stmt><expr><name>dig</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>res_ndigits</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxdig</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * The least significant digits of var1 should be ignored if they don't
	 * contribute directly to the first res_ndigits digits of the result that
	 * we are computing.
	 *
	 * Digit i1 of var1 and digit i2 of var2 are multiplied and added to digit
	 * i1+i2+2 of the accumulator array, so we need only consider digits of
	 * var1 for which i1 &lt;= res_ndigits - 3.
	 */</comment>
	<for>for <control>(<init><expr><name>i1</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>var1ndigits</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>res_ndigits</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i1</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i1</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>var1digit</name> <init>= <expr><name><name>var1digits</name><index>[<expr><name>i1</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>var1digit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Time to normalize? */</comment>
		<expr_stmt><expr><name>maxdig</name> <operator>+=</operator> <name>var1digit</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>maxdig</name> <operator>&gt;</operator> <operator>(</operator><name>INT_MAX</name> <operator>-</operator> <name>INT_MAX</name> <operator>/</operator> <name>NBASE</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>NBASE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Yes, do it */</comment>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>res_ndigits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>newdig</name> <operator>=</operator> <name><name>dig</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>newdig</name> <operator>&gt;=</operator> <name>NBASE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>newdig</name> <operator>/</operator> <name>NBASE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newdig</name> <operator>-=</operator> <name>carry</name> <operator>*</operator> <name>NBASE</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>dig</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newdig</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Reset maxdig to indicate new worst-case */</comment>
			<expr_stmt><expr><name>maxdig</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>var1digit</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Add the appropriate multiple of var2 into the accumulator.
		 *
		 * As above, digits of var2 can be ignored if they don't contribute,
		 * so we only include digits for which i1+i2+2 &lt;= res_ndigits - 1.
		 */</comment>
		<for>for <control>(<init><expr><name>i2</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>var2ndigits</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>res_ndigits</name> <operator>-</operator> <name>i1</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name>i1</name> <operator>+</operator> <name>i2</name> <operator>+</operator> <literal type="number">2</literal></expr>;</init>
			 <condition><expr><name>i2</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i2</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dig</name><index>[<expr><name>i</name><operator>--</operator></expr>]</index></name> <operator>+=</operator> <name>var1digit</name> <operator>*</operator> <name><name>var2digits</name><index>[<expr><name>i2</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now we do a final carry propagation pass to normalize the result, which
	 * we combine with storing the result digits into the output. Note that
	 * this is still done at full precision w/guard digits.
	 */</comment>
	<expr_stmt><expr><call><name>alloc_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>res_ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res_digits</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>digits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>res_ndigits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>newdig</name> <operator>=</operator> <name><name>dig</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newdig</name> <operator>&gt;=</operator> <name>NBASE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>newdig</name> <operator>/</operator> <name>NBASE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newdig</name> <operator>-=</operator> <name>carry</name> <operator>*</operator> <name>NBASE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>res_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newdig</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally, round the result to the requested precision.
	 */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>res_weight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>res_sign</name></expr>;</expr_stmt>

	<comment type="block">/* Round to target rscale (and set result-&gt;dscale) */</comment>
	<expr_stmt><expr><call><name>round_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Strip leading and trailing zeroes */</comment>
	<expr_stmt><expr><call><name>strip_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * div_var() -
 *
 *	Division on variable level. Quotient of var1 / var2 is stored in result.
 *	The quotient is figured to exactly rscale fractional digits.
 *	If round is true, it is rounded at the rscale'th digit; if false, it
 *	is truncated (towards zero) at that digit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>div_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>round</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>div_ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_sign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>carry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>borrow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>divisor1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>divisor2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>dividend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>divisor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>res_digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<comment type="block">/* copy these values into local vars for speed in inner loop */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>var1ndigits</name> <init>= <expr><name><name>var1</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>var2ndigits</name> <init>= <expr><name><name>var2</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * First of all division by zero check; we must not be handed an
	 * unnormalized divisor.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>var2ndigits</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>var2</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now result zero check
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>var1ndigits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>rscale</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine the result sign, weight and number of digits to calculate.
	 * The weight figured here is correct if the emitted quotient has no
	 * leading zero digits; otherwise strip_var() will fix things up.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var1</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name><name>var2</name><operator>-&gt;</operator><name>sign</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res_sign</name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res_sign</name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>res_weight</name> <operator>=</operator> <name><name>var1</name><operator>-&gt;</operator><name>weight</name></name> <operator>-</operator> <name><name>var2</name><operator>-&gt;</operator><name>weight</name></name></expr>;</expr_stmt>
	<comment type="block">/* The number of accurate result digits we need to produce: */</comment>
	<expr_stmt><expr><name>res_ndigits</name> <operator>=</operator> <name>res_weight</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>rscale</name> <operator>+</operator> <name>DEC_DIGITS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
	<comment type="block">/* ... but always at least 1 */</comment>
	<expr_stmt><expr><name>res_ndigits</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>res_ndigits</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If rounding needed, figure one more digit to ensure correct result */</comment>
	<if_stmt><if>if <condition>(<expr><name>round</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res_ndigits</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The working dividend normally requires res_ndigits + var2ndigits
	 * digits, but make it at least var1ndigits so we can load all of var1
	 * into it.  (There will be an additional digit dividend[0] in the
	 * dividend space, but for consistency with Knuth's notation we don't
	 * count that in div_ndigits.)
	 */</comment>
	<expr_stmt><expr><name>div_ndigits</name> <operator>=</operator> <name>res_ndigits</name> <operator>+</operator> <name>var2ndigits</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>div_ndigits</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>div_ndigits</name></expr></argument>, <argument><expr><name>var1ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need a workspace with room for the working dividend (div_ndigits+1
	 * digits) plus room for the possibly-normalized divisor (var2ndigits
	 * digits).  It is convenient also to have a zero at divisor[0] with the
	 * actual divisor data in divisor[1 .. var2ndigits].  Transferring the
	 * digits into the workspace also allows us to realloc the result (which
	 * might be the same as either input var) before we begin the main loop.
	 * Note that we use palloc0 to ensure that divisor[0], dividend[0], and
	 * any additional dividend positions beyond var1ndigits, start out 0.
	 */</comment>
	<expr_stmt><expr><name>dividend</name> <operator>=</operator> <operator>(</operator><name>NumericDigit</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>div_ndigits</name> <operator>+</operator> <name>var2ndigits</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>divisor</name> <operator>=</operator> <name>dividend</name> <operator>+</operator> <operator>(</operator><name>div_ndigits</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dividend</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>var1</name><operator>-&gt;</operator><name>digits</name></name></expr></argument>, <argument><expr><name>var1ndigits</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>divisor</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>digits</name></name></expr></argument>, <argument><expr><name>var2ndigits</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NumericDigit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we can realloc the result to hold the generated quotient digits.
	 */</comment>
	<expr_stmt><expr><call><name>alloc_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>res_ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res_digits</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>digits</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>var2ndigits</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there's only a single divisor digit, we can use a fast path (cf.
		 * Knuth section 4.3.1 exercise 16).
		 */</comment>
		<expr_stmt><expr><name>divisor1</name> <operator>=</operator> <name><name>divisor</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>res_ndigits</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>carry</name> <operator>*</operator> <name>NBASE</name> <operator>+</operator> <name><name>dividend</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>res_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>carry</name> <operator>/</operator> <name>divisor1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>carry</name> <operator>%</operator> <name>divisor1</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The full multiple-place algorithm is taken from Knuth volume 2,
		 * Algorithm 4.3.1D.
		 *
		 * We need the first divisor digit to be &gt;= NBASE/2.  If it isn't,
		 * make it so by scaling up both the divisor and dividend by the
		 * factor "d".  (The reason for allocating dividend[0] above is to
		 * leave room for possible carry here.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>divisor</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>HALF_NBASE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>d</name> <init>= <expr><name>NBASE</name> <operator>/</operator> <operator>(</operator><name><name>divisor</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>var2ndigits</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>carry</name> <operator>+=</operator> <name><name>divisor</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>d</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>divisor</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>carry</name> <operator>%</operator> <name>NBASE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>carry</name> <operator>/</operator> <name>NBASE</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<comment type="block">/* at this point only var1ndigits of dividend can be nonzero */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>var1ndigits</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>carry</name> <operator>+=</operator> <name><name>dividend</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>d</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dividend</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>carry</name> <operator>%</operator> <name>NBASE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>carry</name> <operator>/</operator> <name>NBASE</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>divisor</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <name>HALF_NBASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* First 2 divisor digits are used repeatedly in main loop */</comment>
		<expr_stmt><expr><name>divisor1</name> <operator>=</operator> <name><name>divisor</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>divisor2</name> <operator>=</operator> <name><name>divisor</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Begin the main loop.  Each iteration of this loop produces the j'th
		 * quotient digit by dividing dividend[j .. j + var2ndigits] by the
		 * divisor; this is essentially the same as the common manual
		 * procedure for long division.
		 */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>res_ndigits</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Estimate quotient digit from the first two dividend digits */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>next2digits</name> <init>= <expr><name><name>dividend</name><index>[<expr><name>j</name></expr>]</index></name> <operator>*</operator> <name>NBASE</name> <operator>+</operator> <name><name>dividend</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>qhat</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If next2digits are 0, then quotient digit must be 0 and there's
			 * no need to adjust the working dividend.  It's worth testing
			 * here to fall out ASAP when processing trailing zeroes in a
			 * dividend.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>next2digits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>res_digits</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>dividend</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>divisor1</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>qhat</name> <operator>=</operator> <name>NBASE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>qhat</name> <operator>=</operator> <name>next2digits</name> <operator>/</operator> <name>divisor1</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Adjust quotient digit if it's too large.  Knuth proves that
			 * after this step, the quotient digit will be either correct or
			 * just one too large.  (Note: it's OK to use dividend[j+2] here
			 * because we know the divisor length is at least 2.)
			 */</comment>
			<while>while <condition>(<expr><name>divisor2</name> <operator>*</operator> <name>qhat</name> <operator>&gt;</operator>
				   <operator>(</operator><name>next2digits</name> <operator>-</operator> <name>qhat</name> <operator>*</operator> <name>divisor1</name><operator>)</operator> <operator>*</operator> <name>NBASE</name> <operator>+</operator> <name><name>dividend</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>qhat</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

			<comment type="block">/* As above, need do nothing more when quotient digit is 0 */</comment>
			<if_stmt><if>if <condition>(<expr><name>qhat</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Multiply the divisor by qhat, and subtract that from the
				 * working dividend.  "carry" tracks the multiplication,
				 * "borrow" the subtraction (could we fold these together?)
				 */</comment>
				<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>borrow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>var2ndigits</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name>carry</name> <operator>+=</operator> <name><name>divisor</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>qhat</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>borrow</name> <operator>-=</operator> <name>carry</name> <operator>%</operator> <name>NBASE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>carry</name> <operator>/</operator> <name>NBASE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>borrow</name> <operator>+=</operator> <name><name>dividend</name><index>[<expr><name>j</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>borrow</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>dividend</name><index>[<expr><name>j</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>borrow</name> <operator>+</operator> <name>NBASE</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>borrow</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>dividend</name><index>[<expr><name>j</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>borrow</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>borrow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we got a borrow out of the top dividend digit, then
				 * indeed qhat was one too large.  Fix it, and add back the
				 * divisor to correct the working dividend.  (Knuth proves
				 * that this will occur only about 3/NBASE of the time; hence,
				 * it's a good idea to test this code with small NBASE to be
				 * sure this section gets exercised.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>borrow</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>qhat</name><operator>--</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>var2ndigits</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
					<block>{<block_content>
						<expr_stmt><expr><name>carry</name> <operator>+=</operator> <name><name>dividend</name><index>[<expr><name>j</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>+</operator> <name><name>divisor</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>carry</name> <operator>&gt;=</operator> <name>NBASE</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>dividend</name><index>[<expr><name>j</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>carry</name> <operator>-</operator> <name>NBASE</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><name><name>dividend</name><index>[<expr><name>j</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></for>
					<comment type="block">/* A carry should occur here to cancel the borrow above */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* And we're done with this quotient digit */</comment>
			<expr_stmt><expr><name><name>res_digits</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>qhat</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dividend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally, round or truncate the result to the requested precision.
	 */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>res_weight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>res_sign</name></expr>;</expr_stmt>

	<comment type="block">/* Round or truncate to target rscale (and set result-&gt;dscale) */</comment>
	<if_stmt><if>if <condition>(<expr><name>round</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>round_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>trunc_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Strip leading and trailing zeroes */</comment>
	<expr_stmt><expr><call><name>strip_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * div_var_fast() -
 *
 *	This has the same API as div_var, but is implemented using the division
 *	algorithm from the "FM" library, rather than Knuth's schoolbook-division
 *	approach.  This is significantly faster but can produce inaccurate
 *	results, because it sometimes has to propagate rounding to the left,
 *	and so we can never be entirely sure that we know the requested digits
 *	exactly.  We compute DIV_GUARD_DIGITS extra digits, but there is
 *	no certainty that that's enough.  We use this only in the transcendental
 *	function calculation routines, where everything is approximate anyway.
 *
 *	Although we provide a "round" argument for consistency with div_var,
 *	it is unwise to use this function with round=false.  In truncation mode
 *	it is possible to get a result with no significant digits, for example
 *	with rscale=0 we might compute 0.99999... and truncate that to 0 when
 *	the correct answer is 1.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>div_var_fast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>,
			 <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>round</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>div_ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_sign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>div</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>qdigit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>carry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxdiv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newdig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>res_digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>fdividend</name></decl>,
				<decl><type ref="prev"/><name>fdivisor</name></decl>,
				<decl><type ref="prev"/><name>fdivisorinverse</name></decl>,
				<decl><type ref="prev"/><name>fquotient</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>qi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* copy these values into local vars for speed in inner loop */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>var1ndigits</name> <init>= <expr><name><name>var1</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>var2ndigits</name> <init>= <expr><name><name>var2</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>var1digits</name> <init>= <expr><name><name>var1</name><operator>-&gt;</operator><name>digits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>var2digits</name> <init>= <expr><name><name>var2</name><operator>-&gt;</operator><name>digits</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * First of all division by zero check; we must not be handed an
	 * unnormalized divisor.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>var2ndigits</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>var2digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now result zero check
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>var1ndigits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>rscale</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine the result sign, weight and number of digits to calculate
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var1</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name><name>var2</name><operator>-&gt;</operator><name>sign</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res_sign</name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res_sign</name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>res_weight</name> <operator>=</operator> <name><name>var1</name><operator>-&gt;</operator><name>weight</name></name> <operator>-</operator> <name><name>var2</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* The number of accurate result digits we need to produce: */</comment>
	<expr_stmt><expr><name>div_ndigits</name> <operator>=</operator> <name>res_weight</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>rscale</name> <operator>+</operator> <name>DEC_DIGITS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
	<comment type="block">/* Add guard digits for roundoff error */</comment>
	<expr_stmt><expr><name>div_ndigits</name> <operator>+=</operator> <name>DIV_GUARD_DIGITS</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>div_ndigits</name> <operator>&lt;</operator> <name>DIV_GUARD_DIGITS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>div_ndigits</name> <operator>=</operator> <name>DIV_GUARD_DIGITS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Must be at least var1ndigits, too, to simplify data-loading loop */</comment>
	<if_stmt><if>if <condition>(<expr><name>div_ndigits</name> <operator>&lt;</operator> <name>var1ndigits</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>div_ndigits</name> <operator>=</operator> <name>var1ndigits</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We do the arithmetic in an array "div[]" of signed int's.  Since
	 * INT_MAX is noticeably larger than NBASE*NBASE, this gives us headroom
	 * to avoid normalizing carries immediately.
	 *
	 * We start with div[] containing one zero digit followed by the
	 * dividend's digits (plus appended zeroes to reach the desired precision
	 * including guard digits).  Each step of the main loop computes an
	 * (approximate) quotient digit and stores it into div[], removing one
	 * position of dividend space.  A final pass of carry propagation takes
	 * care of any mistaken quotient digits.
	 */</comment>
	<expr_stmt><expr><name>div</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>div_ndigits</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>var1ndigits</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>div</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>var1digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * We estimate each quotient digit using floating-point arithmetic, taking
	 * the first four digits of the (current) dividend and divisor.  This must
	 * be float to avoid overflow.  The quotient digits will generally be off
	 * by no more than one from the exact answer.
	 */</comment>
	<expr_stmt><expr><name>fdivisor</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>var2digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>fdivisor</name> <operator>*=</operator> <name>NBASE</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>var2ndigits</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fdivisor</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>var2digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>fdivisorinverse</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>fdivisor</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * maxdiv tracks the maximum possible absolute value of any div[] entry;
	 * when this threatens to exceed INT_MAX, we take the time to propagate
	 * carries.  Furthermore, we need to ensure that overflow doesn't occur
	 * during the carry propagation passes either.  The carry values may have
	 * an absolute value as high as INT_MAX/NBASE + 1, so really we must
	 * normalize when digits threaten to exceed INT_MAX - INT_MAX/NBASE - 1.
	 *
	 * To avoid overflow in maxdiv itself, it represents the max absolute
	 * value divided by NBASE-1, ie, at the top of the loop it is known that
	 * no div[] entry has an absolute value exceeding maxdiv * (NBASE-1).
	 *
	 * Actually, though, that holds good only for div[] entries after div[qi];
	 * the adjustment done at the bottom of the loop may cause div[qi + 1] to
	 * exceed the maxdiv limit, so that div[qi] in the next iteration is
	 * beyond the limit.  This does not cause problems, as explained below.
	 */</comment>
	<expr_stmt><expr><name>maxdiv</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Outer loop computes next quotient digit, which will go into div[qi]
	 */</comment>
	<for>for <control>(<init><expr><name>qi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>qi</name> <operator>&lt;</operator> <name>div_ndigits</name></expr>;</condition> <incr><expr><name>qi</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Approximate the current dividend value */</comment>
		<expr_stmt><expr><name>fdividend</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>div</name><index>[<expr><name>qi</name></expr>]</index></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>fdividend</name> <operator>*=</operator> <name>NBASE</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>+</operator> <name>i</name> <operator>&lt;=</operator> <name>div_ndigits</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>fdividend</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>div</name><index>[<expr><name>qi</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<comment type="block">/* Compute the (approximate) quotient digit */</comment>
		<expr_stmt><expr><name>fquotient</name> <operator>=</operator> <name>fdividend</name> <operator>*</operator> <name>fdivisorinverse</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>qdigit</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>fquotient</name> <operator>&gt;=</operator> <literal type="number">0.0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name>fquotient</name><operator>)</operator></expr> </then><else>:
			<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name>fquotient</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>	<comment type="block">/* truncate towards -infinity */</comment>

		<if_stmt><if>if <condition>(<expr><name>qdigit</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Do we need to normalize now? */</comment>
			<expr_stmt><expr><name>maxdiv</name> <operator>+=</operator> <call><name>Abs</name><argument_list>(<argument><expr><name>qdigit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>maxdiv</name> <operator>&gt;</operator> <operator>(</operator><name>INT_MAX</name> <operator>-</operator> <name>INT_MAX</name> <operator>/</operator> <name>NBASE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>NBASE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Yes, do it */</comment>
				<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>div_ndigits</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <name>qi</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name>newdig</name> <operator>=</operator> <name><name>div</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>newdig</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>carry</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><operator>-</operator><name>newdig</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>NBASE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<expr_stmt><expr><name>newdig</name> <operator>-=</operator> <name>carry</name> <operator>*</operator> <name>NBASE</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>newdig</name> <operator>&gt;=</operator> <name>NBASE</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>newdig</name> <operator>/</operator> <name>NBASE</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>newdig</name> <operator>-=</operator> <name>carry</name> <operator>*</operator> <name>NBASE</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<expr_stmt><expr><name><name>div</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newdig</name></expr>;</expr_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><name>newdig</name> <operator>=</operator> <name><name>div</name><index>[<expr><name>qi</name></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>div</name><index>[<expr><name>qi</name></expr>]</index></name> <operator>=</operator> <name>newdig</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * All the div[] digits except possibly div[qi] are now in the
				 * range 0..NBASE-1.  We do not need to consider div[qi] in
				 * the maxdiv value anymore, so we can reset maxdiv to 1.
				 */</comment>
				<expr_stmt><expr><name>maxdiv</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

				<comment type="block">/*
				 * Recompute the quotient digit since new info may have
				 * propagated into the top four dividend digits
				 */</comment>
				<expr_stmt><expr><name>fdividend</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>div</name><index>[<expr><name>qi</name></expr>]</index></name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name>fdividend</name> <operator>*=</operator> <name>NBASE</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>+</operator> <name>i</name> <operator>&lt;=</operator> <name>div_ndigits</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>fdividend</name> <operator>+=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>div</name><index>[<expr><name>qi</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>
				<comment type="block">/* Compute the (approximate) quotient digit */</comment>
				<expr_stmt><expr><name>fquotient</name> <operator>=</operator> <name>fdividend</name> <operator>*</operator> <name>fdivisorinverse</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>qdigit</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>fquotient</name> <operator>&gt;=</operator> <literal type="number">0.0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name>fquotient</name><operator>)</operator></expr> </then><else>:
					<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name>fquotient</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>	<comment type="block">/* truncate towards -infinity */</comment>
				<expr_stmt><expr><name>maxdiv</name> <operator>+=</operator> <call><name>Abs</name><argument_list>(<argument><expr><name>qdigit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Subtract off the appropriate multiple of the divisor.
			 *
			 * The digits beyond div[qi] cannot overflow, because we know they
			 * will fall within the maxdiv limit.  As for div[qi] itself, note
			 * that qdigit is approximately trunc(div[qi] / vardigits[0]),
			 * which would make the new value simply div[qi] mod vardigits[0].
			 * The lower-order terms in qdigit can change this result by not
			 * more than about twice INT_MAX/NBASE, so overflow is impossible.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>qdigit</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>istop</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>var2ndigits</name></expr></argument>, <argument><expr><name>div_ndigits</name> <operator>-</operator> <name>qi</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>istop</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>div</name><index>[<expr><name>qi</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>-=</operator> <name>qdigit</name> <operator>*</operator> <name><name>var2digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The dividend digit we are about to replace might still be nonzero.
		 * Fold it into the next digit position.
		 *
		 * There is no risk of overflow here, although proving that requires
		 * some care.  Much as with the argument for div[qi] not overflowing,
		 * if we consider the first two terms in the numerator and denominator
		 * of qdigit, we can see that the final value of div[qi + 1] will be
		 * approximately a remainder mod (vardigits[0]*NBASE + vardigits[1]).
		 * Accounting for the lower-order terms is a bit complicated but ends
		 * up adding not much more than INT_MAX/NBASE to the possible range.
		 * Thus, div[qi + 1] cannot overflow here, and in its role as div[qi]
		 * in the next loop iteration, it can't be large enough to cause
		 * overflow in the carry propagation step (if any), either.
		 *
		 * But having said that: div[qi] can be more than INT_MAX/NBASE, as
		 * noted above, which means that the product div[qi] * NBASE *can*
		 * overflow.  When that happens, adding it to div[qi + 1] will always
		 * cause a canceling overflow so that the end result is correct.  We
		 * could avoid the intermediate overflow by doing the multiplication
		 * and addition in int64 arithmetic, but so far there appears no need.
		 */</comment>
		<expr_stmt><expr><name><name>div</name><index>[<expr><name>qi</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name><name>div</name><index>[<expr><name>qi</name></expr>]</index></name> <operator>*</operator> <name>NBASE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>div</name><index>[<expr><name>qi</name></expr>]</index></name> <operator>=</operator> <name>qdigit</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Approximate and store the last quotient digit (div[div_ndigits])
	 */</comment>
	<expr_stmt><expr><name>fdividend</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>div</name><index>[<expr><name>qi</name></expr>]</index></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fdividend</name> <operator>*=</operator> <name>NBASE</name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name>fquotient</name> <operator>=</operator> <name>fdividend</name> <operator>*</operator> <name>fdivisorinverse</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>qdigit</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>fquotient</name> <operator>&gt;=</operator> <literal type="number">0.0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name>fquotient</name><operator>)</operator></expr> </then><else>:
		<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name>fquotient</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>	<comment type="block">/* truncate towards -infinity */</comment>
	<expr_stmt><expr><name><name>div</name><index>[<expr><name>qi</name></expr>]</index></name> <operator>=</operator> <name>qdigit</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Because the quotient digits might be off by one, some of them might be
	 * -1 or NBASE at this point.  The represented value is correct in a
	 * mathematical sense, but it doesn't look right.  We do a final carry
	 * propagation pass to normalize the digits, which we combine with storing
	 * the result digits into the output.  Note that this is still done at
	 * full precision w/guard digits.
	 */</comment>
	<expr_stmt><expr><call><name>alloc_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>div_ndigits</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res_digits</name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>digits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>div_ndigits</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>newdig</name> <operator>=</operator> <name><name>div</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newdig</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><operator>-</operator><name>newdig</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>NBASE</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>newdig</name> <operator>-=</operator> <name>carry</name> <operator>*</operator> <name>NBASE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>newdig</name> <operator>&gt;=</operator> <name>NBASE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>newdig</name> <operator>/</operator> <name>NBASE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newdig</name> <operator>-=</operator> <name>carry</name> <operator>*</operator> <name>NBASE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>res_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newdig</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally, round the result to the requested precision.
	 */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>res_weight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>res_sign</name></expr>;</expr_stmt>

	<comment type="block">/* Round to target rscale (and set result-&gt;dscale) */</comment>
	<if_stmt><if>if <condition>(<expr><name>round</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>round_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>trunc_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Strip leading and trailing zeroes */</comment>
	<expr_stmt><expr><call><name>strip_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Default scale selection for division
 *
 * Returns the appropriate result scale for the division result.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>select_div_scale</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>weight1</name></decl>,
				<decl><type ref="prev"/><name>weight2</name></decl>,
				<decl><type ref="prev"/><name>qweight</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name></type> <name>firstdigit1</name></decl>,
				<decl><type ref="prev"/><name>firstdigit2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rscale</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The result scale of a division isn't specified in any SQL standard. For
	 * PostgreSQL we select a result scale that will give at least
	 * NUMERIC_MIN_SIG_DIGITS significant digits, so that numeric gives a
	 * result no less accurate than float8; but use a scale not less than
	 * either input's display scale.
	 */</comment>

	<comment type="block">/* Get the actual (normalized) weight and first digit of each input */</comment>

	<expr_stmt><expr><name>weight1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* values to use if var1 is zero */</comment>
	<expr_stmt><expr><name>firstdigit1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>var1</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>firstdigit1</name> <operator>=</operator> <name><name>var1</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>firstdigit1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>weight1</name> <operator>=</operator> <name><name>var1</name><operator>-&gt;</operator><name>weight</name></name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>weight2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* values to use if var2 is zero */</comment>
	<expr_stmt><expr><name>firstdigit2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>var2</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>firstdigit2</name> <operator>=</operator> <name><name>var2</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>firstdigit2</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>weight2</name> <operator>=</operator> <name><name>var2</name><operator>-&gt;</operator><name>weight</name></name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Estimate weight of quotient.  If the two first digits are equal, we
	 * can't be sure, but assume that var1 is less than var2.
	 */</comment>
	<expr_stmt><expr><name>qweight</name> <operator>=</operator> <name>weight1</name> <operator>-</operator> <name>weight2</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>firstdigit1</name> <operator>&lt;=</operator> <name>firstdigit2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>qweight</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Select result scale */</comment>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <name>NUMERIC_MIN_SIG_DIGITS</name> <operator>-</operator> <name>qweight</name> <operator>*</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name><name>var1</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MAX_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rscale</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * mod_var() -
 *
 *	Calculate the modulo of two numerics at variable level
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mod_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ---------
	 * We do this using the equation
	 *		mod(x,y) = x - trunc(x/y)*y
	 * div_var can be persuaded to give us trunc(x/y) directly.
	 * ----------
	 */</comment>
	<expr_stmt><expr><call><name>div_var</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><name>var2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ceil_var() -
 *
 *	Return the smallest integer greater than or equal to the argument
 *	on variable level
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ceil_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>trunc_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_POS</name> <operator>&amp;&amp;</operator> <call><name>cmp_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * floor_var() -
 *
 *	Return the largest integer equal to or less than the argument
 *	on variable level
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>floor_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>tmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>trunc_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_NEG</name> <operator>&amp;&amp;</operator> <call><name>cmp_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * sqrt_var() -
 *
 *	Compute the square root of x using Newton's algorithm
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sqrt_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>tmp_arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>tmp_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>last_val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>local_rscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>stat</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <name>rscale</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>stat</name> <operator>=</operator> <call><name>cmp_var</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>stat</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>rscale</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * SQL2003 defines sqrt() in terms of power, so we need to emit the right
	 * SQLSTATE error code if the operand is negative.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stat</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot take square root of a negative number"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy arg in case it is the same var as result */</comment>
	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the result to the first guess
	 */</comment>
	<expr_stmt><expr><call><name>alloc_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>tmp_arg</name><operator>.</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name><name>tmp_arg</name><operator>.</operator><name>weight</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>div_var_fast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_arg</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_val</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_val</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero_point_five</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_val</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Round to requested precision */</comment>
	<expr_stmt><expr><call><name>round_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * exp_var() -
 *
 *	Raise e to the power of x, computed to rscale fractional digits
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>exp_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>elem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>ni</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dweight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndiv2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sig_digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>local_rscale</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate the dweight of the result using floating point arithmetic, so
	 * that we can choose an appropriate local rscale for the calculation.
	 */</comment>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>numericvar_to_double_no_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Guard against overflow */</comment>
	<comment type="block">/* If you change this limit, see also power_var()'s limit */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NUMERIC_MAX_RESULT_SCALE</name> <operator>*</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value overflows numeric format"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* decimal weight = log10(e^x) = x * log10(e) */</comment>
	<expr_stmt><expr><name>dweight</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>val</name> <operator>*</operator> <literal type="number">0.434294481903252</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reduce x to the range -0.01 &lt;= x &lt;= 0.01 (approximately) by dividing by
	 * 2^n, to improve the convergence rate of the Taylor series.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0.01</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>tmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_two</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ndiv2</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0.01</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ndiv2</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>val</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <name><name>x</name><operator>.</operator><name>dscale</name></name> <operator>+</operator> <name>ndiv2</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>div_var_fast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ndiv2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Set the scale for the Taylor series expansion.  The final result has
	 * (dweight + rscale + 1) significant digits.  In addition, we have to
	 * raise the Taylor series result to the power 2^ndiv2, which introduces
	 * an error of up to around log10(2^ndiv2) digits, so work with this many
	 * extra digits of precision (plus a few more for good measure).
	 */</comment>
	<expr_stmt><expr><name>sig_digits</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>dweight</name> <operator>+</operator> <name>rscale</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>ndiv2</name> <operator>*</operator> <literal type="number">0.301029995663981</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>sig_digits</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>sig_digits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <name>sig_digits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use the Taylor series
	 *
	 * exp(x) = 1 + x + x^2/2! + x^3/3! + ...
	 *
	 * Given the limited range of x, this should converge reasonably quickly.
	 * We run the series until the terms fall below the local_rscale limit.
	 */</comment>
	<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_two</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>div_var_fast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>elem</name><operator>.</operator><name>ndigits</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>div_var_fast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Compensate for the argument range reduction.  Since the weight of the
	 * result doubles with each multiplication, we can reduce the local rscale
	 * as we proceed.
	 */</comment>
	<while>while <condition>(<expr><name>ndiv2</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <name>sig_digits</name> <operator>-</operator> <name><name>result</name><operator>-&gt;</operator><name>weight</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Round to requested rscale */</comment>
	<expr_stmt><expr><call><name>round_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Estimate the dweight of the most significant decimal digit of the natural
 * logarithm of a number.
 *
 * Essentially, we're approximating log10(abs(ln(var))).  This is used to
 * determine the appropriate rscale when computing natural logarithms.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>estimate_ln_dweight</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ln_dweight</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero_point_nine</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>cmp_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one_point_one</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * 0.9 &lt;= var &lt;= 1.1
		 *
		 * ln(var) has a negative weight (possibly very large).  To get a
		 * reasonably accurate result, estimate it using ln(1+x) ~= x.
		 */</comment>
		<decl_stmt><decl><type><name>NumericVar</name></type>	<name>x</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>x</name><operator>.</operator><name>ndigits</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Use weight of most significant decimal digit of x */</comment>
			<expr_stmt><expr><name>ln_dweight</name> <operator>=</operator> <name><name>x</name><operator>.</operator><name>weight</name></name> <operator>*</operator> <name>DEC_DIGITS</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>log10</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* x = 0.  Since ln(1) = 0 exactly, we don't need extra digits */</comment>
			<expr_stmt><expr><name>ln_dweight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Estimate the logarithm using the first couple of digits from the
		 * input number.  This will give an accurate result whenever the input
		 * is not too close to 1.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>digits</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>dweight</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>ln_var</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>digits</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dweight</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>*</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>digits</name> <operator>=</operator> <name>digits</name> <operator>*</operator> <name>NBASE</name> <operator>+</operator> <name><name>var</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>dweight</name> <operator>-=</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*----------
			 * We have var ~= digits * 10^dweight
			 * so ln(var) ~= ln(digits) + dweight * ln(10)
			 *----------
			 */</comment>
			<expr_stmt><expr><name>ln_var</name> <operator>=</operator> <call><name>log</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>digits</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>dweight</name> <operator>*</operator> <literal type="number">2.302585092994046</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>ln_dweight</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>log10</name><argument_list>(<argument><expr><call><name>Abs</name><argument_list>(<argument><expr><name>ln_var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Caller should fail on ln(0), but for the moment return zero */</comment>
			<expr_stmt><expr><name>ln_dweight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>ln_dweight</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ln_var() -
 *
 *	Compute the natural log of x
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ln_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>xx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>ni</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>elem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>fact</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>local_rscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>cmp_var</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_LOG</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot take logarithm of zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_LOG</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot take logarithm of a negative number"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_two</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reduce input into range 0.9 &lt; x &lt; 1.1 with repeated sqrt() operations.
	 *
	 * The final logarithm will have up to around rscale+6 significant digits.
	 * Each sqrt() will roughly halve the weight of x, so adjust the local
	 * rscale as we work so that we keep this many significant digits at each
	 * step (plus a few more for good measure).
	 */</comment>
	<while>while <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero_point_nine</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <name>rscale</name> <operator>-</operator> <name><name>x</name><operator>.</operator><name>weight</name></name> <operator>*</operator> <name>DEC_DIGITS</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sqrt_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_two</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<while>while <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one_point_one</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <name>rscale</name> <operator>-</operator> <name><name>x</name><operator>.</operator><name>weight</name></name> <operator>*</operator> <name>DEC_DIGITS</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sqrt_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_two</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * We use the Taylor series for 0.5 * ln((1+z)/(1-z)),
	 *
	 * z + z^3/3 + z^5/5 + ...
	 *
	 * where z = (x-1)/(x+1) is in the range (approximately) -0.053 .. 0.048
	 * due to the above range-reduction of x.
	 *
	 * The convergence of this is not as fast as one would like, but is
	 * tolerable given that z is small.
	 */</comment>
	<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <name>rscale</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sub_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>div_var_fast</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_two</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xx</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>div_var_fast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>.</operator><name>ndigits</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>.</operator><name>weight</name></name> <operator>&lt;</operator> <operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>weight</name></name> <operator>-</operator> <name>local_rscale</name> <operator>*</operator> <literal type="number">2</literal> <operator>/</operator> <name>DEC_DIGITS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Compensate for argument range reduction, round to requested rscale */</comment>
	<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * log_var() -
 *
 *	Compute the logarithm of num in a given base.
 *
 *	Note: this routine chooses dscale of the result.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>ln_base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>ln_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ln_base_dweight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ln_num_dweight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_dweight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ln_base_rscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ln_num_rscale</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimated dweights of ln(base), ln(num) and the final result */</comment>
	<expr_stmt><expr><name>ln_base_dweight</name> <operator>=</operator> <call><name>estimate_ln_dweight</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ln_num_dweight</name> <operator>=</operator> <call><name>estimate_ln_dweight</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result_dweight</name> <operator>=</operator> <name>ln_num_dweight</name> <operator>-</operator> <name>ln_base_dweight</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Select the scale of the result so that it will have at least
	 * NUMERIC_MIN_SIG_DIGITS significant digits and is not less than either
	 * input's display scale.
	 */</comment>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <name>NUMERIC_MIN_SIG_DIGITS</name> <operator>-</operator> <name>result_dweight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name><name>base</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name><name>num</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MAX_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the scales for ln(base) and ln(num) so that they each have more
	 * significant digits than the final result.
	 */</comment>
	<expr_stmt><expr><name>ln_base_rscale</name> <operator>=</operator> <name>rscale</name> <operator>+</operator> <name>result_dweight</name> <operator>-</operator> <name>ln_base_dweight</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ln_base_rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>ln_base_rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ln_num_rscale</name> <operator>=</operator> <name>rscale</name> <operator>+</operator> <name>result_dweight</name> <operator>-</operator> <name>ln_num_dweight</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ln_num_rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>ln_num_rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Form natural logarithms */</comment>
	<expr_stmt><expr><call><name>ln_var</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ln_base</name></expr></argument>, <argument><expr><name>ln_base_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ln_var</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ln_num</name></expr></argument>, <argument><expr><name>ln_num_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Divide and round to the required scale */</comment>
	<expr_stmt><expr><call><name>div_var_fast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ln_base</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * power_var() -
 *
 *	Raise base to the power of exp
 *
 *	Note: this routine chooses dscale of the result.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>power_var</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>exp</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>ln_base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>ln_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ln_dweight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>local_rscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>

	<comment type="block">/* If exp can be represented as an integer, use power_var_int */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>exp</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>exp</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>&lt;=</operator> <name><name>exp</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* exact integer, but does it fit in int? */</comment>
		<decl_stmt><decl><type><name>int64</name></type>		<name>expval64</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>numericvar_to_int64</name><argument_list>(<argument><expr><name>exp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expval64</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>expval</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name>expval64</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Test for overflow by reverse-conversion. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int64</name><operator>)</operator> <name>expval</name> <operator>==</operator> <name>expval64</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Okay, select rscale */</comment>
				<expr_stmt><expr><name>rscale</name> <operator>=</operator> <name>NUMERIC_MIN_SIG_DIGITS</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name><name>base</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MAX_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>power_var_int</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>expval</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This avoids log(0) for cases of 0 raised to a non-integer.  0 ^ 0 is
	 * handled by power_var_int().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>cmp_var</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>NUMERIC_MIN_SIG_DIGITS</name></expr>;</expr_stmt>	<comment type="block">/* no need to round */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*----------
	 * Decide on the scale for the ln() calculation.  For this we need an
	 * estimate of the weight of the result, which we obtain by doing an
	 * initial low-precision calculation of exp * ln(base).
	 *
	 * We want result = e ^ (exp * ln(base))
	 * so result dweight = log10(result) = exp * ln(base) * log10(e)
	 *
	 * We also perform a crude overflow test here so that we can exit early if
	 * the full-precision result is sure to overflow, and to guard against
	 * integer overflow when determining the scale for the real calculation.
	 * exp_var() supports inputs up to NUMERIC_MAX_RESULT_SCALE * 3, so the
	 * result will overflow if exp * ln(base) &gt;= NUMERIC_MAX_RESULT_SCALE * 3.
	 * Since the values here are only approximations, we apply a small fuzz
	 * factor to this overflow test and let exp_var() determine the exact
	 * overflow threshold so that it is consistent for all inputs.
	 *----------
	 */</comment>
	<expr_stmt><expr><name>ln_dweight</name> <operator>=</operator> <call><name>estimate_ln_dweight</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <literal type="number">8</literal> <operator>-</operator> <name>ln_dweight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MAX_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ln_var</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ln_base</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_base</name></expr></argument>, <argument><expr><name>exp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ln_num</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>numericvar_to_double_no_overflow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initial overflow test with fuzz factor */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>NUMERIC_MAX_RESULT_SCALE</name> <operator>*</operator> <literal type="number">3.01</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value overflows numeric format"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>val</name> <operator>*=</operator> <literal type="number">0.434294481903252</literal></expr>;</expr_stmt>	<comment type="block">/* approximate decimal result weight */</comment>

	<comment type="block">/* choose the result scale */</comment>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <name>NUMERIC_MIN_SIG_DIGITS</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>val</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name><name>base</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name><name>exp</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MAX_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set the scale for the real exp * ln(base) calculation */</comment>
	<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <name>rscale</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>val</name> <operator>-</operator> <name>ln_dweight</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and do the real calculation */</comment>

	<expr_stmt><expr><call><name>ln_var</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ln_base</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_base</name></expr></argument>, <argument><expr><name>exp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ln_num</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>exp_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_num</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * power_var_int() -
 *
 *	Raise base to the power of exp, where exp is an integer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>power_var_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exp</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sig_digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>neg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>base_prod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>local_rscale</name></decl>;</decl_stmt>

	<comment type="block">/* Handle some common special cases, as well as corner cases */</comment>
	<switch>switch <condition>(<expr><name>exp</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>

			<comment type="block">/*
			 * While 0 ^ 0 can be either 1 or indeterminate (error), we treat
			 * it as 1 because most programming languages do this. SQL:2003
			 * also requires a return value of 1.
			 * https://en.wikipedia.org/wiki/Exponentiation#Zero_to_the_zero_power
			 */</comment>
			<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>rscale</name></expr>;</expr_stmt>	<comment type="block">/* no need to round */</comment>
			<return>return;</return>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>round_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>div_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Handle the special case where the base is zero */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>base</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>exp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>rscale</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The general case repeatedly multiplies base according to the bit
	 * pattern of exp.
	 *
	 * First we need to estimate the weight of the result so that we know how
	 * many significant digits are needed.
	 */</comment>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <name><name>base</name><operator>-&gt;</operator><name>digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>base</name><operator>-&gt;</operator><name>weight</name></name> <operator>*</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>base</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>*</operator> <name>DEC_DIGITS</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>f</name> <operator>=</operator> <name>f</name> <operator>*</operator> <name>NBASE</name> <operator>+</operator> <name><name>base</name><operator>-&gt;</operator><name>digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>-=</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*----------
	 * We have base ~= f * 10^p
	 * so log10(result) = log10(base^exp) ~= exp * (log10(f) + p)
	 *----------
	 */</comment>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <name>exp</name> <operator>*</operator> <operator>(</operator><call><name>log10</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Apply crude overflow/underflow tests so we can exit early if the result
	 * certainly will overflow/underflow.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>*</operator> <name>SHRT_MAX</name> <operator>*</operator> <name>DEC_DIGITS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value overflows numeric format"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <operator>-</operator><name>rscale</name> <operator>||</operator> <name>f</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <operator>-</operator><name>NUMERIC_MAX_DISPLAY_SCALE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>rscale</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Approximate number of significant digits in the result.  Note that the
	 * underflow test above means that this is necessarily &gt;= 0.
	 */</comment>
	<expr_stmt><expr><name>sig_digits</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>rscale</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>f</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The multiplications to produce the result may introduce an error of up
	 * to around log10(abs(exp)) digits, so work with this many extra digits
	 * of precision (plus a few more for good measure).
	 */</comment>
	<expr_stmt><expr><name>sig_digits</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>log</name><argument_list>(<argument><expr><call><name>Abs</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we can proceed with the multiplications.
	 */</comment>
	<expr_stmt><expr><name>neg</name> <operator>=</operator> <operator>(</operator><name>exp</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>mask</name> <operator>=</operator> <call><name>Abs</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base_prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>mask</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do the multiplications using rscales large enough to hold the
		 * results to the required number of significant digits, but don't
		 * waste time by exceeding the scales of the numbers themselves.
		 */</comment>
		<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <name>sig_digits</name> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>base_prod</name><operator>.</operator><name>weight</name></name> <operator>*</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name><name>base_prod</name><operator>.</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base_prod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_prod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_prod</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <name>sig_digits</name> <operator>-</operator>
				<operator>(</operator><name><name>base_prod</name><operator>.</operator><name>weight</name></name> <operator>+</operator> <name><name>result</name><operator>-&gt;</operator><name>weight</name></name><operator>)</operator> <operator>*</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>local_rscale</name></expr></argument>,
							   <argument><expr><name><name>base_prod</name><operator>.</operator><name>dscale</name></name> <operator>+</operator> <name><name>result</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>local_rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>local_rscale</name></expr></argument>, <argument><expr><name>NUMERIC_MIN_DISPLAY_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>mul_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base_prod</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>local_rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * When abs(base) &gt; 1, the number of digits to the left of the decimal
		 * point in base_prod doubles at each iteration, so if exp is large we
		 * could easily spend large amounts of time and memory space doing the
		 * multiplications.  But once the weight exceeds what will fit in
		 * int16, the final result is guaranteed to overflow (or underflow, if
		 * exp &lt; 0), so we can give up before wasting too many cycles.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>base_prod</name><operator>.</operator><name>weight</name></name> <operator>&gt;</operator> <name>SHRT_MAX</name> <operator>||</operator> <name><name>result</name><operator>-&gt;</operator><name>weight</name></name> <operator>&gt;</operator> <name>SHRT_MAX</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* overflow, unless neg, in which case result should be 0 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>neg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value overflows numeric format"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>zero_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>neg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base_prod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compensate for input sign, and round to requested rscale */</comment>
	<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>div_var_fast</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_one</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>round_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------------
 *
 * Following are the lowest level functions that operate unsigned
 * on the variable level
 *
 * ----------------------------------------------------------------------
 */</comment>


<comment type="block">/* ----------
 * cmp_abs() -
 *
 *	Compare the absolute values of var1 and var2
 *	Returns:	-1 for ABS(var1) &lt; ABS(var2)
 *				0  for ABS(var1) == ABS(var2)
 *				1  for ABS(var1) &gt; ABS(var2)
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_abs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>cmp_abs_common</name><argument_list>(<argument><expr><name><name>var1</name><operator>-&gt;</operator><name>digits</name></name></expr></argument>, <argument><expr><name><name>var1</name><operator>-&gt;</operator><name>ndigits</name></name></expr></argument>, <argument><expr><name><name>var1</name><operator>-&gt;</operator><name>weight</name></name></expr></argument>,
						  <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>digits</name></name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>ndigits</name></name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>weight</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * cmp_abs_common() -
 *
 *	Main routine of cmp_abs(). This function can be used by both
 *	NumericVar and Numeric.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_abs_common</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericDigit</name> <modifier>*</modifier></type><name>var1digits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var1ndigits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var1weight</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>NumericDigit</name> <modifier>*</modifier></type><name>var2digits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var2ndigits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>var2weight</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check any digits before the first common digit */</comment>

	<while>while <condition>(<expr><name>var1weight</name> <operator>&gt;</operator> <name>var2weight</name> <operator>&amp;&amp;</operator> <name>i1</name> <operator>&lt;</operator> <name>var1ndigits</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>var1digits</name><index>[<expr><name>i1</name><operator>++</operator></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>var1weight</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<while>while <condition>(<expr><name>var2weight</name> <operator>&gt;</operator> <name>var1weight</name> <operator>&amp;&amp;</operator> <name>i2</name> <operator>&lt;</operator> <name>var2ndigits</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>var2digits</name><index>[<expr><name>i2</name><operator>++</operator></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>var2weight</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* At this point, either w1 == w2 or we've run out of digits */</comment>

	<if_stmt><if>if <condition>(<expr><name>var1weight</name> <operator>==</operator> <name>var2weight</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name>i1</name> <operator>&lt;</operator> <name>var1ndigits</name> <operator>&amp;&amp;</operator> <name>i2</name> <operator>&lt;</operator> <name>var2ndigits</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>stat</name> <init>= <expr><name><name>var1digits</name><index>[<expr><name>i1</name><operator>++</operator></expr>]</index></name> <operator>-</operator> <name><name>var2digits</name><index>[<expr><name>i2</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>stat</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>stat</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At this point, we've run out of digits on one side or the other; so any
	 * remaining nonzero digits imply that side is larger
	 */</comment>
	<while>while <condition>(<expr><name>i1</name> <operator>&lt;</operator> <name>var1ndigits</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>var1digits</name><index>[<expr><name>i1</name><operator>++</operator></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<while>while <condition>(<expr><name>i2</name> <operator>&lt;</operator> <name>var2ndigits</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>var2digits</name><index>[<expr><name>i2</name><operator>++</operator></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * add_abs() -
 *
 *	Add the absolute values of two variables into result.
 *	result might point to one of the operands without danger.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_abs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>res_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>res_digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_rscale</name></decl>,
				<decl><type ref="prev"/><name>rscale1</name></decl>,
				<decl><type ref="prev"/><name>rscale2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_dscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>i1</name></decl>,
				<decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>carry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* copy these values into local vars for speed in inner loop */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>var1ndigits</name> <init>= <expr><name><name>var1</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>var2ndigits</name> <init>= <expr><name><name>var2</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>var1digits</name> <init>= <expr><name><name>var1</name><operator>-&gt;</operator><name>digits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>var2digits</name> <init>= <expr><name><name>var2</name><operator>-&gt;</operator><name>digits</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>res_weight</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>var1</name><operator>-&gt;</operator><name>weight</name></name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>weight</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>res_dscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>var1</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Note: here we are figuring rscale in base-NBASE digits */</comment>
	<expr_stmt><expr><name>rscale1</name> <operator>=</operator> <name><name>var1</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>-</operator> <name><name>var1</name><operator>-&gt;</operator><name>weight</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale2</name> <operator>=</operator> <name><name>var2</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>-</operator> <name><name>var2</name><operator>-&gt;</operator><name>weight</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>res_rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale1</name></expr></argument>, <argument><expr><name>rscale2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res_ndigits</name> <operator>=</operator> <name>res_rscale</name> <operator>+</operator> <name>res_weight</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res_ndigits</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res_ndigits</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res_buf</name> <operator>=</operator> <call><name>digitbuf_alloc</name><argument_list>(<argument><expr><name>res_ndigits</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* spare digit for later rounding */</comment>
	<expr_stmt><expr><name>res_digits</name> <operator>=</operator> <name>res_buf</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>i1</name> <operator>=</operator> <name>res_rscale</name> <operator>+</operator> <name><name>var1</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i2</name> <operator>=</operator> <name>res_rscale</name> <operator>+</operator> <name><name>var2</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>res_ndigits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>i1</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>i2</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i1</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i1</name> <operator>&lt;</operator> <name>var1ndigits</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>carry</name> <operator>+=</operator> <name><name>var1digits</name><index>[<expr><name>i1</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>i2</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i2</name> <operator>&lt;</operator> <name>var2ndigits</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>carry</name> <operator>+=</operator> <name><name>var2digits</name><index>[<expr><name>i2</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>carry</name> <operator>&gt;=</operator> <name>NBASE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>res_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>carry</name> <operator>-</operator> <name>NBASE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>res_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* else we failed to allow for carry out */</comment>

	<expr_stmt><expr><call><name>digitbuf_free</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <name>res_ndigits</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>res_buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>res_digits</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>res_weight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>res_dscale</name></expr>;</expr_stmt>

	<comment type="block">/* Remove leading/trailing zeroes */</comment>
	<expr_stmt><expr><call><name>strip_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * sub_abs()
 *
 *	Subtract the absolute value of var2 from the absolute value of var1
 *	and store in result. result might point to one of the operands
 *	without danger.
 *
 *	ABS(var1) MUST BE GREATER OR EQUAL ABS(var2) !!!
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sub_abs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>res_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>res_digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_rscale</name></decl>,
				<decl><type ref="prev"/><name>rscale1</name></decl>,
				<decl><type ref="prev"/><name>rscale2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>res_dscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>i1</name></decl>,
				<decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>borrow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* copy these values into local vars for speed in inner loop */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>var1ndigits</name> <init>= <expr><name><name>var1</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>var2ndigits</name> <init>= <expr><name><name>var2</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>var1digits</name> <init>= <expr><name><name>var1</name><operator>-&gt;</operator><name>digits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>var2digits</name> <init>= <expr><name><name>var2</name><operator>-&gt;</operator><name>digits</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>res_weight</name> <operator>=</operator> <name><name>var1</name><operator>-&gt;</operator><name>weight</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>res_dscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>var1</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>, <argument><expr><name><name>var2</name><operator>-&gt;</operator><name>dscale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Note: here we are figuring rscale in base-NBASE digits */</comment>
	<expr_stmt><expr><name>rscale1</name> <operator>=</operator> <name><name>var1</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>-</operator> <name><name>var1</name><operator>-&gt;</operator><name>weight</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rscale2</name> <operator>=</operator> <name><name>var2</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>-</operator> <name><name>var2</name><operator>-&gt;</operator><name>weight</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>res_rscale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>rscale1</name></expr></argument>, <argument><expr><name>rscale2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res_ndigits</name> <operator>=</operator> <name>res_rscale</name> <operator>+</operator> <name>res_weight</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res_ndigits</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res_ndigits</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>res_buf</name> <operator>=</operator> <call><name>digitbuf_alloc</name><argument_list>(<argument><expr><name>res_ndigits</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* spare digit for later rounding */</comment>
	<expr_stmt><expr><name>res_digits</name> <operator>=</operator> <name>res_buf</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>i1</name> <operator>=</operator> <name>res_rscale</name> <operator>+</operator> <name><name>var1</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i2</name> <operator>=</operator> <name>res_rscale</name> <operator>+</operator> <name><name>var2</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>res_ndigits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>i1</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>i2</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i1</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i1</name> <operator>&lt;</operator> <name>var1ndigits</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>borrow</name> <operator>+=</operator> <name><name>var1digits</name><index>[<expr><name>i1</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>i2</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i2</name> <operator>&lt;</operator> <name>var2ndigits</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>borrow</name> <operator>-=</operator> <name><name>var2digits</name><index>[<expr><name>i2</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>borrow</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>res_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>borrow</name> <operator>+</operator> <name>NBASE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>borrow</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>res_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>borrow</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>borrow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>borrow</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else caller gave us var1 &lt; var2 */</comment>

	<expr_stmt><expr><call><name>digitbuf_free</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <name>res_ndigits</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>res_buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>res_digits</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>res_weight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>res_dscale</name></expr>;</expr_stmt>

	<comment type="block">/* Remove leading/trailing zeroes */</comment>
	<expr_stmt><expr><call><name>strip_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * round_var
 *
 * Round the value of a variable to no more than rscale decimal digits
 * after the decimal point.  NOTE: we allow rscale &lt; 0 here, implying
 * rounding before the decimal point.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>round_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>di</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>carry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>rscale</name></expr>;</expr_stmt>

	<comment type="block">/* decimal digits wanted */</comment>
	<expr_stmt><expr><name>di</name> <operator>=</operator> <operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>DEC_DIGITS</name> <operator>+</operator> <name>rscale</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If di = 0, the value loses all digits, but could round up to 1 if its
	 * first extra digit is &gt;= 5.  If di &lt; 0 the result must be 0.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>di</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* NBASE digits wanted */</comment>
		<expr_stmt><expr><name>ndigits</name> <operator>=</operator> <operator>(</operator><name>di</name> <operator>+</operator> <name>DEC_DIGITS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>

		<comment type="block">/* 0, or number of decimal digits to keep in last NBASE digit */</comment>
		<expr_stmt><expr><name>di</name> <operator>%=</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ndigits</name> <operator>&lt;</operator> <name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>||</operator>
			<operator>(</operator><name>ndigits</name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>&amp;&amp;</operator> <name>di</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <name>ndigits</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
			<comment type="block">/* di must be zero */</comment>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>digits</name><index>[<expr><name>ndigits</name></expr>]</index></name> <operator>&gt;=</operator> <name>HALF_NBASE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<if_stmt><if>if <condition>(<expr><name>di</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>carry</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>digits</name><index>[<expr><name>ndigits</name></expr>]</index></name> <operator>&gt;=</operator> <name>HALF_NBASE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Must round within last NBASE digit */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>extra</name></decl>,
							<decl><type ref="prev"/><name>pow10</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>
				<expr_stmt><expr><name>pow10</name> <operator>=</operator> <name><name>round_powers</name><index>[<expr><name>di</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:elif>
				<expr_stmt><expr><name>pow10</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> unsupported NBASE</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>extra</name> <operator>=</operator> <name><name>digits</name><index>[<expr><operator>--</operator><name>ndigits</name></expr>]</index></name> <operator>%</operator> <name>pow10</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>digits</name><index>[<expr><name>ndigits</name></expr>]</index></name> <operator>-=</operator> <name>extra</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>&gt;=</operator> <name>pow10</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>pow10</name> <operator>+=</operator> <name><name>digits</name><index>[<expr><name>ndigits</name></expr>]</index></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>pow10</name> <operator>&gt;=</operator> <name>NBASE</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>pow10</name> <operator>-=</operator> <name>NBASE</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>digits</name><index>[<expr><name>ndigits</name></expr>]</index></name> <operator>=</operator> <name>pow10</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/* Propagate carry if needed */</comment>
			<while>while <condition>(<expr><name>carry</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>carry</name> <operator>+=</operator> <name><name>digits</name><index>[<expr><operator>--</operator><name>ndigits</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>carry</name> <operator>&gt;=</operator> <name>NBASE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>digits</name><index>[<expr><name>ndigits</name></expr>]</index></name> <operator>=</operator> <name>carry</name> <operator>-</operator> <name>NBASE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>digits</name><index>[<expr><name>ndigits</name></expr>]</index></name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>ndigits</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndigits</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* better not have added &gt; 1 digit */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name> <operator>&gt;</operator> <name><name>var</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * trunc_var
 *
 * Truncate (towards zero) the value of a variable at rscale decimal digits
 * after the decimal point.  NOTE: we allow rscale &lt; 0 here, implying
 * truncation before the decimal point.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>trunc_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rscale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>di</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name>rscale</name></expr>;</expr_stmt>

	<comment type="block">/* decimal digits wanted */</comment>
	<expr_stmt><expr><name>di</name> <operator>=</operator> <operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>DEC_DIGITS</name> <operator>+</operator> <name>rscale</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If di &lt;= 0, the value loses all digits.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>di</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* NBASE digits wanted */</comment>
		<expr_stmt><expr><name>ndigits</name> <operator>=</operator> <operator>(</operator><name>di</name> <operator>+</operator> <name>DEC_DIGITS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ndigits</name> <operator>&lt;=</operator> <name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <name>ndigits</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
			<comment type="block">/* no within-digit stuff to worry about */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<comment type="block">/* 0, or number of decimal digits to keep in last NBASE digit */</comment>
			<expr_stmt><expr><name>di</name> <operator>%=</operator> <name>DEC_DIGITS</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>di</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Must truncate within last NBASE digit */</comment>
				<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>extra</name></decl>,
							<decl><type ref="prev"/><name>pow10</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:if>
				<expr_stmt><expr><name>pow10</name> <operator>=</operator> <name><name>round_powers</name><index>[<expr><name>di</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>DEC_DIGITS</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:elif>
				<expr_stmt><expr><name>pow10</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> unsupported NBASE</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>extra</name> <operator>=</operator> <name><name>digits</name><index>[<expr><operator>--</operator><name>ndigits</name></expr>]</index></name> <operator>%</operator> <name>pow10</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>digits</name><index>[<expr><name>ndigits</name></expr>]</index></name> <operator>-=</operator> <name>extra</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * strip_var
 *
 * Strip any leading and trailing zeroes from a numeric variable
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>strip_var</name><parameter_list>(<parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Strip leading zeroes */</comment>
	<while>while <condition>(<expr><name>ndigits</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>digits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>digits</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndigits</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Strip trailing zeroes */</comment>
	<while>while <condition>(<expr><name>ndigits</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>digits</name><index>[<expr><name>ndigits</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ndigits</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* If it's zero, normalize the sign and weight */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndigits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>digits</name></name> <operator>=</operator> <name>digits</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <name>ndigits</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------------
 *
 * Fast sum accumulator functions
 *
 * ----------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Reset the accumulator's value to zero.  The buffers to hold the digits
 * are not free'd.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>accum_sum_reset</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>accum</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>pos_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>neg_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Accumulate a new value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>accum_sum_add</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>accum_digits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>val_i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>val_ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericDigit</name> <modifier>*</modifier></type><name>val_digits</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we have accumulated too many values since the last carry
	 * propagation, do it now, to avoid overflowing.  (We could allow more
	 * than NBASE - 1, if we reserved two extra digits, rather than one, for
	 * carry propagation.  But even with NBASE - 1, this needs to be done so
	 * seldom, that the performance difference is negligible.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>accum</name><operator>-&gt;</operator><name>num_uncarried</name></name> <operator>==</operator> <name>NBASE</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>accum_sum_carry</name><argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Adjust the weight or scale of the old value, so that it can accommodate
	 * the new value.
	 */</comment>
	<expr_stmt><expr><call><name>accum_sum_rescale</name><argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <name>NUMERIC_POS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>accum_digits</name> <operator>=</operator> <name><name>accum</name><operator>-&gt;</operator><name>pos_digits</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>accum_digits</name> <operator>=</operator> <name><name>accum</name><operator>-&gt;</operator><name>neg_digits</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* copy these values into local vars for speed in loop */</comment>
	<expr_stmt><expr><name>val_ndigits</name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>val_digits</name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>digits</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>accum</name><operator>-&gt;</operator><name>weight</name></name> <operator>-</operator> <name><name>val</name><operator>-&gt;</operator><name>weight</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>val_i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>val_i</name> <operator>&lt;</operator> <name>val_ndigits</name></expr>;</condition> <incr><expr><name>val_i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>accum_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name><name>val_digits</name><index>[<expr><name>val_i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>num_uncarried</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Propagate carries.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>accum_sum_carry</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>dig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>carry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>newdig</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If no new values have been added since last carry propagation, nothing
	 * to do.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>accum</name><operator>-&gt;</operator><name>num_uncarried</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We maintain that the weight of the accumulator is always one larger
	 * than needed to hold the current value, before carrying, to make sure
	 * there is enough space for the possible extra digit when carry is
	 * propagated.  We cannot expand the buffer here, unless we require
	 * callers of accum_sum_final() to switch to the right memory context.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>accum</name><operator>-&gt;</operator><name>pos_digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>accum</name><operator>-&gt;</operator><name>neg_digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ndigits</name> <operator>=</operator> <name><name>accum</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</expr_stmt>

	<comment type="block">/* Propagate carry in the positive sum */</comment>
	<expr_stmt><expr><name>dig</name> <operator>=</operator> <name><name>accum</name><operator>-&gt;</operator><name>pos_digits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ndigits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>newdig</name> <operator>=</operator> <name><name>dig</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newdig</name> <operator>&gt;=</operator> <name>NBASE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>newdig</name> <operator>/</operator> <name>NBASE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newdig</name> <operator>-=</operator> <name>carry</name> <operator>*</operator> <name>NBASE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>dig</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newdig</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Did we use up the digit reserved for carry propagation? */</comment>
	<if_stmt><if>if <condition>(<expr><name>newdig</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>have_carry_space</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And the same for the negative sum */</comment>
	<expr_stmt><expr><name>dig</name> <operator>=</operator> <name><name>accum</name><operator>-&gt;</operator><name>neg_digits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ndigits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>newdig</name> <operator>=</operator> <name><name>dig</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newdig</name> <operator>&gt;=</operator> <name>NBASE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>newdig</name> <operator>/</operator> <name>NBASE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newdig</name> <operator>-=</operator> <name>carry</name> <operator>*</operator> <name>NBASE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>dig</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>newdig</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>newdig</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>have_carry_space</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>num_uncarried</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Re-scale accumulator to accommodate new value.
 *
 * If the new value has more digits than the current digit buffers in the
 * accumulator, enlarge the buffers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>accum_sum_rescale</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NumericVar</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>old_weight</name> <init>= <expr><name><name>accum</name><operator>-&gt;</operator><name>weight</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>old_ndigits</name> <init>= <expr><name><name>accum</name><operator>-&gt;</operator><name>ndigits</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>accum_ndigits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>accum_weight</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>accum_rscale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>val_rscale</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>accum_weight</name> <operator>=</operator> <name>old_weight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>accum_ndigits</name> <operator>=</operator> <name>old_ndigits</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Does the new value have a larger weight? If so, enlarge the buffers,
	 * and shift the existing value to the new weight, by adding leading
	 * zeros.
	 *
	 * We enforce that the accumulator always has a weight one larger than
	 * needed for the inputs, so that we have space for an extra digit at the
	 * final carry-propagation phase, if necessary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>weight</name></name> <operator>&gt;=</operator> <name>accum_weight</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>accum_weight</name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>weight</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>accum_ndigits</name> <operator>=</operator> <name>accum_ndigits</name> <operator>+</operator> <operator>(</operator><name>accum_weight</name> <operator>-</operator> <name>old_weight</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * Even though the new value is small, we might've used up the space
	 * reserved for the carry digit in the last call to accum_sum_carry().  If
	 * so, enlarge to make room for another one.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>accum</name><operator>-&gt;</operator><name>have_carry_space</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>accum_weight</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>accum_ndigits</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Is the new value wider on the right side? */</comment>
	<expr_stmt><expr><name>accum_rscale</name> <operator>=</operator> <name>accum_ndigits</name> <operator>-</operator> <name>accum_weight</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val_rscale</name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>-</operator> <name><name>val</name><operator>-&gt;</operator><name>weight</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>val_rscale</name> <operator>&gt;</operator> <name>accum_rscale</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>accum_ndigits</name> <operator>=</operator> <name>accum_ndigits</name> <operator>+</operator> <operator>(</operator><name>val_rscale</name> <operator>-</operator> <name>accum_rscale</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>accum_ndigits</name> <operator>!=</operator> <name>old_ndigits</name> <operator>||</operator>
		<name>accum_weight</name> <operator>!=</operator> <name>old_weight</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>new_pos_digits</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>new_neg_digits</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>weightdiff</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>weightdiff</name> <operator>=</operator> <name>accum_weight</name> <operator>-</operator> <name>old_weight</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_pos_digits</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>accum_ndigits</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_neg_digits</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>accum_ndigits</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>accum</name><operator>-&gt;</operator><name>pos_digits</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_pos_digits</name><index>[<expr><name>weightdiff</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>accum</name><operator>-&gt;</operator><name>pos_digits</name></name></expr></argument>,
				   <argument><expr><name>old_ndigits</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>accum</name><operator>-&gt;</operator><name>pos_digits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_neg_digits</name><index>[<expr><name>weightdiff</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>accum</name><operator>-&gt;</operator><name>neg_digits</name></name></expr></argument>,
				   <argument><expr><name>old_ndigits</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>accum</name><operator>-&gt;</operator><name>neg_digits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>pos_digits</name></name> <operator>=</operator> <name>new_pos_digits</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>neg_digits</name></name> <operator>=</operator> <name>new_neg_digits</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name>accum_weight</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <name>accum_ndigits</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>accum</name><operator>-&gt;</operator><name>pos_digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>accum</name><operator>-&gt;</operator><name>neg_digits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>have_carry_space</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>dscale</name></name> <operator>&gt;</operator> <name><name>accum</name><operator>-&gt;</operator><name>dscale</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>accum</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>dscale</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the current value of the accumulator.  This perform final carry
 * propagation, and adds together the positive and negative sums.
 *
 * Unlike all the other routines, the caller is not required to switch to
 * the memory context that holds the accumulator.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>accum_sum_final</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>, <parameter><decl><type><name>NumericVar</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>pos_var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>neg_var</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>accum</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_var_from_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>const_zero</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Perform final carry */</comment>
	<expr_stmt><expr><call><name>accum_sum_carry</name><argument_list>(<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create NumericVars representing the positive and negative sums */</comment>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pos_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>neg_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pos_var</name><operator>.</operator><name>ndigits</name></name> <operator>=</operator> <name><name>neg_var</name><operator>.</operator><name>ndigits</name></name> <operator>=</operator> <name><name>accum</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pos_var</name><operator>.</operator><name>weight</name></name> <operator>=</operator> <name><name>neg_var</name><operator>.</operator><name>weight</name></name> <operator>=</operator> <name><name>accum</name><operator>-&gt;</operator><name>weight</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pos_var</name><operator>.</operator><name>dscale</name></name> <operator>=</operator> <name><name>neg_var</name><operator>.</operator><name>dscale</name></name> <operator>=</operator> <name><name>accum</name><operator>-&gt;</operator><name>dscale</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pos_var</name><operator>.</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_POS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>neg_var</name><operator>.</operator><name>sign</name></name> <operator>=</operator> <name>NUMERIC_NEG</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pos_var</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name><name>pos_var</name><operator>.</operator><name>digits</name></name> <operator>=</operator> <call><name>digitbuf_alloc</name><argument_list>(<argument><expr><name><name>accum</name><operator>-&gt;</operator><name>ndigits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>neg_var</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name><name>neg_var</name><operator>.</operator><name>digits</name></name> <operator>=</operator> <call><name>digitbuf_alloc</name><argument_list>(<argument><expr><name><name>accum</name><operator>-&gt;</operator><name>ndigits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>accum</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>accum</name><operator>-&gt;</operator><name>pos_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>NBASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pos_var</name><operator>.</operator><name>digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <name><name>accum</name><operator>-&gt;</operator><name>pos_digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>accum</name><operator>-&gt;</operator><name>neg_digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>NBASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>neg_var</name><operator>.</operator><name>digits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int16</name><operator>)</operator> <name><name>accum</name><operator>-&gt;</operator><name>neg_digits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* And add them together */</comment>
	<expr_stmt><expr><call><name>add_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pos_var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>neg_var</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove leading/trailing zeroes */</comment>
	<expr_stmt><expr><call><name>strip_var</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy an accumulator's state.
 *
 * 'dst' is assumed to be uninitialized beforehand.  No attempt is made at
 * freeing old values.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>accum_sum_copy</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>pos_digits</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>neg_digits</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>pos_digits</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>pos_digits</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>neg_digits</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>neg_digits</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>num_uncarried</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>num_uncarried</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>ndigits</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>ndigits</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>weight</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>weight</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>dscale</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>dscale</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add the current value of 'accum2' into 'accum'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>accum_sum_combine</name><parameter_list>(<parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum</name></decl></parameter>, <parameter><decl><type><name>NumericSumAccum</name> <modifier>*</modifier></type><name>accum2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NumericVar</name></type>	<name>tmp_var</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>accum_sum_final</name><argument_list>(<argument><expr><name>accum2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>accum_sum_add</name><argument_list>(<argument><expr><name>accum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
