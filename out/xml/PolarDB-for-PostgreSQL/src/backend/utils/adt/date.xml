<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/adt/date.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * date.c
 *	  implements DATE and TIME data types specified in SQL standard
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994-5, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/date.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datetime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/nabstime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sortsupport.h"</cpp:file></cpp:include>

<comment type="block">/*
 * gcc's -ffast-math switch breaks routines that expect exact results from
 * expressions like timeval / SECS_PER_HOUR, where timeval is double.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__FAST_MATH__</name></cpp:ifdef>
<cpp:error>#<cpp:directive>error</cpp:directive> -ffast-math is known to break this code</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>tm2time</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>TimeADT</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>tm2timetz</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tz</name></decl></parameter>, <parameter><decl><type><name>TimeTzADT</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdjustTimeForTypmod</name><parameter_list>(<parameter><decl><type><name>TimeADT</name> <modifier>*</modifier></type><name>time</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* common code for timetypmodin and timetztypmodin */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>anytime_typmodin</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>istz</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>ta</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name>	   <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>ArrayGetIntegerTypmods</name><argument_list>(<argument><expr><name>ta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we're not too tense about good error message here because grammar
	 * shouldn't allow wrong number of modifiers for TIME
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid type modifier"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>anytime_typmod_check</name><argument_list>(<argument><expr><name>istz</name></expr></argument>, <argument><expr><name><name>tl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* exported so parse_expr.c can use it */</comment>
<function><type><name>int32</name></type>
<name>anytime_typmod_check</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>istz</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TIME(%d)%s precision must not be negative"</literal></expr></argument>,
						<argument><expr><name>typmod</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>istz</name></expr> ?</condition><then> <expr><literal type="string">" WITH TIME ZONE"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;</operator> <name>MAX_TIME_PRECISION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TIME(%d)%s precision reduced to maximum allowed, %d"</literal></expr></argument>,
						<argument><expr><name>typmod</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>istz</name></expr> ?</condition><then> <expr><literal type="string">" WITH TIME ZONE"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						<argument><expr><name>MAX_TIME_PRECISION</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typmod</name> <operator>=</operator> <name>MAX_TIME_PRECISION</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>typmod</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* common code for timetypmodout and timetztypmodout */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>anytime_typmodout</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>istz</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tz</name> <init>= <expr><ternary><condition><expr><name>istz</name></expr> ?</condition><then> <expr><literal type="string">" with time zone"</literal></expr> </then><else>: <expr><literal type="string">" without time zone"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%d)%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>typmod</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>tz</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 Date ADT
 *****************************************************************************/</comment>


<comment type="block">/* date_in()
 * Given date text string, convert to internal date format.
 */</comment>
<function><type><name>Datum</name></type>
<name>date_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>date</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tzp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>field</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>ftype</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>workbuf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseDateTime</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>workbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						  <argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>MAXDATEFIELDS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeDateTime</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>dterr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"date"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>dtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTK_DATE</name></expr>:</case>
			<break>break;</break>

		<case>case <expr><name>DTK_CURRENT</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date/time value \"current\" is no longer supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>GetCurrentDateTime</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_EPOCH</name></expr>:</case>
			<expr_stmt><expr><call><name>GetEpochTime</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTK_LATE</name></expr>:</case>
			<expr_stmt><expr><call><name>DATE_NOEND</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<case>case <expr><name>DTK_EARLY</name></expr>:</case>
			<expr_stmt><expr><call><name>DATE_NOBEGIN</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<default>default:</default>
			<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>DTERR_BAD_FORMAT</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"date"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Prevent overflow in Julian-day routines */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_JULIAN</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</expr_stmt>

	<comment type="block">/* Now check for just-out-of-range dates */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_DATE</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range: \"%s\""</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* date_out()
 * Given internal format date, convert to text string.
 */</comment>
<function><type><name>Datum</name></type>
<name>date_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>date</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EncodeSpecialDate</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>date</name> <operator>+</operator> <name>POSTGRES_EPOCH_JDATE</name></expr></argument>,
			   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EncodeDateOnly</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>DateStyle</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		date_recv			- converts external binary format to date
 */</comment>
<function><type><name>Datum</name></type>
<name>date_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>DateADT</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DateADT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Limit to the same range that date_in() accepts. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* ok */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IS_VALID_DATE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		date_send			- converts date to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>date_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>date</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		make_date			- date constructor
 */</comment>
<function><type><name>Datum</name></type>
<name>make_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>date</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle negative years as BC */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>.</operator><name>tm_year</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ValidateDate</name><argument_list>(<argument><expr><name>DTK_DATE_M</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>bc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_FIELD_OVERFLOW</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date field value out of range: %d-%02d-%02d"</literal></expr></argument>,
						<argument><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Prevent overflow in Julian-day routines */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_JULIAN</name><argument_list>(<argument><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range: %d-%02d-%02d"</literal></expr></argument>,
						<argument><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</expr_stmt>

	<comment type="block">/* Now check for just-out-of-range dates */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_DATE</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range: %d-%02d-%02d"</literal></expr></argument>,
						<argument><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert reserved date values to string.
 */</comment>
<function><type><name>void</name></type>
<name>EncodeSpecialDate</name><parameter_list>(<parameter><decl><type><name>DateADT</name></type> <name>dt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>DATE_IS_NOBEGIN</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>EARLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>DATE_IS_NOEND</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>LATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>						<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid argument for EncodeSpecialDate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetSQLCurrentDate -- implements CURRENT_DATE
 */</comment>
<function><type><name>DateADT</name></type>
<name>GetSQLCurrentDate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>ts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetSQLCurrentTime -- implements CURRENT_TIME, CURRENT_TIME(n)
 */</comment>
<function><type><name>TimeTzADT</name> <modifier>*</modifier></type>
<name>GetSQLCurrentTime</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>ts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimeTzADT</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeTzADT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tm2timetz</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AdjustTimeForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>time</name></name><operator>)</operator></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetSQLLocalTime -- implements LOCALTIME, LOCALTIME(n)
 */</comment>
<function><type><name>TimeADT</name></type>
<name>GetSQLLocalTime</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>ts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>tm2time</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AdjustTimeForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Comparison functions for dates
 */</comment>

<function><type><name>Datum</name></type>
<name>date_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal1</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal2</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>dateVal1</name> <operator>==</operator> <name>dateVal2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal1</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal2</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>dateVal1</name> <operator>!=</operator> <name>dateVal2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal1</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal2</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>dateVal1</name> <operator>&lt;</operator> <name>dateVal2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal1</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal2</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>dateVal1</name> <operator>&lt;=</operator> <name>dateVal2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal1</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal2</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>dateVal1</name> <operator>&gt;</operator> <name>dateVal2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal1</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal2</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>dateVal1</name> <operator>&gt;=</operator> <name>dateVal2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal1</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal2</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>dateVal1</name> <operator>&lt;</operator> <name>dateVal2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>dateVal1</name> <operator>&gt;</operator> <name>dateVal2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>date_fastcmp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>a</name> <init>= <expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>b</name> <init>= <expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_sortsupport</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name> <init>= <expr><operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>date_fastcmp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_finite</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>date</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_larger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal1</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal2</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>dateVal1</name> <operator>&gt;</operator> <name>dateVal2</name><operator>)</operator></expr> ?</condition><then> <expr><name>dateVal1</name></expr> </then><else>: <expr><name>dateVal2</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_smaller</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal1</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal2</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>dateVal1</name> <operator>&lt;</operator> <name>dateVal2</name><operator>)</operator></expr> ?</condition><then> <expr><name>dateVal1</name></expr> </then><else>: <expr><name>dateVal2</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Compute difference between two dates in days.
 */</comment>
<function><type><name>Datum</name></type>
<name>date_mi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal1</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal2</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>dateVal1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>dateVal2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot subtract infinite dates"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>dateVal1</name> <operator>-</operator> <name>dateVal2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a number of days to a date, giving a new date.
 * Must handle both positive and negative numbers of days.
 */</comment>
<function><type><name>Datum</name></type>
<name>date_pli</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>days</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* can't change infinity */</comment>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>dateVal</name> <operator>+</operator> <name>days</name></expr>;</expr_stmt>

	<comment type="block">/* Check for integer overflow and out-of-allowed-range */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name>days</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>result</name> <operator>&lt;</operator> <name>dateVal</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>result</name> <operator>&gt;</operator> <name>dateVal</name><operator>)</operator></expr></else></ternary><operator>)</operator> <operator>||</operator>
		<operator>!</operator><call><name>IS_VALID_DATE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Subtract a number of days from a date, giving a new date.
 */</comment>
<function><type><name>Datum</name></type>
<name>date_mii</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>days</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* can't change infinity */</comment>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>dateVal</name> <operator>-</operator> <name>days</name></expr>;</expr_stmt>

	<comment type="block">/* Check for integer overflow and out-of-allowed-range */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name>days</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>result</name> <operator>&gt;</operator> <name>dateVal</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>result</name> <operator>&lt;</operator> <name>dateVal</name><operator>)</operator></expr></else></ternary><operator>)</operator> <operator>||</operator>
		<operator>!</operator><call><name>IS_VALID_DATE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Internal routines for promoting date to timestamp and timestamp with
 * time zone
 */</comment>

<function><type><specifier>static</specifier> <name>Timestamp</name></type>
<name>date2timestamp</name><parameter_list>(<parameter><decl><type><name>DateADT</name></type> <name>dateVal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DATE_IS_NOBEGIN</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>DATE_IS_NOEND</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TIMESTAMP_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Date's range is wider than timestamp's, so check for boundaries.
		 * Since dates have the same minimum values as timestamps, only upper
		 * boundary need be checked for overflow.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>dateVal</name> <operator>&gt;=</operator> <operator>(</operator><name>TIMESTAMP_END_JULIAN</name> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range for timestamp"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* date is days since 2000, timestamp is microseconds since same... */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>dateVal</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TimestampTz</name></type>
<name>date2timestamptz</name><parameter_list>(<parameter><decl><type><name>DateADT</name></type> <name>dateVal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DATE_IS_NOBEGIN</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>DATE_IS_NOEND</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TIMESTAMP_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Date's range is wider than timestamp's, so check for boundaries.
		 * Since dates have the same minimum values as timestamps, only upper
		 * boundary need be checked for overflow.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>dateVal</name> <operator>&gt;=</operator> <operator>(</operator><name>TIMESTAMP_END_JULIAN</name> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range for timestamp"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>dateVal</name> <operator>+</operator> <name>POSTGRES_EPOCH_JDATE</name></expr></argument>,
			   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>dateVal</name> <operator>*</operator> <name>USECS_PER_DAY</name> <operator>+</operator> <name>tz</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since it is possible to go beyond allowed timestamptz range because
		 * of time zone, check for allowed timestamp range after adding tz.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range for timestamp"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * date2timestamp_no_overflow
 *
 * This is chartered to produce a double value that is numerically
 * equivalent to the corresponding Timestamp value, if the date is in the
 * valid range of Timestamps, but in any case not throw an overflow error.
 * We can do this since the numerical range of double is greater than
 * that of non-erroneous timestamps.  The results are currently only
 * used for statistical estimation purposes.
 */</comment>
<function><type><name>double</name></type>
<name>date2timestamp_no_overflow</name><parameter_list>(<parameter><decl><type><name>DateADT</name></type> <name>dateVal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DATE_IS_NOBEGIN</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>DBL_MAX</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>DATE_IS_NOEND</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DBL_MAX</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* date is days since 2000, timestamp is microseconds since same... */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>dateVal</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Crosstype comparison functions for dates
 */</comment>

<function><type><name>Datum</name></type>
<name>date_eq_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_ne_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_lt_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_gt_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_le_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_ge_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_cmp_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_eq_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_ne_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_lt_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_gt_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_le_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_ge_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>date_cmp_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt1</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_eq_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_ne_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_lt_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_gt_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_le_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_ge_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamp_cmp_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>timestamp_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_eq_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_ne_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_lt_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_gt_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_le_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_ge_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_cmp_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt1</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMPTZ</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dt2</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>timestamptz_cmp_internal</name><argument_list>(<argument><expr><name>dt1</name></expr></argument>, <argument><expr><name>dt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * in_range support function for date.
 *
 * We implement this by promoting the dates to timestamp (without time zone)
 * and then using the timestamp-and-interval in_range function.
 */</comment>
<function><type><name>Datum</name></type>
<name>in_range_date_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>base</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>offset</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sub</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>less</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>valStamp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>baseStamp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>valStamp</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>baseStamp</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>DirectFunctionCall5</name><argument_list>(<argument><expr><name>in_range_timestamp_interval</name></expr></argument>,
							   <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>valStamp</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>baseStamp</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>less</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Add an interval to a date, giving a new date.
 * Must handle both positive and negative intervals.
 *
 * We implement this by promoting the date to timestamp (without time zone)
 * and then using the timestamp plus interval function.
 */</comment>
<function><type><name>Datum</name></type>
<name>date_pl_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dateStamp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dateStamp</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_pl_interval</name></expr></argument>,
							   <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>dateStamp</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>span</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Subtract an interval from a date, giving a new date.
 * Must handle both positive and negative intervals.
 *
 * We implement this by promoting the date to timestamp (without time zone)
 * and then using the timestamp minus interval function.
 */</comment>
<function><type><name>Datum</name></type>
<name>date_mi_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dateStamp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dateStamp</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>timestamp_mi_interval</name></expr></argument>,
							   <argument><expr><call><name>TimestampGetDatum</name><argument_list>(<argument><expr><name>dateStamp</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>span</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* date_timestamp()
 * Convert date to timestamp data type.
 */</comment>
<function><type><name>Datum</name></type>
<name>date_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timestamp_date()
 * Convert timestamp to date data type.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DATE_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TIMESTAMP_IS_NOEND</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DATE_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* date_timestamptz()
 * Convert date to timestamp with time zone data type.
 */</comment>
<function><type><name>Datum</name></type>
<name>date_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>dateVal</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>date2timestamptz</name><argument_list>(<argument><expr><name>dateVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* timestamptz_date()
 * Convert timestamp with time zone to date data type.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_IS_NOBEGIN</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DATE_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TIMESTAMP_IS_NOEND</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DATE_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* abstime_date()
 * Convert abstime to date data type.
 */</comment>
<function><type><name>Datum</name></type>
<name>abstime_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AbsoluteTime</name></type> <name>abstime</name> <init>= <expr><call><name>PG_GETARG_ABSOLUTETIME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>abstime</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INVALID_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert reserved abstime value to date"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>

		<case>case <expr><name>NOSTART_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>DATE_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NOEND_ABSTIME</name></expr>:</case>
			<expr_stmt><expr><call><name>DATE_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>abstime2tm</name><argument_list>(<argument><expr><name>abstime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Prevent overflow in Julian-day routines */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_JULIAN</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"abstime out of range for date"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</expr_stmt>
			<comment type="block">/* Now check for just-out-of-range dates */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_DATE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"abstime out of range for date"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 Time ADT
 *****************************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>time_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>workbuf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>field</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>ftype</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseDateTime</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>workbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						  <argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>MAXDATEFIELDS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTimeOnly</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>dterr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>tm2time</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AdjustTimeForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* tm2time()
 * Convert a tm structure to a time data type.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tm2time</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>TimeADT</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>MINS_PER_HOUR</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name><operator>)</operator>
			   <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <name>fsec</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* time_overflows()
 * Check to see if a broken-down time-of-day is out of range.
 */</comment>
<function><type><name>bool</name></type>
<name>time_overflows</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>hour</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sec</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Range-check the fields individually. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hour</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>hour</name></expr></argument> &gt;</argument_list></name> <name>HOURS_PER_DAY</name> <operator>||</operator>
		<name>min</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>min</name> <operator>&gt;=</operator> <name>MINS_PER_HOUR</name> <operator>||</operator>
		<name><name>sec</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>sec</name></expr></argument> &gt;</argument_list></name> <name>SECS_PER_MINUTE</name> <operator>||</operator>
		<name><name>fsec</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>fsec</name></expr></argument> &gt;</argument_list></name> <name>USECS_PER_SEC</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Because we allow, eg, hour = 24 or sec = 60, we must check separately
	 * that the total time value doesn't exceed 24:00:00.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>hour</name> <operator>*</operator> <name>MINS_PER_HOUR</name> <operator>+</operator> <name>min</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator>
		   <operator>+</operator> <name>sec</name><operator>)</operator> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <name>fsec</name><operator>)</operator> <operator>&gt;</operator> <name>USECS_PER_DAY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* float_time_overflows()
 * Same, when we have seconds + fractional seconds as one "double" value.
 */</comment>
<function><type><name>bool</name></type>
<name>float_time_overflows</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>hour</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>sec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Range-check the fields individually. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hour</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>hour</name></expr></argument> &gt;</argument_list></name> <name>HOURS_PER_DAY</name> <operator>||</operator>
		<name>min</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>min</name> <operator>&gt;=</operator> <name>MINS_PER_HOUR</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * "sec", being double, requires extra care.  Cope with NaN, and round off
	 * before applying the range check to avoid unexpected errors due to
	 * imprecise input.  (We assume rint() behaves sanely with infinities.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>sec</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>sec</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sec</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>sec</name></expr></argument> &gt;</argument_list></name> <name>SECS_PER_MINUTE</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Because we allow, eg, hour = 24 or sec = 60, we must check separately
	 * that the total time value doesn't exceed 24:00:00.  This must match the
	 * way that callers will convert the fields to a time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>hour</name> <operator>*</operator> <name>MINS_PER_HOUR</name> <operator>+</operator> <name>min</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator>
		  <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>sec</name><operator>)</operator> <operator>&gt;</operator> <name>USECS_PER_DAY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* time2tm()
 * Convert time data type to POSIX time structure.
 *
 * For dates within the range of pg_time_t, convert to the local time zone.
 * If out of this range, leave as UTC (in practice that could only happen
 * if pg_time_t is just 32 bits) - thomas 97/05/27
 */</comment>
<function><type><name>int</name></type>
<name>time2tm</name><parameter_list>(<parameter><decl><type><name>TimeADT</name></type> <name>time</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>-=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>-=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>*</operator> <name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name>time</name> <operator>/</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>time</name> <operator>-=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <name>time</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>time_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>time2tm</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EncodeTimeOnly</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DateStyle</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		time_recv			- converts external binary format to time
 */</comment>
<function><type><name>Datum</name></type>
<name>time_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>result</name> <argument_list type="generic">&lt; <argument><expr><name>INT64CONST</name><operator>(</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name>result</name></expr></argument> &gt;</argument_list></name> <name>USECS_PER_DAY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AdjustTimeForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		time_send			- converts time to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>time_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetypmodin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ta</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>anytime_typmodin</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>ta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetypmodout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>anytime_typmodout</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		make_time			- time constructor
 */</comment>
<function><type><name>Datum</name></type>
<name>make_time</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tm_hour</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tm_min</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>sec</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time</name></decl>;</decl_stmt>

	<comment type="block">/* Check for time overflow */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>float_time_overflows</name><argument_list>(<argument><expr><name>tm_hour</name></expr></argument>, <argument><expr><name>tm_min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_FIELD_OVERFLOW</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time field value out of range: %d:%02d:%02g"</literal></expr></argument>,
						<argument><expr><name>tm_hour</name></expr></argument>, <argument><expr><name>tm_min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* This should match tm2time */</comment>
	<expr_stmt><expr><name>time</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>tm_hour</name> <operator>*</operator> <name>MINS_PER_HOUR</name> <operator>+</operator> <name>tm_min</name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator>
			<operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>sec</name> <operator>*</operator> <name>USECS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* time_transform()
 * Flatten calls to time_scale() and timetz_scale() that solely represent
 * increases in allowed precision.
 */</comment>
<function><type><name>Datum</name></type>
<name>time_transform</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>TemporalTransform</name><argument_list>(<argument><expr><name>MAX_TIME_PRECISION</name></expr></argument>,
										<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* time_scale()
 * Adjust time type for specified scale factor.
 * Used by PostgreSQL type system to stuff columns.
 */</comment>
<function><type><name>Datum</name></type>
<name>time_scale</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>time</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AdjustTimeForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* AdjustTimeForTypmod()
 * Force the precision of the time value to a specified value.
 * Uses *exactly* the same code as in AdjustTimestampForTypemod()
 * but we make a separate copy because those types do not
 * have a fundamental tie together but rather a coincidence of
 * implementation. - thomas
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustTimeForTypmod</name><parameter_list>(<parameter><decl><type><name>TimeADT</name> <modifier>*</modifier></type><name>time</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int64</name></type> <name><name>TimeScales</name><index>[<expr><name>MAX_TIME_PRECISION</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">10000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>,
		<macro><name>INT64CONST</name><argument_list>(<argument><literal type="number">1</literal></argument>)</argument_list></macro>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int64</name></type> <name><name>TimeOffsets</name><index>[<expr><name>MAX_TIME_PRECISION</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">500000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">50000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">5000</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>,
		<macro><name>INT64CONST</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro>
	}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typmod</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>typmod</name> <operator>&lt;=</operator> <name>MAX_TIME_PRECISION</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>time</name> <operator>&gt;=</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>time</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>time</name> <operator>+</operator> <name><name>TimeOffsets</name><index>[<expr><name>typmod</name></expr>]</index></name><operator>)</operator> <operator>/</operator> <name><name>TimeScales</name><index>[<expr><name>typmod</name></expr>]</index></name><operator>)</operator> <operator>*</operator>
				<name><name>TimeScales</name><index>[<expr><name>typmod</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>time</name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>-</operator><operator>*</operator><name>time</name><operator>)</operator> <operator>+</operator> <name><name>TimeOffsets</name><index>[<expr><name>typmod</name></expr>]</index></name><operator>)</operator> <operator>/</operator> <name><name>TimeScales</name><index>[<expr><name>typmod</name></expr>]</index></name><operator>)</operator> <operator>*</operator>
					  <name><name>TimeScales</name><index>[<expr><name>typmod</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>time_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>time1</name> <operator>==</operator> <name>time2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>time_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>time1</name> <operator>!=</operator> <name>time2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>time_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>time1</name> <operator>&lt;</operator> <name>time2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>time_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>time1</name> <operator>&lt;=</operator> <name>time2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>time_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>time1</name> <operator>&gt;</operator> <name>time2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>time_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>time1</name> <operator>&gt;=</operator> <name>time2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>time_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>time1</name> <operator>&lt;</operator> <name>time2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>time1</name> <operator>&gt;</operator> <name>time2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>time_hash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>hashint8</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>time_hash_extended</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>hashint8extended</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>time_larger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>time1</name> <operator>&gt;</operator> <name>time2</name><operator>)</operator></expr> ?</condition><then> <expr><name>time1</name></expr> </then><else>: <expr><name>time2</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>time_smaller</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>time1</name> <operator>&lt;</operator> <name>time2</name><operator>)</operator></expr> ?</condition><then> <expr><name>time1</name></expr> </then><else>: <expr><name>time2</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* overlaps_time() --- implements the SQL OVERLAPS operator.
 *
 * Algorithm is per SQL spec.  This is much harder than you'd think
 * because the spec requires us to deliver a non-null answer in some cases
 * where some of the inputs are null.
 */</comment>
<function><type><name>Datum</name></type>
<name>overlaps_time</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The arguments are TimeADT, but we leave them as generic Datums to avoid
	 * dereferencing nulls (TimeADT is pass-by-reference!)
	 */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>ts1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>te1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>ts2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>te2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ts1IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>te1IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ts2IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>te2IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMEADT_GT</name><parameter_list>(<parameter><type><name>t1</name></type></parameter>,<parameter><type><name>t2</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(DatumGetTimeADT(t1) &gt; DatumGetTimeADT(t2))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMEADT_LT</name><parameter_list>(<parameter><type><name>t1</name></type></parameter>,<parameter><type><name>t2</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(DatumGetTimeADT(t1) &lt; DatumGetTimeADT(t2))</cpp:value></cpp:define>

	<comment type="block">/*
	 * If both endpoints of interval 1 are null, the result is null (unknown).
	 * If just one endpoint is null, take ts1 as the non-null one. Otherwise,
	 * take ts1 as the lesser endpoint.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ts1IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* swap null for non-null */</comment>
		<expr_stmt><expr><name>ts1</name> <operator>=</operator> <name>te1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>te1IsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>te1IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TIMEADT_GT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>te1</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>tt</name> <init>= <expr><name>ts1</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ts1</name> <operator>=</operator> <name>te1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>te1</name> <operator>=</operator> <name>tt</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Likewise for interval 2. */</comment>
	<if_stmt><if>if <condition>(<expr><name>ts2IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* swap null for non-null */</comment>
		<expr_stmt><expr><name>ts2</name> <operator>=</operator> <name>te2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>te2IsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>te2IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TIMEADT_GT</name><argument_list>(<argument><expr><name>ts2</name></expr></argument>, <argument><expr><name>te2</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>tt</name> <init>= <expr><name>ts2</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ts2</name> <operator>=</operator> <name>te2</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>te2</name> <operator>=</operator> <name>tt</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At this point neither ts1 nor ts2 is null, so we can consider three
	 * cases: ts1 &gt; ts2, ts1 &lt; ts2, ts1 = ts2
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TIMEADT_GT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>ts2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This case is ts1 &lt; te2 OR te1 &lt; te2, which may look redundant but
		 * in the presence of nulls it's not quite completely so.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TIMEADT_LT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>te2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If te1 is not null then we had ts1 &lt;= te1 above, and we just found
		 * ts1 &gt;= te2, hence te1 &gt;= te2.
		 */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TIMEADT_LT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>ts2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This case is ts2 &lt; te1 OR te2 &lt; te1 */</comment>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TIMEADT_LT</name><argument_list>(<argument><expr><name>ts2</name></expr></argument>, <argument><expr><name>te1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If te2 is not null then we had ts2 &lt;= te2 above, and we just found
		 * ts2 &gt;= te1, hence te2 &gt;= te1.
		 */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For ts1 = ts2 the spec says te1 &lt;&gt; te2 OR te1 = te2, which is a
		 * rather silly way of saying "true if both are nonnull, else null".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name> <operator>||</operator> <name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TIMEADT_GT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TIMEADT_LT</name></cpp:undef>
</block_content>}</block></function>

<comment type="block">/* timestamp_time()
 * Convert timestamp to time data type.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_time</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Could also do this with time = (timestamp / USECS_PER_DAY *
	 * USECS_PER_DAY) - timestamp;
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>MINS_PER_HOUR</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name><operator>)</operator> <operator>*</operator>
			  <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <name>fsec</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timestamptz_time()
 * Convert timestamptz to time data type.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_time</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Could also do this with time = (timestamp / USECS_PER_DAY *
	 * USECS_PER_DAY) - timestamp;
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>MINS_PER_HOUR</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name><operator>)</operator> <operator>*</operator>
			  <name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <name>fsec</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* datetime_timestamp()
 * Convert date and time to timestamp data type.
 */</comment>
<function><type><name>Datum</name></type>
<name>datetime_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>date</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>date2timestamp</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>time</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* time_interval()
 * Convert time to interval data type.
 */</comment>
<function><type><name>Datum</name></type>
<name>time_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name>time</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* interval_time()
 * Convert interval to time data type.
 *
 * This is defined as producing the fractional-day portion of the interval.
 * Therefore, we can just ignore the months field.  It is not real clear
 * what to do with negative intervals, but we choose to subtract the floor,
 * so that, say, '-2 hours' becomes '22:00:00'.
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_time</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>days</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;=</operator> <name>USECS_PER_DAY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>days</name> <operator>=</operator> <name>result</name> <operator>/</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>-=</operator> <name>days</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>days</name> <operator>=</operator> <operator>(</operator><operator>-</operator><name>result</name> <operator>+</operator> <name>USECS_PER_DAY</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>days</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* time_mi_time()
 * Subtract two times to produce an interval.
 */</comment>
<function><type><name>Datum</name></type>
<name>time_mi_time</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name>time1</name> <operator>-</operator> <name>time2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INTERVAL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* time_pl_interval()
 * Add interval to time.
 */</comment>
<function><type><name>Datum</name></type>
<name>time_pl_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>time</name> <operator>+</operator> <name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>-=</operator> <name>result</name> <operator>/</operator> <name>USECS_PER_DAY</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* time_mi_interval()
 * Subtract interval from time.
 */</comment>
<function><type><name>Datum</name></type>
<name>time_mi_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>time</name> <operator>-</operator> <name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>-=</operator> <name>result</name> <operator>/</operator> <name>USECS_PER_DAY</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * in_range support function for time.
 */</comment>
<function><type><name>Datum</name></type>
<name>in_range_time_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>base</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>offset</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sub</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>less</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>sum</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Like time_pl_interval/time_mi_interval, we disregard the month and day
	 * fields of the offset.  So our test for negative should too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>offset</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid preceding or following size in window function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can't use time_pl_interval/time_mi_interval here, because their
	 * wraparound behavior would give wrong (or at least undesirable) answers.
	 * Fortunately the equivalent non-wrapping behavior is trivial, especially
	 * since we don't worry about integer overflow.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <name>base</name> <operator>-</operator> <name><name>offset</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name><name>offset</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>less</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>val</name> <operator>&lt;=</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>val</name> <operator>&gt;=</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* time_part()
 * Extract specified field from time type.
 */</comment>
<function><type><name>Datum</name></type>
<name>time_part</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>units</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowunits</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lowunits</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeUnits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNKNOWN_FIELD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeSpecial</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNITS</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>time2tm</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <literal type="number">1000000.0</literal> <operator>+</operator> <name>fsec</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <literal type="number">1000.0</literal> <operator>+</operator> <name>fsec</name> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_SECOND</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+</operator> <name>fsec</name> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_HOUR</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TZ</name></expr>:</case>
			<case>case <expr><name>DTK_TZ_MINUTE</name></expr>:</case>
			<case>case <expr><name>DTK_TZ_HOUR</name></expr>:</case>
			<case>case <expr><name>DTK_DAY</name></expr>:</case>
			<case>case <expr><name>DTK_MONTH</name></expr>:</case>
			<case>case <expr><name>DTK_QUARTER</name></expr>:</case>
			<case>case <expr><name>DTK_YEAR</name></expr>:</case>
			<case>case <expr><name>DTK_DECADE</name></expr>:</case>
			<case>case <expr><name>DTK_CENTURY</name></expr>:</case>
			<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>
			<case>case <expr><name>DTK_ISOYEAR</name></expr>:</case>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"time\" units \"%s\" not recognized"</literal></expr></argument>,
								<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>RESERV</name> <operator>&amp;&amp;</operator> <name>val</name> <operator>==</operator> <name>DTK_EPOCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>time</name> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"time\" units \"%s\" not recognized"</literal></expr></argument>,
						<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 Time With Time Zone ADT
 *****************************************************************************/</comment>

<comment type="block">/* tm2timetz()
 * Convert a tm structure to a time data type.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tm2timetz</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name></type> <name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tz</name></decl></parameter>, <parameter><decl><type><name>TimeTzADT</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>MINS_PER_HOUR</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name><operator>)</operator> <operator>*</operator> <name>SECS_PER_MINUTE</name><operator>)</operator> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name><operator>)</operator> <operator>*</operator>
					<name>USECS_PER_SEC</name><operator>)</operator> <operator>+</operator> <name>fsec</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>zone</name></name> <operator>=</operator> <name>tz</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>workbuf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>field</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>ftype</name><index>[<expr><name>MAXDATEFIELDS</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>ParseDateTime</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>workbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						  <argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>MAXDATEFIELDS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dterr</name> <operator>=</operator> <call><name>DecodeTimeOnly</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>ftype</name></expr></argument>, <argument><expr><name>nf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtype</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>dterr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"time with time zone"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimeTzADT</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeTzADT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tm2timetz</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AdjustTimeForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>time</name></name><operator>)</operator></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMETZADT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>timetz2tm</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EncodeTimeOnly</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>DateStyle</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		timetz_recv			- converts external binary format to timetz
 */</comment>
<function><type><name>Datum</name></type>
<name>timetz_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typelem</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimeTzADT</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeTzADT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;</operator> <name>USECS_PER_DAY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>zone</name></name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>zone</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for sane GMT displacement; see notes in datatype/timestamp.h */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>zone</name></name> <operator>&lt;=</operator> <operator>-</operator><name>TZDISP_LIMIT</name> <operator>||</operator> <name><name>result</name><operator>-&gt;</operator><name>zone</name></name> <operator>&gt;=</operator> <name>TZDISP_LIMIT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone displacement out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AdjustTimeForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>time</name></name><operator>)</operator></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMETZADT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		timetz_send			- converts timetz to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>timetz_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>time</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>time</name><operator>-&gt;</operator><name>zone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetztypmodin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ta</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>anytime_typmodin</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>ta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetztypmodout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>anytime_typmodout</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* timetz2tm()
 * Convert TIME WITH TIME ZONE data type to POSIX time structure.
 */</comment>
<function><type><name>int</name></type>
<name>timetz2tm</name><parameter_list>(<parameter><decl><type><name>TimeTzADT</name> <modifier>*</modifier></type><name>time</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tzp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>trem</name> <init>= <expr><name><name>time</name><operator>-&gt;</operator><name>time</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name>trem</name> <operator>/</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>trem</name> <operator>-=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>USECS_PER_HOUR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name>trem</name> <operator>/</operator> <name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>trem</name> <operator>-=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>*</operator> <name>USECS_PER_MINUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name>trem</name> <operator>/</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <name>trem</name> <operator>-</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tzp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tzp</name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>zone</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* timetz_scale()
 * Adjust time type for specified scale factor.
 * Used by PostgreSQL type system to stuff columns.
 */</comment>
<function><type><name>Datum</name></type>
<name>timetz_scale</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimeTzADT</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeTzADT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>zone</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>zone</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AdjustTimeForTypmod</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>time</name></name><operator>)</operator></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMETZADT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>timetz_cmp_internal</name><parameter_list>(<parameter><decl><type><name>TimeTzADT</name> <modifier>*</modifier></type><name>time1</name></decl></parameter>, <parameter><decl><type><name>TimeTzADT</name> <modifier>*</modifier></type><name>time2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeOffset</name></type>	<name>t1</name></decl>,
				<decl><type ref="prev"/><name>t2</name></decl>;</decl_stmt>

	<comment type="block">/* Primary sort is by true (GMT-equivalent) time */</comment>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <name><name>time1</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <operator>(</operator><name><name>time1</name><operator>-&gt;</operator><name>zone</name></name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <name><name>time2</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <operator>(</operator><name><name>time2</name><operator>-&gt;</operator><name>zone</name></name> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>t1</name> <operator>&gt;</operator> <name>t2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>t1</name> <operator>&lt;</operator> <name>t2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If same GMT time, sort by timezone; we only want to say that two
	 * timetz's are equal if both the time and zone parts are equal.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>time1</name><operator>-&gt;</operator><name>zone</name></name> <operator>&gt;</operator> <name><name>time2</name><operator>-&gt;</operator><name>zone</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>time1</name><operator>-&gt;</operator><name>zone</name></name> <operator>&lt;</operator> <name><name>time2</name><operator>-&gt;</operator><name>zone</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timetz_cmp_internal</name><argument_list>(<argument><expr><name>time1</name></expr></argument>, <argument><expr><name>time2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timetz_cmp_internal</name><argument_list>(<argument><expr><name>time1</name></expr></argument>, <argument><expr><name>time2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timetz_cmp_internal</name><argument_list>(<argument><expr><name>time1</name></expr></argument>, <argument><expr><name>time2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timetz_cmp_internal</name><argument_list>(<argument><expr><name>time1</name></expr></argument>, <argument><expr><name>time2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timetz_cmp_internal</name><argument_list>(<argument><expr><name>time1</name></expr></argument>, <argument><expr><name>time2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timetz_cmp_internal</name><argument_list>(<argument><expr><name>time1</name></expr></argument>, <argument><expr><name>time2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>timetz_cmp_internal</name><argument_list>(<argument><expr><name>time1</name></expr></argument>, <argument><expr><name>time2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_hash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>thash</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To avoid any problems with padding bytes in the struct, we figure the
	 * field hashes separately and XOR them.
	 */</comment>
	<expr_stmt><expr><name>thash</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>hashint8</name></expr></argument>,
											   <argument><expr><call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>thash</name> <operator>^=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>zone</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_UINT32</name><argument_list>(<argument><expr><name>thash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_hash_extended</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>seed</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>thash</name></decl>;</decl_stmt>

	<comment type="block">/* Same approach as timetz_hash */</comment>
	<expr_stmt><expr><name>thash</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>hashint8extended</name></expr></argument>,
											   <argument><expr><call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>thash</name> <operator>^=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>hash_uint32_extended</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>zone</name></name></expr></argument>,
												 <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_UINT64</name><argument_list>(<argument><expr><name>thash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_larger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timetz_cmp_internal</name><argument_list>(<argument><expr><name>time1</name></expr></argument>, <argument><expr><name>time2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>time1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>time2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TIMETZADT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timetz_smaller</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time1</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time2</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timetz_cmp_internal</name><argument_list>(<argument><expr><name>time1</name></expr></argument>, <argument><expr><name>time2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>time1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>time2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TIMETZADT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timetz_pl_interval()
 * Add interval to timetz.
 */</comment>
<function><type><name>Datum</name></type>
<name>timetz_pl_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimeTzADT</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeTzADT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>-=</operator> <name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_DAY</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>+=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>zone</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>zone</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMETZADT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timetz_mi_interval()
 * Subtract interval from timetz.
 */</comment>
<function><type><name>Datum</name></type>
<name>timetz_mi_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>span</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimeTzADT</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeTzADT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>time</name></name> <operator>-</operator> <name><name>span</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>-=</operator> <name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_DAY</name> <operator>*</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>+=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>zone</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>zone</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMETZADT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * in_range support function for timetz.
 */</comment>
<function><type><name>Datum</name></type>
<name>in_range_timetz_interval</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>offset</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sub</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>less</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name></type>	<name>sum</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Like timetz_pl_interval/timetz_mi_interval, we disregard the month and
	 * day fields of the offset.  So our test for negative should too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>offset</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid preceding or following size in window function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can't use timetz_pl_interval/timetz_mi_interval here, because their
	 * wraparound behavior would give wrong (or at least undesirable) answers.
	 * Fortunately the equivalent non-wrapping behavior is trivial, especially
	 * since we don't worry about integer overflow.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sum</name><operator>.</operator><name>time</name></name> <operator>=</operator> <name><name>base</name><operator>-&gt;</operator><name>time</name></name> <operator>-</operator> <name><name>offset</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sum</name><operator>.</operator><name>time</name></name> <operator>=</operator> <name><name>base</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <name><name>offset</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>sum</name><operator>.</operator><name>zone</name></name> <operator>=</operator> <name><name>base</name><operator>-&gt;</operator><name>zone</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>less</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timetz_cmp_internal</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>timetz_cmp_internal</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* overlaps_timetz() --- implements the SQL OVERLAPS operator.
 *
 * Algorithm is per SQL spec.  This is much harder than you'd think
 * because the spec requires us to deliver a non-null answer in some cases
 * where some of the inputs are null.
 */</comment>
<function><type><name>Datum</name></type>
<name>overlaps_timetz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The arguments are TimeTzADT *, but we leave them as generic Datums for
	 * convenience of notation --- and to avoid dereferencing nulls.
	 */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>ts1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>te1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>ts2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>te2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ts1IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>te1IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ts2IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>te2IsNull</name> <init>= <expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMETZ_GT</name><parameter_list>(<parameter><type><name>t1</name></type></parameter>,<parameter><type><name>t2</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>DatumGetBool(DirectFunctionCall2(timetz_gt,t1,t2))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMETZ_LT</name><parameter_list>(<parameter><type><name>t1</name></type></parameter>,<parameter><type><name>t2</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>DatumGetBool(DirectFunctionCall2(timetz_lt,t1,t2))</cpp:value></cpp:define>

	<comment type="block">/*
	 * If both endpoints of interval 1 are null, the result is null (unknown).
	 * If just one endpoint is null, take ts1 as the non-null one. Otherwise,
	 * take ts1 as the lesser endpoint.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ts1IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* swap null for non-null */</comment>
		<expr_stmt><expr><name>ts1</name> <operator>=</operator> <name>te1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>te1IsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>te1IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TIMETZ_GT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>te1</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>tt</name> <init>= <expr><name>ts1</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ts1</name> <operator>=</operator> <name>te1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>te1</name> <operator>=</operator> <name>tt</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Likewise for interval 2. */</comment>
	<if_stmt><if>if <condition>(<expr><name>ts2IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* swap null for non-null */</comment>
		<expr_stmt><expr><name>ts2</name> <operator>=</operator> <name>te2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>te2IsNull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>te2IsNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TIMETZ_GT</name><argument_list>(<argument><expr><name>ts2</name></expr></argument>, <argument><expr><name>te2</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>tt</name> <init>= <expr><name>ts2</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ts2</name> <operator>=</operator> <name>te2</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>te2</name> <operator>=</operator> <name>tt</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At this point neither ts1 nor ts2 is null, so we can consider three
	 * cases: ts1 &gt; ts2, ts1 &lt; ts2, ts1 = ts2
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TIMETZ_GT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>ts2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This case is ts1 &lt; te2 OR te1 &lt; te2, which may look redundant but
		 * in the presence of nulls it's not quite completely so.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TIMETZ_LT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>te2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If te1 is not null then we had ts1 &lt;= te1 above, and we just found
		 * ts1 &gt;= te2, hence te1 &gt;= te2.
		 */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TIMETZ_LT</name><argument_list>(<argument><expr><name>ts1</name></expr></argument>, <argument><expr><name>ts2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This case is ts2 &lt; te1 OR te2 &lt; te1 */</comment>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TIMETZ_LT</name><argument_list>(<argument><expr><name>ts2</name></expr></argument>, <argument><expr><name>te1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If te2 is not null then we had ts2 &lt;= te2 above, and we just found
		 * ts2 &gt;= te1, hence te2 &gt;= te1.
		 */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For ts1 = ts2 the spec says te1 &lt;&gt; te2 OR te1 = te2, which is a
		 * rather silly way of saying "true if both are nonnull, else null".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>te1IsNull</name> <operator>||</operator> <name>te2IsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TIMETZ_GT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TIMETZ_LT</name></cpp:undef>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>timetz_time</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>timetz</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* swallow the time zone and just return the time */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>timetz</name><operator>-&gt;</operator><name>time</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>time_timetz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time</name> <init>= <expr><call><name>PG_GETARG_TIMEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetCurrentDateTime</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>time2tm</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimeTzADT</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeTzADT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name>time</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>zone</name></name> <operator>=</operator> <name>tz</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMETZADT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* timestamptz_timetz()
 * Convert timestamp to timetz data type.
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamptz_timetz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimeTzADT</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeTzADT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tm2timetz</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMETZADT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* datetimetz_timestamptz()
 * Convert date and timetz to timestamp with time zone data type.
 * Timestamp is stored in GMT, so add the time zone
 * stored with the timetz to the result.
 * - thomas 2000-03-10
 */</comment>
<function><type><name>Datum</name></type>
<name>datetimetz_timestamptz</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>date</name> <init>= <expr><call><name>PG_GETARG_DATEADT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DATE_IS_NOBEGIN</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TIMESTAMP_NOBEGIN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>DATE_IS_NOEND</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TIMESTAMP_NOEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Date's range is wider than timestamp's, so check for boundaries.
		 * Since dates have the same minimum values as timestamps, only upper
		 * boundary need be checked for overflow.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>date</name> <operator>&gt;=</operator> <operator>(</operator><name>TIMESTAMP_END_JULIAN</name> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range for timestamp"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>date</name> <operator>*</operator> <name>USECS_PER_DAY</name> <operator>+</operator> <name><name>time</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <name><name>time</name><operator>-&gt;</operator><name>zone</name></name> <operator>*</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since it is possible to go beyond allowed timestamptz range because
		 * of time zone, check for allowed timestamp range after adding tz.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range for timestamp"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* timetz_part()
 * Extract specified field from time type.
 */</comment>
<function><type><name>Datum</name></type>
<name>timetz_part</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>units</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowunits</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lowunits</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>units</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeUnits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNKNOWN_FIELD</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeSpecial</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowunits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UNITS</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>dummy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>timetz2tm</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>val</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DTK_TZ</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>tz</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TZ_MINUTE</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>tz</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>/=</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FMODULO</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>SECS_PER_MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_TZ_HOUR</name></expr>:</case>
				<expr_stmt><expr><name>dummy</name> <operator>=</operator> <operator>-</operator><name>tz</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FMODULO</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>SECS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MICROSEC</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <literal type="number">1000000.0</literal> <operator>+</operator> <name>fsec</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MILLISEC</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>*</operator> <literal type="number">1000.0</literal> <operator>+</operator> <name>fsec</name> <operator>/</operator> <literal type="number">1000.0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_SECOND</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>+</operator> <name>fsec</name> <operator>/</operator> <literal type="number">1000000.0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_MINUTE</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_HOUR</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>DTK_DAY</name></expr>:</case>
			<case>case <expr><name>DTK_MONTH</name></expr>:</case>
			<case>case <expr><name>DTK_QUARTER</name></expr>:</case>
			<case>case <expr><name>DTK_YEAR</name></expr>:</case>
			<case>case <expr><name>DTK_DECADE</name></expr>:</case>
			<case>case <expr><name>DTK_CENTURY</name></expr>:</case>
			<case>case <expr><name>DTK_MILLENNIUM</name></expr>:</case>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"time with time zone\" units \"%s\" not recognized"</literal></expr></argument>,
								<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>RESERV</name> <operator>&amp;&amp;</operator> <name>val</name> <operator>==</operator> <name>DTK_EPOCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <literal type="number">1000000.0</literal> <operator>+</operator> <name><name>time</name><operator>-&gt;</operator><name>zone</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"time with time zone\" units \"%s\" not recognized"</literal></expr></argument>,
						<argument><expr><name>lowunits</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timetz_zone()
 * Encode time with time zone type with specified time zone.
 * Applies DST rules as of the current date.
 */</comment>
<function><type><name>Datum</name></type>
<name>timetz_zone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>zone</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tzname</name><index>[<expr><name>TZ_STRLEN_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lowzone</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>type</name></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_tz</name>	   <modifier>*</modifier></type><name>tzp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Look up the requested timezone.  First we look in the timezone
	 * abbreviation table (to handle cases like "EST"), and if that fails, we
	 * look in the timezone database (to handle cases like
	 * "America/New_York").  (This matches the order in which timestamp input
	 * checks the cases; it's important because the timezone database unwisely
	 * uses a few zone names that are identical to offset abbreviations.)
	 */</comment>
	<expr_stmt><expr><call><name>text_to_cstring_buffer</name><argument_list>(<argument><expr><name>zone</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* DecodeTimezoneAbbrev requires lowercase input */</comment>
	<expr_stmt><expr><name>lowzone</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>,
										   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DecodeTimezoneAbbrev</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowzone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TZ</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>DTZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fixed-offset abbreviation */</comment>
		<expr_stmt><expr><name>tz</name> <operator>=</operator> <operator>-</operator><name>val</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>DYNTZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* dynamic-offset abbreviation, resolve using current time */</comment>
		<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>now</name> <init>= <expr><operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneAbbrevOffset</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>tzname</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* try it as a full zone name */</comment>
		<expr_stmt><expr><name>tzp</name> <operator>=</operator> <call><name>pg_tzset</name><argument_list>(<argument><expr><name>tzname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tzp</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Get the offset-from-GMT that is valid today for the zone */</comment>
			<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>now</name> <init>= <expr><operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>tzp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tz</name> <operator>=</operator> <operator>-</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"time zone \"%s\" not recognized"</literal></expr></argument>, <argument><expr><name>tzname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimeTzADT</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeTzADT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>zone</name></name> <operator>-</operator> <name>tz</name><operator>)</operator> <operator>*</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>+=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt></block_content></block></while>
	<while>while <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;=</operator> <name>USECS_PER_DAY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>-=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>zone</name></name> <operator>=</operator> <name>tz</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMETZADT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* timetz_izone()
 * Encode time with time zone type with specified time interval as time zone.
 */</comment>
<function><type><name>Datum</name></type>
<name>timetz_izone</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>zone</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time</name> <init>= <expr><call><name>PG_GETARG_TIMETZADT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>zone</name><operator>-&gt;</operator><name>month</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>zone</name><operator>-&gt;</operator><name>day</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interval time zone \"%s\" must not include months or days"</literal></expr></argument>,
						<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>interval_out</name></expr></argument>,
															<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>zone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tz</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>zone</name><operator>-&gt;</operator><name>time</name></name> <operator>/</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>TimeTzADT</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TimeTzADT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <operator>(</operator><name><name>time</name><operator>-&gt;</operator><name>zone</name></name> <operator>-</operator> <name>tz</name><operator>)</operator> <operator>*</operator> <name>USECS_PER_SEC</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&lt;</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>+=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt></block_content></block></while>
	<while>while <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;=</operator> <name>USECS_PER_DAY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>time</name></name> <operator>-=</operator> <name>USECS_PER_DAY</name></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>zone</name></name> <operator>=</operator> <name>tz</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMETZADT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
