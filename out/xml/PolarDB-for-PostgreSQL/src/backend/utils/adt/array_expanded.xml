<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/adt/array_expanded.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * array_expanded.c
 *	  Basic functions for manipulating expanded arrays.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/array_expanded.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupmacs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/* "Methods" required for an expanded object */</comment>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>EA_get_flat_size</name><parameter_list>(<parameter><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eohptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EA_flatten_into</name><parameter_list>(<parameter><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eohptr</name></decl></parameter>,
				<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>allocated_size</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ExpandedObjectMethods</name></type> <name>EA_methods</name> <init>=
<expr><block>{
	<expr><name>EA_get_flat_size</name></expr>,
	<expr><name>EA_flatten_into</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Other local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_byval_expanded_array</name><parameter_list>(<parameter><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>eah</name></decl></parameter>,
						  <parameter><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>oldeah</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * expand_array: convert an array Datum into an expanded array
 *
 * The expanded object will be a child of parentcontext.
 *
 * Some callers can provide cache space to avoid repeated lookups of element
 * type data across calls; if so, pass a metacache pointer, making sure that
 * metacache-&gt;element_type is initialized to InvalidOid before first call.
 * If no cross-call caching is required, pass NULL for metacache.
 */</comment>
<function><type><name>Datum</name></type>
<name>expand_array</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arraydatum</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>parentcontext</name></decl></parameter>,
			 <parameter><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>metacache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>eah</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>objcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayMetaState</name></type> <name>fakecache</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate private context for expanded object.  We start by assuming
	 * that the array won't be very large; but if it does grow a lot, don't
	 * constrain aset.c's large-context behavior.
	 */</comment>
	<expr_stmt><expr><name>objcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>parentcontext</name></expr></argument>,
								   <argument><expr><literal type="string">"expanded array"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_START_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up expanded array header */</comment>
	<expr_stmt><expr><name>eah</name> <operator>=</operator> <operator>(</operator><name>ExpandedArrayHeader</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedArrayHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EOH_init_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eah</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>EA_methods</name></expr></argument>, <argument><expr><name>objcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>ea_magic</name></name> <operator>=</operator> <name>EA_MAGIC</name></expr>;</expr_stmt>

	<comment type="block">/* If the source is an expanded array, we may be able to optimize */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>oldeah</name> <init>= <expr><operator>(</operator><name>ExpandedArrayHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>oldeah</name><operator>-&gt;</operator><name>ea_magic</name></name> <operator>==</operator> <name>EA_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update caller's cache if provided; we don't need it this time, but
		 * next call might be for a non-expanded source array.  Furthermore,
		 * if the caller didn't provide a cache area, use some local storage
		 * to cache anyway, thereby avoiding a catalog lookup in the case
		 * where we fall through to the flat-copy code path.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>metacache</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>metacache</name> <operator>=</operator> <operator>&amp;</operator><name>fakecache</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name><name>oldeah</name><operator>-&gt;</operator><name>element_type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <name><name>oldeah</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>=</operator> <name><name>oldeah</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>typalign</name></name> <operator>=</operator> <name><name>oldeah</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If element type is pass-by-value and we have a Datum-array
		 * representation, just copy the source's metadata and Datum/isnull
		 * arrays.  The original flat array, if present at all, adds no
		 * additional information so we need not copy it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>oldeah</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>&amp;&amp;</operator> <name><name>oldeah</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>copy_byval_expanded_array</name><argument_list>(<argument><expr><name>eah</name></expr></argument>, <argument><expr><name>oldeah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* return a R/W pointer to the expanded array */</comment>
			<return>return <expr><call><name>EOHPGetRWDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eah</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Otherwise, either we have only a flat representation or the
		 * elements are pass-by-reference.  In either case, the best thing
		 * seems to be to copy the source as a flat representation and then
		 * deconstruct that later if necessary.  For the pass-by-ref case, we
		 * could perhaps save some cycles with custom code that generates the
		 * deconstructed representation in parallel with copying the values,
		 * but it would be a lot of extra code for fairly marginal gain.  So,
		 * fall through into the flat-source code path.
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Detoast and copy source array into private context, as a flat array.
	 *
	 * Note that this coding risks leaking some memory in the private context
	 * if we have to fetch data from a TOAST table; however, experimentation
	 * says that the leak is minimal.  Doing it this way saves a copy step,
	 * which seems worthwhile, especially if the array is large enough to need
	 * external storage.
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>ndims</name></name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* note these pointers point into the fvalue header! */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dims</name></name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>lbound</name></name> <operator>=</operator> <call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save array's element-type data for possible use later */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>metacache</name> <operator>&amp;&amp;</operator> <name><name>metacache</name><operator>-&gt;</operator><name>element_type</name></name> <operator>==</operator> <name><name>eah</name><operator>-&gt;</operator><name>element_type</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We have a valid cache of representational data */</comment>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <name><name>metacache</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>=</operator> <name><name>metacache</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>typalign</name></name> <operator>=</operator> <name><name>metacache</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No, so look it up */</comment>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>element_type</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>eah</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>eah</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>eah</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Update cache if provided */</comment>
		<if_stmt><if>if <condition>(<expr><name>metacache</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>element_type</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>typalign</name></name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* we don't make a deconstructed representation now */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dvalueslen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>nelems</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>flat_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* remember we have a flat representation */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>fvalue</name></name> <operator>=</operator> <name>array</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>fstartptr</name></name> <operator>=</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>fendptr</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>array</name><operator>)</operator> <operator>+</operator> <call><name>ARR_SIZE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* return a R/W pointer to the expanded array */</comment>
	<return>return <expr><call><name>EOHPGetRWDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>eah</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * helper for expand_array(): copy pass-by-value Datum-array representation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_byval_expanded_array</name><parameter_list>(<parameter><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>eah</name></decl></parameter>,
						  <parameter><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>oldeah</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>objcxt</name> <init>= <expr><name><name>eah</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name> <init>= <expr><name><name>oldeah</name><operator>-&gt;</operator><name>ndims</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dvalueslen</name> <init>= <expr><name><name>oldeah</name><operator>-&gt;</operator><name>dvalueslen</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Copy array dimensionality information */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>ndims</name></name> <operator>=</operator> <name>ndims</name></expr>;</expr_stmt>
	<comment type="block">/* We can alloc both dimensionality arrays with one palloc */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dims</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>lbound</name></name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>dims</name></name> <operator>+</operator> <name>ndims</name></expr>;</expr_stmt>
	<comment type="block">/* .. but don't assume the source's arrays are contiguous */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>dims</name></name></expr></argument>, <argument><expr><name><name>oldeah</name><operator>-&gt;</operator><name>dims</name></name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>lbound</name></name></expr></argument>, <argument><expr><name><name>oldeah</name><operator>-&gt;</operator><name>lbound</name></name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy element-type data */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name><name>oldeah</name><operator>-&gt;</operator><name>element_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <name><name>oldeah</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>=</operator> <name><name>oldeah</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>typalign</name></name> <operator>=</operator> <name><name>oldeah</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<comment type="block">/* Copy the deconstructed representation */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>,
												<argument><expr><name>dvalueslen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>, <argument><expr><name><name>oldeah</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>, <argument><expr><name>dvalueslen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>oldeah</name><operator>-&gt;</operator><name>dnulls</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>,
												  <argument><expr><name>dvalueslen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>, <argument><expr><name><name>oldeah</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>, <argument><expr><name>dvalueslen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dvalueslen</name></name> <operator>=</operator> <name>dvalueslen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>nelems</name></name> <operator>=</operator> <name><name>oldeah</name><operator>-&gt;</operator><name>nelems</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>flat_size</name></name> <operator>=</operator> <name><name>oldeah</name><operator>-&gt;</operator><name>flat_size</name></name></expr>;</expr_stmt>

	<comment type="block">/* we don't make a flat representation */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>fvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>fstartptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>fendptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_flat_size method for expanded arrays
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>EA_get_flat_size</name><parameter_list>(<parameter><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eohptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>eah</name> <init>= <expr><operator>(</operator><name>ExpandedArrayHeader</name> <operator>*</operator><operator>)</operator> <name>eohptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>dnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>ea_magic</name></name> <operator>==</operator> <name>EA_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Easy if we have a valid flattened value */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>eah</name><operator>-&gt;</operator><name>fvalue</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ARR_SIZE</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>fvalue</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If we have a cached size value, believe that */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>eah</name><operator>-&gt;</operator><name>flat_size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>eah</name><operator>-&gt;</operator><name>flat_size</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Compute space needed by examining dvalues/dnulls.  Note that the result
	 * array will have a nulls bitmap if dnulls isn't NULL, even if the array
	 * doesn't actually contain any nulls now.
	 */</comment>
	<expr_stmt><expr><name>nelems</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>nelems</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndims</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>ndims</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nelems</name> <operator>==</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>dims</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dvalues</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>dvalues</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dnulls</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>dnulls</name> <operator>&amp;&amp;</operator> <name><name>dnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><name><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* check for overflow of total request */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllocSizeIsValid</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array size exceeds the maximum allowed (%d)"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>MaxAllocSize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>dnulls</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nbytes</name> <operator>+=</operator> <call><name>ARR_OVERHEAD_NONULLS</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* cache for next time */</comment>
	<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>flat_size</name></name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>

	<return>return <expr><name>nbytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * flatten_into method for expanded arrays
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EA_flatten_into</name><parameter_list>(<parameter><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eohptr</name></decl></parameter>,
				<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>allocated_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>eah</name> <init>= <expr><operator>(</operator><name>ExpandedArrayHeader</name> <operator>*</operator><operator>)</operator> <name>eohptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>aresult</name> <init>= <expr><operator>(</operator><name>ArrayType</name> <operator>*</operator><operator>)</operator> <name>result</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataoffset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>ea_magic</name></name> <operator>==</operator> <name>EA_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Easy if we have a valid flattened value */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>eah</name><operator>-&gt;</operator><name>fvalue</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allocated_size</name> <operator>==</operator> <call><name>ARR_SIZE</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>fvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>fvalue</name></name></expr></argument>, <argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else allocation should match previous get_flat_size result */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allocated_size</name> <operator>==</operator> <name><name>eah</name><operator>-&gt;</operator><name>flat_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill result array from dvalues/dnulls */</comment>
	<expr_stmt><expr><name>nelems</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>nelems</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndims</name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>ndims</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <call><name>ARR_OVERHEAD_WITHNULLS</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>dataoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>			<comment type="block">/* marker for no null bitmap */</comment>

	<comment type="block">/* We must ensure that any pad space is zero-filled */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>aresult</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>aresult</name></expr></argument>, <argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aresult</name><operator>-&gt;</operator><name>ndim</name></name> <operator>=</operator> <name>ndims</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aresult</name><operator>-&gt;</operator><name>dataoffset</name></name> <operator>=</operator> <name>dataoffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>aresult</name><operator>-&gt;</operator><name>elemtype</name></name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>element_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>aresult</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>dims</name></name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>aresult</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>lbound</name></name></expr></argument>, <argument><expr><name>ndims</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CopyArrayEls</name><argument_list>(<argument><expr><name>aresult</name></expr></argument>,
				 <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>,
				 <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>,
				 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Argument fetching support code
 */</comment>

<comment type="block">/*
 * DatumGetExpandedArray: get a writable expanded array from an input argument
 *
 * Caution: if the input is a read/write pointer, this returns the input
 * argument; so callers must be sure that their changes are "safe", that is
 * they cannot leave the array in a corrupt state.
 */</comment>
<function><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type>
<name>DatumGetExpandedArray</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If it's a writable expanded array already, just return it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED_RW</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>eah</name> <init>= <expr><operator>(</operator><name>ExpandedArrayHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>ea_magic</name></name> <operator>==</operator> <name>EA_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>eah</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else expand the hard way */</comment>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>expand_array</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>ExpandedArrayHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * As above, when caller has the ability to cache element type info
 */</comment>
<function><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type>
<name>DatumGetExpandedArrayX</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>metacache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If it's a writable expanded array already, just return it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED_RW</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>eah</name> <init>= <expr><operator>(</operator><name>ExpandedArrayHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>ea_magic</name></name> <operator>==</operator> <name>EA_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Update cache if provided */</comment>
		<if_stmt><if>if <condition>(<expr><name>metacache</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>element_type</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>metacache</name><operator>-&gt;</operator><name>typalign</name></name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>eah</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else expand using caller's cache if any */</comment>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>expand_array</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>metacache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>ExpandedArrayHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DatumGetAnyArrayP: return either an expanded array or a detoasted varlena
 * array.  The result must not be modified in-place.
 */</comment>
<function><type><name>AnyArrayType</name> <modifier>*</modifier></type>
<name>DatumGetAnyArrayP</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>eah</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's an expanded array (RW or RO), return the header pointer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>eah</name> <operator>=</operator> <operator>(</operator><name>ExpandedArrayHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>ea_magic</name></name> <operator>==</operator> <name>EA_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>AnyArrayType</name> <operator>*</operator><operator>)</operator> <name>eah</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else do regular detoasting as needed */</comment>
	<return>return <expr><operator>(</operator><name>AnyArrayType</name> <operator>*</operator><operator>)</operator> <call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create the Datum/isnull representation of an expanded array object
 * if we didn't do so previously
 */</comment>
<function><type><name>void</name></type>
<name>deconstruct_expanded_array</name><parameter_list>(<parameter><decl><type><name>ExpandedArrayHeader</name> <modifier>*</modifier></type><name>eah</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>eah</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>dnulls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dnulls</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>fvalue</name></name></expr></argument>,
						  <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>element_type</name></name></expr></argument>,
						  <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>, <argument><expr><name><name>eah</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>dvalues</name></expr></argument>,
						  <argument><expr><ternary><condition><expr><call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name><name>eah</name><operator>-&gt;</operator><name>fvalue</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>&amp;</operator><name>dnulls</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update header only after successful completion of this step.  If
		 * deconstruct_array fails partway through, worst consequence is some
		 * leaked memory in the object's context.  If the caller fails at a
		 * later point, that's fine, since the deconstructed representation is
		 * valid anyhow.
		 */</comment>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <name>dvalues</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <name>dnulls</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>eah</name><operator>-&gt;</operator><name>dvalueslen</name></name> <operator>=</operator> <name><name>eah</name><operator>-&gt;</operator><name>nelems</name></name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
