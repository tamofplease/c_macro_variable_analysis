<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/adt/rangetypes_gist.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * rangetypes_gist.c
 *	  GiST support for range types.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/rangetypes_gist.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rangetypes.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Range class properties used to segregate different classes of ranges in
 * GiST.  Each unique combination of properties is a class.  CLS_EMPTY cannot
 * be combined with anything else.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_NORMAL</name></cpp:macro>			<cpp:value>0</cpp:value></cpp:define>	<comment type="block">/* Ordinary finite range (no bits set) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_LOWER_INF</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* Lower bound is infinity */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_UPPER_INF</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>	<comment type="block">/* Upper bound is infinity */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_CONTAIN_EMPTY</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>	<comment type="block">/* Contains underlying empty ranges */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_EMPTY</name></cpp:macro>			<cpp:value>8</cpp:value></cpp:define>	<comment type="block">/* Special class for empty ranges */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLS_COUNT</name></cpp:macro>			<cpp:value>9</cpp:value></cpp:define>	<comment type="block">/* # of classes; includes all combinations of
								 * properties. CLS_EMPTY doesn't combine with
								 * anything else, so it's only 2^3 + 1. */</comment>

<comment type="block">/*
 * Minimum accepted ratio of split for items of the same class.  If the items
 * are of different classes, we will separate along those lines regardless of
 * the ratio.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIMIT_RATIO</name></cpp:macro>  <cpp:value>0.3</cpp:value></cpp:define>

<comment type="block">/* Constants for fixed penalty values */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INFINITE_BOUND_PENALTY</name></cpp:macro>	<cpp:value>2.0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONTAIN_EMPTY_PENALTY</name></cpp:macro>  <cpp:value>1.0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SUBTYPE_DIFF_PENALTY</name></cpp:macro>  <cpp:value>1.0</cpp:value></cpp:define>

<comment type="block">/*
 * Per-item data for range_gist_single_sorting_split.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>bound</name></decl>;</decl_stmt>
}</block></struct></type> <name>SingleBoundSortItem</name>;</typedef>

<comment type="block">/* place on left or right side of split? */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>SPLIT_LEFT</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,				<comment type="block">/* makes initialization to SPLIT_LEFT easier */</comment>
	<decl><name>SPLIT_RIGHT</name></decl>
}</block></enum></type> <name>SplitLR</name>;</typedef>

<comment type="block">/*
 * Context for range_gist_consider_split.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>	<comment type="block">/* typcache for range type */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_subtype_diff</name></decl>;</decl_stmt>	<comment type="block">/* does it have subtype_diff? */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>entries_count</name></decl>;</decl_stmt>	<comment type="block">/* total number of entries being split */</comment>

	<comment type="block">/* Information about currently selected split follows */</comment>

	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name></decl>;</decl_stmt>			<comment type="block">/* true if no split was selected yet */</comment>

	<decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>left_upper</name></decl>;</decl_stmt>		<comment type="block">/* upper bound of left interval */</comment>
	<decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>right_lower</name></decl>;</decl_stmt>	<comment type="block">/* lower bound of right interval */</comment>

	<decl_stmt><decl><type><name>float4</name></type>		<name>ratio</name></decl>;</decl_stmt>			<comment type="block">/* split ratio */</comment>
	<decl_stmt><decl><type><name>float4</name></type>		<name>overlap</name></decl>;</decl_stmt>		<comment type="block">/* overlap between left and right predicate */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>common_left</name></decl>;</decl_stmt>	<comment type="block">/* # common entries destined for each side */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>common_right</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConsiderSplitContext</name>;</typedef>

<comment type="block">/*
 * Bounds extracted from a non-empty range, for use in
 * range_gist_double_sorting_split.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper</name></decl>;</decl_stmt>
}</block></struct></type> <name>NonEmptyRange</name>;</typedef>

<comment type="block">/*
 * Represents information about an entry that can be placed in either group
 * without affecting overlap over selected axis ("common entry").
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* Index of entry in the initial array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
	<comment type="block">/* Delta between closeness of range to each of the two groups */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>delta</name></decl>;</decl_stmt>
}</block></struct></type> <name>CommonEntry</name>;</typedef>

<comment type="block">/* Helper macros to place an entry in the left or right group during split */</comment>
<comment type="block">/* Note direct access to variables v, typcache, left_range, right_range */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLACE_LEFT</name><parameter_list>(<parameter><type><name>range</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro>					\
	<cpp:value>do {										\
		if (v-&gt;spl_nleft &gt; 0)					\
			left_range = range_super_union(typcache, left_range, range); \
		else									\
			left_range = (range);				\
		v-&gt;spl_left[v-&gt;spl_nleft++] = (off);	\
	} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLACE_RIGHT</name><parameter_list>(<parameter><type><name>range</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro>					\
	<cpp:value>do {										\
		if (v-&gt;spl_nright &gt; 0)					\
			right_range = range_super_union(typcache, right_range, range); \
		else									\
			right_range = (range);				\
		v-&gt;spl_right[v-&gt;spl_nright++] = (off);	\
	} while(0)</cpp:value></cpp:define>

<comment type="block">/* Copy a RangeType datum (hardwires typbyval and typlen for ranges...) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rangeCopy</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((RangeType *) DatumGetPointer(datumCopy(PointerGetDatum(r), \
											 false, -1)))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>RangeType</name> <modifier>*</modifier></type><name>range_super_union</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>,
				  <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>range_gist_consistent_int</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
						  <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name></type> <name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>range_gist_consistent_leaf</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
						   <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name></type> <name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>range_gist_fallback_split</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
						  <parameter><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl></parameter>,
						  <parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>range_gist_class_split</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
					   <parameter><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl></parameter>,
					   <parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
					   <parameter><decl><type><name>SplitLR</name> <modifier>*</modifier></type><name>classes_groups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>range_gist_single_sorting_split</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
								<parameter><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl></parameter>,
								<parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>use_upper_bound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>range_gist_double_sorting_split</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
								<parameter><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl></parameter>,
								<parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>range_gist_consider_split</name><parameter_list>(<parameter><decl><type><name>ConsiderSplitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						  <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>right_lower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min_left_count</name></decl></parameter>,
						  <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>left_upper</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_left_count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>get_gist_range_class</name><parameter_list>(<parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>single_bound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>interval_cmp_lower</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>interval_cmp_upper</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>common_entry_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>call_subtype_diff</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>val1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val2</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* GiST query consistency check */</comment>
<function><type><name>Datum</name></type>
<name>range_gist_consistent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>query</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><operator>(</operator><name>StrategyNumber</name><operator>)</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Oid subtype = PG_GETARG_OID(3); */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>recheck</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

	<comment type="block">/* All operators served by this function are exact */</comment>
	<expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GIST_LEAF</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_gist_consistent_leaf</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>,
												  <argument><expr><name>key</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>range_gist_consistent_int</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>,
												 <argument><expr><name>key</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* form union range */</comment>
<function><type><name>Datum</name></type>
<name>range_gist_union</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name> <init>= <expr><operator>(</operator><name>GistEntryVector</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>ent</name> <init>= <expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>result_range</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result_range</name> <operator>=</operator> <call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>ent</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>result_range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>result_range</name> <operator>=</operator> <call><name>range_super_union</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>result_range</name></expr></argument>,
										 <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>ent</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_RANGE_P</name><argument_list>(<argument><expr><name>result_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * We store ranges as ranges in GiST indexes, so we do not need
 * compress, decompress, or fetch functions.  Note this implies a limit
 * on the size of range values that can be indexed.
 */</comment>

<comment type="block">/*
 * GiST page split penalty function.
 *
 * The penalty function has the following goals (in order from most to least
 * important):
 * - Keep normal ranges separate
 * - Avoid broadening the class of the original predicate
 * - Avoid broadening (as determined by subtype_diff) the original predicate
 * - Favor adding ranges to narrower original predicates
 */</comment>
<function><type><name>Datum</name></type>
<name>range_gist_penalty</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>origentry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTENTRY</name>  <modifier>*</modifier></type><name>newentry</name> <init>= <expr><operator>(</operator><name>GISTENTRY</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name>	   <modifier>*</modifier></type><name>penalty</name> <init>= <expr><operator>(</operator><name>float</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>orig</name> <init>= <expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>origentry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>newentry</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_subtype_diff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>orig_lower</name></decl>,
				<decl><type ref="prev"/><name>new_lower</name></decl>,
				<decl><type ref="prev"/><name>orig_upper</name></decl>,
				<decl><type ref="prev"/><name>new_upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>orig_empty</name></decl>,
				<decl><type ref="prev"/><name>new_empty</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"range types do not match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>has_subtype_diff</name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_subdiff_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig_lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig_upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>new</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Distinct branches for handling distinct classes of ranges.  Note that
	 * penalty values only need to be commensurate within the same class of
	 * new range.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_empty</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Handle insertion of empty range */</comment>
		<if_stmt><if>if <condition>(<expr><name>orig_empty</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The best case is to insert it to empty original range.
			 * Insertion here means no broadening of original range. Also
			 * original range is the most narrow.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>RangeIsOrContainsEmpty</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The second case is to insert empty range into range which
			 * contains at least one underlying empty range.  There is still
			 * no broadening of original range, but original range is not as
			 * narrow as possible.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <name>CONTAIN_EMPTY_PENALTY</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>orig_lower</name><operator>.</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <name><name>orig_upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Original range requires broadening.  (-inf; +inf) is most far
			 * from normal range in this case.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>CONTAIN_EMPTY_PENALTY</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>orig_lower</name><operator>.</operator><name>infinite</name></name> <operator>||</operator> <name><name>orig_upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * (-inf, x) or (x, +inf) original ranges are closer to normal
			 * ranges, so it's worse to mix it with empty ranges.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">3</literal> <operator>*</operator> <name>CONTAIN_EMPTY_PENALTY</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The least preferred case is broadening of normal range.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <name>CONTAIN_EMPTY_PENALTY</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>new_lower</name><operator>.</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <name><name>new_upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Handle insertion of (-inf, +inf) range */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>orig_lower</name><operator>.</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <name><name>orig_upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Best case is inserting to (-inf, +inf) original range.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>orig_lower</name><operator>.</operator><name>infinite</name></name> <operator>||</operator> <name><name>orig_upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When original range is (-inf, x) or (x, +inf) it requires
			 * broadening of original range (extension of one bound to
			 * infinity).
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <name>INFINITE_BOUND_PENALTY</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Insertion to normal original range is least preferred.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>INFINITE_BOUND_PENALTY</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RangeIsOrContainsEmpty</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Original range is narrower when it doesn't contain empty
			 * ranges. Add additional penalty otherwise.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>+=</operator> <name>CONTAIN_EMPTY_PENALTY</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>new_lower</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Handle insertion of (-inf, x) range */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>orig_empty</name> <operator>&amp;&amp;</operator> <name><name>orig_lower</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>orig_upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * (-inf, +inf) range won't be extended by insertion of (-inf,
				 * x) range. It's a less desirable case than insertion to
				 * (-inf, y) original range without extension, because in that
				 * case original range is narrower. But we can't express that
				 * in single float value.
				 */</comment>
				<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig_upper</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Get extension of original range using subtype_diff. Use
					 * constant if subtype_diff unavailable.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>has_subtype_diff</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <call><name>call_subtype_diff</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>,
													 <argument><expr><name><name>new_upper</name><operator>.</operator><name>val</name></name></expr></argument>,
													 <argument><expr><name><name>orig_upper</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <name>DEFAULT_SUBTYPE_DIFF_PENALTY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* No extension of original range */</comment>
					<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If lower bound of original range is not -inf, then extension of
			 * it is infinity.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <call><name>get_float4_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>new_upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Handle insertion of (x, +inf) range */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>orig_empty</name> <operator>&amp;&amp;</operator> <name><name>orig_upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>orig_lower</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * (-inf, +inf) range won't be extended by insertion of (x,
				 * +inf) range. It's a less desirable case than insertion to
				 * (y, +inf) original range without extension, because in that
				 * case original range is narrower. But we can't express that
				 * in single float value.
				 */</comment>
				<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig_lower</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Get extension of original range using subtype_diff. Use
					 * constant if subtype_diff unavailable.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>has_subtype_diff</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <call><name>call_subtype_diff</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>,
													 <argument><expr><name><name>orig_lower</name><operator>.</operator><name>val</name></name></expr></argument>,
													 <argument><expr><name><name>new_lower</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <name>DEFAULT_SUBTYPE_DIFF_PENALTY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* No extension of original range */</comment>
					<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If upper bound of original range is not +inf, then extension of
			 * it is infinity.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <call><name>get_float4_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Handle insertion of normal (non-empty, non-infinite) range */</comment>
		<if_stmt><if>if <condition>(<expr><name>orig_empty</name> <operator>||</operator> <name><name>orig_lower</name><operator>.</operator><name>infinite</name></name> <operator>||</operator> <name><name>orig_upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Avoid mixing normal ranges with infinite and empty ranges.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <call><name>get_float4_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Calculate extension of original range by calling subtype_diff.
			 * Use constant if subtype_diff unavailable.
			 */</comment>
			<decl_stmt><decl><type><name>float8</name></type>		<name>diff</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig_lower</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>has_subtype_diff</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>diff</name> <operator>+=</operator> <call><name>call_subtype_diff</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>,
											  <argument><expr><name><name>orig_lower</name><operator>.</operator><name>val</name></name></expr></argument>,
											  <argument><expr><name><name>new_lower</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>diff</name> <operator>+=</operator> <name>DEFAULT_SUBTYPE_DIFF_PENALTY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig_upper</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>has_subtype_diff</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>diff</name> <operator>+=</operator> <call><name>call_subtype_diff</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>,
											  <argument><expr><name><name>new_upper</name><operator>.</operator><name>val</name></name></expr></argument>,
											  <argument><expr><name><name>orig_upper</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>diff</name> <operator>+=</operator> <name>DEFAULT_SUBTYPE_DIFF_PENALTY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>penalty</name> <operator>=</operator> <name>diff</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>penalty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The GiST PickSplit method for ranges
 *
 * Primarily, we try to segregate ranges of different classes.  If splitting
 * ranges of the same class, use the appropriate split method for that class.
 */</comment>
<function><type><name>Datum</name></type>
<name>range_gist_picksplit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name> <init>= <expr><operator>(</operator><name>GistEntryVector</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>GIST_SPLITVEC</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>pred_left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>count_in_classes</name><index>[<expr><name>CLS_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>non_empty_classes_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>biggest_class</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>biggest_class_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>total_count</name></decl>;</decl_stmt>

	<comment type="block">/* use first item to look up range type's info */</comment>
	<expr_stmt><expr><name>pred_left</name> <operator>=</operator> <call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>FirstOffsetNumber</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>pred_left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <operator>(</operator><name>maxoff</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_left</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_right</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get count distribution of range classes.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>count_in_classes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>count_in_classes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>count_in_classes</name><index>[<expr><call><name>get_gist_range_class</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Count non-empty classes and find biggest class.
	 */</comment>
	<expr_stmt><expr><name>total_count</name> <operator>=</operator> <name>maxoff</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>CLS_COUNT</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>count_in_classes</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>count_in_classes</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <name>biggest_class_count</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>biggest_class_count</name> <operator>=</operator> <name><name>count_in_classes</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>biggest_class</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>non_empty_classes_count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>non_empty_classes_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>non_empty_classes_count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* One non-empty class, so split inside class */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>biggest_class</name> <operator>&amp;</operator> <operator>~</operator><name>CLS_CONTAIN_EMPTY</name><operator>)</operator> <operator>==</operator> <name>CLS_NORMAL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* double sorting split for normal ranges */</comment>
			<expr_stmt><expr><call><name>range_gist_double_sorting_split</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>entryvec</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>biggest_class</name> <operator>&amp;</operator> <operator>~</operator><name>CLS_CONTAIN_EMPTY</name><operator>)</operator> <operator>==</operator> <name>CLS_LOWER_INF</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* upper bound sorting split for (-inf, x) ranges */</comment>
			<expr_stmt><expr><call><name>range_gist_single_sorting_split</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>entryvec</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>biggest_class</name> <operator>&amp;</operator> <operator>~</operator><name>CLS_CONTAIN_EMPTY</name><operator>)</operator> <operator>==</operator> <name>CLS_UPPER_INF</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* lower bound sorting split for (x, +inf) ranges */</comment>
			<expr_stmt><expr><call><name>range_gist_single_sorting_split</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>entryvec</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* trivial split for all (-inf, +inf) or all empty ranges */</comment>
			<expr_stmt><expr><call><name>range_gist_fallback_split</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>entryvec</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Class based split.
		 *
		 * To which side of the split should each class go?  Initialize them
		 * all to go to the left side.
		 */</comment>
		<decl_stmt><decl><type><name>SplitLR</name></type>		<name><name>classes_groups</name><index>[<expr><name>CLS_COUNT</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>classes_groups</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>classes_groups</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>count_in_classes</name><index>[<expr><name>CLS_NORMAL</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* separate normal ranges if any */</comment>
			<expr_stmt><expr><name><name>classes_groups</name><index>[<expr><name>CLS_NORMAL</name></expr>]</index></name> <operator>=</operator> <name>SPLIT_RIGHT</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*----------
			 * Try to split classes in one of two ways:
			 *	1) containing infinities - not containing infinities
			 *	2) containing empty - not containing empty
			 *
			 * Select the way which balances the ranges between left and right
			 * the best. If split in these ways is not possible, there are at
			 * most 3 classes, so just separate biggest class.
			 *----------
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>infCount</name></decl>,
						<decl><type ref="prev"/><name>nonInfCount</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>emptyCount</name></decl>,
						<decl><type ref="prev"/><name>nonEmptyCount</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>nonInfCount</name> <operator>=</operator>
				<name><name>count_in_classes</name><index>[<expr><name>CLS_NORMAL</name></expr>]</index></name> <operator>+</operator>
				<name><name>count_in_classes</name><index>[<expr><name>CLS_CONTAIN_EMPTY</name></expr>]</index></name> <operator>+</operator>
				<name><name>count_in_classes</name><index>[<expr><name>CLS_EMPTY</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>infCount</name> <operator>=</operator> <name>total_count</name> <operator>-</operator> <name>nonInfCount</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>nonEmptyCount</name> <operator>=</operator>
				<name><name>count_in_classes</name><index>[<expr><name>CLS_NORMAL</name></expr>]</index></name> <operator>+</operator>
				<name><name>count_in_classes</name><index>[<expr><name>CLS_LOWER_INF</name></expr>]</index></name> <operator>+</operator>
				<name><name>count_in_classes</name><index>[<expr><name>CLS_UPPER_INF</name></expr>]</index></name> <operator>+</operator>
				<name><name>count_in_classes</name><index>[<expr><name>CLS_LOWER_INF</name> <operator>|</operator> <name>CLS_UPPER_INF</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>emptyCount</name> <operator>=</operator> <name>total_count</name> <operator>-</operator> <name>nonEmptyCount</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>infCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nonInfCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<operator>(</operator><call><name>Abs</name><argument_list>(<argument><expr><name>infCount</name> <operator>-</operator> <name>nonInfCount</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator>
				 <call><name>Abs</name><argument_list>(<argument><expr><name>emptyCount</name> <operator>-</operator> <name>nonEmptyCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>classes_groups</name><index>[<expr><name>CLS_NORMAL</name></expr>]</index></name> <operator>=</operator> <name>SPLIT_RIGHT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>classes_groups</name><index>[<expr><name>CLS_CONTAIN_EMPTY</name></expr>]</index></name> <operator>=</operator> <name>SPLIT_RIGHT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>classes_groups</name><index>[<expr><name>CLS_EMPTY</name></expr>]</index></name> <operator>=</operator> <name>SPLIT_RIGHT</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>emptyCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nonEmptyCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>classes_groups</name><index>[<expr><name>CLS_NORMAL</name></expr>]</index></name> <operator>=</operator> <name>SPLIT_RIGHT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>classes_groups</name><index>[<expr><name>CLS_LOWER_INF</name></expr>]</index></name> <operator>=</operator> <name>SPLIT_RIGHT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>classes_groups</name><index>[<expr><name>CLS_UPPER_INF</name></expr>]</index></name> <operator>=</operator> <name>SPLIT_RIGHT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>classes_groups</name><index>[<expr><name>CLS_LOWER_INF</name> <operator>|</operator> <name>CLS_UPPER_INF</name></expr>]</index></name> <operator>=</operator> <name>SPLIT_RIGHT</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Either total_count == emptyCount or total_count ==
				 * infCount.
				 */</comment>
				<expr_stmt><expr><name><name>classes_groups</name><index>[<expr><name>biggest_class</name></expr>]</index></name> <operator>=</operator> <name>SPLIT_RIGHT</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>range_gist_class_split</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>entryvec</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>classes_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* equality comparator for GiST */</comment>
<function><type><name>Datum</name></type>
<name>range_gist_same</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r1</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>r2</name> <init>= <expr><call><name>PG_GETARG_RANGE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * range_eq will ignore the RANGE_CONTAIN_EMPTY flag, so we have to check
	 * that for ourselves.  More generally, if the entries have been properly
	 * normalized, then unequal flags bytes must mean unequal ranges ... so
	 * let's just test all the flag bits at once.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>range_get_flags</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>range_get_flags</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><call><name>RangeTypeGetOid</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>range_eq_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *----------------------------------------------------------
 * STATIC FUNCTIONS
 *----------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Return the smallest range that contains r1 and r2
 *
 * This differs from regular range_union in two critical ways:
 * 1. It won't throw an error for non-adjacent r1 and r2, but just absorb
 * the intervening values into the result range.
 * 2. We track whether any empty range has been union'd into the result,
 * so that contained_by searches can be indexed.  Note that this means
 * that *all* unions formed within the GiST index must go through here.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeType</name> <modifier>*</modifier></type>
<name>range_super_union</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower1</name></decl>,
				<decl><type ref="prev"/><name>lower2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>upper1</name></decl>,
				<decl><type ref="prev"/><name>upper2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty1</name></decl>,
				<decl><type ref="prev"/><name>empty2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags1</name></decl>,
				<decl><type ref="prev"/><name>flags2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>result_lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>result_upper</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flags1</name> <operator>=</operator> <call><name>range_get_flags</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flags2</name> <operator>=</operator> <call><name>range_get_flags</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>empty1</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We can return r2 as-is if it already is or contains empty */</comment>
		<if_stmt><if>if <condition>(<expr><name>flags2</name> <operator>&amp;</operator> <operator>(</operator><name>RANGE_EMPTY</name> <operator>|</operator> <name>RANGE_CONTAIN_EMPTY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>r2</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Else we'd better copy it (modify-in-place isn't safe) */</comment>
		<expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>rangeCopy</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>range_set_contain_empty</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>r2</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>empty2</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We can return r1 as-is if it already is or contains empty */</comment>
		<if_stmt><if>if <condition>(<expr><name>flags1</name> <operator>&amp;</operator> <operator>(</operator><name>RANGE_EMPTY</name> <operator>|</operator> <name>RANGE_CONTAIN_EMPTY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>r1</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Else we'd better copy it (modify-in-place isn't safe) */</comment>
		<expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>rangeCopy</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>range_set_contain_empty</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>r1</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_lower</name> <operator>=</operator> <operator>&amp;</operator><name>lower1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_lower</name> <operator>=</operator> <operator>&amp;</operator><name>lower2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_upper</name> <operator>=</operator> <operator>&amp;</operator><name>upper1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_upper</name> <operator>=</operator> <operator>&amp;</operator><name>upper2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* optimization to avoid constructing a new range */</comment>
	<if_stmt><if>if <condition>(<expr><name>result_lower</name> <operator>==</operator> <operator>&amp;</operator><name>lower1</name> <operator>&amp;&amp;</operator> <name>result_upper</name> <operator>==</operator> <operator>&amp;</operator><name>upper1</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>RANGE_CONTAIN_EMPTY</name><operator>)</operator> <operator>||</operator> <operator>!</operator><operator>(</operator><name>flags2</name> <operator>&amp;</operator> <name>RANGE_CONTAIN_EMPTY</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>r1</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>result_lower</name> <operator>==</operator> <operator>&amp;</operator><name>lower2</name> <operator>&amp;&amp;</operator> <name>result_upper</name> <operator>==</operator> <operator>&amp;</operator><name>upper2</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>flags2</name> <operator>&amp;</operator> <name>RANGE_CONTAIN_EMPTY</name><operator>)</operator> <operator>||</operator> <operator>!</operator><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>RANGE_CONTAIN_EMPTY</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>r2</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>make_range</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>result_lower</name></expr></argument>, <argument><expr><name>result_upper</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags1</name> <operator>&amp;</operator> <name>RANGE_CONTAIN_EMPTY</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>flags2</name> <operator>&amp;</operator> <name>RANGE_CONTAIN_EMPTY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>range_set_contain_empty</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GiST consistent test on an index internal page
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>range_gist_consistent_int</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>,
						  <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RANGESTRAT_BEFORE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>RangeIsEmpty</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RangeIsEmpty</name><argument_list>(<argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><operator>(</operator><operator>!</operator><call><name>range_overright_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
											  <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>RANGESTRAT_OVERLEFT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>RangeIsEmpty</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RangeIsEmpty</name><argument_list>(<argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><operator>(</operator><operator>!</operator><call><name>range_after_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										  <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>RANGESTRAT_OVERLAPS</name></expr>:</case>
			<return>return <expr><call><name>range_overlaps_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										   <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_OVERRIGHT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>RangeIsEmpty</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RangeIsEmpty</name><argument_list>(<argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><operator>(</operator><operator>!</operator><call><name>range_before_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										   <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>RANGESTRAT_AFTER</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>RangeIsEmpty</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RangeIsEmpty</name><argument_list>(<argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><operator>(</operator><operator>!</operator><call><name>range_overleft_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
											 <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>RANGESTRAT_ADJACENT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>RangeIsEmpty</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RangeIsEmpty</name><argument_list>(<argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>range_adjacent_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										<argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><call><name>range_overlaps_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										   <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_CONTAINS</name></expr>:</case>
			<return>return <expr><call><name>range_contains_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										   <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_CONTAINED_BY</name></expr>:</case>

			<comment type="block">/*
			 * Empty ranges are contained by anything, so if key is or
			 * contains any empty ranges, we must descend into it.  Otherwise,
			 * descend only if key overlaps the query.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RangeIsOrContainsEmpty</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><call><name>range_overlaps_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										   <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_CONTAINS_ELEM</name></expr>:</case>
			<return>return <expr><call><name>range_contains_elem_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_EQ</name></expr>:</case>

			<comment type="block">/*
			 * If query is empty, descend only if the key is or contains any
			 * empty ranges.  Otherwise, descend if key contains query.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RangeIsEmpty</name><argument_list>(<argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>RangeIsOrContainsEmpty</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><call><name>range_contains_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										   <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized range strategy: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * GiST consistent test on an index leaf page
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>range_gist_consistent_leaf</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl></parameter>,
						   <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RANGESTRAT_BEFORE</name></expr>:</case>
			<return>return <expr><call><name>range_before_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										 <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_OVERLEFT</name></expr>:</case>
			<return>return <expr><call><name>range_overleft_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										   <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_OVERLAPS</name></expr>:</case>
			<return>return <expr><call><name>range_overlaps_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										   <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_OVERRIGHT</name></expr>:</case>
			<return>return <expr><call><name>range_overright_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
											<argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_AFTER</name></expr>:</case>
			<return>return <expr><call><name>range_after_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										<argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_ADJACENT</name></expr>:</case>
			<return>return <expr><call><name>range_adjacent_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										   <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_CONTAINS</name></expr>:</case>
			<return>return <expr><call><name>range_contains_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
										   <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_CONTAINED_BY</name></expr>:</case>
			<return>return <expr><call><name>range_contained_by_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
											   <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_CONTAINS_ELEM</name></expr>:</case>
			<return>return <expr><call><name>range_contains_elem_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>RANGESTRAT_EQ</name></expr>:</case>
			<return>return <expr><call><name>range_eq_internal</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized range strategy: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Trivial split: half of entries will be placed on one page
 * and the other half on the other page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>range_gist_fallback_split</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
						  <parameter><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl></parameter>,
						  <parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>left_range</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>right_range</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>,
				<decl><type ref="prev"/><name>split_idx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* Split entries before this to left page, after to right: */</comment>
	<expr_stmt><expr><name>split_idx</name> <operator>=</operator> <operator>(</operator><name>maxoff</name> <operator>-</operator> <name>FirstOffsetNumber</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>split_idx</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PLACE_LEFT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PLACE_RIGHT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_ldatum</name></name> <operator>=</operator> <call><name>RangeTypePGetDatum</name><argument_list>(<argument><expr><name>left_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_rdatum</name></name> <operator>=</operator> <call><name>RangeTypePGetDatum</name><argument_list>(<argument><expr><name>right_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Split based on classes of ranges.
 *
 * See get_gist_range_class for class definitions.
 * classes_groups is an array of length CLS_COUNT indicating the side of the
 * split to which each class should go.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>range_gist_class_split</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
					   <parameter><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl></parameter>,
					   <parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
					   <parameter><decl><type><name>SplitLR</name> <modifier>*</modifier></type><name>classes_groups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>left_range</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>right_range</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>class</name></decl>;</decl_stmt>

		<comment type="block">/* Get class of range */</comment>
		<expr_stmt><expr><name>class</name> <operator>=</operator> <call><name>get_gist_range_class</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Place range to appropriate page */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classes_groups</name><index>[<expr><name>class</name></expr>]</index></name> <operator>==</operator> <name>SPLIT_LEFT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PLACE_LEFT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>classes_groups</name><index>[<expr><name>class</name></expr>]</index></name> <operator>==</operator> <name>SPLIT_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PLACE_RIGHT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_ldatum</name></name> <operator>=</operator> <call><name>RangeTypePGetDatum</name><argument_list>(<argument><expr><name>left_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_rdatum</name></name> <operator>=</operator> <call><name>RangeTypePGetDatum</name><argument_list>(<argument><expr><name>right_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sorting based split. First half of entries according to the sort will be
 * placed to one page, and second half of entries will be placed to other
 * page. use_upper_bound parameter indicates whether to use upper or lower
 * bound for sorting.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>range_gist_single_sorting_split</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
								<parameter><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl></parameter>,
								<parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>use_upper_bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SingleBoundSortItem</name> <modifier>*</modifier></type><name>sortItems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>left_range</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>right_range</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>,
				<decl><type ref="prev"/><name>split_idx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>sortItems</name> <operator>=</operator> <operator>(</operator><name>SingleBoundSortItem</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><name>maxoff</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SingleBoundSortItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare auxiliary array and sort the values.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeBound</name></type>	<name>bound2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sortItems</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<comment type="block">/* Put appropriate bound into array */</comment>
		<if_stmt><if>if <condition>(<expr><name>use_upper_bound</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bound2</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>sortItems</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>bound</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sortItems</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>bound</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>bound2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>sortItems</name></expr></argument>, <argument><expr><name>maxoff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SingleBoundSortItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>single_bound_cmp</name></expr></argument>, <argument><expr><name>typcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>split_idx</name> <operator>=</operator> <name>maxoff</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>idx</name> <init>= <expr><name><name>sortItems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>split_idx</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PLACE_LEFT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PLACE_RIGHT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_ldatum</name></name> <operator>=</operator> <call><name>RangeTypePGetDatum</name><argument_list>(<argument><expr><name>left_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_rdatum</name></name> <operator>=</operator> <call><name>RangeTypePGetDatum</name><argument_list>(<argument><expr><name>right_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Double sorting split algorithm.
 *
 * The algorithm considers dividing ranges into two groups. The first (left)
 * group contains general left bound. The second (right) group contains
 * general right bound. The challenge is to find upper bound of left group
 * and lower bound of right group so that overlap of groups is minimal and
 * ratio of distribution is acceptable. Algorithm finds for each lower bound of
 * right group minimal upper bound of left group, and for each upper bound of
 * left group maximal lower bound of right group. For each found pair
 * range_gist_consider_split considers replacement of currently selected
 * split with the new one.
 *
 * After that, all the entries are divided into three groups:
 * 1) Entries which should be placed to the left group
 * 2) Entries which should be placed to the right group
 * 3) "Common entries" which can be placed to either group without affecting
 *	  amount of overlap.
 *
 * The common ranges are distributed by difference of distance from lower
 * bound of common range to lower bound of right group and distance from upper
 * bound of common range to upper bound of left group.
 *
 * For details see:
 * "A new double sorting-based node splitting algorithm for R-tree",
 * A. Korotkov
 * http://syrcose.ispras.ru/2011/files/SYRCoSE2011_Proceedings.pdf#page=36
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>range_gist_double_sorting_split</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
								<parameter><decl><type><name>GistEntryVector</name> <modifier>*</modifier></type><name>entryvec</name></decl></parameter>,
								<parameter><decl><type><name>GIST_SPLITVEC</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConsiderSplitContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>left_range</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>right_range</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>common_entries_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NonEmptyRange</name> <modifier>*</modifier></type><name>by_lower</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>by_upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommonEntry</name> <modifier>*</modifier></type><name>common_entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nentries</name></decl>,
				<decl><type ref="prev"/><name>i1</name></decl>,
				<decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>right_lower</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>left_upper</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConsiderSplitContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>typcache</name></name> <operator>=</operator> <name>typcache</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>has_subtype_diff</name></name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_subdiff_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name><name>entryvec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nentries</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>entries_count</name></name> <operator>=</operator> <name>maxoff</name> <operator>-</operator> <name>FirstOffsetNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>first</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Allocate arrays for sorted range bounds */</comment>
	<expr_stmt><expr><name>by_lower</name> <operator>=</operator> <operator>(</operator><name>NonEmptyRange</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nentries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NonEmptyRange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>by_upper</name> <operator>=</operator> <operator>(</operator><name>NonEmptyRange</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nentries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NonEmptyRange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill arrays of bounds */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>range</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>by_lower</name><index>[<expr><name>i</name> <operator>-</operator> <name>FirstOffsetNumber</name></expr>]</index></name><operator>.</operator><name>lower</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>by_lower</name><index>[<expr><name>i</name> <operator>-</operator> <name>FirstOffsetNumber</name></expr>]</index></name><operator>.</operator><name>upper</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Make two arrays of range bounds: one sorted by lower bound and another
	 * sorted by upper bound.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>by_upper</name></expr></argument>, <argument><expr><name>by_lower</name></expr></argument>, <argument><expr><name>nentries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NonEmptyRange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>by_lower</name></expr></argument>, <argument><expr><name>nentries</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NonEmptyRange</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>interval_cmp_lower</name></expr></argument>, <argument><expr><name>typcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name>by_upper</name></expr></argument>, <argument><expr><name>nentries</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NonEmptyRange</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>interval_cmp_upper</name></expr></argument>, <argument><expr><name>typcache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*----------
	 * The goal is to form a left and right range, so that every entry
	 * range is contained by either left or right interval (or both).
	 *
	 * For example, with the ranges (0,1), (1,3), (2,3), (2,4):
	 *
	 * 0 1 2 3 4
	 * +-+
	 *	 +---+
	 *	   +-+
	 *	   +---+
	 *
	 * The left and right ranges are of the form (0,a) and (b,4).
	 * We first consider splits where b is the lower bound of an entry.
	 * We iterate through all entries, and for each b, calculate the
	 * smallest possible a. Then we consider splits where a is the
	 * upper bound of an entry, and for each a, calculate the greatest
	 * possible b.
	 *
	 * In the above example, the first loop would consider splits:
	 * b=0: (0,1)-(0,4)
	 * b=1: (0,1)-(1,4)
	 * b=2: (0,3)-(2,4)
	 *
	 * And the second loop:
	 * a=1: (0,1)-(1,4)
	 * a=3: (0,3)-(2,4)
	 * a=4: (0,4)-(2,4)
	 *----------
	 */</comment>

	<comment type="block">/*
	 * Iterate over lower bound of right group, finding smallest possible
	 * upper bound of left group.
	 */</comment>
	<expr_stmt><expr><name>i1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>right_lower</name> <operator>=</operator> <operator>&amp;</operator><name><name>by_lower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>lower</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>left_upper</name> <operator>=</operator> <operator>&amp;</operator><name><name>by_upper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>lower</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Find next lower bound of right group.
		 */</comment>
		<while>while <condition>(<expr><name>i1</name> <operator>&lt;</operator> <name>nentries</name> <operator>&amp;&amp;</operator>
			   <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>right_lower</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>by_lower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>lower</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>by_lower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>upper</name></expr></argument>,
								 <argument><expr><name>left_upper</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>left_upper</name> <operator>=</operator> <operator>&amp;</operator><name><name>by_lower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>upper</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>i1</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>i1</name> <operator>&gt;=</operator> <name>nentries</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>right_lower</name> <operator>=</operator> <operator>&amp;</operator><name><name>by_lower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>lower</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find count of ranges which anyway should be placed to the left
		 * group.
		 */</comment>
		<while>while <condition>(<expr><name>i2</name> <operator>&lt;</operator> <name>nentries</name> <operator>&amp;&amp;</operator>
			   <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>by_upper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>upper</name></expr></argument>,
								<argument><expr><name>left_upper</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>i2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/*
		 * Consider found split to see if it's better than what we had.
		 */</comment>
		<expr_stmt><expr><call><name>range_gist_consider_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>right_lower</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>left_upper</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Iterate over upper bound of left group finding greatest possible lower
	 * bound of right group.
	 */</comment>
	<expr_stmt><expr><name>i1</name> <operator>=</operator> <name>nentries</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i2</name> <operator>=</operator> <name>nentries</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>right_lower</name> <operator>=</operator> <operator>&amp;</operator><name><name>by_lower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>upper</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>left_upper</name> <operator>=</operator> <operator>&amp;</operator><name><name>by_upper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>upper</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Find next upper bound of left group.
		 */</comment>
		<while>while <condition>(<expr><name>i2</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			   <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>left_upper</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>by_upper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>upper</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>by_upper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>lower</name></expr></argument>,
								 <argument><expr><name>right_lower</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>right_lower</name> <operator>=</operator> <operator>&amp;</operator><name><name>by_upper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>lower</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>i2</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>i2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>left_upper</name> <operator>=</operator> <operator>&amp;</operator><name><name>by_upper</name><index>[<expr><name>i2</name></expr>]</index></name><operator>.</operator><name>upper</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find count of intervals which anyway should be placed to the right
		 * group.
		 */</comment>
		<while>while <condition>(<expr><name>i1</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			   <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>by_lower</name><index>[<expr><name>i1</name></expr>]</index></name><operator>.</operator><name>lower</name></expr></argument>,
								<argument><expr><name>right_lower</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>i1</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/*
		 * Consider found split to see if it's better than what we had.
		 */</comment>
		<expr_stmt><expr><call><name>range_gist_consider_split</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>right_lower</name></expr></argument>, <argument><expr><name>i1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>left_upper</name></expr></argument>, <argument><expr><name>i2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If we failed to find any acceptable splits, use trivial split.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>first</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>range_gist_fallback_split</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>entryvec</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Ok, we have now selected bounds of the groups. Now we have to
	 * distribute entries themselves. At first we distribute entries which can
	 * be placed unambiguously and collect "common entries" to array.
	 */</comment>

	<comment type="block">/* Allocate vectors for results */</comment>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_left</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nentries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_right</name></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nentries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nleft</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_nright</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate an array for "common entries" - entries which can be placed to
	 * either group without affecting overlap along selected axis.
	 */</comment>
	<expr_stmt><expr><name>common_entries_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>common_entries</name> <operator>=</operator> <operator>(</operator><name>CommonEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nentries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CommonEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Distribute entries which can be distributed unambiguously, and collect
	 * common entries.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>,
					<decl><type ref="prev"/><name>upper</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get upper and lower bounds along selected axis.
		 */</comment>
		<expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>left_upper</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Fits in the left group */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>right_lower</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Fits also in the right group, so "common entry" */</comment>
				<expr_stmt><expr><name><name>common_entries</name><index>[<expr><name>common_entries_count</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>has_subtype_diff</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * delta = (lower - context.right_lower) -
					 * (context.left_upper - upper)
					 */</comment>
					<expr_stmt><expr><name><name>common_entries</name><index>[<expr><name>common_entries_count</name></expr>]</index></name><operator>.</operator><name>delta</name> <operator>=</operator>
						<call><name>call_subtype_diff</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>,
										  <argument><expr><name><name>lower</name><operator>.</operator><name>val</name></name></expr></argument>,
										  <argument><expr><name><name>context</name><operator>.</operator><name>right_lower</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call> <operator>-</operator>
						<call><name>call_subtype_diff</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>,
										  <argument><expr><name><name>context</name><operator>.</operator><name>left_upper</name><operator>-&gt;</operator><name>val</name></name></expr></argument>,
										  <argument><expr><name><name>upper</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Without subtype_diff, take all deltas as zero */</comment>
					<expr_stmt><expr><name><name>common_entries</name><index>[<expr><name>common_entries_count</name></expr>]</index></name><operator>.</operator><name>delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>common_entries_count</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Doesn't fit to the right group, so join to the left group */</comment>
				<expr_stmt><expr><call><name>PLACE_LEFT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Each entry should fit on either left or right group. Since this
			 * entry didn't fit in the left group, it better fit in the right
			 * group.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>,
									<argument><expr><name><name>context</name><operator>.</operator><name>right_lower</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PLACE_RIGHT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Distribute "common entries", if any.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>common_entries_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Sort "common entries" by calculated deltas in order to distribute
		 * the most ambiguous entries first.
		 */</comment>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>common_entries</name></expr></argument>, <argument><expr><name>common_entries_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CommonEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			  <argument><expr><name>common_entry_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Distribute "common entries" between groups according to sorting.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>common_entries_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>idx</name> <init>= <expr><name><name>common_entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>entryvec</name><operator>-&gt;</operator><name>vector</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check if we have to place this entry in either group to achieve
			 * LIMIT_RATIO.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>context</name><operator>.</operator><name>common_left</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PLACE_LEFT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PLACE_RIGHT</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_ldatum</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>left_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>spl_rdatum</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>right_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Consider replacement of currently selected split with a better one
 * during range_gist_double_sorting_split.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>range_gist_consider_split</name><parameter_list>(<parameter><decl><type><name>ConsiderSplitContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
						  <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>right_lower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min_left_count</name></decl></parameter>,
						  <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>left_upper</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_left_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>left_count</name></decl>,
				<decl><type ref="prev"/><name>right_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>ratio</name></decl>,
				<decl><type ref="prev"/><name>overlap</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Calculate entries distribution ratio assuming most uniform distribution
	 * of common entries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>min_left_count</name> <operator>&gt;=</operator> <operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>entries_count</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>left_count</name> <operator>=</operator> <name>min_left_count</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>max_left_count</name> <operator>&lt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>entries_count</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>left_count</name> <operator>=</operator> <name>max_left_count</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>left_count</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>entries_count</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>right_count</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>entries_count</name></name> <operator>-</operator> <name>left_count</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ratio of split: quotient between size of smaller group and total
	 * entries count.  This is necessarily 0.5 or less; if it's less than
	 * LIMIT_RATIO then we will never accept the new split.
	 */</comment>
	<expr_stmt><expr><name>ratio</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float4</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><name>left_count</name></expr></argument>, <argument><expr><name>right_count</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator>
		<operator>(</operator><operator>(</operator><name>float4</name><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>entries_count</name></name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ratio</name> <operator>&gt;</operator> <name>LIMIT_RATIO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>selectthis</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The ratio is acceptable, so compare current split with previously
		 * selected one. We search for minimal overlap (allowing negative
		 * values) and minimal ratio secondarily.  If subtype_diff is
		 * available, it's used for overlap measure.  Without subtype_diff we
		 * use number of "common entries" as an overlap measure.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>has_subtype_diff</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>overlap</name> <operator>=</operator> <call><name>call_subtype_diff</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>typcache</name></name></expr></argument>,
										<argument><expr><name><name>left_upper</name><operator>-&gt;</operator><name>val</name></name></expr></argument>,
										<argument><expr><name><name>right_lower</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>overlap</name> <operator>=</operator> <name>max_left_count</name> <operator>-</operator> <name>min_left_count</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* If there is no previous selection, select this split */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>first</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selectthis</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Choose the new split if it has a smaller overlap, or same
			 * overlap but better ratio.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>overlap</name> <operator>&lt;</operator> <name><name>context</name><operator>-&gt;</operator><name>overlap</name></name> <operator>||</operator>
				<operator>(</operator><name>overlap</name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>overlap</name></name> <operator>&amp;&amp;</operator> <name>ratio</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>ratio</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selectthis</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>selectthis</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* save information about selected split */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>ratio</name></name> <operator>=</operator> <name>ratio</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>overlap</name></name> <operator>=</operator> <name>overlap</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>right_lower</name></name> <operator>=</operator> <name>right_lower</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>left_upper</name></name> <operator>=</operator> <name>left_upper</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>common_left</name></name> <operator>=</operator> <name>max_left_count</name> <operator>-</operator> <name>left_count</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>common_right</name></name> <operator>=</operator> <name>left_count</name> <operator>-</operator> <name>min_left_count</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find class number for range.
 *
 * The class number is a valid combination of the properties of the
 * range.  Note: the highest possible number is 8, because CLS_EMPTY
 * can't be combined with anything else.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_gist_range_class</name><parameter_list>(<parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>classNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>flags</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>range_get_flags</name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_EMPTY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>classNumber</name> <operator>=</operator> <name>CLS_EMPTY</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>classNumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_LB_INF</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>classNumber</name> <operator>|=</operator> <name>CLS_LOWER_INF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_UB_INF</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>classNumber</name> <operator>|=</operator> <name>CLS_UPPER_INF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>RANGE_CONTAIN_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>classNumber</name> <operator>|=</operator> <name>CLS_CONTAIN_EMPTY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>classNumber</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison function for range_gist_single_sorting_split.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>single_bound_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SingleBoundSortItem</name> <modifier>*</modifier></type><name>i1</name> <init>= <expr><operator>(</operator><name>SingleBoundSortItem</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SingleBoundSortItem</name> <modifier>*</modifier></type><name>i2</name> <init>= <expr><operator>(</operator><name>SingleBoundSortItem</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name> <init>= <expr><operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>i1</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>i2</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare NonEmptyRanges by lower bound.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>interval_cmp_lower</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NonEmptyRange</name> <modifier>*</modifier></type><name>i1</name> <init>= <expr><operator>(</operator><name>NonEmptyRange</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NonEmptyRange</name> <modifier>*</modifier></type><name>i2</name> <init>= <expr><operator>(</operator><name>NonEmptyRange</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name> <init>= <expr><operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>i1</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>i2</name><operator>-&gt;</operator><name>lower</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare NonEmptyRanges by upper bound.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>interval_cmp_upper</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NonEmptyRange</name> <modifier>*</modifier></type><name>i1</name> <init>= <expr><operator>(</operator><name>NonEmptyRange</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NonEmptyRange</name> <modifier>*</modifier></type><name>i2</name> <init>= <expr><operator>(</operator><name>NonEmptyRange</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name> <init>= <expr><operator>(</operator><name>TypeCacheEntry</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>i1</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>i2</name><operator>-&gt;</operator><name>upper</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare CommonEntrys by their deltas.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>common_entry_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>delta1</name> <init>= <expr><operator>(</operator><operator>(</operator><name>CommonEntry</name> <operator>*</operator><operator>)</operator> <name>i1</name><operator>)</operator><operator>-&gt;</operator><name>delta</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>delta2</name> <init>= <expr><operator>(</operator><operator>(</operator><name>CommonEntry</name> <operator>*</operator><operator>)</operator> <name>i2</name><operator>)</operator><operator>-&gt;</operator><name>delta</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>delta1</name> <operator>&lt;</operator> <name>delta2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>delta1</name> <operator>&gt;</operator> <name>delta2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convenience function to invoke type-specific subtype_diff function.
 * Caller must have already checked that there is one for the range type.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>call_subtype_diff</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val1</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>value</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>typcache</name><operator>-&gt;</operator><name>rng_subdiff_finfo</name></name></expr></argument>,
											 <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
											 <argument><expr><name>val1</name></expr></argument>, <argument><expr><name>val2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Cope with buggy subtype_diff function by returning zero */</comment>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>value</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0.0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
