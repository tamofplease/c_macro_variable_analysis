<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/adt/jsonfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * jsonfuncs.c
 *		Functions to process JSON data types.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/jsonfuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/jsonapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/jsonb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<comment type="block">/* Operations available for setPath */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JB_PATH_CREATE</name></cpp:macro>					<cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JB_PATH_DELETE</name></cpp:macro>					<cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JB_PATH_REPLACE</name></cpp:macro>					<cpp:value>0x0004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JB_PATH_INSERT_BEFORE</name></cpp:macro>			<cpp:value>0x0008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JB_PATH_INSERT_AFTER</name></cpp:macro>			<cpp:value>0x0010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JB_PATH_CREATE_OR_INSERT</name></cpp:macro> \
	<cpp:value>(JB_PATH_INSERT_BEFORE | JB_PATH_INSERT_AFTER | JB_PATH_CREATE)</cpp:value></cpp:define>

<comment type="block">/* state for json_object_keys */</comment>
<typedef>typedef <type><struct>struct <name>OkeysState</name>
<block>{
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sent_count</name></decl>;</decl_stmt>
}</block></struct></type> <name>OkeysState</name>;</typedef>

<comment type="block">/* state for iterate_json_string_values function */</comment>
<typedef>typedef <type><struct>struct <name>IterateJsonStringValuesState</name>
<block>{
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonIterateStringValuesAction</name></type> <name>action</name></decl>;</decl_stmt>	<comment type="block">/* an action that will be applied
											 * to each json value */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>action_state</name></decl>;</decl_stmt>	<comment type="block">/* any necessary context for iteration */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>flags</name></decl>;</decl_stmt>			<comment type="block">/* what kind of elements from a json we want
								 * to iterate */</comment>
}</block></struct></type> <name>IterateJsonStringValuesState</name>;</typedef>

<comment type="block">/* state for transform_json_string_values function */</comment>
<typedef>typedef <type><struct>struct <name>TransformJsonStringValuesState</name>
<block>{
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>strval</name></decl>;</decl_stmt>			<comment type="block">/* resulting json */</comment>
	<decl_stmt><decl><type><name>JsonTransformStringValuesAction</name></type> <name>action</name></decl>;</decl_stmt> <comment type="block">/* an action that will be applied
											 * to each json value */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>action_state</name></decl>;</decl_stmt>	<comment type="block">/* any necessary context for transformation */</comment>
}</block></struct></type> <name>TransformJsonStringValuesState</name>;</typedef>

<comment type="block">/* state for json_get* functions */</comment>
<typedef>typedef <type><struct>struct <name>GetState</name>
<block>{
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>tresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>normalize_results</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>next_scalar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>npath</name></decl>;</decl_stmt>			<comment type="block">/* length of each path-related array */</comment>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>path_names</name></decl>;</decl_stmt>		<comment type="block">/* field name(s) being sought */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>path_indexes</name></decl>;</decl_stmt>	<comment type="block">/* array index(es) being sought */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>pathok</name></decl>;</decl_stmt>			<comment type="block">/* is path matched to current depth? */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>array_cur_index</name></decl>;</decl_stmt>	<comment type="block">/* current element index at each path
									 * level */</comment>
}</block></struct></type> <name>GetState</name>;</typedef>

<comment type="block">/* state for json_array_length */</comment>
<typedef>typedef <type><struct>struct <name>AlenState</name>
<block>{
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>
}</block></struct></type> <name>AlenState</name>;</typedef>

<comment type="block">/* state for json_each */</comment>
<typedef>typedef <type><struct>struct <name>EachState</name>
<block>{
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>ret_tdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmp_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>normalize_results</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>next_scalar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>normalized_scalar</name></decl>;</decl_stmt>
}</block></struct></type> <name>EachState</name>;</typedef>

<comment type="block">/* state for json_array_elements */</comment>
<typedef>typedef <type><struct>struct <name>ElementsState</name>
<block>{
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>function_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>ret_tdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmp_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>normalize_results</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>next_scalar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>normalized_scalar</name></decl>;</decl_stmt>
}</block></struct></type> <name>ElementsState</name>;</typedef>

<comment type="block">/* state for get_json_object_as_hash */</comment>
<typedef>typedef <type><struct>struct <name>JHashState</name>
<block>{
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>function_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>saved_scalar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save_json_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTokenType</name></type> <name>saved_token_type</name></decl>;</decl_stmt>
}</block></struct></type> <name>JHashState</name>;</typedef>

<comment type="block">/* hashtable element */</comment>
<typedef>typedef <type><struct>struct <name>JsonHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* hash key (MUST BE FIRST) */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTokenType</name></type> <name>type</name></decl>;</decl_stmt>
}</block></struct></type> <name>JsonHashEntry</name>;</typedef>

<comment type="block">/* structure to cache type I/O metadata needed for populate_scalar() */</comment>
<typedef>typedef <type><struct>struct <name>ScalarIOData</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typioparam</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>typiofunc</name></decl>;</decl_stmt>
}</block></struct></type> <name>ScalarIOData</name>;</typedef>

<comment type="block">/* these two structures are used recursively */</comment>
<typedef>typedef <type><name><name>struct</name> <name>ColumnIOData</name></name></type> <name>ColumnIOData</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>RecordIOData</name></name></type> <name>RecordIOData</name>;</typedef>

<comment type="block">/* structure to cache metadata needed for populate_array() */</comment>
<typedef>typedef <type><struct>struct <name>ArrayIOData</name>
<block>{
	<decl_stmt><decl><type><name>ColumnIOData</name> <modifier>*</modifier></type><name>element_info</name></decl>;</decl_stmt> <comment type="block">/* metadata cache */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name></decl>;</decl_stmt>	<comment type="block">/* array element type id */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>element_typmod</name></decl>;</decl_stmt> <comment type="block">/* array element type modifier */</comment>
}</block></struct></type> <name>ArrayIOData</name>;</typedef>

<comment type="block">/* structure to cache metadata needed for populate_composite() */</comment>
<typedef>typedef <type><struct>struct <name>CompositeIOData</name>
<block>{
	<comment type="block">/*
	 * We use pointer to a RecordIOData here because variable-length struct
	 * RecordIOData can't be used directly in ColumnIOData.io union
	 */</comment>
	<decl_stmt><decl><type><name>RecordIOData</name> <modifier>*</modifier></type><name>record_io</name></decl>;</decl_stmt>	<comment type="block">/* metadata cache for populate_record() */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>		<comment type="block">/* cached tuple descriptor */</comment>
	<comment type="block">/* these fields differ from target type only if domain over composite: */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>base_typid</name></decl>;</decl_stmt>		<comment type="block">/* base type id */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>base_typmod</name></decl>;</decl_stmt>	<comment type="block">/* base type modifier */</comment>
	<comment type="block">/* this field is used only if target type is domain over composite: */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>domain_info</name></decl>;</decl_stmt>	<comment type="block">/* opaque cache for domain checks */</comment>
}</block></struct></type> <name>CompositeIOData</name>;</typedef>

<comment type="block">/* structure to cache metadata needed for populate_domain() */</comment>
<typedef>typedef <type><struct>struct <name>DomainIOData</name>
<block>{
	<decl_stmt><decl><type><name>ColumnIOData</name> <modifier>*</modifier></type><name>base_io</name></decl>;</decl_stmt>		<comment type="block">/* metadata cache */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>base_typid</name></decl>;</decl_stmt>		<comment type="block">/* base type id */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>base_typmod</name></decl>;</decl_stmt>	<comment type="block">/* base type modifier */</comment>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>domain_info</name></decl>;</decl_stmt>	<comment type="block">/* opaque cache for domain checks */</comment>
}</block></struct></type> <name>DomainIOData</name>;</typedef>

<comment type="block">/* enumeration type categories */</comment>
<typedef>typedef <type><enum>enum <name>TypeCat</name>
<block>{
	<decl><name>TYPECAT_SCALAR</name> <init>= <expr><literal type="char">'s'</literal></expr></init></decl>,
	<decl><name>TYPECAT_ARRAY</name> <init>= <expr><literal type="char">'a'</literal></expr></init></decl>,
	<decl><name>TYPECAT_COMPOSITE</name> <init>= <expr><literal type="char">'c'</literal></expr></init></decl>,
	<decl><name>TYPECAT_COMPOSITE_DOMAIN</name> <init>= <expr><literal type="char">'C'</literal></expr></init></decl>,
	<decl><name>TYPECAT_DOMAIN</name> <init>= <expr><literal type="char">'d'</literal></expr></init></decl>
}</block></enum></type> <name>TypeCat</name>;</typedef>

<comment type="block">/* these two are stolen from hstore / record_out, used in populate_record* */</comment>

<comment type="block">/* structure to cache record metadata needed for populate_record_field() */</comment>
<struct>struct <name>ColumnIOData</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name></decl>;</decl_stmt>			<comment type="block">/* column type id */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>			<comment type="block">/* column type modifier */</comment>
	<decl_stmt><decl><type><name>TypeCat</name></type>		<name>typcat</name></decl>;</decl_stmt>			<comment type="block">/* column type category */</comment>
	<decl_stmt><decl><type><name>ScalarIOData</name></type> <name>scalar_io</name></decl>;</decl_stmt>		<comment type="block">/* metadata cache for directi conversion
								 * through input function */</comment>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>ArrayIOData</name></type> <name>array</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CompositeIOData</name></type> <name>composite</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DomainIOData</name></type> <name>domain</name></decl>;</decl_stmt>
	}</block>			<decl><name>io</name></decl>;</union>				<comment type="block">/* metadata cache for various column type
								 * categories */</comment>
}</block>;</struct>

<comment type="block">/* structure to cache record metadata needed for populate_record() */</comment>
<struct>struct <name>RecordIOData</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>record_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>record_typmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnIOData</name></type> <name><name>columns</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* per-query cache for populate_record_worker and populate_recordset_worker */</comment>
<typedef>typedef <type><struct>struct <name>PopulateRecordCache</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name></decl>;</decl_stmt>		<comment type="block">/* declared type of the record argument */</comment>
	<decl_stmt><decl><type><name>ColumnIOData</name></type> <name>c</name></decl>;</decl_stmt>				<comment type="block">/* metadata cache for populate_composite() */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>fn_mcxt</name></decl>;</decl_stmt>		<comment type="block">/* where this is stored */</comment>
}</block></struct></type> <name>PopulateRecordCache</name>;</typedef>

<comment type="block">/* per-call state for populate_recordset */</comment>
<typedef>typedef <type><struct>struct <name>PopulateRecordsetState</name>
<block>{
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>function_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>json_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>saved_scalar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save_json_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTokenType</name></type> <name>saved_token_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>rec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PopulateRecordCache</name> <modifier>*</modifier></type><name>cache</name></decl>;</decl_stmt>
}</block></struct></type> <name>PopulateRecordsetState</name>;</typedef>

<comment type="block">/* common data for populate_array_json() and populate_array_dim_jsonb() */</comment>
<typedef>typedef <type><struct>struct <name>PopulateArrayContext</name>
<block>{
	<decl_stmt><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name></decl>;</decl_stmt>	<comment type="block">/* array build state */</comment>
	<decl_stmt><decl><type><name>ArrayIOData</name> <modifier>*</modifier></type><name>aio</name></decl>;</decl_stmt>			<comment type="block">/* metadata cache */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>acxt</name></decl>;</decl_stmt>			<comment type="block">/* array build memory context */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl>;</decl_stmt>			<comment type="block">/* cache memory context */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>		<comment type="block">/* for diagnostics only */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dims</name></decl>;</decl_stmt>			<comment type="block">/* dimensions */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>sizes</name></decl>;</decl_stmt>			<comment type="block">/* current dimension counters */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name></decl>;</decl_stmt>			<comment type="block">/* number of dimensions */</comment>
}</block></struct></type> <name>PopulateArrayContext</name>;</typedef>

<comment type="block">/* state for populate_array_json() */</comment>
<typedef>typedef <type><struct>struct <name>PopulateArrayState</name>
<block>{
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>		<comment type="block">/* json lexer */</comment>
	<decl_stmt><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>	<comment type="block">/* context */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>element_start</name></decl>;</decl_stmt>	<comment type="block">/* start of the current array element */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>element_scalar</name></decl>;</decl_stmt> <comment type="block">/* current array element token if it is a
								 * scalar */</comment>
	<decl_stmt><decl><type><name>JsonTokenType</name></type> <name>element_type</name></decl>;</decl_stmt> <comment type="block">/* current array element type */</comment>
}</block></struct></type> <name>PopulateArrayState</name>;</typedef>

<comment type="block">/* state for json_strip_nulls */</comment>
<typedef>typedef <type><struct>struct <name>StripnullState</name>
<block>{
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>strval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skip_next_null</name></decl>;</decl_stmt>
}</block></struct></type> <name>StripnullState</name>;</typedef>

<comment type="block">/* structure for generalized json/jsonb value passing */</comment>
<typedef>typedef <type><struct>struct <name>JsValue</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_json</name></decl>;</decl_stmt>		<comment type="block">/* json/jsonb */</comment>
	<union>union
	<block>{
		<struct>struct
		<block>{
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>	<comment type="block">/* json string */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>	<comment type="block">/* json string length or -1 if null-terminated */</comment>
			<decl_stmt><decl><type><name>JsonTokenType</name></type> <name>type</name></decl>;</decl_stmt> <comment type="block">/* json type */</comment>
		}</block>			<decl><name>json</name></decl>;</struct>		<comment type="block">/* json value */</comment>

		<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>jsonb</name></decl>;</decl_stmt>		<comment type="block">/* jsonb value */</comment>
	}</block>			<decl><name>val</name></decl>;</union>
}</block></struct></type> <name>JsValue</name>;</typedef>

<typedef>typedef <type><struct>struct <name>JsObject</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_json</name></decl>;</decl_stmt>		<comment type="block">/* json/jsonb */</comment>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>json_hash</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>jsonb_cont</name></decl>;</decl_stmt>
	}</block>			<decl><name>val</name></decl>;</union>
}</block></struct></type> <name>JsObject</name>;</typedef>

<comment type="block">/* useful macros for testing JsValue properties */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JsValueIsNull</name><parameter_list>(<parameter><type><name>jsv</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((jsv)-&gt;is_json ?  \
		(!(jsv)-&gt;val.json.str || (jsv)-&gt;val.json.type == JSON_TOKEN_NULL) : \
		(!(jsv)-&gt;val.jsonb || (jsv)-&gt;val.jsonb-&gt;type == jbvNull))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JsValueIsString</name><parameter_list>(<parameter><type><name>jsv</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((jsv)-&gt;is_json ? (jsv)-&gt;val.json.type == JSON_TOKEN_STRING \
		: ((jsv)-&gt;val.jsonb &amp;&amp; (jsv)-&gt;val.jsonb-&gt;type == jbvString))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JsObjectIsEmpty</name><parameter_list>(<parameter><type><name>jso</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((jso)-&gt;is_json \
		? hash_get_num_entries((jso)-&gt;val.json_hash) == 0 \
		: ((jso)-&gt;val.jsonb_cont == NULL || \
		   JsonContainerSize((jso)-&gt;val.jsonb_cont) == 0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JsObjectFree</name><parameter_list>(<parameter><type><name>jso</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if ((jso)-&gt;is_json) \
			hash_destroy((jso)-&gt;val.json_hash); \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* semantic action functions for json_object_keys */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>okeys_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>okeys_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>okeys_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* semantic action functions for json_get* functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_object_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_object_field_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_array_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_array_element_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* common worker function for json getter functions */</comment>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>get_path_all</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>get_worker</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tpath</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ipath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>npath</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>normalize_results</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>get_jsonb_path_all</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* semantic action functions for json_array_length */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>alen_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>alen_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>alen_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* common workers for json{b}_each* functions */</comment>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>each_worker</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>each_worker_jsonb</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* semantic action functions for json_each */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>each_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>each_object_field_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>each_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>each_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* common workers for json{b}_array_elements_* functions */</comment>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>elements_worker</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>elements_worker_jsonb</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* semantic action functions for json_array_elements */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elements_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elements_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elements_array_element_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elements_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* turn a json object into a hash table */</comment>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>get_json_object_as_hash</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* semantic actions for populate_array_json */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_array_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_array_array_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_array_element_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_array_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* semantic action functions for get_json_object_as_hash */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hash_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hash_object_field_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hash_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>hash_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* semantic action functions for populate_recordset */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_recordset_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_recordset_object_field_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_recordset_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_recordset_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_recordset_object_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_recordset_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_recordset_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* semantic action functions for json_strip_nulls */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sn_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sn_object_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sn_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sn_array_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sn_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sn_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sn_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* worker functions for populate_record, to_record, populate_recordset and to_recordset */</comment>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>populate_recordset_worker</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>is_json</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>have_record_arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>populate_record_worker</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>is_json</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>have_record_arg</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* helper functions for populate_record[set] */</comment>
<function_decl><type><specifier>static</specifier> <name>HeapTupleHeader</name></type> <name>populate_record</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>RecordIOData</name> <modifier>*</modifier><modifier>*</modifier></type><name>record_p</name></decl></parameter>,
				<parameter><decl><type><name>HeapTupleHeader</name></type> <name>defaultval</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>,
				<parameter><decl><type><name>JsObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_record_type_from_argument</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
										  <parameter><decl><type><name>PopulateRecordCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_record_type_from_query</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
									   <parameter><decl><type><name>PopulateRecordCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>JsValueToJsObject</name><parameter_list>(<parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>, <parameter><decl><type><name>JsObject</name> <modifier>*</modifier></type><name>jso</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>populate_composite</name><parameter_list>(<parameter><decl><type><name>CompositeIOData</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>,
				   <parameter><decl><type><name>HeapTupleHeader</name></type> <name>defaultval</name></decl></parameter>, <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>populate_scalar</name><parameter_list>(<parameter><decl><type><name>ScalarIOData</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>, <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepare_column_cache</name><parameter_list>(<parameter><decl><type><name>ColumnIOData</name> <modifier>*</modifier></type><name>column</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
					 <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_scalar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>populate_record_field</name><parameter_list>(<parameter><decl><type><name>ColumnIOData</name> <modifier>*</modifier></type><name>col</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>defaultval</name></decl></parameter>,
					  <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RecordIOData</name> <modifier>*</modifier></type><name>allocate_record_info</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ncolumns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>JsObjectGetField</name><parameter_list>(<parameter><decl><type><name>JsObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_recordset_record</name><parameter_list>(<parameter><decl><type><name>PopulateRecordsetState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>JsObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_array_json</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_array_dim_jsonb</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>jbv</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_array_report_expected_array</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_array_assign_ndims</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndims</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_array_check_dimension</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>populate_array_element</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>, <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>populate_array</name><parameter_list>(<parameter><decl><type><name>ArrayIOData</name> <modifier>*</modifier></type><name>aio</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
			   <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>, <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>populate_domain</name><parameter_list>(<parameter><decl><type><name>DomainIOData</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
				<parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>, <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Worker that takes care of common setup for us */</comment>
<function_decl><type><specifier>static</specifier> <name>JsonbValue</name> <modifier>*</modifier></type><name>findJsonbValueFromContainerLen</name><parameter_list>(<parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>container</name></decl></parameter>,
							   <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>,
							   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
							   <parameter><decl><type><name>uint32</name></type> <name>keylen</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* functions supporting jsonb_delete, jsonb_set and jsonb_concat */</comment>
<function_decl><type><specifier>static</specifier> <name>JsonbValue</name> <modifier>*</modifier></type><name>IteratorConcat</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it1</name></decl></parameter>, <parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it2</name></decl></parameter>,
			   <parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JsonbValue</name> <modifier>*</modifier></type><name>setPath</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>path_elems</name></decl></parameter>,
		<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>path_nulls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>path_len</name></decl></parameter>,
		<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>,
		<parameter><decl><type><name>int</name></type> <name>op_type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setPathObject</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>path_elems</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>path_nulls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>path_len</name></decl></parameter>, <parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>st</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
			  <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>npairs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op_type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setPathArray</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>path_elems</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>path_nulls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>path_len</name></decl></parameter>, <parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>st</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>nelems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op_type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addJsonbToParseState</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>jbps</name></decl></parameter>, <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>jb</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* function supporting iterate_json_values */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>iterate_values_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>iterate_values_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* functions supporting transform_json_string_values */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transform_string_values_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transform_string_values_object_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transform_string_values_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transform_string_values_array_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transform_string_values_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transform_string_values_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transform_string_values_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * SQL function json_object_keys
 *
 * Returns the set of keys for the object argument.
 *
 * This SRF operates in value-per-call mode. It processes the
 * object during the first call, and the keys are simply stashed
 * in an array, whose size is expanded as necessary. This is probably
 * safe enough for a list of keys of a single object, since they are
 * limited in size to NAMEDATALEN and the number of keys is unlikely to
 * be so huge that it has major memory implications.
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_object_keys</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OkeysState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>skipNested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on a scalar"</literal></expr></argument>,
							<argument><expr><literal type="string">"jsonb_object_keys"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>JB_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on an array"</literal></expr></argument>,
							<argument><expr><literal type="string">"jsonb_object_keys"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OkeysState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result_size</name></name> <operator>=</operator> <call><name>JB_ROOT_COUNT</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sent_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>skipNested</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>skipNested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_KEY</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cstr</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>cstr</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cstr</name><index>[<expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>result_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>cstr</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>OkeysState</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>sent_count</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>result_count</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nxt</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>result</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>sent_count</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>nxt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* cleanup to reduce or eliminate memory leaks */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>result_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>json_object_keys</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OkeysState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name> <init>= <expr><call><name>makeJsonLexContext</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OkeysState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sem</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonSemAction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lex</name></name> <operator>=</operator> <name>lex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result_size</name></name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sent_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">256</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_start</name></name> <operator>=</operator> <name>okeys_array_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name> <operator>=</operator> <name>okeys_scalar</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_start</name></name> <operator>=</operator> <name>okeys_object_field_start</name></expr>;</expr_stmt>
		<comment type="block">/* remainder are all NULL, courtesy of palloc0 above */</comment>

		<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* keys are now in state-&gt;result */</comment>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>OkeysState</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>sent_count</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>result_count</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nxt</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>result</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>sent_count</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>nxt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* cleanup to reduce or eliminate memory leaks */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>result_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>okeys_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OkeysState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>OkeysState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* only collecting keys for the top level object */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* enlarge result array if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>result_count</name></name> <operator>&gt;=</operator> <name><name>_state</name><operator>-&gt;</operator><name>result_size</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result_size</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>_state</name><operator>-&gt;</operator><name>result_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* save a copy of the field name */</comment>
	<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result</name><index>[<expr><name><name>_state</name><operator>-&gt;</operator><name>result_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>okeys_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OkeysState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>OkeysState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* top level must be a json object */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on an array"</literal></expr></argument>,
						<argument><expr><literal type="string">"json_object_keys"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>okeys_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OkeysState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>OkeysState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* top level must be a json object */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on a scalar"</literal></expr></argument>,
						<argument><expr><literal type="string">"json_object_keys"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * json and jsonb getter functions
 * these implement the -&gt; -&gt;&gt; #&gt; and #&gt;&gt; operators
 * and the json{b?}_extract_path*(json, text, ...) functions
 */</comment>


<function><type><name>Datum</name></type>
<name>json_object_field</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fname</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fnamestr</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_worker</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fnamestr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_object_field</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JB_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>findJsonbValueFromContainerLen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>JB_FOBJECT</name></expr></argument>,
									   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_object_field_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fname</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fnamestr</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_worker</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fnamestr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_object_field_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JB_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>findJsonbValueFromContainerLen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>JB_FOBJECT</name></expr></argument>,
									   <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>jbvNull</name></expr>:</case>
				<break>break;</break>
			<case>case <expr><name>jbvBool</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>jbvString</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>jbvNumeric</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_out</name></expr></argument>,
																			 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>jbvBinary</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>StringInfo</name></type>	<name>jtext</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>JsonbToCString</name><argument_list>(<argument><expr><name>jtext</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>jtext</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>jtext</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized jsonb type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>v</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_array_element</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>element</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_worker</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>element</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_array_element</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>element</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JB_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Handle negative subscript */</comment>
	<if_stmt><if>if <condition>(<expr><name>element</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>nelements</name> <init>= <expr><call><name>JB_ROOT_COUNT</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>-</operator><name>element</name> <operator>&gt;</operator> <name>nelements</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>element</name> <operator>+=</operator> <name>nelements</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>getIthJsonbValueFromContainer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_array_element_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>element</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_worker</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>element</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_array_element_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>element</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JB_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Handle negative subscript */</comment>
	<if_stmt><if>if <condition>(<expr><name>element</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>nelements</name> <init>= <expr><call><name>JB_ROOT_COUNT</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>-</operator><name>element</name> <operator>&gt;</operator> <name>nelements</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>element</name> <operator>+=</operator> <name>nelements</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>getIthJsonbValueFromContainer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>jbvNull</name></expr>:</case>
				<break>break;</break>
			<case>case <expr><name>jbvBool</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>jbvString</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>jbvNumeric</name></expr>:</case>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_out</name></expr></argument>,
																			 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>jbvBinary</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>StringInfo</name></type>	<name>jtext</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>JsonbToCString</name><argument_list>(<argument><expr><name>jtext</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>jtext</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>jtext</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized jsonb type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>v</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_extract_path</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_path_all</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_extract_path_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_path_all</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * common routine for extract_path functions
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>get_path_all</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>pathtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>pathnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>npath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>tpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>ipath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the array contains any null elements, return NULL, on the grounds
	 * that you'd have gotten NULL if any RHS value were NULL in a nested
	 * series of applications of the -&gt; operator.  (Note: because we also
	 * return NULL for error cases such as no-such-field, this is true
	 * regardless of the contents of the rest of the array.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>pathtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pathnulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>npath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tpath</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>npath</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ipath</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>npath</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npath</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>pathnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tpath</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>pathtext</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * we have no idea at this stage what structure the document is so
		 * just convert anything in the path that we can to an integer and set
		 * all the other integers to INT_MIN which will never match.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>tpath</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>long</name></type>		<name>ind</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>ind</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name><name>tpath</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ind</name> <operator>&lt;=</operator> <name>INT_MAX</name> <operator>&amp;&amp;</operator> <name>ind</name> <operator>&gt;=</operator> <name>INT_MIN</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ipath</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>ind</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ipath</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>INT_MIN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ipath</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>INT_MIN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_worker</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>tpath</name></expr></argument>, <argument><expr><name>ipath</name></expr></argument>, <argument><expr><name>npath</name></expr></argument>, <argument><expr><name>as_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_worker
 *
 * common worker for all the json getter functions
 *
 * json: JSON object (in text form)
 * tpath[]: field name(s) to extract
 * ipath[]: array index(es) (zero-based) to extract, accepts negatives
 * npath: length of tpath[] and/or ipath[]
 * normalize_results: true to de-escape string and null scalars
 *
 * tpath can be NULL, or any one tpath[] entry can be NULL, if an object
 * field is not to be matched at that nesting level.  Similarly, ipath can
 * be NULL, or any one ipath[] entry can be INT_MIN if an array element is
 * not to be matched at that nesting level (a json datum should never be
 * large enough to have -INT_MIN elements due to MaxAllocSize restriction).
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>get_worker</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>json</name></decl></parameter>,
		   <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tpath</name></decl></parameter>,
		   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ipath</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>npath</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>normalize_results</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name> <init>= <expr><call><name>makeJsonLexContext</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonSemAction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GetState</name>   <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GetState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npath</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lex</name></name> <operator>=</operator> <name>lex</name></expr>;</expr_stmt>
	<comment type="block">/* is it "_as_text" variant? */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>normalize_results</name></name> <operator>=</operator> <name>normalize_results</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>npath</name></name> <operator>=</operator> <name>npath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>path_names</name></name> <operator>=</operator> <name>tpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>path_indexes</name></name> <operator>=</operator> <name>ipath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pathok</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>array_cur_index</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>npath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>npath</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pathok</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Not all variants need all the semantic routines. Only set the ones that
	 * are actually needed for maximum efficiency.
	 */</comment>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name> <operator>=</operator> <name>get_scalar</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>npath</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_start</name></name> <operator>=</operator> <name>get_object_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_end</name></name> <operator>=</operator> <name>get_object_end</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_start</name></name> <operator>=</operator> <name>get_array_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_end</name></name> <operator>=</operator> <name>get_array_end</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tpath</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_start</name></name> <operator>=</operator> <name>get_object_field_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_end</name></name> <operator>=</operator> <name>get_object_field_end</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ipath</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_start</name></name> <operator>=</operator> <name>get_array_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_start</name></name> <operator>=</operator> <name>get_array_element_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_end</name></name> <operator>=</operator> <name>get_array_element_end</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>tresult</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GetState</name>   <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>GetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lex_level</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Special case: we should match the entire object.  We only need this
		 * at outermost level because at nested levels the match will have
		 * been started by the outer field or array element callback.
		 */</comment>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_object_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GetState</name>   <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>GetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lex_level</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Special case: return the entire object */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>tresult</name></name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GetState</name>   <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>GetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>get_next</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lex_level</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>&lt;=</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>pathok</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>path_names</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>path_names</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>_state</name><operator>-&gt;</operator><name>path_names</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>&lt;</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if not at end of path just mark path ok */</comment>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>pathok</name><index>[<expr><name>lex_level</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* end of path, so we want this value */</comment>
			<expr_stmt><expr><name>get_next</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>get_next</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this object overrides any previous matching object */</comment>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>tresult</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>normalize_results</name></name> <operator>&amp;&amp;</operator>
			<name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>JSON_TOKEN_STRING</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* for as_text variants, tell get_scalar to set it for us */</comment>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* for non-as_text variants, just note the json starting point */</comment>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_object_field_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GetState</name>   <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>GetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>get_last</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lex_level</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* same tests as in get_object_field_start */</comment>
	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>&lt;=</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>pathok</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>path_names</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>path_names</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>_state</name><operator>-&gt;</operator><name>path_names</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>&lt;</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* done with this field so reset pathok */</comment>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>pathok</name><index>[<expr><name>lex_level</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* end of path, so we want this value */</comment>
			<expr_stmt><expr><name>get_last</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* for as_text scalar case, our work is already done */</comment>
	<if_stmt><if>if <condition>(<expr><name>get_last</name> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * make a text object from the string from the previously noted json
		 * start up to the end of the previous token (the lexer is by now
		 * ahead of us on whatever came after what we're interested in).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>normalize_results</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>tresult</name></name> <operator>=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>tresult</name></name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* this should be unnecessary but let's do it for cleanliness: */</comment>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GetState</name>   <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>GetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lex_level</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>&lt;</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Initialize counting of elements in this array */</comment>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>array_cur_index</name><index>[<expr><name>lex_level</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/* INT_MIN value is reserved to represent invalid subscript */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>path_indexes</name><index>[<expr><name>lex_level</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>_state</name><operator>-&gt;</operator><name>path_indexes</name><index>[<expr><name>lex_level</name></expr>]</index></name> <operator>!=</operator> <name>INT_MIN</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Negative subscript -- convert to positive-wise subscript */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>nelements</name> <init>= <expr><call><name>json_count_array_elements</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>-</operator><name><name>_state</name><operator>-&gt;</operator><name>path_indexes</name><index>[<expr><name>lex_level</name></expr>]</index></name> <operator>&lt;=</operator> <name>nelements</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>path_indexes</name><index>[<expr><name>lex_level</name></expr>]</index></name> <operator>+=</operator> <name>nelements</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>lex_level</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Special case: we should match the entire array.  We only need this
		 * at the outermost level because at nested levels the match will have
		 * been started by the outer field or array element callback.
		 */</comment>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_array_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GetState</name>   <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>GetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lex_level</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Special case: return the entire array */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>tresult</name></name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GetState</name>   <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>GetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>get_next</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lex_level</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Update array element counter */</comment>
	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>&lt;=</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>array_cur_index</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>&lt;=</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>pathok</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>path_indexes</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>array_cur_index</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>_state</name><operator>-&gt;</operator><name>path_indexes</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>&lt;</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if not at end of path just mark path ok */</comment>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>pathok</name><index>[<expr><name>lex_level</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* end of path, so we want this value */</comment>
			<expr_stmt><expr><name>get_next</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* same logic as for objects */</comment>
	<if_stmt><if>if <condition>(<expr><name>get_next</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>tresult</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>normalize_results</name></name> <operator>&amp;&amp;</operator>
			<name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>JSON_TOKEN_STRING</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_array_element_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GetState</name>   <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>GetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>get_last</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lex_level</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* same tests as in get_array_element_start */</comment>
	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>&lt;=</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>pathok</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>path_indexes</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>array_cur_index</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>_state</name><operator>-&gt;</operator><name>path_indexes</name><index>[<expr><name>lex_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>&lt;</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* done with this element so reset pathok */</comment>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>pathok</name><index>[<expr><name>lex_level</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* end of path, so we want this value */</comment>
			<expr_stmt><expr><name>get_last</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* same logic as for objects */</comment>
	<if_stmt><if>if <condition>(<expr><name>get_last</name> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>normalize_results</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>tresult</name></name> <operator>=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>tresult</name></name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GetState</name>   <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>GetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lex_level</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Check for whole-object match */</comment>
	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>npath</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>normalize_results</name></name> <operator>&amp;&amp;</operator> <name>tokentype</name> <operator>==</operator> <name>JSON_TOKEN_STRING</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we want the de-escaped string */</comment>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>normalize_results</name></name> <operator>&amp;&amp;</operator> <name>tokentype</name> <operator>==</operator> <name>JSON_TOKEN_NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>tresult</name></name> <operator>=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * This is a bit hokey: we will suppress whitespace after the
			 * scalar token, but not whitespace before it.  Probably not worth
			 * doing our own space-skipping to avoid that.
			 */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>input</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>tresult</name></name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* a de-escaped text value is wanted, so supply it */</comment>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>tresult</name></name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* make sure the next call to get_scalar doesn't overwrite it */</comment>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_extract_path</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_jsonb_path_all</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_extract_path_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_jsonb_path_all</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>get_jsonb_path_all</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>pathtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>pathnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>npath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_object</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>have_array</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>jbvp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>tv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>container</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the array contains any null elements, return NULL, on the grounds
	 * that you'd have gotten NULL if any RHS value were NULL in a nested
	 * series of applications of the -&gt; operator.  (Note: because we also
	 * return NULL for error cases such as no-such-field, this is true
	 * regardless of the contents of the rest of the array.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>pathtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pathnulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>npath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Identify whether we have object, array, or scalar at top-level */</comment>
	<expr_stmt><expr><name>container</name> <operator>=</operator> <operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>have_object</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>JB_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>have_array</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>JB_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Extract the scalar value, if it is what we'll return */</comment>
		<if_stmt><if>if <condition>(<expr><name>npath</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>jbvp</name> <operator>=</operator> <call><name>getIthJsonbValueFromContainer</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the array is empty, return the entire LHS object, on the grounds
	 * that we should do zero field or element extractions.  For the
	 * non-scalar case we can just hand back the object without much work. For
	 * the scalar case, fall through and deal with the value below the loop.
	 * (This inconsistency arises because there's no easy way to generate a
	 * JsonbValue directly for root-level containers.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>npath</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jbvp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>as_text</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>JsonbToCString</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
															<argument><expr><name>container</name></expr></argument>,
															<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* not text mode - just hand back the jsonb */</comment>
			<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npath</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>have_object</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>jbvp</name> <operator>=</operator> <call><name>findJsonbValueFromContainerLen</name><argument_list>(<argument><expr><name>container</name></expr></argument>,
												  <argument><expr><name>JB_FOBJECT</name></expr></argument>,
												  <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name><name>pathtext</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>pathtext</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>have_array</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>long</name></type>		<name>lindex</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>index</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>indextext</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>pathtext</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>lindex</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>indextext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>indextext</name> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
				<name>lindex</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator> <name>lindex</name> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>lindex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>lindex</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Handle negative subscript */</comment>
				<decl_stmt><decl><type><name>uint32</name></type>		<name>nelements</name></decl>;</decl_stmt>

				<comment type="block">/* Container must be array, but make sure */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JsonContainerIsArray</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not a jsonb array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>nelements</name> <operator>=</operator> <call><name>JsonContainerSize</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>-</operator><name>lindex</name> <operator>&gt;</operator> <name>nelements</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>index</name> <operator>=</operator> <name>nelements</name> <operator>+</operator> <name>lindex</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>jbvp</name> <operator>=</operator> <call><name>getIthJsonbValueFromContainer</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* scalar, extraction yields a null */</comment>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>jbvp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>npath</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>jbvp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvBinary</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>(</operator><name>JsonbContainer</name> <operator>*</operator><operator>)</operator> <name><name>jbvp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>container</name> <operator>=</operator> <operator>(</operator><name>JsonbContainer</name> <operator>*</operator><operator>)</operator> <name><name>jbvp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_object</name> <operator>=</operator> <name>r</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_array</name> <operator>=</operator> <name>r</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>have_object</name> <operator>=</operator> <name><name>jbvp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvObject</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_array</name> <operator>=</operator> <name><name>jbvp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvArray</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>as_text</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* special-case outputs for string and null values */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>jbvp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>jbvp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
													  <argument><expr><name><name>jbvp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>jbvp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>jbvp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>as_text</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>JsonbToCString</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
														<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* not text mode - just hand back the jsonb */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function json_array_length(json) -&gt; int
 */</comment>
<function><type><name>Datum</name></type>
<name>json_array_length</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlenState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lex</name> <operator>=</operator> <call><name>makeJsonLexContext</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AlenState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sem</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonSemAction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* palloc0 does this for us */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	state-&gt;count = 0;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lex</name></name> <operator>=</operator> <name>lex</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_start</name></name> <operator>=</operator> <name>alen_object_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name> <operator>=</operator> <name>alen_scalar</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_start</name></name> <operator>=</operator> <name>alen_array_element_start</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_array_length</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot get array length of a scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>JB_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot get array length of a non-array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>JB_ROOT_COUNT</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * These next two checks ensure that the json is an array (since it can't be
 * a scalar or an object).
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>alen_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlenState</name>  <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>AlenState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* json structure check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot get array length of a non-array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>alen_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlenState</name>  <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>AlenState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* json structure check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot get array length of a scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>alen_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlenState</name>  <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>AlenState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* just count up all the level 1 elements */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function json_each and json_each_text
 *
 * decompose a json object into key value pairs.
 *
 * Unlike json_object_keys() these SRFs operate in materialize mode,
 * stashing results into a Tuplestore object as they go.
 * The construction of tuples is done using a temporary memory context
 * that is cleared out after each tuple is built.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_each</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>each_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_each</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>each_worker_jsonb</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"jsonb_each"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_each_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>each_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_each_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>each_worker_jsonb</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"jsonb_each_text"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>each_worker_jsonb</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>ret_tdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>,
				<decl><type ref="prev"/><name>tmp_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skipNested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>JB_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on a non-object"</literal></expr></argument>,
						<argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that "</literal>
						<literal type="string">"cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in context "</literal>
						<literal type="string">"that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret_tdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>ret_tdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple_store</name> <operator>=</operator>
		<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									<argument><expr><literal type="string">"jsonb_each temporary cxt"</literal></expr></argument>,
									<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>skipNested</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>skipNested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_KEY</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Use the tmp context so we can clean up after each tuple is done */</comment>
			<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The next thing the iterator fetches should be the value, no
			 * matter what shape it is.
			 */</comment>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>skipNested</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>r</name> <operator>!=</operator> <name>WJB_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>as_text</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvNull</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* a json null is an sql null in text mode */</comment>
					<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>sv</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* In text mode, scalar strings should be dequoted */</comment>
						<expr_stmt><expr><name>sv</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Turn anything else into a json string */</comment>
						<decl_stmt><decl><type><name>StringInfo</name></type>	<name>jtext</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>JsonbToCString</name><argument_list>(<argument><expr><name>jtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>sv</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>jtext</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>jtext</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Not in text mode, just return the Jsonb */</comment>
				<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>ret_tdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name>tuple_store</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* clean up and switch back */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tuple_store</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>ret_tdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>each_worker</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EachState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lex</name> <operator>=</operator> <call><name>makeJsonLexContext</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EachState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sem</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonSemAction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that "</literal>
						<literal type="string">"cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make these in a sufficiently long-lived memory context */</comment>
	<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ret_tdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ret_tdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>=</operator>
		<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_start</name></name> <operator>=</operator> <name>each_array_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name> <operator>=</operator> <name>each_scalar</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_start</name></name> <operator>=</operator> <name>each_object_field_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_end</name></name> <operator>=</operator> <name>each_object_field_end</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>normalize_results</name></name> <operator>=</operator> <name>as_text</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_scalar</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lex</name></name> <operator>=</operator> <name>lex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tmp_cxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										   <argument><expr><literal type="string">"json_each temporary cxt"</literal></expr></argument>,
										   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tmp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tuple_store</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ret_tdesc</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>each_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EachState</name>  <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>EachState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* save a pointer to where the value starts */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * next_scalar will be reset in the object_field_end handler, and
		 * since we know the value is a scalar there is no danger of it being
		 * on while recursing down the tree.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>normalize_results</name></name> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>JSON_TOKEN_STRING</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>each_object_field_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EachState</name>  <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>EachState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* skip over nested objects */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* use the tmp context so we can clean up after each tuple is done */</comment>
	<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>tmp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>normalize_results</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>normalized_scalar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>-</operator> <name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>ret_tdesc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up and switch back */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>tmp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>each_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EachState</name>  <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>EachState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* json structure check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot deconstruct an array as an object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>each_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EachState</name>  <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>EachState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* json structure check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot deconstruct a scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* supply de-escaped value if required */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>normalized_scalar</name></name> <operator>=</operator> <name>token</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL functions json_array_elements and json_array_elements_text
 *
 * get the elements from a json array
 *
 * a lot of this processing is similar to the json_each* functions
 */</comment>

<function><type><name>Datum</name></type>
<name>jsonb_array_elements</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>elements_worker_jsonb</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"jsonb_array_elements"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_array_elements_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>elements_worker_jsonb</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"jsonb_array_elements_text"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>elements_worker_jsonb</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>ret_tdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>,
				<decl><type ref="prev"/><name>tmp_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skipNested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extract elements from a scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>JB_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extract elements from an object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that "</literal>
						<literal type="string">"cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

	<comment type="block">/* it's a simple type, so don't use get_call_result_type() */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret_tdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>ret_tdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple_store</name> <operator>=</operator>
		<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									<argument><expr><literal type="string">"jsonb_array_elements temporary cxt"</literal></expr></argument>,
									<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>skipNested</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>skipNested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_ELEM</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

			<comment type="block">/* use the tmp context so we can clean up after each tuple is done */</comment>
			<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>as_text</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvNull</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* a json null is an sql null in text mode */</comment>
					<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>sv</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* in text mode scalar strings should be dequoted */</comment>
						<expr_stmt><expr><name>sv</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* turn anything else into a json string */</comment>
						<decl_stmt><decl><type><name>StringInfo</name></type>	<name>jtext</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>JsonbToCString</name><argument_list>(<argument><expr><name>jtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>sv</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>jtext</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>jtext</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>sv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>ret_tdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name>tuple_store</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* clean up and switch back */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tuple_store</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>ret_tdesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_array_elements</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>elements_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"json_array_elements"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_array_elements_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>elements_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"json_array_elements_text"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>elements_worker</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* elements only needs escaped strings when as_text */</comment>
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name> <init>= <expr><call><name>makeJsonLexContext</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>as_text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ElementsState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ElementsState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sem</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonSemAction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that "</literal>
						<literal type="string">"cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

	<comment type="block">/* it's a simple type, so don't use get_call_result_type() */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr>;</expr_stmt>

	<comment type="block">/* make these in a sufficiently long-lived memory context */</comment>
	<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ret_tdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ret_tdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>=</operator>
		<call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_start</name></name> <operator>=</operator> <name>elements_object_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name> <operator>=</operator> <name>elements_scalar</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_start</name></name> <operator>=</operator> <name>elements_array_element_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_end</name></name> <operator>=</operator> <name>elements_array_element_end</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>function_name</name></name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>normalize_results</name></name> <operator>=</operator> <name>as_text</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>next_scalar</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lex</name></name> <operator>=</operator> <name>lex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tmp_cxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										   <argument><expr><literal type="string">"json_array_elements temporary cxt"</literal></expr></argument>,
										   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tmp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tuple_store</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ret_tdesc</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>elements_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ElementsState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>ElementsState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* save a pointer to where the value starts */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * next_scalar will be reset in the array_element_end handler, and
		 * since we know the value is a scalar there is no danger of it being
		 * on while recursing down the tree.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>normalize_results</name></name> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>JSON_TOKEN_STRING</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>elements_array_element_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ElementsState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>ElementsState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* skip over nested objects */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* use the tmp context so we can clean up after each tuple is done */</comment>
	<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>tmp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>&amp;&amp;</operator> <name><name>_state</name><operator>-&gt;</operator><name>normalize_results</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>normalized_scalar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>-</operator> <name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>result_start</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>ret_tdesc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up and switch back */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>tmp_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>elements_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ElementsState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>ElementsState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* json structure check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on a non-array"</literal></expr></argument>,
						<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>function_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>elements_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ElementsState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>ElementsState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* json structure check */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on a scalar"</literal></expr></argument>,
						<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>function_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* supply de-escaped value if required */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>next_scalar</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>normalized_scalar</name></name> <operator>=</operator> <name>token</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function json_populate_record
 *
 * set fields in a record from the argument json
 *
 * Code adapted shamelessly from hstore's populate_record
 * which is in turn partly adapted from record_out.
 *
 * The json is decomposed into a hash table, in which each
 * field in the record is then looked up by name. For jsonb
 * we fetch the values direct from the object.
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_populate_record</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>populate_record_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"jsonb_populate_record"</literal></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_to_record</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>populate_record_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"jsonb_to_record"</literal></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_populate_record</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>populate_record_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"json_populate_record"</literal></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_to_record</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>populate_record_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"json_to_record"</literal></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper function for diagnostics */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_array_report_expected_array</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>colname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected JSON array"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"See the value of key \"%s\"."</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected JSON array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>indices</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ndim</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indices</name></expr></argument>, <argument><expr><literal type="string">"[%d]"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>colname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected JSON array"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"See the array element %s of key \"%s\"."</literal></expr></argument>,
							 <argument><expr><name><name>indices</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected JSON array"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"See the array element %s."</literal></expr></argument>,
							 <argument><expr><name><name>indices</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* set the number of dimensions of the populated array when it becomes known */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_array_assign_ndims</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndims</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndims</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>populate_array_report_expected_array</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>=</operator> <name>ndims</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dims</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sizes</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndims</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dims</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>		<comment type="block">/* dimensions are unknown yet */</comment>
</block_content>}</block></function>

<comment type="block">/* check the populated subarray dimension */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_array_check_dimension</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>dim</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>sizes</name><index>[<expr><name>ndim</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="block">/* current dimension counter */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>dims</name><index>[<expr><name>ndim</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>dims</name><index>[<expr><name>ndim</name></expr>]</index></name> <operator>=</operator> <name>dim</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* assign dimension if not yet known */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>dims</name><index>[<expr><name>ndim</name></expr>]</index></name> <operator>!=</operator> <name>dim</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"malformed JSON array"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Multidimensional arrays must have "</literal>
						   <literal type="string">"sub-arrays with matching dimensions."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* reset the current array dimension size counter */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sizes</name><index>[<expr><name>ndim</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* increment the parent dimension counter if it is a nested sub-array */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sizes</name><index>[<expr><name>ndim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_array_element</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>, <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>element</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>element_isnull</name></decl>;</decl_stmt>

	<comment type="block">/* populate the array element */</comment>
	<expr_stmt><expr><name>element</name> <operator>=</operator> <call><name>populate_record_field</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>aio</name><operator>-&gt;</operator><name>element_info</name></name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>aio</name><operator>-&gt;</operator><name>element_type</name></name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>aio</name><operator>-&gt;</operator><name>element_typmod</name></name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>jsv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>element_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>accumArrayResult</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>astate</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>, <argument><expr><name>element_isnull</name></expr></argument>,
					 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>aio</name><operator>-&gt;</operator><name>element_type</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>acxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ndim</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>sizes</name><index>[<expr><name>ndim</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>		<comment type="block">/* increment current dimension counter */</comment>
</block_content>}</block></function>

<comment type="block">/* json object start handler for populate_array_json() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_array_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateArrayState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>PopulateArrayState</name> <operator>*</operator><operator>)</operator> <name>_state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>populate_array_assign_ndims</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>ndim</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>populate_array_report_expected_array</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* json array end handler for populate_array_json() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_array_array_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateArrayState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>PopulateArrayState</name> <operator>*</operator><operator>)</operator> <name>_state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>ctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>populate_array_assign_ndims</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ndim</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>populate_array_check_dimension</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* json array element start handler for populate_array_json() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateArrayState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>PopulateArrayState</name> <operator>*</operator><operator>)</operator> <name>_state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>ndim</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* remember current array element start */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>element_start</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>element_scalar</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* json array element end handler for populate_array_json() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_array_element_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateArrayState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>PopulateArrayState</name> <operator>*</operator><operator>)</operator> <name>_state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>ctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsValue</name></type>		<name>jsv</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>is_json</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>element_type</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>JSON_TOKEN_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>element_scalar</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>element_scalar</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>len</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* null-terminated */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>element_start</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>-</operator>
								<name><name>state</name><operator>-&gt;</operator><name>element_start</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>populate_array_element</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jsv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* json scalar handler for populate_array_json() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_array_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateArrayState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>PopulateArrayState</name> <operator>*</operator><operator>)</operator> <name>_state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>ctx</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>populate_array_assign_ndims</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>ndim</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>populate_array_report_expected_array</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ndim</name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* remember the scalar element token */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>element_scalar</name></name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
		<comment type="block">/* element_type must already be set in populate_array_element_start() */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>element_type</name></name> <operator>==</operator> <name>tokentype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* parse a json array and populate array */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_array_json</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateArrayState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonSemAction</name></type> <name>sem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>lex</name></name> <operator>=</operator> <call><name>makeJsonLexContextCstringLen</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>ctx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>.</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>.</operator><name>object_start</name></name> <operator>=</operator> <name>populate_array_object_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>.</operator><name>array_end</name></name> <operator>=</operator> <name>populate_array_array_end</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>.</operator><name>array_element_start</name></name> <operator>=</operator> <name>populate_array_element_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>.</operator><name>array_element_end</name></name> <operator>=</operator> <name>populate_array_element_end</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>.</operator><name>scalar</name></name> <operator>=</operator> <name>populate_array_scalar</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>lex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* number of dimensions should be already known */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>dims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>lex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * populate_array_dim_jsonb() -- Iterate recursively through jsonb sub-array
 *		elements and accumulate result using given ArrayBuildState.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_array_dim_jsonb</name><parameter_list>(<parameter><decl><type><name>PopulateArrayContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <comment type="block">/* context */</comment>
						 <parameter><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>jbv</name></decl></parameter>,	<comment type="block">/* jsonb sub-array */</comment>
						 <parameter><decl><type><name>int</name></type> <name>ndim</name></decl></parameter>)</parameter_list>	<comment type="block">/* current dimension */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>jbc</name> <init>= <expr><name><name>jbv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>tok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsValue</name></type>		<name>jsv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>jbv</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>jbvBinary</name> <operator>||</operator> <operator>!</operator><call><name>JsonContainerIsArray</name><argument_list>(<argument><expr><name>jbc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>populate_array_report_expected_array</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ndim</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>JsonContainerIsScalar</name><argument_list>(<argument><expr><name>jbc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><name>jbc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tok</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the number of dimensions is not yet known and we have found end of
	 * the array, or the first child element is not an array, then assign the
	 * number of dimensions now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>tok</name> <operator>==</operator> <name>WJB_END_ARRAY</name> <operator>||</operator>
		 <operator>(</operator><name>tok</name> <operator>==</operator> <name>WJB_ELEM</name> <operator>&amp;&amp;</operator>
		  <operator>(</operator><name><name>val</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>jbvBinary</name> <operator>||</operator>
		   <operator>!</operator><call><name>JsonContainerIsArray</name><argument_list>(<argument><expr><name><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>populate_array_assign_ndims</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>is_json</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>jsonb</name></name> <operator>=</operator> <operator>&amp;</operator><name>val</name></expr>;</expr_stmt>

	<comment type="block">/* process all the array elements */</comment>
	<while>while <condition>(<expr><name>tok</name> <operator>==</operator> <name>WJB_ELEM</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Recurse only if the dimensions of dimensions is still unknown or if
		 * it is not the innermost dimension.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ndim</name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>populate_array_element</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jsv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* populate child sub-array */</comment>
			<expr_stmt><expr><call><name>populate_array_dim_jsonb</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>ndim</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* number of dimensions should be already known */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ndims</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>dims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>populate_array_check_dimension</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tok</name> <operator>==</operator> <name>WJB_END_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free iterator, iterating until WJB_DONE */</comment>
	<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tok</name> <operator>==</operator> <name>WJB_DONE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* recursively populate an array from json/jsonb */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>populate_array</name><parameter_list>(<parameter><decl><type><name>ArrayIOData</name> <modifier>*</modifier></type><name>aio</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
			   <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>,
			   <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateArrayContext</name></type> <name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>lbs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>aio</name></name> <operator>=</operator> <name>aio</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>mcxt</name></name> <operator>=</operator> <name>mcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>acxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>astate</name></name> <operator>=</operator> <call><name>initArrayResult</name><argument_list>(<argument><expr><name><name>aio</name><operator>-&gt;</operator><name>element_type</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>.</operator><name>acxt</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>colname</name></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>ndims</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* unknown yet */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>dims</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>sizes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>jsv</name><operator>-&gt;</operator><name>is_json</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>populate_array_json</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>str</name></name></expr></argument>,
							<argument><expr><ternary><condition><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>len</name></name></expr>
							</then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>populate_array_dim_jsonb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>jsonb</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>sizes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>ndims</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lbs</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>ctx</name><operator>.</operator><name>ndims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>.</operator><name>ndims</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lbs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeMdArrayResult</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>astate</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>.</operator><name>ndims</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>.</operator><name>dims</name></name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>,
							   <argument><expr><name><name>ctx</name><operator>.</operator><name>acxt</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>dims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>sizes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>JsValueToJsObject</name><parameter_list>(<parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>, <parameter><decl><type><name>JsObject</name> <modifier>*</modifier></type><name>jso</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>jso</name><operator>-&gt;</operator><name>is_json</name></name> <operator>=</operator> <name><name>jsv</name><operator>-&gt;</operator><name>is_json</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>jsv</name><operator>-&gt;</operator><name>is_json</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* convert plain-text json into a hash table */</comment>
		<expr_stmt><expr><name><name>jso</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json_hash</name></name> <operator>=</operator>
			<call><name>get_json_object_as_hash</name><argument_list>(<argument><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>str</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>
									?</condition><then> <expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>len</name></name></expr>
									</then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
									<argument><expr><literal type="string">"populate_composite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>jbv</name> <init>= <expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>jsonb</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>jbv</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvBinary</name> <operator>&amp;&amp;</operator>
			<call><name>JsonContainerIsObject</name><argument_list>(<argument><expr><name><name>jbv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>jso</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>jsonb_cont</name></name> <operator>=</operator> <name><name>jbv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>is_scalar</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>is_scalar</name> <operator>=</operator> <call><name>IsAJsonbScalar</name><argument_list>(<argument><expr><name>jbv</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>(</operator><name><name>jbv</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvBinary</name> <operator>&amp;&amp;</operator>
				 <call><name>JsonContainerIsScalar</name><argument_list>(<argument><expr><name><name>jbv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name>is_scalar</name></expr>
					 ?</condition><then> <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on a scalar"</literal></expr></argument>,
							  <argument><expr><literal type="string">"populate_composite"</literal></expr></argument>)</argument_list></call></expr>
					 </then><else>: <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on an array"</literal></expr></argument>,
							  <argument><expr><literal type="string">"populate_composite"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* acquire or update cached tuple descriptor for a composite type */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_cached_tupdesc</name><parameter_list>(<parameter><decl><type><name>CompositeIOData</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>io</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>||</operator>
		<name><name>io</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>!=</operator> <name><name>io</name><operator>-&gt;</operator><name>base_typid</name></name> <operator>||</operator>
		<name><name>io</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>!=</operator> <name><name>io</name><operator>-&gt;</operator><name>base_typmod</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>base_typid</name></name></expr></argument>,
													 <argument><expr><name><name>io</name><operator>-&gt;</operator><name>base_typmod</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>io</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* copy tuple desc without constraints into cache memory context */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* recursively populate a composite (row type) value from json/jsonb */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>populate_composite</name><parameter_list>(<parameter><decl><type><name>CompositeIOData</name> <modifier>*</modifier></type><name>io</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>,
				   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
				   <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>,
				   <parameter><decl><type><name>HeapTupleHeader</name></type> <name>defaultval</name></decl></parameter>,
				   <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* acquire/update cached tuple descriptor */</comment>
	<expr_stmt><expr><call><name>update_cached_tupdesc</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsObject</name></type>	<name>jso</name></decl>;</decl_stmt>

		<comment type="block">/* prepare input value */</comment>
		<expr_stmt><expr><call><name>JsValueToJsObject</name><argument_list>(<argument><expr><name>jsv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jso</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* populate resulting record tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>populate_record</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>io</name><operator>-&gt;</operator><name>record_io</name></name></expr></argument>,
								<argument><expr><name>defaultval</name></expr></argument>, <argument><expr><name>mcxt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jso</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>JsObjectFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jso</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If it's domain over composite, check domain constraints.  (This should
	 * probably get refactored so that we can see the TYPECAT value, but for
	 * now, we can tell by comparing typid to base_typid.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>!=</operator> <name><name>io</name><operator>-&gt;</operator><name>base_typid</name></name> <operator>&amp;&amp;</operator> <name>typid</name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>domain_check</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>io</name><operator>-&gt;</operator><name>domain_info</name></name></expr></argument>, <argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* populate non-null scalar value from json/jsonb value */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>populate_scalar</name><parameter_list>(<parameter><decl><type><name>ScalarIOData</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>, <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>jsv</name><operator>-&gt;</operator><name>is_json</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>json</name> <operator>=</operator> <name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Need to copy non-null-terminated string */</comment>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>json</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>str</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <name>json</name></expr>;</expr_stmt></block_content></block></else></if_stmt>			<comment type="block">/* string is already null-terminated */</comment>

		<comment type="block">/* If converting to json/jsonb, make string into valid JSON literal */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>typid</name> <operator>==</operator> <name>JSONOID</name> <operator>||</operator> <name>typid</name> <operator>==</operator> <name>JSONBOID</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>JSON_TOKEN_STRING</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* free temporary buffer */</comment>
			<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>json</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>jbv</name> <init>= <expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>jsonb</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>JSONBOID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jsonb</name> <init>= <expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>jbv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* directly use jsonb */</comment>

			<return>return <expr><call><name>JsonbPGetDatum</name><argument_list>(<argument><expr><name>jsonb</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<comment type="block">/* convert jsonb to string for typio call */</comment>
		<if type="elseif">else if <condition>(<expr><name>typid</name> <operator>==</operator> <name>JSONOID</name> <operator>&amp;&amp;</operator> <name><name>jbv</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>jbvBinary</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Convert scalar jsonb (non-scalars are passed here as jbvBinary)
			 * to json string, preserving quotes around top-level strings.
			 */</comment>
			<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jsonb</name> <init>= <expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>jbv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>JsonbToCString</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>jsonb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>jsonb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>jbv</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* quotes are stripped */</comment>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>jbv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>jbv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>jbv</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvBool</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>jbv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>jbv</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvNumeric</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_out</name></expr></argument>,
													  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>jbv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>jbv</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvBinary</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>JsonbToCString</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>jbv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>,
								 <argument><expr><name><name>jbv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized jsonb type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>jbv</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>InputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>io</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>io</name><operator>-&gt;</operator><name>typioparam</name></name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free temporary buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>json</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>populate_domain</name><parameter_list>(<parameter><decl><type><name>DomainIOData</name> <modifier>*</modifier></type><name>io</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
				<parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>,
				<parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>populate_record_field</name><argument_list>(<argument><expr><name><name>io</name><operator>-&gt;</operator><name>base_io</name></name></expr></argument>,
									<argument><expr><name><name>io</name><operator>-&gt;</operator><name>base_typid</name></name></expr></argument>, <argument><expr><name><name>io</name><operator>-&gt;</operator><name>base_typmod</name></name></expr></argument>,
									<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>mcxt</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>jsv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>domain_check</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>io</name><operator>-&gt;</operator><name>domain_info</name></name></expr></argument>, <argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* prepare column metadata cache for the given type */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepare_column_cache</name><parameter_list>(<parameter><decl><type><name>ColumnIOData</name> <modifier>*</modifier></type><name>column</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>,
					 <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
					 <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>need_scalar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>type</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typid</name></name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can move directly to the bottom base type; domain_check() will
		 * take care of checking all constraints for a stack of domains.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>base_typid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>base_typmod</name> <init>= <expr><name>typmod</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>base_typid</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name>base_typid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* domain over composite has its own code path */</comment>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typcat</name></name> <operator>=</operator> <name>TYPECAT_COMPOSITE_DOMAIN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>record_io</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>tupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>base_typid</name></name> <operator>=</operator> <name>base_typid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>base_typmod</name></name> <operator>=</operator> <name>base_typmod</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>domain_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* domain over anything else */</comment>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typcat</name></name> <operator>=</operator> <name>TYPECAT_DOMAIN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>domain</name><operator>.</operator><name>base_typid</name></name> <operator>=</operator> <name>base_typid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>domain</name><operator>.</operator><name>base_typmod</name></name> <operator>=</operator> <name>base_typmod</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>domain</name><operator>.</operator><name>base_io</name></name> <operator>=</operator>
				<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnIOData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>domain</name><operator>.</operator><name>domain_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name> <operator>||</operator> <name>typid</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typcat</name></name> <operator>=</operator> <name>TYPECAT_COMPOSITE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>record_io</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>tupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>base_typid</name></name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>base_typmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>domain_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>type</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typcat</name></name> <operator>=</operator> <name>TYPECAT_ARRAY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>array</name><operator>.</operator><name>element_info</name></name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>,
															   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnIOData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>array</name><operator>.</operator><name>element_type</name></name> <operator>=</operator> <name><name>type</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</expr_stmt>
		<comment type="block">/* array element typemod stored in attribute's typmod */</comment>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>array</name><operator>.</operator><name>element_typmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typcat</name></name> <operator>=</operator> <name>TYPECAT_SCALAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>need_scalar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* caller can force us to look up scalar_io info even for non-scalars */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_scalar</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typioproc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioproc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>column</name><operator>-&gt;</operator><name>scalar_io</name><operator>.</operator><name>typioparam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>typioproc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>column</name><operator>-&gt;</operator><name>scalar_io</name><operator>.</operator><name>typiofunc</name></name></expr></argument>, <argument><expr><name>mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* recursively populate a record field or an array element from a json/jsonb value */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>populate_record_field</name><parameter_list>(<parameter><decl><type><name>ColumnIOData</name> <modifier>*</modifier></type><name>col</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>,
					  <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
					  <parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name></type> <name>defaultval</name></decl></parameter>,
					  <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TypeCat</name></type>		<name>typcat</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare column metadata cache for the given type.  Force lookup of the
	 * scalar_io data so that the json string hack below will work.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>col</name><operator>-&gt;</operator><name>typid</name></name> <operator>!=</operator> <name>typid</name> <operator>||</operator> <name><name>col</name><operator>-&gt;</operator><name>typmod</name></name> <operator>!=</operator> <name>typmod</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>prepare_column_cache</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>mcxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <call><name>JsValueIsNull</name><argument_list>(<argument><expr><name>jsv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typcat</name> <operator>=</operator> <name><name>col</name><operator>-&gt;</operator><name>typcat</name></name></expr>;</expr_stmt>

	<comment type="block">/* try to convert json string to a non-scalar type through input function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>JsValueIsString</name><argument_list>(<argument><expr><name>jsv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>typcat</name> <operator>==</operator> <name>TYPECAT_ARRAY</name> <operator>||</operator>
		 <name>typcat</name> <operator>==</operator> <name>TYPECAT_COMPOSITE</name> <operator>||</operator>
		 <name>typcat</name> <operator>==</operator> <name>TYPECAT_COMPOSITE_DOMAIN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>typcat</name> <operator>=</operator> <name>TYPECAT_SCALAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* we must perform domain checks for NULLs, otherwise exit immediately */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>isnull</name> <operator>&amp;&amp;</operator>
		<name>typcat</name> <operator>!=</operator> <name>TYPECAT_DOMAIN</name> <operator>&amp;&amp;</operator>
		<name>typcat</name> <operator>!=</operator> <name>TYPECAT_COMPOSITE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>typcat</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TYPECAT_SCALAR</name></expr>:</case>
			<return>return <expr><call><name>populate_scalar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>col</name><operator>-&gt;</operator><name>scalar_io</name></name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>jsv</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>TYPECAT_ARRAY</name></expr>:</case>
			<return>return <expr><call><name>populate_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>col</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>array</name></name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>mcxt</name></expr></argument>, <argument><expr><name>jsv</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>TYPECAT_COMPOSITE</name></expr>:</case>
		<case>case <expr><name>TYPECAT_COMPOSITE_DOMAIN</name></expr>:</case>
			<return>return <expr><call><name>populate_composite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>col</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>composite</name></name></expr></argument>, <argument><expr><name>typid</name></expr></argument>,
									  <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>mcxt</name></expr></argument>,
									  <argument><expr><ternary><condition><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>defaultval</name></expr></argument>)</argument_list></call></expr>
									  ?</condition><then> <expr><call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>defaultval</name></expr></argument>)</argument_list></call></expr>
									  </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
									  <argument><expr><name>jsv</name></expr></argument>, <argument><expr><operator>*</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>TYPECAT_DOMAIN</name></expr>:</case>
			<return>return <expr><call><name>populate_domain</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>col</name><operator>-&gt;</operator><name>io</name><operator>.</operator><name>domain</name></name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>mcxt</name></expr></argument>,
								   <argument><expr><name>jsv</name></expr></argument>, <argument><expr><operator>*</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized type category '%c'"</literal></expr></argument>, <argument><expr><name>typcat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RecordIOData</name> <modifier>*</modifier></type>
<name>allocate_record_info</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ncolumns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecordIOData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>RecordIOData</name> <operator>*</operator><operator>)</operator>
	<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>,
					   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RecordIOData</name></expr></argument>, <argument><expr><name>columns</name></expr></argument>)</argument_list></call> <operator>+</operator>
					   <name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnIOData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>record_type</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>record_typmod</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>=</operator> <name>ncolumns</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnIOData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>JsObjectGetField</name><parameter_list>(<parameter><decl><type><name>JsObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>JsValue</name> <modifier>*</modifier></type><name>jsv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>jsv</name><operator>-&gt;</operator><name>is_json</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>is_json</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>jsv</name><operator>-&gt;</operator><name>is_json</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonHashEntry</name> <modifier>*</modifier></type><name>hashentry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json_hash</name></name></expr></argument>, <argument><expr><name>field</name></expr></argument>,
											   <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>type</name></name> <operator>=</operator> <ternary><condition><expr><name>hashentry</name></expr> ?</condition><then> <expr><name><name>hashentry</name><operator>-&gt;</operator><name>type</name></name></expr> </then><else>: <expr><name>JSON_TOKEN_NULL</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>str</name></name> <operator>=</operator> <ternary><condition><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>JSON_TOKEN_NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
			<expr><name><name>hashentry</name><operator>-&gt;</operator><name>val</name></name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>len</name></name> <operator>=</operator> <ternary><condition><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>str</name></name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt> <comment type="block">/* null-terminated */</comment>

		<return>return <expr><name>hashentry</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>jsonb</name></name> <operator>=</operator> <ternary><condition><expr><operator>!</operator><name><name>obj</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>jsonb_cont</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
			<expr><call><name>findJsonbValueFromContainerLen</name><argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>jsonb_cont</name></name></expr></argument>, <argument><expr><name>JB_FOBJECT</name></expr></argument>,
										   <argument><expr><name>field</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

		<return>return <expr><name><name>jsv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>jsonb</name></name> <operator>!=</operator> <name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* populate a record tuple from json/jsonb value */</comment>
<function><type><specifier>static</specifier> <name>HeapTupleHeader</name></type>
<name>populate_record</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
				<parameter><decl><type><name>RecordIOData</name> <modifier>*</modifier><modifier>*</modifier></type><name>record_p</name></decl></parameter>,
				<parameter><decl><type><name>HeapTupleHeader</name></type> <name>defaultval</name></decl></parameter>,
				<parameter><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl></parameter>,
				<parameter><decl><type><name>JsObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecordIOData</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><operator>*</operator><name>record_p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncolumns</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * if the input json is empty, we can only skip the rest if we were passed
	 * in a non-null record, since otherwise there may be issues with domain
	 * nulls.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>defaultval</name> <operator>&amp;&amp;</operator> <call><name>JsObjectIsEmpty</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>defaultval</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* (re)allocate metadata cache */</comment>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>record</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>!=</operator> <name>ncolumns</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>record_p</name> <operator>=</operator> <name>record</name> <operator>=</operator> <call><name>allocate_record_info</name><argument_list>(<argument><expr><name>mcxt</name></expr></argument>, <argument><expr><name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* invalidate metadata cache if the record type has changed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>record_type</name></name> <operator>!=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>||</operator>
		<name><name>record</name><operator>-&gt;</operator><name>record_typmod</name></name> <operator>!=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>RecordIOData</name></expr></argument>, <argument><expr><name>columns</name></expr></argument>)</argument_list></call> <operator>+</operator>
			   <name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnIOData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>record_type</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>record_typmod</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>=</operator> <name>ncolumns</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>defaultval</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tuple</name></decl>;</decl_stmt>

		<comment type="block">/* Build a temporary HeapTuple control structure */</comment>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>defaultval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>defaultval</name></expr>;</expr_stmt>

		<comment type="block">/* Break down the tuple into fields */</comment>
		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsValue</name></type>		<name>field</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped columns in datatype */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>JsObjectGetField</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * we can't just skip here if the key wasn't found since we might have
		 * a domain to deal with. If we were passed in a non-null record
		 * datum, we assume that the existing values are valid (if they're
		 * not, then it's not our fault), but if we were passed in a null,
		 * then every field which we don't populate needs to be run through
		 * the input function just in case it's a domain type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>defaultval</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>populate_record_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>record</name><operator>-&gt;</operator><name>columns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
										  <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
										  <argument><expr><name>colname</name></expr></argument>,
										  <argument><expr><name>mcxt</name></expr></argument>,
										  <argument><expr><ternary><condition><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>field</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>res</name><operator>-&gt;</operator><name>t_data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Setup for json{b}_populate_record{set}: result type will be same as first
 * argument's type --- unless first argument is "null::record", which we can't
 * extract type info from; we handle that later.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_record_type_from_argument</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
							  <parameter><decl><type><name>PopulateRecordCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>argtype</name></name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prepare_column_cache</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>c</name></name></expr></argument>,
						 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>argtype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>typcat</name></name> <operator>!=</operator> <name>TYPECAT_COMPOSITE</name> <operator>&amp;&amp;</operator>
		<name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>typcat</name></name> <operator>!=</operator> <name>TYPECAT_COMPOSITE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is a function name, eg json_to_record */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"first argument of %s must be a row type"</literal></expr></argument>,
						<argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Setup for json{b}_to_record{set}: result type is specified by calling
 * query.  We'll also use this code for json{b}_populate_record{set},
 * if we discover that the first argument is a null of type RECORD.
 *
 * Here it is syntactically impossible to specify the target type
 * as domain-over-composite.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_record_type_from_query</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
						   <parameter><decl><type><name>PopulateRecordCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is a function name, eg json_to_record */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine row type for result of %s"</literal></expr></argument>,
						<argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Provide a non-null record argument, "</literal>
						 <literal type="string">"or call the function in the FROM clause "</literal>
						 <literal type="string">"using a column definition list."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>argtype</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>

	<comment type="block">/* If we go through this more than once, avoid memory leak */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>tupdesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Save identified tupdesc */</comment>
	<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>tupdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>base_typid</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>base_typmod</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * common worker for json{b}_populate_record() and json{b}_to_record()
 * is_json and have_record_arg identify the specific function
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>populate_record_worker</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>is_json</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>have_record_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>json_arg_num</name> <init>= <expr><ternary><condition><expr><name>have_record_arg</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsValue</name></type>		<name>jsv</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>rec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>rettuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>jbv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>fnmcxt</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PopulateRecordCache</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If first time through, identify input/result record type.  Note that
	 * this stanza looks only at fcinfo context, which can't change during the
	 * query; so we may not be able to fully resolve a RECORD input type yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cache</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <name>cache</name> <operator>=</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>fnmcxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>fn_mcxt</name></name> <operator>=</operator> <name>fnmcxt</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>have_record_arg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_record_type_from_argument</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_record_type_from_query</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Collect record arg if we have one */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_record_arg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rec</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* it's json{b}_to_record() */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rec</name> <operator>=</operator> <call><name>PG_GETARG_HEAPTUPLEHEADER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * When declared arg type is RECORD, identify actual record type from
		 * the tuple itself.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>argtype</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>base_typid</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>base_typmod</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rec</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When declared arg type is RECORD, identify actual record type from
		 * calling query, or fail if we can't.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>argtype</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_record_type_from_query</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This can't change argtype, which is important for next time */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>argtype</name></name> <operator>==</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* If no JSON argument, just return the record (if any) unchanged */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>json_arg_num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rec</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>is_json</name></name> <operator>=</operator> <name>is_json</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_json</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><name>json_arg_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>str</name></name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>json</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>JSON_TOKEN_INVALID</name></expr>;</expr_stmt> <comment type="block">/* not used in
												 * populate_composite() */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><name>json_arg_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>jsv</name><operator>.</operator><name>val</name><operator>.</operator><name>jsonb</name></name> <operator>=</operator> <operator>&amp;</operator><name>jbv</name></expr>;</expr_stmt>

		<comment type="block">/* fill binary jsonb value pointing to jb */</comment>
		<expr_stmt><expr><name><name>jbv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvBinary</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jbv</name><operator>.</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jbv</name><operator>.</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>rettuple</name> <operator>=</operator> <call><name>populate_composite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>argtype</name></name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fnmcxt</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jsv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>rettuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_json_object_as_hash
 *
 * decompose a json object into a hash table.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>get_json_object_as_hash</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JHashState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name> <init>= <expr><call><name>makeJsonLexContextCstringLen</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>JsonHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"json object hashtable"</literal></expr></argument>,
					  <argument><expr><literal type="number">100</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
					  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JHashState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sem</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonSemAction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>function_name</name></name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <name>tab</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lex</name></name> <operator>=</operator> <name>lex</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_start</name></name> <operator>=</operator> <name>hash_array_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name> <operator>=</operator> <name>hash_scalar</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_start</name></name> <operator>=</operator> <name>hash_object_field_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_end</name></name> <operator>=</operator> <name>hash_object_field_end</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tab</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hash_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JHashState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>JHashState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* remember token type */</comment>
	<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>saved_token_type</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>JSON_TOKEN_ARRAY_START</name> <operator>||</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>JSON_TOKEN_OBJECT_START</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* remember start position of the whole text of the subobject */</comment>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>save_json_start</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* must be a scalar */</comment>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>save_json_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hash_object_field_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JHashState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>JHashState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonHashEntry</name> <modifier>*</modifier></type><name>hashentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ignore nested fields.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ignore field names &gt;= NAMEDATALEN - they can't match a record field.
	 * (Note: without this test, the hash code would truncate the string at
	 * NAMEDATALEN-1, and could then match against a similarly-truncated
	 * record field name.  That would be a reasonable behavior, but this code
	 * has previously insisted on exact equality, so we keep this behavior.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hashentry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * found being true indicates a duplicate. We don't do anything about
	 * that, a later field with the same name overrides the earlier field.
	 */</comment>

	<expr_stmt><expr><name><name>hashentry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>saved_token_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>isnull</name> <operator>==</operator> <operator>(</operator><name><name>hashentry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>JSON_TOKEN_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>save_json_start</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>-</operator> <name><name>_state</name><operator>-&gt;</operator><name>save_json_start</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>_state</name><operator>-&gt;</operator><name>save_json_start</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>val</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashentry</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* must have had a scalar instead */</comment>
		<expr_stmt><expr><name><name>hashentry</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>saved_scalar</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hash_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JHashState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>JHashState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on an array"</literal></expr></argument>, <argument><expr><name><name>_state</name><operator>-&gt;</operator><name>function_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hash_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JHashState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>JHashState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on a scalar"</literal></expr></argument>, <argument><expr><name><name>_state</name><operator>-&gt;</operator><name>function_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>saved_scalar</name></name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
		<comment type="block">/* saved_token_type must already be set in hash_object_field_start() */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>saved_token_type</name></name> <operator>==</operator> <name>tokentype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SQL function json_populate_recordset
 *
 * set fields in a set of records from the argument json,
 * which must be an array of objects.
 *
 * similar to json_populate_record, but the tuple-building code
 * is pushed down into the semantic action handlers so it's done
 * per object in the array.
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_populate_recordset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>populate_recordset_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"jsonb_populate_recordset"</literal></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>jsonb_to_recordset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>populate_recordset_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"jsonb_to_recordset"</literal></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_populate_recordset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>populate_recordset_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"json_populate_recordset"</literal></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>json_to_recordset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>populate_recordset_worker</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"json_to_recordset"</literal></expr></argument>,
									 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_recordset_record</name><parameter_list>(<parameter><decl><type><name>PopulateRecordsetState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>JsObject</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateRecordCache</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>cache</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tuphead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/* acquire/update cached tuple descriptor */</comment>
	<expr_stmt><expr><call><name>update_cached_tupdesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* replace record fields from json */</comment>
	<expr_stmt><expr><name>tuphead</name> <operator>=</operator> <call><name>populate_record</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>tupdesc</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>record_io</name></name></expr></argument>,
							  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>rec</name></name></expr></argument>,
							  <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
							  <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if it's domain over composite, check domain constraints */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>typcat</name></name> <operator>==</operator> <name>TYPECAT_COMPOSITE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>domain_check</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetDatum</name><argument_list>(<argument><expr><name>tuphead</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>argtype</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>domain_info</name></name></expr></argument>,
					 <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* ok, save into tuplestore */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuphead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuple</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tuphead</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuple_store</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * common worker for json{b}_populate_recordset() and json{b}_to_recordset()
 * is_json and have_record_arg identify the specific function
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>populate_recordset_worker</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>is_json</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>have_record_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>json_arg_num</name> <init>= <expr><ternary><condition><expr><name>have_record_arg</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>rec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PopulateRecordCache</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PopulateRecordsetState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that "</literal>
						<literal type="string">"cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If first time through, identify input/result record type.  Note that
	 * this stanza looks only at fcinfo context, which can't change during the
	 * query; so we may not be able to fully resolve a RECORD input type yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cache</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <name>cache</name> <operator>=</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>fn_mcxt</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>have_record_arg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_record_type_from_argument</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_record_type_from_query</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Collect record arg if we have one */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_record_arg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rec</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* it's json{b}_to_recordset() */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rec</name> <operator>=</operator> <call><name>PG_GETARG_HEAPTUPLEHEADER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * When declared arg type is RECORD, identify actual record type from
		 * the tuple itself.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>argtype</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>base_typid</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>base_typmod</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rec</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When declared arg type is RECORD, identify actual record type from
		 * calling query, or fail if we can't.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cache</name><operator>-&gt;</operator><name>argtype</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_record_type_from_query</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* This can't change argtype, which is important for next time */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>argtype</name></name> <operator>==</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* if the json is null send back an empty set */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>json_arg_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Forcibly update the cached tupdesc, to ensure we have the right tupdesc
	 * to return even if the JSON contains no rows.
	 */</comment>
	<expr_stmt><expr><call><name>update_cached_tupdesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name></name></expr></argument>, <argument><expr><name><name>cache</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PopulateRecordsetState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make tuplestore in a sufficiently long-lived memory context */</comment>
	<expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tuple_store</name></name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator>
											   <name>SFRM_Materialize_Random</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>function_name</name></name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>cache</name></name> <operator>=</operator> <name>cache</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>rec</name></name> <operator>=</operator> <name>rec</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_json</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><name>json_arg_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sem</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonSemAction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>lex</name> <operator>=</operator> <call><name>makeJsonLexContext</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_start</name></name> <operator>=</operator> <name>populate_recordset_array_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_start</name></name> <operator>=</operator> <name>populate_recordset_array_element_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name> <operator>=</operator> <name>populate_recordset_scalar</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_start</name></name> <operator>=</operator> <name>populate_recordset_object_field_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_end</name></name> <operator>=</operator> <name>populate_recordset_object_field_end</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_start</name></name> <operator>=</operator> <name>populate_recordset_object_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_end</name></name> <operator>=</operator> <name>populate_recordset_object_end</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lex</name></name> <operator>=</operator> <name>lex</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><name>json_arg_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>skipNested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>JB_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on a non-array"</literal></expr></argument>,
							<argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>skipNested</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>skipNested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_ELEM</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JsObject</name></type>	<name>obj</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>jbvBinary</name> <operator>||</operator>
					<operator>!</operator><call><name>JsonContainerIsObject</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must be an array of objects"</literal></expr></argument>,
									<argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>is_json</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>val</name><operator>.</operator><name>jsonb_cont</name></name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>populate_recordset_record</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Note: we must copy the cached tupdesc because the executor will free
	 * the passed-back setDesc, but we want to hang onto the cache in case
	 * we're called again in the same query.
	 */</comment>
	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>tuple_store</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>io</name><operator>.</operator><name>composite</name><operator>.</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_recordset_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateRecordsetState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>PopulateRecordsetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lex_level</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

	<comment type="block">/* Reject object at top level: we must have an array at level 0 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on an object"</literal></expr></argument>,
						<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>function_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Nested objects require no special processing */</comment>
	<if_stmt><if>if <condition>(<expr><name>lex_level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Object at level 1: set up a new hash table for this object */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>JsonHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>json_hash</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"json object hashtable"</literal></expr></argument>,
									<argument><expr><literal type="number">100</literal></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
									<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_recordset_object_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateRecordsetState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>PopulateRecordsetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsObject</name></type>	<name>obj</name></decl>;</decl_stmt>

	<comment type="block">/* Nested objects require no special processing */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>is_json</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>val</name><operator>.</operator><name>json_hash</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>json_hash</name></name></expr>;</expr_stmt>

	<comment type="block">/* Otherwise, construct and return a tuple based on this level-1 object */</comment>
	<expr_stmt><expr><call><name>populate_recordset_record</name><argument_list>(<argument><expr><name>_state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Done with hash for this object */</comment>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>json_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>json_hash</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_recordset_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateRecordsetState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>PopulateRecordsetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>!=</operator> <name>JSON_TOKEN_OBJECT_START</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must be an array of objects"</literal></expr></argument>,
						<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>function_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_recordset_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* nothing to do */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_recordset_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateRecordsetState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>PopulateRecordsetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot call %s on a scalar"</literal></expr></argument>,
						<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>function_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>saved_scalar</name></name> <operator>=</operator> <name>token</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_recordset_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateRecordsetState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>PopulateRecordsetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>saved_token_type</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>JSON_TOKEN_ARRAY_START</name> <operator>||</operator>
		<name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>JSON_TOKEN_OBJECT_START</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>save_json_start</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>save_json_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>populate_recordset_object_field_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PopulateRecordsetState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>PopulateRecordsetState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonHashEntry</name> <modifier>*</modifier></type><name>hashentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ignore nested fields.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ignore field names &gt;= NAMEDATALEN - they can't match a record field.
	 * (Note: without this test, the hash code would truncate the string at
	 * NAMEDATALEN-1, and could then match against a similarly-truncated
	 * record field name.  That would be a reasonable behavior, but this code
	 * has previously insisted on exact equality, so we keep this behavior.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hashentry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>json_hash</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * found being true indicates a duplicate. We don't do anything about
	 * that, a later field with the same name overrides the earlier field.
	 */</comment>

	<expr_stmt><expr><name><name>hashentry</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>saved_token_type</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>isnull</name> <operator>==</operator> <operator>(</operator><name><name>hashentry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>JSON_TOKEN_NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>save_json_start</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><name><name>_state</name><operator>-&gt;</operator><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>-</operator> <name><name>_state</name><operator>-&gt;</operator><name>save_json_start</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>_state</name><operator>-&gt;</operator><name>save_json_start</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>val</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashentry</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* must have had a scalar instead */</comment>
		<expr_stmt><expr><name><name>hashentry</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name><name>_state</name><operator>-&gt;</operator><name>saved_scalar</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * findJsonbValueFromContainer() wrapper that sets up JsonbValue key string.
 */</comment>
<function><type><specifier>static</specifier> <name>JsonbValue</name> <modifier>*</modifier></type>
<name>findJsonbValueFromContainerLen</name><parameter_list>(<parameter><decl><type><name>JsonbContainer</name> <modifier>*</modifier></type><name>container</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>,
							   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>keylen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>k</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>k</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvString</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>k</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>k</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>keylen</name></expr>;</expr_stmt>

	<return>return <expr><call><name>findJsonbValueFromContainer</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Semantic actions for json_strip_nulls.
 *
 * Simply repeat the input on the output unless we encounter
 * a null object field. State for this is set when the field
 * is started and reset when the scalar action (which must be next)
 * is called.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sn_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripnullState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>StripnullState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sn_object_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripnullState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>StripnullState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sn_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripnullState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>StripnullState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sn_array_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripnullState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>StripnullState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sn_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripnullState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>StripnullState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The next thing must be a scalar or isnull couldn't be true, so
		 * there is no danger of this state being carried down into a nested
		 * object or array. The flag will be reset in the scalar action.
		 */</comment>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>skip_next_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unfortunately we don't have the quoted and escaped string any more, so
	 * we have to re-escape it.
	 */</comment>
	<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sn_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripnullState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>StripnullState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'['</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sn_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripnullState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>StripnullState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>skip_next_null</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tokentype</name> <operator>==</operator> <name>JSON_TOKEN_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>skip_next_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>tokentype</name> <operator>==</operator> <name>JSON_TOKEN_STRING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function json_strip_nulls(json) -&gt; json
 */</comment>
<function><type><name>Datum</name></type>
<name>json_strip_nulls</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripnullState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lex</name> <operator>=</operator> <call><name>makeJsonLexContext</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StripnullState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sem</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonSemAction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>strval</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skip_next_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lex</name></name> <operator>=</operator> <name>lex</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_start</name></name> <operator>=</operator> <name>sn_object_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_end</name></name> <operator>=</operator> <name>sn_object_end</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_start</name></name> <operator>=</operator> <name>sn_array_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_end</name></name> <operator>=</operator> <name>sn_array_end</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name> <operator>=</operator> <name>sn_scalar</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_start</name></name> <operator>=</operator> <name>sn_array_element_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_start</name></name> <operator>=</operator> <name>sn_object_field_start</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
											  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * SQL function jsonb_strip_nulls(jsonb) -&gt; jsonb
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_strip_nulls</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>parseState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>last_was_key</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>type</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>type</name> <operator>==</operator> <name>WJB_KEY</name> <operator>&amp;&amp;</operator> <name>last_was_key</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>WJB_KEY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* stash the key until we know if it has a null value */</comment>
			<expr_stmt><expr><name>k</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_was_key</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>last_was_key</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if the last element was a key this one can't be */</comment>
			<expr_stmt><expr><name>last_was_key</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* skip this field if value is null */</comment>
			<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>WJB_VALUE</name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvNull</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* otherwise, do a delayed push of the key */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parseState</name></expr></argument>, <argument><expr><name>WJB_KEY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>WJB_VALUE</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>WJB_ELEM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parseState</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parseState</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add values from the jsonb to the parse state.
 *
 * If the parse state container is an object, the jsonb is pushed as
 * a value, not a key.
 *
 * This needs to be done using an iterator because pushJsonbValue doesn't
 * like getting jbvBinary values, so we can't just push jb as a whole.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addJsonbToParseState</name><parameter_list>(<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>jbps</name></decl></parameter>, <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>jb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>jbps</name><operator>)</operator><operator>-&gt;</operator><name>contVal</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>type</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvArray</name> <operator>||</operator> <name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* skip array header */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* fetch scalar value */</comment>

		<switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>jbvArray</name></expr>:</case>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>jbps</name></expr></argument>, <argument><expr><name>WJB_ELEM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>jbvObject</name></expr>:</case>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>jbps</name></expr></argument>, <argument><expr><name>WJB_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected parent of nested structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<while>while <condition>(<expr><operator>(</operator><name>type</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>WJB_KEY</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>WJB_VALUE</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>WJB_ELEM</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>jbps</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>jbps</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * SQL function jsonb_pretty (jsonb)
 *
 * Pretty-printed text for the jsonb
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_pretty</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>str</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>JsonbToCStringIndent</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>jb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function jsonb_concat (jsonb, jsonb)
 *
 * function for || operator
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_concat</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb1</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>jb2</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>it2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If one of the jsonb is empty, just return the other if it's not scalar
	 * and both are of the same kind.  If it's a scalar or they are of
	 * different kinds we need to perform the concatenation even if one is
	 * empty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>jb1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>JB_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>jb2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_COUNT</name><argument_list>(<argument><expr><name>jb1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>jb2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>jb2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>JB_ROOT_COUNT</name><argument_list>(<argument><expr><name>jb2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>jb1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>jb1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>it1</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb1</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>it2</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb2</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>IteratorConcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SQL function jsonb_delete (jsonb, text)
 *
 * return a copy of the jsonb with the indicated item
 * removed.
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_delete</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>keyptr</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keylen</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skipNested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot delete from scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_COUNT</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>in</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>skipNested</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>skipNested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>==</operator> <name>WJB_ELEM</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>WJB_KEY</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name> <operator>&amp;&amp;</operator> <name>keylen</name> <operator>==</operator> <name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator>
			 <call><name>memcmp</name><argument_list>(<argument><expr><name>keyptr</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip corresponding value as well */</comment>
			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_KEY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r</name> <operator>&lt;</operator> <name>WJB_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function jsonb_delete (jsonb, variadic text[])
 *
 * return a copy of the jsonb with the indicated items
 * removed.
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_delete_array</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>keys</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>keys_elems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>keys_nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keys_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skipNested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot delete from scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_COUNT</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>keys_elems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keys_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keys_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>keys_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>in</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>skipNested</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>skipNested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>==</operator> <name>WJB_ELEM</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>WJB_KEY</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>keys_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>keyptr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>keylen</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>keys_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>keyptr</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>keys_elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>keylen</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name><name>keys_elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>keylen</name> <operator>==</operator> <name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator>
					<call><name>memcmp</name><argument_list>(<argument><expr><name>keyptr</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* skip corresponding value as well */</comment>
				<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_KEY</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r</name> <operator>&lt;</operator> <name>WJB_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function jsonb_delete (jsonb, int)
 *
 * return a copy of the jsonb with the indicated item
 * removed. Negative int means count back from the
 * end of the items.
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_delete_idx</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot delete from scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot delete from object using integer index"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_COUNT</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>in</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>r</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>-</operator><name>idx</name> <operator>&gt;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>n</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_ELEM</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name><operator>++</operator> <operator>==</operator> <name>idx</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r</name> <operator>&lt;</operator> <name>WJB_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function jsonb_set(jsonb, text[], jsonb, boolean)
 *
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_set</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>newval</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>create</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>path_elems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>path_nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>path_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set path in scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_COUNT</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>create</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>path_elems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>path_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>in</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>setPath</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>path_elems</name></expr></argument>, <argument><expr><name>path_nulls</name></expr></argument>, <argument><expr><name>path_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>,
				  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><ternary><condition><expr><name>create</name></expr> ?</condition><then> <expr><name>JB_PATH_CREATE</name></expr> </then><else>: <expr><name>JB_PATH_REPLACE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SQL function jsonb_delete_path(jsonb, text[])
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_delete_path</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>path_elems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>path_nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>path_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot delete path in scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_COUNT</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>path_elems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>path_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>in</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>setPath</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>path_elems</name></expr></argument>, <argument><expr><name>path_nulls</name></expr></argument>, <argument><expr><name>path_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>,
				  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>JB_PATH_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function jsonb_insert(jsonb, text[], jsonb, boolean)
 *
 */</comment>
<function><type><name>Datum</name></type>
<name>jsonb_insert</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Jsonb</name>	   <modifier>*</modifier></type><name>newval</name> <init>= <expr><call><name>PG_GETARG_JSONB_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>after</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>path_elems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>path_nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>path_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>JB_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set path in scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>path_elems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>path_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>in</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>setPath</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>path_elems</name></expr></argument>, <argument><expr><name>path_nulls</name></expr></argument>, <argument><expr><name>path_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>,
				  <argument><expr><ternary><condition><expr><name>after</name></expr> ?</condition><then> <expr><name>JB_PATH_INSERT_AFTER</name></expr> </then><else>: <expr><name>JB_PATH_INSERT_BEFORE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_JSONB_P</name><argument_list>(<argument><expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Iterate over all jsonb objects and merge them into one.
 * The logic of this function copied from the same hstore function,
 * except the case, when it1 &amp; it2 represents jbvObject.
 * In that case we just append the content of it2 to it1 without any
 * verifications.
 */</comment>
<function><type><specifier>static</specifier> <name>JsonbValue</name> <modifier>*</modifier></type>
<name>IteratorConcat</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it1</name></decl></parameter>, <parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it2</name></decl></parameter>,
			   <parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v1</name></decl>,
				<decl><type ref="prev"/><name>v2</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r1</name></decl>,
				<decl><type ref="prev"/><name>r2</name></decl>,
				<decl><type ref="prev"/><name>rk1</name></decl>,
				<decl><type ref="prev"/><name>rk2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>r1</name> <operator>=</operator> <name>rk1</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r2</name> <operator>=</operator> <name>rk2</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Both elements are objects.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rk1</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name> <operator>&amp;&amp;</operator> <name>rk2</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Append the all tokens from v1 to res, except last WJB_END_OBJECT
		 * (because res will not be finished yet).
		 */</comment>
		<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>r1</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_END_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/*
		 * Append the all tokens from v2 to res, include last WJB_END_OBJECT
		 * (the concatenation will be completed).
		 */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>r2</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r2</name> <operator>!=</operator> <name>WJB_END_OBJECT</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v2</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if>

	<comment type="block">/*
	 * Both elements are arrays (either can be scalar).
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name>rk1</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name> <operator>&amp;&amp;</operator> <name>rk2</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>r1</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_END_ARRAY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>r1</name> <operator>==</operator> <name>WJB_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<while>while <condition>(<expr><operator>(</operator><name>r2</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_END_ARRAY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>r2</name> <operator>==</operator> <name>WJB_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_ELEM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* signal to sort */</comment> )</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* have we got array || object or object || array? */</comment>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>rk1</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><operator>(</operator><operator>*</operator><name>it1</name><operator>)</operator><operator>-&gt;</operator><name>isScalar</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>rk2</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><name>rk1</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>rk2</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><operator>(</operator><operator>*</operator><name>it2</name><operator>)</operator><operator>-&gt;</operator><name>isScalar</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>

		<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it_array</name> <init>= <expr><ternary><condition><expr><name>rk1</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><name>it1</name></expr> </then><else>: <expr><name>it2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it_object</name> <init>= <expr><ternary><condition><expr><name>rk1</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name></expr> ?</condition><then> <expr><name>it1</name></expr> </then><else>: <expr><name>it2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type>		<name>prepend</name> <init>= <expr><operator>(</operator><name>rk1</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>prepend</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>r1</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it_object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r1</name> <operator>!=</operator> <name>WJB_END_OBJECT</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v1</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

			<while>while <condition>(<expr><operator>(</operator><name>r2</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it_array</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r2</name> <operator>!=</operator> <name>WJB_END_ARRAY</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v2</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<while>while <condition>(<expr><operator>(</operator><name>r1</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it_array</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_END_ARRAY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

			<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>r2</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it_object</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r2</name> <operator>!=</operator> <name>WJB_END_OBJECT</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v2</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>WJB_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * This must be scalar || object or object || scalar, as that's all
		 * that's left. Both of these make no sense, so error out.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid concatenation of jsonb objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do most of the heavy work for jsonb_set/jsonb_insert
 *
 * If JB_PATH_DELETE bit is set in op_type, the element is to be removed.
 *
 * If any bit mentioned in JB_PATH_CREATE_OR_INSERT is set in op_type,
 * we create the new value if the key or array index does not exist.
 *
 * Bits JB_PATH_INSERT_BEFORE and JB_PATH_INSERT_AFTER in op_type
 * behave as JB_PATH_CREATE if new value is inserted in JsonbObject.
 *
 * All path elements before the last must already exist
 * whatever bits in op_type are set, or nothing is done.
 */</comment>
<function><type><specifier>static</specifier> <name>JsonbValue</name> <modifier>*</modifier></type>
<name>setPath</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>path_elems</name></decl></parameter>,
		<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>path_nulls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>path_len</name></decl></parameter>,
		<parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>path_nulls</name><index>[<expr><name>level</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"path element at position %d is null"</literal></expr></argument>,
						<argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>r</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>WJB_BEGIN_ARRAY</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>setPathArray</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>path_elems</name></expr></argument>, <argument><expr><name>path_nulls</name></expr></argument>, <argument><expr><name>path_len</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>level</name></expr></argument>,
						 <argument><expr><name>newval</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>nElems</name></name></expr></argument>, <argument><expr><name>op_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>r</name> <operator>==</operator> <name>WJB_END_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WJB_BEGIN_OBJECT</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>setPathObject</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>path_elems</name></expr></argument>, <argument><expr><name>path_nulls</name></expr></argument>, <argument><expr><name>path_len</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>level</name></expr></argument>,
						  <argument><expr><name>newval</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>nPairs</name></name></expr></argument>, <argument><expr><name>op_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>r</name> <operator>==</operator> <name>WJB_END_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WJB_ELEM</name></expr>:</case>
		<case>case <expr><name>WJB_VALUE</name></expr>:</case>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized iterator result: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Object walker for setPath
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setPathObject</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>path_elems</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>path_nulls</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>path_len</name></decl></parameter>, <parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
			  <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>npairs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;=</operator> <name>path_len</name> <operator>||</operator> <name><name>path_nulls</name><index>[<expr><name>level</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* empty object is a special case for create */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>npairs</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>op_type</name> <operator>&amp;</operator> <name>JB_PATH_CREATE_OR_INSERT</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>level</name> <operator>==</operator> <name>path_len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>newkey</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>newkey</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvString</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newkey</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name><name>path_elems</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newkey</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>path_elems</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>WJB_KEY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addJsonbToParseState</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npairs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r</name> <init>= <expr><call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>r</name> <operator>==</operator> <name>WJB_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name> <operator>&amp;&amp;</operator>
			<name><name>k</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>==</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name><name>path_elems</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>memcmp</name><argument_list>(<argument><expr><name><name>k</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>path_elems</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
				   <argument><expr><name><name>k</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <name>path_len</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * called from jsonb_insert(), it forbids redefining an
				 * existing value
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>op_type</name> <operator>&amp;</operator> <operator>(</operator><name>JB_PATH_INSERT_BEFORE</name> <operator>|</operator> <name>JB_PATH_INSERT_AFTER</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot replace existing key"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try using the function jsonb_set "</literal>
									 <literal type="string">"to replace key value."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* skip value */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>op_type</name> <operator>&amp;</operator> <name>JB_PATH_DELETE</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>WJB_KEY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>addJsonbToParseState</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>setPath</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>path_elems</name></expr></argument>, <argument><expr><name>path_nulls</name></expr></argument>, <argument><expr><name>path_len</name></expr></argument>,
						<argument><expr><name>st</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><name>op_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>op_type</name> <operator>&amp;</operator> <name>JB_PATH_CREATE_OR_INSERT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>done</name> <operator>&amp;&amp;</operator>
				<name>level</name> <operator>==</operator> <name>path_len</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>npairs</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>newkey</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>newkey</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>jbvString</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newkey</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name><name>path_elems</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newkey</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name><name>path_elems</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>WJB_KEY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>addJsonbToParseState</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r</name> <operator>&lt;</operator> <name>WJB_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>walking_level</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

				<while>while <condition>(<expr><name>walking_level</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>++</operator><name>walking_level</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_END_ARRAY</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>WJB_END_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>--</operator><name>walking_level</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r</name> <operator>&lt;</operator> <name>WJB_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Array walker for setPath
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setPathArray</name><parameter_list>(<parameter><decl><type><name>JsonbIterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>path_elems</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>path_nulls</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>path_len</name></decl></parameter>, <parameter><decl><type><name>JsonbParseState</name> <modifier>*</modifier><modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
			 <parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>nelems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* pick correct index */</comment>
	<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&lt;</operator> <name>path_len</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>path_nulls</name><index>[<expr><name>level</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>path_elems</name><index>[<expr><name>level</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>lindex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>badp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>lindex</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>badp</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>badp</name> <operator>==</operator> <name>c</name> <operator>||</operator> <operator>*</operator><name>badp</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>lindex</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator>
			<name>lindex</name> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"path element at position %d is not an integer: \"%s\""</literal></expr></argument>,
							<argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>lindex</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>-</operator><name>idx</name> <operator>&gt;</operator> <name>nelems</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>INT_MIN</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>nelems</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>idx</name> <operator>&gt;</operator> <name>nelems</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * if we're creating, and idx == INT_MIN, we prepend the new value to the
	 * array also if the array is empty - in which case we don't really care
	 * what the idx value is
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idx</name> <operator>==</operator> <name>INT_MIN</name> <operator>||</operator> <name>nelems</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>level</name> <operator>==</operator> <name>path_len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>op_type</name> <operator>&amp;</operator> <name>JB_PATH_CREATE_OR_INSERT</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>addJsonbToParseState</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* iterate over the array elements */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>r</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>idx</name> <operator>&amp;&amp;</operator> <name>level</name> <operator>&lt;</operator> <name>path_len</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <name>path_len</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* skip */</comment>

				<if_stmt><if>if <condition>(<expr><name>op_type</name> <operator>&amp;</operator> <operator>(</operator><name>JB_PATH_INSERT_BEFORE</name> <operator>|</operator> <name>JB_PATH_CREATE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>addJsonbToParseState</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * We should keep current value only in case of
				 * JB_PATH_INSERT_BEFORE or JB_PATH_INSERT_AFTER because
				 * otherwise it should be deleted or replaced
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>op_type</name> <operator>&amp;</operator> <operator>(</operator><name>JB_PATH_INSERT_AFTER</name> <operator>|</operator> <name>JB_PATH_INSERT_BEFORE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>op_type</name> <operator>&amp;</operator> <operator>(</operator><name>JB_PATH_INSERT_AFTER</name> <operator>|</operator> <name>JB_PATH_REPLACE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>addJsonbToParseState</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>setPath</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>path_elems</name></expr></argument>, <argument><expr><name>path_nulls</name></expr></argument>, <argument><expr><name>path_len</name></expr></argument>,
							   <argument><expr><name>st</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><name>op_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r</name> <operator>&lt;</operator> <name>WJB_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>walking_level</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

				<while>while <condition>(<expr><name>walking_level</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_BEGIN_ARRAY</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>WJB_BEGIN_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>++</operator><name>walking_level</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WJB_END_ARRAY</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>WJB_END_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>--</operator><name>walking_level</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><ternary><condition><expr><name>r</name> <operator>&lt;</operator> <name>WJB_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>op_type</name> <operator>&amp;</operator> <name>JB_PATH_CREATE_OR_INSERT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>done</name> <operator>&amp;&amp;</operator>
				<name>level</name> <operator>==</operator> <name>path_len</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>nelems</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>addJsonbToParseState</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Parse information about what elements of a jsonb document we want to iterate
 * in functions iterate_json(b)_values. This information is presented in jsonb
 * format, so that it can be easily extended in the future.
 */</comment>
<function><type><name>uint32</name></type>
<name>parse_jsonb_index_flags</name><parameter_list>(<parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>jb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We iterate over array (scalar internally is represented as array, so,
	 * we will accept it too) to check all its elements.  Flag names are
	 * chosen the same as jsonb_typeof uses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>WJB_BEGIN_ARRAY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong flag type, only arrays and scalars are allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>type</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>WJB_ELEM</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>jbvString</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"flag array element is not a string"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Possible values are: \"string\", \"numeric\", \"boolean\", \"key\", and \"all\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator>
			<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>jtiAll</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator>
				 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><literal type="string">"key"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>jtiKey</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>
				 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><literal type="string">"string"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>jtiString</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator>
				 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><literal type="string">"numeric"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>jtiNumeric</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator>
				 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><literal type="string">"boolean"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>jtiBool</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong flag in flag array: \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Possible values are: \"string\", \"numeric\", \"boolean\", \"key\", and \"all\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* expect end of array now */</comment>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>WJB_END_ARRAY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of flag array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* get final WJB_DONE and free iterator */</comment>
	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of flag array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Iterate over jsonb values or elements, specified by flags, and pass them
 * together with an iteration state to a specified JsonIterateStringValuesAction.
 */</comment>
<function><type><name>void</name></type>
<name>iterate_jsonb_values</name><parameter_list>(<parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>jb</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
					 <parameter><decl><type><name>JsonIterateStringValuesAction</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>type</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Just recursively iterating over jsonb and call callback on all
	 * correspoding elements
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>type</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>WJB_KEY</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>jtiKey</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>action</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>type</name> <operator>==</operator> <name>WJB_VALUE</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>WJB_ELEM</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* do not call callback for composite JsonbValue */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* JsonbValue is a value of object or element of array */</comment>
		<switch>switch <condition>(<expr><name><name>v</name><operator>.</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>jbvString</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>jtiString</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>action</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>jbvNumeric</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>jtiNumeric</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_out</name></expr></argument>,
															  <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>action</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>jbvBool</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>jtiBool</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>action</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>action</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* do not call callback for composite JsonbValue */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Iterate over json values and elements, specified by flags, and pass them
 * together with an iteration state to a specified JsonIterateStringValuesAction.
 */</comment>
<function><type><name>void</name></type>
<name>iterate_json_values</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>action_state</name></decl></parameter>,
					<parameter><decl><type><name>JsonIterateStringValuesAction</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name> <init>= <expr><call><name>makeJsonLexContext</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonSemAction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IterateJsonStringValuesState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IterateJsonStringValuesState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lex</name></name> <operator>=</operator> <name>lex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>action_state</name></name> <operator>=</operator> <name>action_state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name> <operator>=</operator> <name>iterate_values_scalar</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_start</name></name> <operator>=</operator> <name>iterate_values_object_field_start</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * An auxiliary function for iterate_json_values to invoke a specified
 * JsonIterateStringValuesAction for specified values.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>iterate_values_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IterateJsonStringValuesState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>IterateJsonStringValuesState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>tokentype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JSON_TOKEN_STRING</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>jtiString</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name><name>_state</name><operator>-&gt;</operator><name>action</name></name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>action_state</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_NUMBER</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>jtiNumeric</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name><name>_state</name><operator>-&gt;</operator><name>action</name></name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>action_state</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_TRUE</name></expr>:</case>
		<case>case <expr><name>JSON_TOKEN_FALSE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>jtiBool</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name><name>_state</name><operator>-&gt;</operator><name>action</name></name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>action_state</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* do not call callback for any other token */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>iterate_values_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IterateJsonStringValuesState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>IterateJsonStringValuesState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>jtiKey</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name><name>_state</name><operator>-&gt;</operator><name>action</name></name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>action_state</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Iterate over a jsonb, and apply a specified JsonTransformStringValuesAction
 * to every string value or element. Any necessary context for a
 * JsonTransformStringValuesAction can be passed in the action_state variable.
 * Function returns a copy of an original jsonb object with transformed values.
 */</comment>
<function><type><name>Jsonb</name> <modifier>*</modifier></type>
<name>transform_jsonb_string_values</name><parameter_list>(<parameter><decl><type><name>Jsonb</name> <modifier>*</modifier></type><name>jsonb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>action_state</name></decl></parameter>,
							  <parameter><decl><type><name>JsonTransformStringValuesAction</name></type> <name>transform_action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonbIterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbValue</name></type>	<name>v</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbIteratorToken</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonbParseState</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_scalar</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>JsonbIteratorInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jsonb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_scalar</name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>isScalar</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>type</name> <operator>=</operator> <call><name>JsonbIteratorNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WJB_DONE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>==</operator> <name>WJB_VALUE</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>WJB_ELEM</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>jbvString</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>transform_action</name><argument_list>(<argument><expr><name>action_state</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* POLAR: type will alwaly be smaller than WJB_BEGIN_ARRAY in this case */</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* POLAR end */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pushJsonbValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>WJB_KEY</name> <operator>||</operator>
											 <name>type</name> <operator>==</operator> <name>WJB_VALUE</name> <operator>||</operator>
											 <name>type</name> <operator>==</operator> <name>WJB_ELEM</name><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>jbvArray</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>rawScalar</name></name> <operator>=</operator> <name>is_scalar</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>JsonbValueToJsonb</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Iterate over a json, and apply a specified JsonTransformStringValuesAction
 * to every string value or element. Any necessary context for a
 * JsonTransformStringValuesAction can be passed in the action_state variable.
 * Function returns a StringInfo, which is a copy of an original json with
 * transformed values.
 */</comment>
<function><type><name>text</name> <modifier>*</modifier></type>
<name>transform_json_string_values</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>action_state</name></decl></parameter>,
							 <parameter><decl><type><name>JsonTransformStringValuesAction</name></type> <name>transform_action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name> <init>= <expr><call><name>makeJsonLexContext</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonSemAction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransformJsonStringValuesState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransformJsonStringValuesState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>lex</name></name> <operator>=</operator> <name>lex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>strval</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>transform_action</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>action_state</name></name> <operator>=</operator> <name>action_state</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>state</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name> <operator>=</operator> <name>transform_string_values_scalar</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_start</name></name> <operator>=</operator> <name>transform_string_values_object_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_end</name></name> <operator>=</operator> <name>transform_string_values_object_end</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_start</name></name> <operator>=</operator> <name>transform_string_values_array_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_end</name></name> <operator>=</operator> <name>transform_string_values_array_end</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name> <operator>=</operator> <name>transform_string_values_scalar</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_start</name></name> <operator>=</operator> <name>transform_string_values_array_element_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_start</name></name> <operator>=</operator> <name>transform_string_values_object_field_start</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set of auxiliary functions for transform_json_string_values to invoke a
 * specified JsonTransformStringValuesAction for all values and left everything
 * else untouched.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transform_string_values_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransformJsonStringValuesState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>TransformJsonStringValuesState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>transform_string_values_object_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransformJsonStringValuesState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>TransformJsonStringValuesState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>transform_string_values_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransformJsonStringValuesState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>TransformJsonStringValuesState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>transform_string_values_array_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransformJsonStringValuesState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>TransformJsonStringValuesState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>transform_string_values_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransformJsonStringValuesState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>TransformJsonStringValuesState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Unfortunately we don't have the quoted and escaped string any more, so
	 * we have to re-escape it.
	 */</comment>
	<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>transform_string_values_array_element_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransformJsonStringValuesState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>TransformJsonStringValuesState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'['</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>transform_string_values_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>tokentype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransformJsonStringValuesState</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>TransformJsonStringValuesState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tokentype</name> <operator>==</operator> <name>JSON_TOKEN_STRING</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name><name>_state</name><operator>-&gt;</operator><name>action</name></name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>action_state</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>_state</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
