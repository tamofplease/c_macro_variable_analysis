<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/adt/float.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * float.c
 *	  Functions for the built-in floating-point types.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/float.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sortsupport.h"</cpp:file></cpp:include>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>M_PI</name></cpp:ifndef>
<comment type="block">/* from my RH5.2 gcc math.h file - thomas 2000-04-03 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_PI</name></cpp:macro> <cpp:value>3.14159265358979323846</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Radians per degree, a.k.a. PI / 180 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIANS_PER_DEGREE</name></cpp:macro> <cpp:value>0.0174532925199432957692</cpp:value></cpp:define>

<comment type="block">/* Visual C++ etc lacks NAN, and won't accept 0.0/0.0.  NAN definition from
 * http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/vclrfNotNumberNANItems.asp
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name><name>nan</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0xffffffff</literal></expr>, <expr><literal type="number">0x7fffffff</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAN</name></cpp:macro> <cpp:value>(*(const double *) nan)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * check to see if a float4/8 val has underflowed or overflowed
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKFLOATVAL</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>inf_is_valid</name></type></parameter>, <parameter><type><name>zero_is_valid</name></type></parameter>)</parameter_list></cpp:macro>			\
<cpp:value>do {															\
	if (isinf(val) &amp;&amp; !(inf_is_valid))							\
		ereport(ERROR,											\
				(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),	\
		  errmsg("value out of range: overflow")));				\
																\
	if ((val) == 0.0 &amp;&amp; !(zero_is_valid))						\
		ereport(ERROR,											\
				(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),	\
		 errmsg("value out of range: underflow")));				\
} while(0)</cpp:value></cpp:define>


<comment type="block">/* Configurable GUC parameter */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>extra_float_digits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Added to DBL_DIG or FLT_DIG */</comment>

<comment type="block">/* Cached constants for degree-based trig functions */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>degree_consts_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float8</name></type> <name>sin_30</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float8</name></type> <name>one_minus_cos_60</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float8</name></type> <name>asin_0_5</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float8</name></type> <name>acos_0_5</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float8</name></type> <name>atan_1_0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float8</name></type> <name>tan_45</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float8</name></type> <name>cot_45</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * These are intentionally not static; don't "fix" them.  They will never
 * be referenced by other files, much less changed; but we don't want the
 * compiler to know that, else it might try to precompute expressions
 * involving them.  See comments for init_degree_constants().
 */</comment>
<decl_stmt><decl><type><name>float8</name></type>		<name>degree_c_thirty</name> <init>= <expr><literal type="number">30.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float8</name></type>		<name>degree_c_forty_five</name> <init>= <expr><literal type="number">45.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float8</name></type>		<name>degree_c_sixty</name> <init>= <expr><literal type="number">60.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float8</name></type>		<name>degree_c_one_half</name> <init>= <expr><literal type="number">0.5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float8</name></type>		<name>degree_c_one</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Local function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>sind_q1</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>cosd_q1</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_degree_constants</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_CBRT</name></cpp:ifndef>
<comment type="block">/*
 * Some machines (in particular, some versions of AIX) have an extern
 * declaration for cbrt() in &lt;math.h&gt; but fail to provide the actual
 * function, which causes configure to not set HAVE_CBRT.  Furthermore,
 * their compilers spit up at the mismatch between extern declaration
 * and static definition.  We work around that here by the expedient
 * of a #define to make the actual name of the static function different.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cbrt</name></cpp:macro> <cpp:value>my_cbrt</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>cbrt</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_CBRT */</comment>


<comment type="block">/*
 * Routines to provide reasonably platform-independent handling of
 * infinity and NaN.  We assume that isinf() and isnan() are available
 * and work per spec.  (On some platforms, we have to supply our own;
 * see src/port.)  However, generating an Infinity or NaN in the first
 * place is less well standardized; pre-C99 systems tend not to have C99's
 * INFINITY and NAN macros.  We centralize our workarounds for this here.
 */</comment>

<function><type><name>double</name></type>
<name>get_float8_infinity</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INFINITY</name></cpp:ifdef>
	<comment type="block">/* C99 standard way */</comment>
	<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <name>INFINITY</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the
	 * largest normal double.  We assume forcing an overflow will get us a
	 * true infinity.
	 */</comment>
	<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>HUGE_VAL</name> <operator>*</operator> <name>HUGE_VAL</name><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
* The funny placements of the two #pragmas is necessary because of a
* long lived bug in the Microsoft compilers.
* See http://support.microsoft.com/kb/120968/en-us for details
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1800</literal><operator>)</operator></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4756</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>float</name></type>
<name>get_float4_infinity</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INFINITY</name></cpp:ifdef>
	<comment type="block">/* C99 standard way */</comment>
	<return>return <expr><operator>(</operator><name>float</name><operator>)</operator> <name>INFINITY</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1800</literal><operator>)</operator></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>default</name><name>:</name><name>4756</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the
	 * largest normal double.  We assume forcing an overflow will get us a
	 * true infinity.
	 */</comment>
	<return>return <expr><operator>(</operator><name>float</name><operator>)</operator> <operator>(</operator><name>HUGE_VAL</name> <operator>*</operator> <name>HUGE_VAL</name><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>double</name></type>
<name>get_float8_nan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* (double) NAN doesn't work on some NetBSD/MIPS releases */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NAN</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__mips__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
	<comment type="block">/* C99 standard way */</comment>
	<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <name>NAN</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* Assume we can get a NAN via zero divide */</comment>
	<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><literal type="number">0.0</literal> <operator>/</operator> <literal type="number">0.0</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>float</name></type>
<name>get_float4_nan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NAN</name></cpp:ifdef>
	<comment type="block">/* C99 standard way */</comment>
	<return>return <expr><operator>(</operator><name>float</name><operator>)</operator> <name>NAN</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<comment type="block">/* Assume we can get a NAN via zero divide */</comment>
	<return>return <expr><operator>(</operator><name>float</name><operator>)</operator> <operator>(</operator><literal type="number">0.0</literal> <operator>/</operator> <literal type="number">0.0</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * Returns -1 if 'val' represents negative infinity, 1 if 'val'
 * represents (positive) infinity, and 0 otherwise. On some platforms,
 * this is equivalent to the isinf() macro, but not everywhere: C99
 * does not specify that isinf() needs to distinguish between positive
 * and negative infinity.
 */</comment>
<function><type><name>int</name></type>
<name>is_infinite</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>inf</name> <init>= <expr><call><name>isinf</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>inf</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>val</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ========== USER I/O ROUTINES ========== */</comment>


<comment type="block">/*
 *		float4in		- converts "num" to float4
 */</comment>
<function><type><name>Datum</name></type>
<name>float4in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>num</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>orig_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * endptr points to the first character _after_ the sequence we recognized
	 * as a valid floating point number. orig_num points to the original input
	 * string.
	 */</comment>
	<expr_stmt><expr><name>orig_num</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>

	<comment type="block">/* skip leading whitespace */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>num</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/*
	 * Check for an empty-string input to begin with, to avoid the vagaries of
	 * strtod() on different platforms.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>num</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><literal type="string">"real"</literal></expr></argument>, <argument><expr><name>orig_num</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* did we not see anything that looks like a double? */</comment>
	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>num</name> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,
		 * but not all platforms support all of these (and some accept them
		 * but set ERANGE anyway...)  Therefore, we check for these inputs
		 * ourselves if strtod() fails.
		 *
		 * Note: C99 also requires hexadecimal input as well as some extended
		 * forms of NaN, but we consider these forms unportable and don't try
		 * to support them.  You can use 'em if your strtod() takes 'em.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"NaN"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float4_nan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"Infinity"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float4_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"+Infinity"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float4_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"-Infinity"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><call><name>get_float4_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"inf"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float4_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"+inf"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float4_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"-inf"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><call><name>get_float4_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>save_errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Some platforms return ERANGE for denormalized numbers (those
			 * that are not zero, but are too close to zero to have full
			 * precision).  We'd prefer not to throw error for that, so try to
			 * detect whether it's a "real" out-of-range condition by checking
			 * to see if the result is zero or huge.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0.0</literal> <operator>||</operator> <name>val</name> <operator>&gt;=</operator> <name>HUGE_VAL</name> <operator>||</operator> <name>val</name> <operator>&lt;=</operator> <operator>-</operator><name>HUGE_VAL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is out of range for type real"</literal></expr></argument>,
								<argument><expr><name>orig_num</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
							<argument><expr><literal type="string">"real"</literal></expr></argument>, <argument><expr><name>orig_num</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BUGGY_SOLARIS_STRTOD</name></cpp:ifdef>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Many versions of Solaris have a bug wherein strtod sets endptr to
		 * point one byte beyond the end of the string when given "inf" or
		 * "infinity".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>num</name> <operator>&amp;&amp;</operator> <name><name>endptr</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>endptr</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_BUGGY_SOLARIS_STRTOD */</comment>

	<comment type="block">/* skip trailing whitespace */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* if there is any junk left at the end of the string, bail out */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><literal type="string">"real"</literal></expr></argument>, <argument><expr><name>orig_num</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * if we get here, we have a legal double, still need to check to see if
	 * it's a legal float4
	 */</comment>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><operator>(</operator><name>float4</name><operator>)</operator> <name>val</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><operator>(</operator><name>float4</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float4out		- converts a float4 number to a string
 *						  using a standard output format
 */</comment>
<function><type><name>Datum</name></type>
<name>float4out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ascii</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>is_infinite</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><name>ascii</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"Infinity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><name>ascii</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"-Infinity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>ndig</name> <init>= <expr><name>FLT_DIG</name> <operator>+</operator> <name>extra_float_digits</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>ndig</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>ndig</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>ascii</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%.*g"</literal></expr></argument>, <argument><expr><name>ndig</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>ascii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float4recv			- converts external binary format to float4
 */</comment>
<function><type><name>Datum</name></type>
<name>float4recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><call><name>pq_getmsgfloat4</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float4send			- converts float4 to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>float4send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat4</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float8in		- converts "num" to float8
 */</comment>
<function><type><name>Datum</name></type>
<name>float8in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>num</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>float8in_internal</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * float8in_internal - guts of float8in()
 *
 * This is exposed for use by functions that want a reasonably
 * platform-independent way of inputting doubles.  The behavior is
 * essentially like strtod + ereport on error, but note the following
 * differences:
 * 1. Both leading and trailing whitespace are skipped.
 * 2. If endptr_p is NULL, we throw error if there's trailing junk.
 * Otherwise, it's up to the caller to complain about trailing junk.
 * 3. In event of a syntax error, the report mentions the given type_name
 * and prints orig_string as the input; this is meant to support use of
 * this function with types such as "box" and "point", where what we are
 * parsing here is just a substring of orig_string.
 *
 * "num" could validly be declared "const char *", but that results in an
 * unreasonable amount of extra casting both here and in callers, so we don't.
 */</comment>
<function><type><name>double</name></type>
<name>float8in_internal</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr_p</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<comment type="block">/* skip leading whitespace */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>num</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/*
	 * Check for an empty-string input to begin with, to avoid the vagaries of
	 * strtod() on different platforms.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>num</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* did we not see anything that looks like a double? */</comment>
	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>num</name> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,
		 * but not all platforms support all of these (and some accept them
		 * but set ERANGE anyway...)  Therefore, we check for these inputs
		 * ourselves if strtod() fails.
		 *
		 * Note: C99 also requires hexadecimal input as well as some extended
		 * forms of NaN, but we consider these forms unportable and don't try
		 * to support them.  You can use 'em if your strtod() takes 'em.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"NaN"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"Infinity"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"+Infinity"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"-Infinity"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"inf"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"+inf"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"-inf"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>save_errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Some platforms return ERANGE for denormalized numbers (those
			 * that are not zero, but are too close to zero to have full
			 * precision).  We'd prefer not to throw error for that, so try to
			 * detect whether it's a "real" out-of-range condition by checking
			 * to see if the result is zero or huge.
			 *
			 * On error, we intentionally complain about double precision not
			 * the given type name, and we print only the part of the string
			 * that is the current number.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0.0</literal> <operator>||</operator> <name>val</name> <operator>&gt;=</operator> <name>HUGE_VAL</name> <operator>||</operator> <name>val</name> <operator>&lt;=</operator> <operator>-</operator><name>HUGE_VAL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>errnumber</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>errnumber</name><index>[<expr><name>endptr</name> <operator>-</operator> <name>num</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is out of range for type double precision"</literal></expr></argument>,
								<argument><expr><name>errnumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
							<argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BUGGY_SOLARIS_STRTOD</name></cpp:ifdef>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Many versions of Solaris have a bug wherein strtod sets endptr to
		 * point one byte beyond the end of the string when given "inf" or
		 * "infinity".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>num</name> <operator>&amp;&amp;</operator> <name><name>endptr</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>endptr</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_BUGGY_SOLARIS_STRTOD */</comment>

	<comment type="block">/* skip trailing whitespace */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* report stopping point if wanted, else complain if not end of string */</comment>
	<if_stmt><if>if <condition>(<expr><name>endptr_p</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>endptr_p</name> <operator>=</operator> <name>endptr</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
						<argument><expr><name>type_name</name></expr></argument>, <argument><expr><name>orig_string</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		float8out		- converts float8 number to a string
 *						  using a standard output format
 */</comment>
<function><type><name>Datum</name></type>
<name>float8out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>float8out_internal</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * float8out_internal - guts of float8out()
 *
 * This is exposed for use by functions that want a reasonably
 * platform-independent way of outputting doubles.
 * The result is always palloc'd.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>float8out_internal</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ascii</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>is_infinite</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><name>ascii</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"Infinity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><name>ascii</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"-Infinity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>ndig</name> <init>= <expr><name>DBL_DIG</name> <operator>+</operator> <name>extra_float_digits</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>ndig</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>ndig</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>ascii</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%.*g"</literal></expr></argument>, <argument><expr><name>ndig</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
	</block_content>}</block></switch>

	<return>return <expr><name>ascii</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		float8recv			- converts external binary format to float8
 */</comment>
<function><type><name>Datum</name></type>
<name>float8recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float8send			- converts float8 to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>float8send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ========== PUBLIC ROUTINES ========== */</comment>


<comment type="block">/*
 *		======================
 *		FLOAT4 BASE OPERATIONS
 *		======================
 */</comment>

<comment type="block">/*
 *		float4abs		- returns |arg1| (absolute value)
 */</comment>
<function><type><name>Datum</name></type>
<name>float4abs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><operator>(</operator><name>float4</name><operator>)</operator> <call><name>fabs</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float4um		- returns -arg1 (unary minus)
 */</comment>
<function><type><name>Datum</name></type>
<name>float4um</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4up</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4larger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>float4_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4smaller</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>float4_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		======================
 *		FLOAT8 BASE OPERATIONS
 *		======================
 */</comment>

<comment type="block">/*
 *		float8abs		- returns |arg1| (absolute value)
 */</comment>
<function><type><name>Datum</name></type>
<name>float8abs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		float8um		- returns -arg1 (unary minus)
 */</comment>
<function><type><name>Datum</name></type>
<name>float8um</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>arg1</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8up</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8larger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8smaller</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		====================
 *		ARITHMETIC OPERATORS
 *		====================
 */</comment>

<comment type="block">/*
 *		float4pl		- returns arg1 + arg2
 *		float4mi		- returns arg1 - arg2
 *		float4mul		- returns arg1 * arg2
 *		float4div		- returns arg1 / arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>float4pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>+</operator> <name>arg2</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * There isn't any way to check for underflow of addition/subtraction
	 * because numbers near the underflow value have already been rounded to
	 * the point where we can't detect that the two values were originally
	 * different, e.g. on x86, '1e-45'::float4 == '2e-45'::float4 ==
	 * 1.4013e-45.
	 */</comment>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4mi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>-</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4mul</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>*</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>arg2</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg2</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>/</operator> <name>arg2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float8pl		- returns arg1 + arg2
 *		float8mi		- returns arg1 - arg2
 *		float8mul		- returns arg1 * arg2
 *		float8div		- returns arg1 / arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>float8pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>+</operator> <name>arg2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8mi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>-</operator> <name>arg2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8mul</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>*</operator> <name>arg2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>arg2</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg2</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>/</operator> <name>arg2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		====================
 *		COMPARISON OPERATORS
 *		====================
 */</comment>

<comment type="block">/*
 *		float4{eq,ne,lt,le,gt,ge}		- float4/float4 comparison operations
 */</comment>
<function><type><name>int</name></type>
<name>float4_cmp_internal</name><parameter_list>(<parameter><decl><type><name>float4</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>float4</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We consider all NANs to be equal and larger than any non-NAN. This is
	 * somewhat arbitrary; the important thing is to have a consistent sort
	 * order.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>			<comment type="block">/* NAN = NAN */</comment>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>			<comment type="block">/* NAN &gt; non-NAN */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>				<comment type="block">/* non-NAN &lt; NAN */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float4_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float4_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float4_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float4_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float4_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float4_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>btfloat4cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>float4_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>btfloat4fastcmp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>float4_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>btfloat4sortsupport</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name> <init>= <expr><operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>btfloat4fastcmp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float8{eq,ne,lt,le,gt,ge}		- float8/float8 comparison operations
 */</comment>
<function><type><name>int</name></type>
<name>float8_cmp_internal</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We consider all NANs to be equal and larger than any non-NAN. This is
	 * somewhat arbitrary; the important thing is to have a consistent sort
	 * order.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>			<comment type="block">/* NAN = NAN */</comment>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>			<comment type="block">/* NAN &gt; non-NAN */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>				<comment type="block">/* non-NAN &lt; NAN */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>btfloat8cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>btfloat8fastcmp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>btfloat8sortsupport</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name> <init>= <expr><operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>btfloat8fastcmp</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>btfloat48cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* widen float4 to float8 and then compare */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>btfloat84cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* widen float4 to float8 and then compare */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * in_range support function for float8.
 *
 * Note: we needn't supply a float8_float4 variant, as implicit coercion
 * of the offset value takes care of that scenario just as well.
 */</comment>
<function><type><name>Datum</name></type>
<name>in_range_float8_float8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>base</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>offset</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sub</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>less</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>sum</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reject negative or NaN offset.  Negative is per spec, and NaN is
	 * because appropriate semantics for that seem non-obvious.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid preceding or following size in window function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Deal with cases where val and/or base is NaN, following the rule that
	 * NaN sorts after non-NaN (cf float8_cmp_internal).  The offset cannot
	 * affect the conclusion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* NAN = NAN */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><name>less</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* NAN &gt; non-NAN */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>less</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* non-NAN &lt; NAN */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Deal with infinite offset (necessarily +inf, at this point).  We must
	 * special-case this because if base happens to be -inf, their sum would
	 * be NaN, which is an overflow-ish condition we should avoid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><ternary><condition><expr><name>sub</name></expr> ?</condition><then> <expr><operator>!</operator><name>less</name></expr> </then><else>: <expr><name>less</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise it should be safe to compute base +/- offset.  We trust the
	 * FPU to cope if base is +/-inf or the true sum would overflow, and
	 * produce a suitably signed infinity, which will compare properly against
	 * val whether or not that's infinity.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <name>base</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>less</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>val</name> <operator>&lt;=</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>val</name> <operator>&gt;=</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * in_range support function for float4.
 *
 * We would need a float4_float8 variant in any case, so we supply that and
 * let implicit coercion take care of the float4_float4 case.
 */</comment>
<function><type><name>Datum</name></type>
<name>in_range_float4_float8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>base</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>offset</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sub</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>less</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>sum</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Reject negative or NaN offset.  Negative is per spec, and NaN is
	 * because appropriate semantics for that seem non-obvious.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid preceding or following size in window function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Deal with cases where val and/or base is NaN, following the rule that
	 * NaN sorts after non-NaN (cf float8_cmp_internal).  The offset cannot
	 * affect the conclusion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* NAN = NAN */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>!</operator><name>less</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* NAN &gt; non-NAN */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>less</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* non-NAN &lt; NAN */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Deal with infinite offset (necessarily +inf, at this point).  We must
	 * special-case this because if base happens to be -inf, their sum would
	 * be NaN, which is an overflow-ish condition we should avoid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><ternary><condition><expr><name>sub</name></expr> ?</condition><then> <expr><operator>!</operator><name>less</name></expr> </then><else>: <expr><name>less</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise it should be safe to compute base +/- offset.  We trust the
	 * FPU to cope if base is +/-inf or the true sum would overflow, and
	 * produce a suitably signed infinity, which will compare properly against
	 * val whether or not that's infinity.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <name>base</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>less</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>val</name> <operator>&lt;=</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>val</name> <operator>&gt;=</operator> <name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		===================
 *		CONVERSION ROUTINES
 *		===================
 */</comment>

<comment type="block">/*
 *		ftod			- converts a float4 number to a float8 number
 */</comment>
<function><type><name>Datum</name></type>
<name>ftod</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dtof			- converts a float8 number to a float4 number
 */</comment>
<function><type><name>Datum</name></type>
<name>dtof</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><operator>(</operator><name>float4</name><operator>)</operator> <name>num</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><operator>(</operator><name>float4</name><operator>)</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dtoi4			- converts a float8 number to an int4 number
 */</comment>
<function><type><name>Datum</name></type>
<name>dtoi4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get rid of any fractional part in the input.  This is so we don't fail
	 * on just-out-of-range values that would round into range.  Note
	 * assumption that rint() will pass through a NaN or Inf unchanged.
	 */</comment>
	<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Range check */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>isnan</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>FLOAT8_FITS_IN_INT32</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dtoi2			- converts a float8 number to an int2 number
 */</comment>
<function><type><name>Datum</name></type>
<name>dtoi2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get rid of any fractional part in the input.  This is so we don't fail
	 * on just-out-of-range values that would round into range.  Note
	 * assumption that rint() will pass through a NaN or Inf unchanged.
	 */</comment>
	<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Range check */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>isnan</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>FLOAT8_FITS_IN_INT16</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"smallint out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><operator>(</operator><name>int16</name><operator>)</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		i4tod			- converts an int4 number to a float8 number
 */</comment>
<function><type><name>Datum</name></type>
<name>i4tod</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		i2tod			- converts an int2 number to a float8 number
 */</comment>
<function><type><name>Datum</name></type>
<name>i2tod</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		ftoi4			- converts a float4 number to an int4 number
 */</comment>
<function><type><name>Datum</name></type>
<name>ftoi4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get rid of any fractional part in the input.  This is so we don't fail
	 * on just-out-of-range values that would round into range.  Note
	 * assumption that rint() will pass through a NaN or Inf unchanged.
	 */</comment>
	<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Range check */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>isnan</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>FLOAT4_FITS_IN_INT32</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		ftoi2			- converts a float4 number to an int2 number
 */</comment>
<function><type><name>Datum</name></type>
<name>ftoi2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get rid of any fractional part in the input.  This is so we don't fail
	 * on just-out-of-range values that would round into range.  Note
	 * assumption that rint() will pass through a NaN or Inf unchanged.
	 */</comment>
	<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Range check */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>isnan</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>FLOAT4_FITS_IN_INT16</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"smallint out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><operator>(</operator><name>int16</name><operator>)</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		i4tof			- converts an int4 number to a float4 number
 */</comment>
<function><type><name>Datum</name></type>
<name>i4tof</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><operator>(</operator><name>float4</name><operator>)</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		i2tof			- converts an int2 number to a float4 number
 */</comment>
<function><type><name>Datum</name></type>
<name>i2tof</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><operator>(</operator><name>float4</name><operator>)</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		=======================
 *		RANDOM FLOAT8 OPERATORS
 *		=======================
 */</comment>

<comment type="block">/*
 *		dround			- returns	ROUND(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>dround</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>rint</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		dceil			- returns the smallest integer greater than or
 *						  equal to the specified float
 */</comment>
<function><type><name>Datum</name></type>
<name>dceil</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>ceil</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		dfloor			- returns the largest integer lesser than or
 *						  equal to the specified float
 */</comment>
<function><type><name>Datum</name></type>
<name>dfloor</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>floor</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		dsign			- returns -1 if the argument is less than 0, 0
 *						  if the argument is equal to 0, and 1 if the
 *						  argument is greater than zero.
 */</comment>
<function><type><name>Datum</name></type>
<name>dsign</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>arg1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		dtrunc			- returns truncation-towards-zero of arg1,
 *						  arg1 &gt;= 0 ... the greatest integer less
 *										than or equal to arg1
 *						  arg1 &lt; 0	... the least integer greater
 *										than or equal to arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>dtrunc</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><call><name>floor</name><argument_list>(<argument><expr><operator>-</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dsqrt			- returns square root of arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>dsqrt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot take square root of a negative number"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dcbrt			- returns cube root of arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>dcbrt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cbrt</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dpow			- returns pow(arg1,arg2)
 */</comment>
<function><type><name>Datum</name></type>
<name>dpow</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The POSIX spec says that NaN ^ 0 = 1, and 1 ^ NaN = 1, while all other
	 * cases with NaN inputs yield NaN (with no error).  Many older platforms
	 * get one or more of these cases wrong, so deal with them via explicit
	 * logic rather than trusting pow(3).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>arg2</name> <operator>!=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>!=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The SQL spec requires that we emit a particular SQLSTATE error code for
	 * certain error conditions.  Specifically, we don't return a
	 * divide-by-zero error code for 0 ^ -1.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>arg2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"zero raised to a negative power is undefined"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>floor</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>arg2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a negative number raised to a non-integer power yields a complex result"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * pow() sets errno only on some platforms, depending on whether it
	 * follows _IEEE_, _POSIX_, _XOPEN_, or _SVID_, so we try to avoid using
	 * errno.  However, some platform/CPU combinations return errno == EDOM
	 * and result == NaN for negative arg1 and very large arg2 (they must be
	 * using something different from our floor() test to decide it's
	 * invalid).  Other platforms (HPPA) return errno == ERANGE and a large
	 * (HUGE_VAL) but finite result to signal overflow.
	 */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pow</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EDOM</name> <operator>&amp;&amp;</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>fabs</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>arg2</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>fabs</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>arg2</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* The sign of Inf is not significant in this case. */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isinf</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dexp			- returns the exponential function of arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>dexp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>exp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isinf</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dlog1			- returns the natural logarithm of arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>dlog1</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Emit particular SQLSTATE error codes for ln(). This is required by the
	 * SQL standard.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_LOG</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot take logarithm of zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_LOG</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot take logarithm of a negative number"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>log</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dlog10			- returns the base 10 logarithm of arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>dlog10</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Emit particular SQLSTATE error codes for log(). The SQL spec doesn't
	 * define log(), but it does define ln(), so it makes sense to emit the
	 * same error code for an analogous error condition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_LOG</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot take logarithm of zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_LOG</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot take logarithm of a negative number"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>log10</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dacos			- returns the arccos of arg1 (radians)
 */</comment>
<function><type><name>Datum</name></type>
<name>dacos</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if the input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The principal branch of the inverse cosine function maps values in the
	 * range [-1, 1] to values in the range [0, Pi], so we should reject any
	 * inputs outside that range and the result will always be finite.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>arg1</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">1.0</literal> <operator>||</operator> <name>arg1</name></expr></argument> &gt;</argument_list></name> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>acos</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dasin			- returns the arcsin of arg1 (radians)
 */</comment>
<function><type><name>Datum</name></type>
<name>dasin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if the input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The principal branch of the inverse sine function maps values in the
	 * range [-1, 1] to values in the range [-Pi/2, Pi/2], so we should reject
	 * any inputs outside that range and the result will always be finite.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>arg1</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">1.0</literal> <operator>||</operator> <name>arg1</name></expr></argument> &gt;</argument_list></name> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>asin</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		datan			- returns the arctan of arg1 (radians)
 */</comment>
<function><type><name>Datum</name></type>
<name>datan</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if the input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The principal branch of the inverse tangent function maps all inputs to
	 * values in the range [-Pi/2, Pi/2], so the result should always be
	 * finite, even if the input is infinite.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>atan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		atan2			- returns the arctan of arg1/arg2 (radians)
 */</comment>
<function><type><name>Datum</name></type>
<name>datan2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if either input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * atan2 maps all inputs to values in the range [-Pi, Pi], so the result
	 * should always be finite, even if the inputs are infinite.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>atan2</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dcos			- returns the cosine of arg1 (radians)
 */</comment>
<function><type><name>Datum</name></type>
<name>dcos</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if the input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * cos() is periodic and so theoretically can work for all finite inputs,
	 * but some implementations may choose to throw error if the input is so
	 * large that there are no significant digits in the result.  So we should
	 * check for errors.  POSIX allows an error to be reported either via
	 * errno or via fetestexcept(), but currently we only support checking
	 * errno.  (fetestexcept() is rumored to report underflow unreasonably
	 * early on some platforms, so it's not clear that believing it would be a
	 * net improvement anyway.)
	 *
	 * For infinite inputs, POSIX specifies that the trigonometric functions
	 * should return a domain error; but we won't notice that unless the
	 * platform reports via errno, so also explicitly test for infinite
	 * inputs.
	 */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cos</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dcot			- returns the cotangent of arg1 (radians)
 */</comment>
<function><type><name>Datum</name></type>
<name>dcot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if the input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Be sure to throw an error if the input is infinite --- see dcos() */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>result</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* cot(0) == Inf */</comment> , <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dsin			- returns the sine of arg1 (radians)
 */</comment>
<function><type><name>Datum</name></type>
<name>dsin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if the input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Be sure to throw an error if the input is infinite --- see dcos() */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>sin</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dtan			- returns the tangent of arg1 (radians)
 */</comment>
<function><type><name>Datum</name></type>
<name>dtan</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if the input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Be sure to throw an error if the input is infinite --- see dcos() */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* tan(pi/2) == Inf */</comment> , <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ========== DEGREE-BASED TRIGONOMETRIC FUNCTIONS ========== */</comment>


<comment type="block">/*
 * Initialize the cached constants declared at the head of this file
 * (sin_30 etc).  The fact that we need those at all, let alone need this
 * Rube-Goldberg-worthy method of initializing them, is because there are
 * compilers out there that will precompute expressions such as sin(constant)
 * using a sin() function different from what will be used at runtime.  If we
 * want exact results, we must ensure that none of the scaling constants used
 * in the degree-based trig functions are computed that way.  To do so, we
 * compute them from the variables degree_c_thirty etc, which are also really
 * constants, but the compiler cannot assume that.
 *
 * Other hazards we are trying to forestall with this kluge include the
 * possibility that compilers will rearrange the expressions, or compute
 * some intermediate results in registers wider than a standard double.
 *
 * In the places where we use these constants, the typical pattern is like
 *		volatile float8 sin_x = sin(x * RADIANS_PER_DEGREE);
 *		return (sin_x / sin_30);
 * where we hope to get a value of exactly 1.0 from the division when x = 30.
 * The volatile temporary variable is needed on machines with wide float
 * registers, to ensure that the result of sin(x) is rounded to double width
 * the same as the value of sin_30 has been.  Experimentation with gcc shows
 * that marking the temp variable volatile is necessary to make the store and
 * reload actually happen; hopefully the same trick works for other compilers.
 * (gcc's documentation suggests using the -ffloat-store compiler switch to
 * ensure this, but that is compiler-specific and it also pessimizes code in
 * many places where we don't care about this.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_degree_constants</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>sin_30</name> <operator>=</operator> <call><name>sin</name><argument_list>(<argument><expr><name>degree_c_thirty</name> <operator>*</operator> <name>RADIANS_PER_DEGREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>one_minus_cos_60</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <call><name>cos</name><argument_list>(<argument><expr><name>degree_c_sixty</name> <operator>*</operator> <name>RADIANS_PER_DEGREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>asin_0_5</name> <operator>=</operator> <call><name>asin</name><argument_list>(<argument><expr><name>degree_c_one_half</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>acos_0_5</name> <operator>=</operator> <call><name>acos</name><argument_list>(<argument><expr><name>degree_c_one_half</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>atan_1_0</name> <operator>=</operator> <call><name>atan</name><argument_list>(<argument><expr><name>degree_c_one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tan_45</name> <operator>=</operator> <call><name>sind_q1</name><argument_list>(<argument><expr><name>degree_c_forty_five</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>cosd_q1</name><argument_list>(<argument><expr><name>degree_c_forty_five</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cot_45</name> <operator>=</operator> <call><name>cosd_q1</name><argument_list>(<argument><expr><name>degree_c_forty_five</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>sind_q1</name><argument_list>(<argument><expr><name>degree_c_forty_five</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>degree_consts_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_DEGREE_CONSTANTS</name><parameter_list>()</parameter_list></cpp:macro> \
<cpp:value>do { \
	if (!degree_consts_set) \
		init_degree_constants(); \
} while(0)</cpp:value></cpp:define>


<comment type="block">/*
 *		asind_q1		- returns the inverse sine of x in degrees, for x in
 *						  the range [0, 1].  The result is an angle in the
 *						  first quadrant --- [0, 90] degrees.
 *
 *						  For the 3 special case inputs (0, 0.5 and 1), this
 *						  function will return exact values (0, 30 and 90
 *						  degrees respectively).
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>asind_q1</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Stitch together inverse sine and cosine functions for the ranges [0,
	 * 0.5] and (0.5, 1].  Each expression below is guaranteed to return
	 * exactly 30 for x=0.5, so the result is a continuous monotonic function
	 * over the full range.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;=</operator> <literal type="number">0.5</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>float8</name></type> <name>asin_x</name> <init>= <expr><call><name>asin</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><operator>(</operator><name>asin_x</name> <operator>/</operator> <name>asin_0_5</name><operator>)</operator> <operator>*</operator> <literal type="number">30.0</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>float8</name></type> <name>acos_x</name> <init>= <expr><call><name>acos</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><literal type="number">90.0</literal> <operator>-</operator> <operator>(</operator><name>acos_x</name> <operator>/</operator> <name>acos_0_5</name><operator>)</operator> <operator>*</operator> <literal type="number">60.0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		acosd_q1		- returns the inverse cosine of x in degrees, for x in
 *						  the range [0, 1].  The result is an angle in the
 *						  first quadrant --- [0, 90] degrees.
 *
 *						  For the 3 special case inputs (0, 0.5 and 1), this
 *						  function will return exact values (0, 60 and 90
 *						  degrees respectively).
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>acosd_q1</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Stitch together inverse sine and cosine functions for the ranges [0,
	 * 0.5] and (0.5, 1].  Each expression below is guaranteed to return
	 * exactly 60 for x=0.5, so the result is a continuous monotonic function
	 * over the full range.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;=</operator> <literal type="number">0.5</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>float8</name></type> <name>asin_x</name> <init>= <expr><call><name>asin</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><literal type="number">90.0</literal> <operator>-</operator> <operator>(</operator><name>asin_x</name> <operator>/</operator> <name>asin_0_5</name><operator>)</operator> <operator>*</operator> <literal type="number">30.0</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>float8</name></type> <name>acos_x</name> <init>= <expr><call><name>acos</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><operator>(</operator><name>acos_x</name> <operator>/</operator> <name>acos_0_5</name><operator>)</operator> <operator>*</operator> <literal type="number">60.0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dacosd			- returns the arccos of arg1 (degrees)
 */</comment>
<function><type><name>Datum</name></type>
<name>dacosd</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if the input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_DEGREE_CONSTANTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The principal branch of the inverse cosine function maps values in the
	 * range [-1, 1] to values in the range [0, 180], so we should reject any
	 * inputs outside that range and the result will always be finite.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>arg1</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">1.0</literal> <operator>||</operator> <name>arg1</name></expr></argument> &gt;</argument_list></name> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>acosd_q1</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">90.0</literal> <operator>+</operator> <call><name>asind_q1</name><argument_list>(<argument><expr><operator>-</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dasind			- returns the arcsin of arg1 (degrees)
 */</comment>
<function><type><name>Datum</name></type>
<name>dasind</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if the input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_DEGREE_CONSTANTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The principal branch of the inverse sine function maps values in the
	 * range [-1, 1] to values in the range [-90, 90], so we should reject any
	 * inputs outside that range and the result will always be finite.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>arg1</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">1.0</literal> <operator>||</operator> <name>arg1</name></expr></argument> &gt;</argument_list></name> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>asind_q1</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><call><name>asind_q1</name><argument_list>(<argument><expr><operator>-</operator><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		datand			- returns the arctan of arg1 (degrees)
 */</comment>
<function><type><name>Datum</name></type>
<name>datand</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>float8</name></type> <name>atan_arg1</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if the input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_DEGREE_CONSTANTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The principal branch of the inverse tangent function maps all inputs to
	 * values in the range [-90, 90], so the result should always be finite,
	 * even if the input is infinite.  Additionally, we take care to ensure
	 * than when arg1 is 1, the result is exactly 45.
	 */</comment>
	<expr_stmt><expr><name>atan_arg1</name> <operator>=</operator> <call><name>atan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>atan_arg1</name> <operator>/</operator> <name>atan_1_0</name><operator>)</operator> <operator>*</operator> <literal type="number">45.0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		atan2d			- returns the arctan of arg1/arg2 (degrees)
 */</comment>
<function><type><name>Datum</name></type>
<name>datan2d</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>float8</name></type> <name>atan2_arg1_arg2</name></decl>;</decl_stmt>

	<comment type="block">/* Per the POSIX spec, return NaN if either input is NaN */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_DEGREE_CONSTANTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * atan2d maps all inputs to values in the range [-180, 180], so the
	 * result should always be finite, even if the inputs are infinite.
	 *
	 * Note: this coding assumes that atan(1.0) is a suitable scaling constant
	 * to get an exact result from atan2().  This might well fail on us at
	 * some point, requiring us to decide exactly what inputs we think we're
	 * going to guarantee an exact result for.
	 */</comment>
	<expr_stmt><expr><name>atan2_arg1_arg2</name> <operator>=</operator> <call><name>atan2</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>atan2_arg1_arg2</name> <operator>/</operator> <name>atan_1_0</name><operator>)</operator> <operator>*</operator> <literal type="number">45.0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		sind_0_to_30	- returns the sine of an angle that lies between 0 and
 *						  30 degrees.  This will return exactly 0 when x is 0,
 *						  and exactly 0.5 when x is 30 degrees.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>sind_0_to_30</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>float8</name></type> <name>sin_x</name> <init>= <expr><call><name>sin</name><argument_list>(<argument><expr><name>x</name> <operator>*</operator> <name>RADIANS_PER_DEGREE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><name>sin_x</name> <operator>/</operator> <name>sin_30</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *		cosd_0_to_60	- returns the cosine of an angle that lies between 0
 *						  and 60 degrees.  This will return exactly 1 when x
 *						  is 0, and exactly 0.5 when x is 60 degrees.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>cosd_0_to_60</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>float8</name></type> <name>one_minus_cos_x</name> <init>= <expr><literal type="number">1.0</literal> <operator>-</operator> <call><name>cos</name><argument_list>(<argument><expr><name>x</name> <operator>*</operator> <name>RADIANS_PER_DEGREE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><literal type="number">1.0</literal> <operator>-</operator> <operator>(</operator><name>one_minus_cos_x</name> <operator>/</operator> <name>one_minus_cos_60</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *		sind_q1			- returns the sine of an angle in the first quadrant
 *						  (0 to 90 degrees).
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>sind_q1</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Stitch together the sine and cosine functions for the ranges [0, 30]
	 * and (30, 90].  These guarantee to return exact answers at their
	 * endpoints, so the overall result is a continuous monotonic function
	 * that gives exact results when x = 0, 30 and 90 degrees.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;=</operator> <literal type="number">30.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>sind_0_to_30</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>cosd_0_to_60</name><argument_list>(<argument><expr><literal type="number">90.0</literal> <operator>-</operator> <name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		cosd_q1			- returns the cosine of an angle in the first quadrant
 *						  (0 to 90 degrees).
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>cosd_q1</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Stitch together the sine and cosine functions for the ranges [0, 60]
	 * and (60, 90].  These guarantee to return exact answers at their
	 * endpoints, so the overall result is a continuous monotonic function
	 * that gives exact results when x = 0, 60 and 90 degrees.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;=</operator> <literal type="number">60.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>cosd_0_to_60</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>sind_0_to_30</name><argument_list>(<argument><expr><literal type="number">90.0</literal> <operator>-</operator> <name>x</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dcosd			- returns the cosine of arg1 (degrees)
 */</comment>
<function><type><name>Datum</name></type>
<name>dcosd</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Per the POSIX spec, return NaN if the input is NaN and throw an error
	 * if the input is infinite.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_DEGREE_CONSTANTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce the range of the input to [0,90] degrees */</comment>
	<expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>fmod</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">360.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cosd(-x) = cosd(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <operator>-</operator><name>arg1</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;</operator> <literal type="number">180.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cosd(360-x) = cosd(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <literal type="number">360.0</literal> <operator>-</operator> <name>arg1</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;</operator> <literal type="number">90.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cosd(180-x) = -cosd(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <literal type="number">180.0</literal> <operator>-</operator> <name>arg1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><name>sign</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>sign</name> <operator>*</operator> <call><name>cosd_q1</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dcotd			- returns the cotangent of arg1 (degrees)
 */</comment>
<function><type><name>Datum</name></type>
<name>dcotd</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>float8</name></type> <name>cot_arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Per the POSIX spec, return NaN if the input is NaN and throw an error
	 * if the input is infinite.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_DEGREE_CONSTANTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce the range of the input to [0,90] degrees */</comment>
	<expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>fmod</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">360.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cotd(-x) = -cotd(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <operator>-</operator><name>arg1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><name>sign</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;</operator> <literal type="number">180.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cotd(360-x) = -cotd(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <literal type="number">360.0</literal> <operator>-</operator> <name>arg1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><name>sign</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;</operator> <literal type="number">90.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cotd(180-x) = -cotd(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <literal type="number">180.0</literal> <operator>-</operator> <name>arg1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><name>sign</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>cot_arg1</name> <operator>=</operator> <call><name>cosd_q1</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>sind_q1</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>sign</name> <operator>*</operator> <operator>(</operator><name>cot_arg1</name> <operator>/</operator> <name>cot_45</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * On some machines we get cotd(270) = minus zero, but this isn't always
	 * true.  For portability, and because the user constituency for this
	 * function probably doesn't want minus zero, force it to plain zero.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* cotd(0) == Inf */</comment> , <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dsind			- returns the sine of arg1 (degrees)
 */</comment>
<function><type><name>Datum</name></type>
<name>dsind</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Per the POSIX spec, return NaN if the input is NaN and throw an error
	 * if the input is infinite.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_DEGREE_CONSTANTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce the range of the input to [0,90] degrees */</comment>
	<expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>fmod</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">360.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* sind(-x) = -sind(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <operator>-</operator><name>arg1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><name>sign</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;</operator> <literal type="number">180.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* sind(360-x) = -sind(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <literal type="number">360.0</literal> <operator>-</operator> <name>arg1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><name>sign</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;</operator> <literal type="number">90.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* sind(180-x) = sind(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <literal type="number">180.0</literal> <operator>-</operator> <name>arg1</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>sign</name> <operator>*</operator> <call><name>sind_q1</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dtand			- returns the tangent of arg1 (degrees)
 */</comment>
<function><type><name>Datum</name></type>
<name>dtand</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>float8</name></type> <name>tan_arg1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Per the POSIX spec, return NaN if the input is NaN and throw an error
	 * if the input is infinite.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_DEGREE_CONSTANTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reduce the range of the input to [0,90] degrees */</comment>
	<expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>fmod</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">360.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* tand(-x) = -tand(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <operator>-</operator><name>arg1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><name>sign</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;</operator> <literal type="number">180.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* tand(360-x) = -tand(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <literal type="number">360.0</literal> <operator>-</operator> <name>arg1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><name>sign</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>&gt;</operator> <literal type="number">90.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* tand(180-x) = -tand(x) */</comment>
		<expr_stmt><expr><name>arg1</name> <operator>=</operator> <literal type="number">180.0</literal> <operator>-</operator> <name>arg1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><name>sign</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tan_arg1</name> <operator>=</operator> <call><name>sind_q1</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>cosd_q1</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>sign</name> <operator>*</operator> <operator>(</operator><name>tan_arg1</name> <operator>/</operator> <name>tan_45</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * On some machines we get tand(180) = minus zero, but this isn't always
	 * true.  For portability, and because the user constituency for this
	 * function probably doesn't want minus zero, force it to plain zero.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* tand(90) == Inf */</comment> , <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		degrees		- returns degrees converted from radians
 */</comment>
<function><type><name>Datum</name></type>
<name>degrees</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>/</operator> <name>RADIANS_PER_DEGREE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		dpi				- returns the constant PI
 */</comment>
<function><type><name>Datum</name></type>
<name>dpi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>M_PI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		radians		- returns radians converted from degrees
 */</comment>
<function><type><name>Datum</name></type>
<name>radians</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>*</operator> <name>RADIANS_PER_DEGREE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		drandom		- returns a random number
 */</comment>
<function><type><name>Datum</name></type>
<name>drandom</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* result [0.0 - 1.0) */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <call><name>random</name><argument_list>()</argument_list></call> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>MAX_RANDOM_VALUE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		setseed		- set seed for the random number generator
 */</comment>
<function><type><name>Datum</name></type>
<name>setseed</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>seed</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>iseed</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>seed</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>seed</name></expr></argument> &gt;</argument_list></name> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"setseed parameter %f out of range [-1,1]"</literal></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>iseed</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>seed</name> <operator>*</operator> <name>MAX_RANDOM_VALUE</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>srandom</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>iseed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
 *		=========================
 *		FLOAT AGGREGATE OPERATORS
 *		=========================
 *
 *		float8_accum		- accumulate for AVG(), variance aggregates, etc.
 *		float4_accum		- same, but input data is float4
 *		float8_avg			- produce final result for float AVG()
 *		float8_var_samp		- produce final result for float VAR_SAMP()
 *		float8_var_pop		- produce final result for float VAR_POP()
 *		float8_stddev_samp	- produce final result for float STDDEV_SAMP()
 *		float8_stddev_pop	- produce final result for float STDDEV_POP()
 *
 * The transition datatype for all these aggregates is a 3-element array
 * of float8, holding the values N, sum(X), sum(X*X) in that order.
 *
 * Note that we represent N as a float to avoid having to build a special
 * datatype.  Given a reasonable floating-point implementation, there should
 * be no accuracy loss unless N exceeds 2 ^ 52 or so (by which time the
 * user will have doubtless lost interest anyway...)
 */</comment>

<function><type><specifier>static</specifier> <name>float8</name> <modifier>*</modifier></type>
<name>check_float8_array</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>transarray</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>caller</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We expect the input to be an N-element float array; verify that. We
	 * don't need to use deconstruct_array() since the array data is just
	 * going to look like a C array of N float8 values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <name>n</name> <operator>||</operator>
		<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>FLOAT8OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%s: expected %d-element float8 array"</literal></expr></argument>, <argument><expr><name>caller</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>float8</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * float8_combine
 *
 * An aggregate combine function used to combine two 3 fields
 * aggregate transition data into a single transition data.
 * This function is used only in two stage aggregation and
 * shouldn't be called outside aggregate context.
 */</comment>
<function><type><name>Datum</name></type>
<name>float8_combine</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray1</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray2</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>transvalues1</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray1</name></expr></argument>, <argument><expr><literal type="string">"float8_combine"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>transvalues2</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray2</name></expr></argument>, <argument><expr><literal type="string">"float8_combine"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>N</name> <operator>+=</operator> <name><name>transvalues2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>+=</operator> <name><name>transvalues2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>+=</operator> <name><name>transvalues2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>transvalues1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transvalues1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sumX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transvalues1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>sumX2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>transarray1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>newval</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_accum"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>N</name> <operator>+=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>+=</operator> <name>newval</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>+=</operator> <name>newval</name> <operator>*</operator> <name>newval</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're invoked as an aggregate, we can cheat and modify our first
	 * parameter in-place to reduce palloc overhead. Otherwise we construct a
	 * new array with the updated transition data and return it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sumX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>sumX2</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>transdatums</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>transdatums</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>,
								 <argument><expr><name>FLOAT8OID</name></expr></argument>,
								 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>FLOAT8PASSBYVAL</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float4_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* do computations as float8 */</comment>
	<decl_stmt><decl><type><name>float8</name></type>		<name>newval</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float4_accum"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>N</name> <operator>+=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>+=</operator> <name>newval</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>+=</operator> <name>newval</name> <operator>*</operator> <name>newval</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're invoked as an aggregate, we can cheat and modify our first
	 * parameter in-place to reduce palloc overhead. Otherwise we construct a
	 * new array with the updated transition data and return it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sumX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>sumX2</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>transdatums</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>transdatums</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>,
								 <argument><expr><name>FLOAT8OID</name></expr></argument>,
								 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>FLOAT8PASSBYVAL</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_avg</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_avg"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* ignore sumX2 */</comment>

	<comment type="block">/* SQL defines AVG of no values to be NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>sumX</name> <operator>/</operator> <name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_var_pop</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>,
				<decl><type ref="prev"/><name>numerator</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_var_pop"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Population variance is undefined when N is 0, so return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numerator</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumX2</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Watch out for roundoff error producing a negative numerator */</comment>
	<if_stmt><if>if <condition>(<expr><name>numerator</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>numerator</name> <operator>/</operator> <operator>(</operator><name>N</name> <operator>*</operator> <name>N</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_var_samp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>,
				<decl><type ref="prev"/><name>numerator</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_var_samp"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Sample variance is undefined when N is 0 or 1, so return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numerator</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumX2</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Watch out for roundoff error producing a negative numerator */</comment>
	<if_stmt><if>if <condition>(<expr><name>numerator</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>numerator</name> <operator>/</operator> <operator>(</operator><name>N</name> <operator>*</operator> <operator>(</operator><name>N</name> <operator>-</operator> <literal type="number">1.0</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_stddev_pop</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>,
				<decl><type ref="prev"/><name>numerator</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_stddev_pop"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Population stddev is undefined when N is 0, so return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numerator</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumX2</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Watch out for roundoff error producing a negative numerator */</comment>
	<if_stmt><if>if <condition>(<expr><name>numerator</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>sqrt</name><argument_list>(<argument><expr><name>numerator</name> <operator>/</operator> <operator>(</operator><name>N</name> <operator>*</operator> <name>N</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_stddev_samp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>,
				<decl><type ref="prev"/><name>numerator</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_stddev_samp"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Sample stddev is undefined when N is 0 or 1, so return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numerator</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumX2</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Watch out for roundoff error producing a negative numerator */</comment>
	<if_stmt><if>if <condition>(<expr><name>numerator</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>sqrt</name><argument_list>(<argument><expr><name>numerator</name> <operator>/</operator> <operator>(</operator><name>N</name> <operator>*</operator> <operator>(</operator><name>N</name> <operator>-</operator> <literal type="number">1.0</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		=========================
 *		SQL2003 BINARY AGGREGATES
 *		=========================
 *
 * The transition datatype for all these aggregates is a 6-element array of
 * float8, holding the values N, sum(X), sum(X*X), sum(Y), sum(Y*Y), sum(X*Y)
 * in that order.  Note that Y is the first argument to the aggregates!
 *
 * It might seem attractive to optimize this by having multiple accumulator
 * functions that only calculate the sums actually needed.  But on most
 * modern machines, a couple of extra floating-point multiplies will be
 * insignificant compared to the other per-tuple overhead, so I've chosen
 * to minimize code space instead.
 */</comment>

<function><type><name>Datum</name></type>
<name>float8_regr_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>newvalY</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>newvalX</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>,
				<decl><type ref="prev"/><name>sumY</name></decl>,
				<decl><type ref="prev"/><name>sumY2</name></decl>,
				<decl><type ref="prev"/><name>sumXY</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_regr_accum"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumXY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>N</name> <operator>+=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>+=</operator> <name>newvalX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>newvalX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>+=</operator> <name>newvalX</name> <operator>*</operator> <name>newvalX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>newvalX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>+=</operator> <name>newvalY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>newvalY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY2</name> <operator>+=</operator> <name>newvalY</name> <operator>*</operator> <name>newvalY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumY2</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>newvalY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumXY</name> <operator>+=</operator> <name>newvalX</name> <operator>*</operator> <name>newvalY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumXY</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>newvalX</name></expr></argument>)</argument_list></call> <operator>||</operator>
				  <call><name>isinf</name><argument_list>(<argument><expr><name>newvalY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're invoked as an aggregate, we can cheat and modify our first
	 * parameter in-place to reduce palloc overhead. Otherwise we construct a
	 * new array with the updated transition data and return it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sumX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>sumX2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>sumY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>sumY2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transvalues</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>sumXY</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>transdatums</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>sumY2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transdatums</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatumFast</name><argument_list>(<argument><expr><name>sumXY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>transdatums</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>,
								 <argument><expr><name>FLOAT8OID</name></expr></argument>,
								 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float8</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>FLOAT8PASSBYVAL</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * float8_regr_combine
 *
 * An aggregate combine function used to combine two 6 fields
 * aggregate transition data into a single transition data.
 * This function is used only in two stage aggregation and
 * shouldn't be called outside aggregate context.
 */</comment>
<function><type><name>Datum</name></type>
<name>float8_regr_combine</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray1</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray2</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>,
				<decl><type ref="prev"/><name>sumY</name></decl>,
				<decl><type ref="prev"/><name>sumY2</name></decl>,
				<decl><type ref="prev"/><name>sumXY</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"aggregate function called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>transvalues1</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray1</name></expr></argument>, <argument><expr><literal type="string">"float8_regr_combine"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>=</operator> <name><name>transvalues1</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY2</name> <operator>=</operator> <name><name>transvalues1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumXY</name> <operator>=</operator> <name><name>transvalues1</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>transvalues2</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray2</name></expr></argument>, <argument><expr><literal type="string">"float8_regr_combine"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>N</name> <operator>+=</operator> <name><name>transvalues2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>+=</operator> <name><name>transvalues2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>+=</operator> <name><name>transvalues2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>+=</operator> <name><name>transvalues2</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues1</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues2</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY2</name> <operator>+=</operator> <name><name>transvalues2</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumY2</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues2</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumXY</name> <operator>+=</operator> <name><name>transvalues2</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>sumXY</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues1</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>transvalues2</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>transvalues1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transvalues1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sumX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transvalues1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>sumX2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transvalues1</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>sumY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transvalues1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>sumY2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transvalues1</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>sumXY</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>transarray1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>float8_regr_sxx</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>,
				<decl><type ref="prev"/><name>numerator</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_regr_sxx"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* if N is 0 we should return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numerator</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumX2</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Watch out for roundoff error producing a negative numerator */</comment>
	<if_stmt><if>if <condition>(<expr><name>numerator</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>numerator</name> <operator>/</operator> <name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_regr_syy</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumY</name></decl>,
				<decl><type ref="prev"/><name>sumY2</name></decl>,
				<decl><type ref="prev"/><name>numerator</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_regr_syy"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* if N is 0 we should return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numerator</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumY2</name> <operator>-</operator> <name>sumY</name> <operator>*</operator> <name>sumY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumY2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Watch out for roundoff error producing a negative numerator */</comment>
	<if_stmt><if>if <condition>(<expr><name>numerator</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>numerator</name> <operator>/</operator> <name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_regr_sxy</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumY</name></decl>,
				<decl><type ref="prev"/><name>sumXY</name></decl>,
				<decl><type ref="prev"/><name>numerator</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_regr_sxy"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumXY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* if N is 0 we should return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numerator</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumXY</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumXY</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call> <operator>||</operator>
				  <call><name>isinf</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* A negative result is valid here */</comment>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>numerator</name> <operator>/</operator> <name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_regr_avgx</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_regr_avgx"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* if N is 0 we should return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>sumX</name> <operator>/</operator> <name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_regr_avgy</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumY</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_regr_avgy"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* if N is 0 we should return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>sumY</name> <operator>/</operator> <name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_covar_pop</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumY</name></decl>,
				<decl><type ref="prev"/><name>sumXY</name></decl>,
				<decl><type ref="prev"/><name>numerator</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_covar_pop"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumXY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* if N is 0 we should return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numerator</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumXY</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumXY</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call> <operator>||</operator>
				  <call><name>isinf</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>numerator</name> <operator>/</operator> <operator>(</operator><name>N</name> <operator>*</operator> <name>N</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_covar_samp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumY</name></decl>,
				<decl><type ref="prev"/><name>sumXY</name></decl>,
				<decl><type ref="prev"/><name>numerator</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_covar_samp"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumXY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* if N is &lt;= 1 we should return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;</operator> <literal type="number">2.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numerator</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumXY</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numerator</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumXY</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call> <operator>||</operator>
				  <call><name>isinf</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>numerator</name> <operator>/</operator> <operator>(</operator><name>N</name> <operator>*</operator> <operator>(</operator><name>N</name> <operator>-</operator> <literal type="number">1.0</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_corr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>,
				<decl><type ref="prev"/><name>sumY</name></decl>,
				<decl><type ref="prev"/><name>sumY2</name></decl>,
				<decl><type ref="prev"/><name>sumXY</name></decl>,
				<decl><type ref="prev"/><name>numeratorX</name></decl>,
				<decl><type ref="prev"/><name>numeratorY</name></decl>,
				<decl><type ref="prev"/><name>numeratorXY</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_corr"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumXY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* if N is 0 we should return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numeratorX</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumX2</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numeratorX</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numeratorY</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumY2</name> <operator>-</operator> <name>sumY</name> <operator>*</operator> <name>sumY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numeratorY</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumY2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numeratorXY</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumXY</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numeratorXY</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumXY</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call> <operator>||</operator>
				  <call><name>isinf</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numeratorX</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>numeratorY</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>numeratorXY</name> <operator>/</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>numeratorX</name> <operator>*</operator> <name>numeratorY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_regr_r2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>,
				<decl><type ref="prev"/><name>sumY</name></decl>,
				<decl><type ref="prev"/><name>sumY2</name></decl>,
				<decl><type ref="prev"/><name>sumXY</name></decl>,
				<decl><type ref="prev"/><name>numeratorX</name></decl>,
				<decl><type ref="prev"/><name>numeratorY</name></decl>,
				<decl><type ref="prev"/><name>numeratorXY</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_regr_r2"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumXY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* if N is 0 we should return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numeratorX</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumX2</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numeratorX</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numeratorY</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumY2</name> <operator>-</operator> <name>sumY</name> <operator>*</operator> <name>sumY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numeratorY</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumY2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numeratorXY</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumXY</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numeratorXY</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumXY</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call> <operator>||</operator>
				  <call><name>isinf</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numeratorX</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* per spec, horizontal line produces 1.0 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numeratorY</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>numeratorXY</name> <operator>*</operator> <name>numeratorXY</name><operator>)</operator> <operator>/</operator>
					 <operator>(</operator><name>numeratorX</name> <operator>*</operator> <name>numeratorY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_regr_slope</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>,
				<decl><type ref="prev"/><name>sumY</name></decl>,
				<decl><type ref="prev"/><name>sumXY</name></decl>,
				<decl><type ref="prev"/><name>numeratorX</name></decl>,
				<decl><type ref="prev"/><name>numeratorXY</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_regr_slope"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumXY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* if N is 0 we should return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numeratorX</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumX2</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numeratorX</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numeratorXY</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumXY</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numeratorXY</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumXY</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call> <operator>||</operator>
				  <call><name>isinf</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numeratorX</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>numeratorXY</name> <operator>/</operator> <name>numeratorX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float8_regr_intercept</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>transarray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name>	   <modifier>*</modifier></type><name>transvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>N</name></decl>,
				<decl><type ref="prev"/><name>sumX</name></decl>,
				<decl><type ref="prev"/><name>sumX2</name></decl>,
				<decl><type ref="prev"/><name>sumY</name></decl>,
				<decl><type ref="prev"/><name>sumXY</name></decl>,
				<decl><type ref="prev"/><name>numeratorX</name></decl>,
				<decl><type ref="prev"/><name>numeratorXXY</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>transvalues</name> <operator>=</operator> <call><name>check_float8_array</name><argument_list>(<argument><expr><name>transarray</name></expr></argument>, <argument><expr><literal type="string">"float8_regr_intercept"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>N</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumX2</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumXY</name> <operator>=</operator> <name><name>transvalues</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* if N is 0 we should return NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numeratorX</name> <operator>=</operator> <name>N</name> <operator>*</operator> <name>sumX2</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumX</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numeratorX</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numeratorXXY</name> <operator>=</operator> <name>sumY</name> <operator>*</operator> <name>sumX2</name> <operator>-</operator> <name>sumX</name> <operator>*</operator> <name>sumXY</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>numeratorXXY</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>sumY</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumX2</name></expr></argument>)</argument_list></call> <operator>||</operator>
				  <call><name>isinf</name><argument_list>(<argument><expr><name>sumX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>sumXY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numeratorX</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>numeratorXXY</name> <operator>/</operator> <name>numeratorX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		====================================
 *		MIXED-PRECISION ARITHMETIC OPERATORS
 *		====================================
 */</comment>

<comment type="block">/*
 *		float48pl		- returns arg1 + arg2
 *		float48mi		- returns arg1 - arg2
 *		float48mul		- returns arg1 * arg2
 *		float48div		- returns arg1 / arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>float48pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>+</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float48mi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>-</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float48mul</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>*</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>arg2</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float48div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg2</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>/</operator> <name>arg2</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float84pl		- returns arg1 + arg2
 *		float84mi		- returns arg1 - arg2
 *		float84mul		- returns arg1 * arg2
 *		float84div		- returns arg1 / arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>float84pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>+</operator> <name>arg2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float84mi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>-</operator> <name>arg2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float84mul</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>*</operator> <name>arg2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>arg2</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float84div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>arg2</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DIVISION_BY_ZERO</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg1</name> <operator>/</operator> <name>arg2</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		====================
 *		COMPARISON OPERATORS
 *		====================
 */</comment>

<comment type="block">/*
 *		float48{eq,ne,lt,le,gt,ge}		- float4/float8 comparison operations
 */</comment>
<function><type><name>Datum</name></type>
<name>float48eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float48ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float48lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float48le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float48gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float48ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float84{eq,ne,lt,le,gt,ge}		- float8/float4 comparison operations
 */</comment>
<function><type><name>Datum</name></type>
<name>float84eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float84ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float84lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float84le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float84gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float84ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>float8_cmp_internal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Implements the float8 version of the width_bucket() function
 * defined by SQL2003. See also width_bucket_numeric().
 *
 * 'bound1' and 'bound2' are the lower and upper bounds of the
 * histogram's range, respectively. 'count' is the number of buckets
 * in the histogram. width_bucket() returns an integer indicating the
 * bucket number that 'operand' belongs to in an equiwidth histogram
 * with the specified characteristics. An operand smaller than the
 * lower bound is assigned to bucket 0. An operand greater than the
 * upper bound is assigned to an additional bucket (with number
 * count+1). We don't allow "NaN" for any of the float8 inputs, and we
 * don't allow either of the histogram bounds to be +/- infinity.
 */</comment>
<function><type><name>Datum</name></type>
<name>width_bucket_float8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>operand</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>bound1</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>bound2</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>count</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"count must be greater than zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>operand</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>bound1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>bound2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operand, lower bound, and upper bound cannot be NaN"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Note that we allow "operand" to be infinite */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>bound1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>bound2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lower and upper bounds must be finite"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>bound1</name> <operator>&lt;</operator> <name>bound2</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>operand</name> <operator>&lt;</operator> <name>bound1</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>operand</name> <operator>&gt;=</operator> <name>bound2</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_add_s32_overflow</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float8</name><operator>)</operator> <name>count</name> <operator>*</operator> <operator>(</operator><name>operand</name> <operator>-</operator> <name>bound1</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>bound2</name> <operator>-</operator> <name>bound1</name><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>bound1</name> <operator>&gt;</operator> <name>bound2</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>operand</name> <operator>&gt;</operator> <name>bound1</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>operand</name> <operator>&lt;=</operator> <name>bound2</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_add_s32_overflow</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>float8</name><operator>)</operator> <name>count</name> <operator>*</operator> <operator>(</operator><name>bound1</name> <operator>-</operator> <name>operand</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>bound1</name> <operator>-</operator> <name>bound2</name><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lower bound cannot equal upper bound"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* keep the compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ========== PRIVATE ROUTINES ========== */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_CBRT</name></cpp:ifndef>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>cbrt</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>isneg</name> <init>= <expr><operator>(</operator><name>x</name> <operator>&lt;</operator> <literal type="number">0.0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>absx</name> <init>= <expr><call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>tmpres</name> <init>= <expr><call><name>pow</name><argument_list>(<argument><expr><name>absx</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <literal type="number">3.0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The result is somewhat inaccurate --- not really pow()'s fault, as the
	 * exponent it's handed contains roundoff error.  We can improve the
	 * accuracy by doing one iteration of Newton's formula.  Beware of zero
	 * input however.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tmpres</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tmpres</name> <operator>-=</operator> <operator>(</operator><name>tmpres</name> <operator>-</operator> <name>absx</name> <operator>/</operator> <operator>(</operator><name>tmpres</name> <operator>*</operator> <name>tmpres</name><operator>)</operator><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <literal type="number">3.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><ternary><condition><expr><name>isneg</name></expr> ?</condition><then> <expr><operator>-</operator><name>tmpres</name></expr> </then><else>: <expr><name>tmpres</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !HAVE_CBRT */</comment>
</unit>
