<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/adt/expandedrecord.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * expandedrecord.c
 *	  Functions for manipulating composite expanded objects.
 *
 * This module supports "expanded objects" (cf. expandeddatum.h) that can
 * store values of named composite types, domains over named composite types,
 * and record types (registered or anonymous).
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/expandedrecord.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/expandedrecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/* "Methods" required for an expanded object */</comment>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>ER_get_flat_size</name><parameter_list>(<parameter><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eohptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ER_flatten_into</name><parameter_list>(<parameter><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eohptr</name></decl></parameter>,
				<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>allocated_size</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ExpandedObjectMethods</name></type> <name>ER_methods</name> <init>=
<expr><block>{
	<expr><name>ER_get_flat_size</name></expr>,
	<expr><name>ER_flatten_into</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Other local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ER_mc_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>get_short_term_cxt</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_dummy_expanded_header</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>main_erh</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pg_noinline</name> <name>void</name></type> <name>check_domain_for_new_field</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>fnumber</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name></type> <name>newValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pg_noinline</name> <name>void</name></type> <name>check_domain_for_new_tuple</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>,
						   <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Build an expanded record of the specified composite type
 *
 * type_id can be RECORDOID, but only if a positive typmod is given.
 *
 * The expanded record is initially "empty", having a state logically
 * equivalent to a NULL composite value (not ROW(NULL, NULL, ...)).
 * Note that this might not be a valid state for a domain type;
 * if the caller needs to check that, call
 * expanded_record_set_tuple(erh, NULL, false, false).
 *
 * The expanded object will be a child of parentcontext.
 */</comment>
<function><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type>
<name>make_expanded_record_from_typeid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type_id</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
								 <parameter><decl><type><name>MemoryContext</name></type> <name>parentcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>tupdesc_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>objcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>type_id</name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Consult the typcache to see if it's a domain over composite, and in
		 * any case to get the tupdesc and tupdesc identifier.
		 */</comment>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>,
									 <argument><expr><name>TYPECACHE_TUPDESC</name> <operator>|</operator>
									 <name>TYPECACHE_DOMAIN_BASE_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ER_FLAG_IS_DOMAIN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseType</name></name></expr></argument>,
										 <argument><expr><name>TYPECACHE_TUPDESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not composite"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc_id</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>tupDesc_identifier</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For RECORD types, get the tupdesc and identifier from typcache.
		 */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc_id</name> <operator>=</operator> <call><name>assign_record_type_identifier</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Allocate private context for expanded object.  We use a regular-size
	 * context, not a small one, to improve the odds that we can fit a tupdesc
	 * into it without needing an extra malloc block.  (This code path doesn't
	 * ever need to copy a tupdesc into the expanded record, but let's be
	 * consistent with the other ways of making an expanded record.)
	 */</comment>
	<expr_stmt><expr><name>objcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>parentcontext</name></expr></argument>,
								   <argument><expr><literal type="string">"expanded record"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we already know the number of fields in the tupdesc, we can
	 * allocate the dvalues/dnulls arrays along with the record header.  This
	 * is useless if we never need those arrays, but it costs almost nothing,
	 * and it will save a palloc cycle if we do need them.
	 */</comment>
	<expr_stmt><expr><name>erh</name> <operator>=</operator> <operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
						   <operator>+</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure all header fields are initialized to 0/null */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>erh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EOH_init_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ER_methods</name></expr></argument>, <argument><expr><name>objcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>=</operator> <name>ER_MAGIC</name></expr>;</expr_stmt>

	<comment type="block">/* Set up dvalues/dnulls, with no valid contents as yet */</comment>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>erh</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name>chunk</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>chunk</name> <operator>+</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<comment type="block">/* Fill in composite-type identification info */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_decltypeid</name></name> <operator>=</operator> <name>type_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name> <operator>=</operator> <name>tupdesc_id</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If what we got from the typcache is a refcounted tupdesc, we need to
	 * acquire our own refcount on it.  We manage the refcount with a memory
	 * context callback rather than assuming that the CurrentResourceOwner is
	 * longer-lived than this expanded object.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Register callback to release the refcount */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>ER_mc_callback</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>erh</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextRegisterResetCallback</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And save the pointer */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* If we called lookup_rowtype_tupdesc, release the pin it took */</comment>
		<if_stmt><if>if <condition>(<expr><name>type_id</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it's not refcounted, just assume it will outlive the expanded
		 * object.  (This can happen for shared record types, for instance.)
		 */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the
	 * record remains logically empty.
	 */</comment>

	<return>return <expr><name>erh</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build an expanded record of the rowtype defined by the tupdesc
 *
 * The tupdesc is copied if necessary (i.e., if we can't just bump its
 * reference count instead).
 *
 * The expanded record is initially "empty", having a state logically
 * equivalent to a NULL composite value (not ROW(NULL, NULL, ...)).
 *
 * The expanded object will be a child of parentcontext.
 */</comment>
<function><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type>
<name>make_expanded_record_from_tupdesc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
								  <parameter><decl><type><name>MemoryContext</name></type> <name>parentcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>tupdesc_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>objcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If it's a named composite type (not RECORD), we prefer to reference
		 * the typcache's copy of the tupdesc, which is guaranteed to be
		 * refcounted (the given tupdesc might not be).  In any case, we need
		 * to consult the typcache to get the correct tupdesc identifier.
		 *
		 * Note that tdtypeid couldn't be a domain type, so we need not
		 * consider that case here.
		 */</comment>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>, <argument><expr><name>TYPECACHE_TUPDESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not composite"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc_id</name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>tupDesc_identifier</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For RECORD types, get the appropriate unique identifier (possibly
		 * freshly assigned).
		 */</comment>
		<expr_stmt><expr><name>tupdesc_id</name> <operator>=</operator> <call><name>assign_record_type_identifier</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>,
												   <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Allocate private context for expanded object.  We use a regular-size
	 * context, not a small one, to improve the odds that we can fit a tupdesc
	 * into it without needing an extra malloc block.
	 */</comment>
	<expr_stmt><expr><name>objcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>parentcontext</name></expr></argument>,
								   <argument><expr><literal type="string">"expanded record"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we already know the number of fields in the tupdesc, we can
	 * allocate the dvalues/dnulls arrays along with the record header.  This
	 * is useless if we never need those arrays, but it costs almost nothing,
	 * and it will save a palloc cycle if we do need them.
	 */</comment>
	<expr_stmt><expr><name>erh</name> <operator>=</operator> <operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
						   <operator>+</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure all header fields are initialized to 0/null */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>erh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EOH_init_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ER_methods</name></expr></argument>, <argument><expr><name>objcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>=</operator> <name>ER_MAGIC</name></expr>;</expr_stmt>

	<comment type="block">/* Set up dvalues/dnulls, with no valid contents as yet */</comment>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>erh</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name>chunk</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>chunk</name> <operator>+</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<comment type="block">/* Fill in composite-type identification info */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_decltypeid</name></name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name> <operator>=</operator> <name>tupdesc_id</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy tupdesc if needed, but we prefer to bump its refcount if possible.
	 * We manage the refcount with a memory context callback rather than
	 * assuming that the CurrentResourceOwner is longer-lived than this
	 * expanded object.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Register callback to release the refcount */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>ER_mc_callback</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>erh</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextRegisterResetCallback</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And save the pointer */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Just copy it */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_TUPDESC_ALLOCED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the
	 * record remains logically empty.
	 */</comment>

	<return>return <expr><name>erh</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build an expanded record of the same rowtype as the given expanded record
 *
 * This is faster than either of the above routines because we can bypass
 * typcache lookup(s).
 *
 * The expanded record is initially "empty" --- we do not copy whatever
 * tuple might be in the source expanded record.
 *
 * The expanded object will be a child of parentcontext.
 */</comment>
<function><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type>
<name>make_expanded_record_from_exprecord</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>olderh</name></decl></parameter>,
									<parameter><decl><type><name>MemoryContext</name></type> <name>parentcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>olderh</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>objcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate private context for expanded object.  We use a regular-size
	 * context, not a small one, to improve the odds that we can fit a tupdesc
	 * into it without needing an extra malloc block.
	 */</comment>
	<expr_stmt><expr><name>objcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>parentcontext</name></expr></argument>,
								   <argument><expr><literal type="string">"expanded record"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we already know the number of fields in the tupdesc, we can
	 * allocate the dvalues/dnulls arrays along with the record header.  This
	 * is useless if we never need those arrays, but it costs almost nothing,
	 * and it will save a palloc cycle if we do need them.
	 */</comment>
	<expr_stmt><expr><name>erh</name> <operator>=</operator> <operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>, <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
						   <operator>+</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure all header fields are initialized to 0/null */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>erh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EOH_init_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ER_methods</name></expr></argument>, <argument><expr><name>objcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>=</operator> <name>ER_MAGIC</name></expr>;</expr_stmt>

	<comment type="block">/* Set up dvalues/dnulls, with no valid contents as yet */</comment>
	<expr_stmt><expr><name>chunk</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>erh</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name>chunk</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>chunk</name> <operator>+</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

	<comment type="block">/* Fill in composite-type identification info */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_decltypeid</name></name> <operator>=</operator> <name><name>olderh</name><operator>-&gt;</operator><name>er_decltypeid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name> <operator>=</operator> <name><name>olderh</name><operator>-&gt;</operator><name>er_typeid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name> <operator>=</operator> <name><name>olderh</name><operator>-&gt;</operator><name>er_typmod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name> <operator>=</operator> <name><name>olderh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr>;</expr_stmt>

	<comment type="block">/* The only flag bit that transfers over is IS_DOMAIN */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>olderh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_IS_DOMAIN</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy tupdesc if needed, but we prefer to bump its refcount if possible.
	 * We manage the refcount with a memory context callback rather than
	 * assuming that the CurrentResourceOwner is longer-lived than this
	 * expanded object.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Register callback to release the refcount */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>ER_mc_callback</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>erh</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextRegisterResetCallback</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And save the pointer */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>olderh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_TUPDESC_ALLOCED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We need to make our own copy of the tupdesc */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_TUPDESC_ALLOCED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Assume the tupdesc will outlive this expanded object, just like
		 * we're assuming it will outlive the source object.
		 */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the
	 * record remains logically empty.
	 */</comment>

	<return>return <expr><name>erh</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert given tuple as the value of the expanded record
 *
 * It is caller's responsibility that the tuple matches the record's
 * previously-assigned rowtype.  (However domain constraints, if any,
 * will be checked here.)
 *
 * The tuple is physically copied into the expanded record's local storage
 * if "copy" is true, otherwise it's caller's responsibility that the tuple
 * will live as long as the expanded record does.
 *
 * Out-of-line field values in the tuple are automatically inlined if
 * "expand_external" is true, otherwise not.  (The combination copy = false,
 * expand_external = true is not sensible and not supported.)
 *
 * Alternatively, tuple can be NULL, in which case we just set the expanded
 * record to be empty.
 */</comment>
<function><type><name>void</name></type>
<name>expanded_record_set_tuple</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>,
						  <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>copy</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>expand_external</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldflags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldfstartptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldfendptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newflags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Shouldn't ever be trying to assign new data to a dummy header */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_IS_DUMMY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before performing the assignment, see if result will satisfy domain.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_IS_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_domain_for_new_tuple</name><argument_list>(<argument><expr><name>erh</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we need to get rid of out-of-line field values, do so, using the
	 * short-term context to avoid leaking whatever cruft the toast fetch
	 * might generate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>expand_external</name> <operator>&amp;&amp;</operator> <name>tuple</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Assert caller didn't ask for unsupported case */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_short_term_cxt</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>toast_flatten_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>expand_external</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* need not clean up below */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize new flags, keeping only non-data status bits.
	 */</comment>
	<expr_stmt><expr><name>oldflags</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newflags</name> <operator>=</operator> <name>oldflags</name> <operator>&amp;</operator> <name>ER_FLAGS_NON_DATA</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy tuple into local storage if needed.  We must be sure this succeeds
	 * before we start to modify the expanded record's state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&amp;&amp;</operator> <name>tuple</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newflags</name> <operator>|=</operator> <name>ER_FLAG_FVALUE_ALLOCED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We can now flush anything that detoasting might have leaked. */</comment>
		<if_stmt><if>if <condition>(<expr><name>expand_external</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Make copies of fields we're about to overwrite */</comment>
	<expr_stmt><expr><name>oldtuple</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>fvalue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldfstartptr</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>fstartptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldfendptr</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>fendptr</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's now safe to update the expanded record's state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newtuple</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Save flat representation */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name></name> <operator>=</operator> <name>newtuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>fstartptr</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>newtuple</name><operator>-&gt;</operator><name>t_data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>fendptr</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>newtuple</name><operator>-&gt;</operator><name>t_data</name></name><operator>)</operator> <operator>+</operator> <name><name>newtuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newflags</name> <operator>|=</operator> <name>ER_FLAG_FVALUE_VALID</name></expr>;</expr_stmt>

		<comment type="block">/* Remember if we have any out-of-line field values */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newflags</name> <operator>|=</operator> <name>ER_FLAG_HAVE_EXTERNAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>fstartptr</name></name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>fendptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>newflags</name></expr>;</expr_stmt>

	<comment type="block">/* Reset flat-size info; we don't bother to make it valid now */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flat_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now, release any storage belonging to old field values.  It's safe to
	 * do this because ER_FLAG_DVALUES_VALID is no longer set in erh-&gt;flags;
	 * even if we fail partway through, the record is valid, and at worst
	 * we've failed to reclaim some space.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldflags</name> <operator>&amp;</operator> <name>ER_FLAG_DVALUES_ALLOCED</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><operator>(</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attbyval</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldValue</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>oldValue</name> <operator>&lt;</operator> <name>oldfstartptr</name> <operator>||</operator> <name>oldValue</name> <operator>&gt;=</operator> <name>oldfendptr</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Likewise free the old tuple, if it was locally allocated */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldflags</name> <operator>&amp;</operator> <name>ER_FLAG_FVALUE_ALLOCED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>oldtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We won't make a new deconstructed representation until/unless needed */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * make_expanded_record_from_datum: build expanded record from composite Datum
 *
 * This combines the functions of make_expanded_record_from_typeid and
 * expanded_record_set_tuple.  However, we do not force a lookup of the
 * tupdesc immediately, reasoning that it might never be needed.
 *
 * The expanded object will be a child of parentcontext.
 *
 * Note: a composite datum cannot self-identify as being of a domain type,
 * so we need not consider domain cases here.
 */</comment>
<function><type><name>Datum</name></type>
<name>make_expanded_record_from_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>recorddatum</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>parentcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tuphdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>objcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate private context for expanded object.  We use a regular-size
	 * context, not a small one, to improve the odds that we can fit a tupdesc
	 * into it without needing an extra malloc block.
	 */</comment>
	<expr_stmt><expr><name>objcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>parentcontext</name></expr></argument>,
								   <argument><expr><literal type="string">"expanded record"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up expanded record header, initializing fields to 0/null */</comment>
	<expr_stmt><expr><name>erh</name> <operator>=</operator> <operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EOH_init_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ER_methods</name></expr></argument>, <argument><expr><name>objcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>=</operator> <name>ER_MAGIC</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Detoast and copy source record into private context, as a HeapTuple.
	 * (If we actually have to detoast the source, we'll leak some memory in
	 * the caller's context, but it doesn't seem worth worrying about.)
	 */</comment>
	<expr_stmt><expr><name>tuphdr</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>recorddatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tmptup</name><operator>.</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_tableOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>tuphdr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>objcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmptup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_FVALUE_ALLOCED</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill in composite-type identification info */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_decltypeid</name></name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remember we have a flat representation */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name></name> <operator>=</operator> <name>newtuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>fstartptr</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>newtuple</name><operator>-&gt;</operator><name>t_data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>fendptr</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>newtuple</name><operator>-&gt;</operator><name>t_data</name></name><operator>)</operator> <operator>+</operator> <name><name>newtuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_FVALUE_VALID</name></expr>;</expr_stmt>

	<comment type="block">/* Shouldn't need to set ER_FLAG_HAVE_EXTERNAL */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>HeapTupleHeaderHasExternal</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We won't look up the tupdesc till we have to, nor make a deconstructed
	 * representation.  We don't have enough info to fill flat_size and
	 * friends, either.
	 */</comment>

	<comment type="block">/* return a R/W pointer to the expanded record */</comment>
	<return>return <expr><call><name>EOHPGetRWDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_flat_size method for expanded records
 *
 * Note: call this in a reasonably short-lived memory context, in case of
 * memory leaks from activities such as detoasting.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>ER_get_flat_size</name><parameter_list>(<parameter><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eohptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name> <init>= <expr><operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator> <name>eohptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>data_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>==</operator> <name>ER_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The flat representation has to be a valid composite datum.  Make sure
	 * that we have a registered, not anonymous, RECORD type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator>
		<name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assign_record_type_typmod</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have a valid flattened value without out-of-line fields, we can
	 * just use it as-is.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_FVALUE_VALID</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_HAVE_EXTERNAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If we have a cached size value, believe that */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>flat_size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>erh</name><operator>-&gt;</operator><name>flat_size</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If we haven't yet deconstructed the tuple, do that */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_DVALUES_VALID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deconstruct_expanded_record</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Tuple descriptor must be valid by now */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Composite datums mustn't contain any out-of-line values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_HAVE_EXTERNAL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>&amp;&amp;</operator> <name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * expanded_record_set_field_internal can do the actual work
				 * of detoasting.  It needn't recheck domain constraints.
				 */</comment>
				<expr_stmt><expr><call><name>expanded_record_set_field_internal</name><argument_list>(<argument><expr><name>erh</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
												   <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												   <argument><expr><name>true</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * We have now removed all external field values, so we can clear the
		 * flag about them.  This won't cause ER_flatten_into() to mistakenly
		 * take the fast path, since expanded_record_set_field() will have
		 * cleared ER_FLAG_FVALUE_VALID.
		 */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ER_FLAG_HAVE_EXTERNAL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Test if we currently have any null values */</comment>
	<expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Determine total space needed */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>HeapTupleHeaderData</name></expr></argument>, <argument><expr><name>t_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>BITMAPLEN</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hoff</name> <operator>=</operator> <name>len</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* align user data safely */</comment>

	<expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>data_len</name></expr>;</expr_stmt>

	<comment type="block">/* Cache for next time */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flat_size</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>data_len</name></name> <operator>=</operator> <name>data_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>hoff</name></name> <operator>=</operator> <name>hoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>hasnull</name></name> <operator>=</operator> <name>hasnull</name></expr>;</expr_stmt>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * flatten_into method for expanded records
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ER_flatten_into</name><parameter_list>(<parameter><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eohptr</name></decl></parameter>,
				<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>allocated_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name> <init>= <expr><operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator> <name>eohptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>tuphdr</name> <init>= <expr><operator>(</operator><name>HeapTupleHeader</name><operator>)</operator> <name>result</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>==</operator> <name>ER_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Easy if we have a valid flattened value without out-of-line fields */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_FVALUE_VALID</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_HAVE_EXTERNAL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allocated_size</name> <operator>==</operator> <name><name>erh</name><operator>-&gt;</operator><name>fvalue</name><operator>-&gt;</operator><name>t_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>, <argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* The original flattened value might not have datum header fields */</comment>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else allocation should match previous get_flat_size result */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allocated_size</name> <operator>==</operator> <name><name>erh</name><operator>-&gt;</operator><name>flat_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We'll need the tuple descriptor */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We must ensure that any pad space is zero-filled */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up header fields of composite Datum */</comment>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetDatumLength</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name>allocated_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetTypeId</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>HeapTupleHeaderSetTypMod</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We also make sure that t_ctid is invalid unless explicitly set */</comment>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuphdr</name><operator>-&gt;</operator><name>t_ctid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>HeapTupleHeaderSetNatts</name><argument_list>(<argument><expr><name>tuphdr</name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>t_hoff</name></name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>hoff</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* else leave infomask = 0 */</comment>
		<expr_stmt><expr><name><name>tuphdr</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>=</operator> <name>HEAP_HASOID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And fill the data area from dvalues/dnulls */</comment>
	<expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
					<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>,
					<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuphdr</name> <operator>+</operator> <name><name>erh</name><operator>-&gt;</operator><name>hoff</name></name></expr></argument>,
					<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>data_len</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>tuphdr</name><operator>-&gt;</operator><name>t_infomask</name></name></expr></argument>,
					<argument><expr><operator>(</operator><ternary><condition><expr><name><name>erh</name><operator>-&gt;</operator><name>hasnull</name></name></expr> ?</condition><then> <expr><name><name>tuphdr</name><operator>-&gt;</operator><name>t_bits</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Look up the tupdesc for the expanded record's actual type
 *
 * Note: code internal to this module is allowed to just fetch
 * erh-&gt;er_tupdesc if ER_FLAG_DVALUES_VALID is set; otherwise it should call
 * expanded_record_get_tupdesc.  This function is the out-of-line portion
 * of expanded_record_get_tupdesc.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>expanded_record_fetch_tupdesc</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

	<comment type="block">/* Easy if we already have it (but caller should have checked already) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Lookup the composite type's tupdesc using the typcache */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a refcounted tupdesc rather than a statically allocated one, we
	 * want to manage the refcount with a memory context callback rather than
	 * assuming that the CurrentResourceOwner is longer-lived than this
	 * expanded object.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Register callback if we didn't already */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name><operator>.</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>ER_mc_callback</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>erh</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextRegisterResetCallback</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>er_mcb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Remember our own pointer */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Release the pin lookup_rowtype_tupdesc acquired */</comment>
		<expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Just remember the pointer */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* In either case, fetch the process-global ID for this tupdesc */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name> <operator>=</operator> <call><name>assign_record_type_identifier</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>,
													   <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tupdesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get a HeapTuple representing the current value of the expanded record
 *
 * If valid, the originally stored tuple is returned, so caller must not
 * scribble on it.  Otherwise, we return a HeapTuple created in the current
 * memory context.  In either case, no attempt has been made to inline
 * out-of-line toasted values, so the tuple isn't usable as a composite
 * datum.
 *
 * Returns NULL if expanded record is empty.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>expanded_record_get_tuple</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Easy case if we still have original tuple */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_FVALUE_VALID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else just build a tuple from datums */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_DVALUES_VALID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Expanded record is empty */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Memory context reset callback for cleaning up external resources
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ER_mc_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name> <init>= <expr><operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Release our privately-managed tupdesc refcount, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupdesc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* just for luck */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>tupdesc</name><operator>-&gt;</operator><name>tdrefcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DatumGetExpandedRecord: get a writable expanded record from an input argument
 *
 * Caution: if the input is a read/write pointer, this returns the input
 * argument; so callers must be sure that their changes are "safe", that is
 * they cannot leave the record in a corrupt state.
 */</comment>
<function><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type>
<name>DatumGetExpandedRecord</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If it's a writable expanded record already, just return it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL_EXPANDED_RW</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name> <init>= <expr><operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>==</operator> <name>ER_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>erh</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else expand the hard way */</comment>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>make_expanded_record_from_datum</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create the Datum/isnull representation of an expanded record object
 * if we didn't do so already.  After calling this, it's OK to read the
 * dvalues/dnulls arrays directly, rather than going through get_field.
 *
 * Note that if the object is currently empty ("null"), this will change
 * it to represent a row of nulls.
 */</comment>
<function><type><name>void</name></type>
<name>deconstruct_expanded_record</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>dnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfields</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_DVALUES_VALID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* already valid, nothing to do */</comment>

	<comment type="block">/* We'll need the tuple descriptor */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate arrays in private context, if we don't have them already.  We
	 * don't expect to see a change in nfields here, so while we cope if it
	 * happens, we don't bother avoiding a leak of the old arrays (which might
	 * not be separately palloc'd, anyway).
	 */</comment>
	<expr_stmt><expr><name>nfields</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>!=</operator> <name>nfields</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * To save a palloc cycle, we allocate both the Datum and isnull
		 * arrays in one palloc chunk.
		 */</comment>
		<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>,
								   <argument><expr><name>nfields</name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name>chunk</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dnulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>chunk</name> <operator>+</operator> <name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <name>dvalues</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <name>dnulls</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>=</operator> <name>nfields</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>dvalues</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dnulls</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_FVALUE_VALID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Deconstruct tuple */</comment>
		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>dvalues</name></expr></argument>, <argument><expr><name>dnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If record was empty, instantiate it as a row of nulls */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dvalues</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dnulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>nfields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Mark the dvalues as valid */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_DVALUES_VALID</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Look up a record field by name
 *
 * If there is a field named "fieldname", fill in the contents of finfo
 * and return "true".  Else return "false" without changing *finfo.
 */</comment>
<function><type><name>bool</name></type>
<name>expanded_record_lookup_field</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fieldname</name></decl></parameter>,
							 <parameter><decl><type><name>ExpandedRecordFieldInfo</name> <modifier>*</modifier></type><name>finfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First, check user-defined attributes */</comment>
	<for>for <control>(<init><expr><name>fno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fno</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>fno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><name>fieldname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fnumber</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>ftypeid</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>ftypmod</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fcollation</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* How about system attributes? */</comment>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>SystemAttributeByName</name><argument_list>(<argument><expr><name>fieldname</name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fnumber</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>ftypeid</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>ftypmod</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>finfo</name><operator>-&gt;</operator><name>fcollation</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch value of record field
 *
 * expanded_record_get_field is the frontend for this; it handles the
 * easy inline-able cases.
 */</comment>
<function><type><name>Datum</name></type>
<name>expanded_record_fetch_field</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fnumber</name></decl></parameter>,
							<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>fnumber</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Empty record has null fields */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ExpandedRecordIsEmpty</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Make sure we have deconstructed form */</comment>
		<expr_stmt><expr><call><name>deconstruct_expanded_record</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Out-of-range field number reads as null */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>fnumber</name> <operator>&gt;</operator> <name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>dnulls</name><index>[<expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<return>return <expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name><index>[<expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* System columns read as null if we haven't got flat tuple */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* heap_getsysattr doesn't actually use tupdesc, so just pass null */</comment>
		<return>return <expr><call><name>heap_getsysattr</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name></name></expr></argument>, <argument><expr><name>fnumber</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set value of record field
 *
 * If the expanded record is of domain type, the assignment will be rejected
 * (without changing the record's state) if the domain's constraints would
 * be violated.
 *
 * If expand_external is true and newValue is an out-of-line value, we'll
 * forcibly detoast it so that the record does not depend on external storage.
 *
 * Internal callers can pass check_constraints = false to skip application
 * of domain constraints.  External callers should never do that.
 */</comment>
<function><type><name>void</name></type>
<name>expanded_record_set_field_internal</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fnumber</name></decl></parameter>,
								   <parameter><decl><type><name>Datum</name></type> <name>newValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>expand_external</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>check_constraints</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>dnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldValue</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Shouldn't ever be trying to assign new data to a dummy header, except
	 * in the case of an internal call for field inlining.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_IS_DUMMY</name><operator>)</operator> <operator>||</operator> <operator>!</operator><name>check_constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Before performing the assignment, see if result will satisfy domain */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_IS_DOMAIN</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>check_constraints</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_domain_for_new_field</name><argument_list>(<argument><expr><name>erh</name></expr></argument>, <argument><expr><name>fnumber</name></expr></argument>, <argument><expr><name>newValue</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If we haven't yet deconstructed the tuple, do that */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_DVALUES_VALID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deconstruct_expanded_record</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Tuple descriptor must be valid by now */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>==</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Caller error if fnumber is system column or nonexistent column */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>fnumber</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fnumber</name> <operator>&gt;</operator> <name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign to field %d of expanded record"</literal></expr></argument>, <argument><expr><name>fnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Copy new field value into record's context, and deal with detoasting,
	 * if needed.
	 */</comment>
	<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<comment type="block">/* If requested, detoast any external value */</comment>
		<if_stmt><if>if <condition>(<expr><name>expand_external</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Detoasting should be done in short-lived context. */</comment>
				<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_short_term_cxt</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>newValue</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>heap_tuple_fetch_attr</name><argument_list>(<argument><expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>expand_external</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* need not clean up below */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Copy value into record's context */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newValue</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We can now flush anything that detoasting might have leaked */</comment>
		<if_stmt><if>if <condition>(<expr><name>expand_external</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Remember that we have field(s) that may need to be pfree'd */</comment>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_DVALUES_ALLOCED</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * While we're here, note whether it's an external toasted value,
		 * because that could mean we need to inline it later.  (Think not to
		 * merge this into the previous expand_external logic: datumCopy could
		 * by itself have made the value non-external.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_HAVE_EXTERNAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We're ready to make irreversible changes.
	 */</comment>
	<expr_stmt><expr><name>dvalues</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dnulls</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name></expr>;</expr_stmt>

	<comment type="block">/* Flattened value will no longer represent record accurately */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ER_FLAG_FVALUE_VALID</name></expr>;</expr_stmt>
	<comment type="block">/* And we don't know the flattened size either */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flat_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Grab old field value for pfree'ing, if needed. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dnulls</name><index>[<expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldValue</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>dvalues</name><index>[<expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldValue</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* And finally we can insert the new field. */</comment>
	<expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dnulls</name><index>[<expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free old field if needed; this keeps repeated field replacements from
	 * bloating the record's storage.  If the pfree somehow fails, it won't
	 * corrupt the record.
	 *
	 * If we're updating a dummy header, we can't risk pfree'ing the old
	 * value, because most likely the expanded record's main header still has
	 * a pointer to it.  This won't result in any sustained memory leak, since
	 * whatever we just allocated here is in the short-lived domain check
	 * context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldValue</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_IS_DUMMY</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Don't try to pfree a part of the original flat record */</comment>
		<if_stmt><if>if <condition>(<expr><name>oldValue</name> <operator>&lt;</operator> <name><name>erh</name><operator>-&gt;</operator><name>fstartptr</name></name> <operator>||</operator> <name>oldValue</name> <operator>&gt;=</operator> <name><name>erh</name><operator>-&gt;</operator><name>fendptr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set all record field(s)
 *
 * Caller must ensure that the provided datums are of the right types
 * to match the record's previously assigned rowtype.
 *
 * If expand_external is true, we'll forcibly detoast out-of-line field values
 * so that the record does not depend on external storage.
 *
 * Unlike repeated application of expanded_record_set_field(), this does not
 * guarantee to leave the expanded record in a non-corrupt state in event
 * of an error.  Typically it would only be used for initializing a new
 * expanded record.  Also, because we expect this to be applied at most once
 * in the lifespan of an expanded record, we do not worry about any cruft
 * that detoasting might leak.
 */</comment>
<function><type><name>void</name></type>
<name>expanded_record_set_fields</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>Datum</name> <modifier>*</modifier></type><name>newValues</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name> <modifier>*</modifier></type><name>isnulls</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>expand_external</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>dvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>dnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fnumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Shouldn't ever be trying to assign new data to a dummy header */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_IS_DUMMY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we haven't yet deconstructed the tuple, do that */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_DVALUES_VALID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deconstruct_expanded_record</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Tuple descriptor must be valid by now */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>==</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Flattened value will no longer represent record accurately */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ER_FLAG_FVALUE_VALID</name></expr>;</expr_stmt>
	<comment type="block">/* And we don't know the flattened size either */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flat_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dvalues</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dnulls</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>fnumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fnumber</name> <operator>&lt;</operator> <name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name></expr>;</condition> <incr><expr><name>fnumber</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fnumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>newValue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>newValue</name> <operator>=</operator> <name><name>newValues</name><index>[<expr><name>fnumber</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name><name>isnulls</name><index>[<expr><name>fnumber</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Copy new field value into record's context, and deal with
			 * detoasting, if needed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Is it an external toasted value? */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
					<call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>expand_external</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Detoast as requested while copying the value */</comment>
						<expr_stmt><expr><name>newValue</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>heap_tuple_fetch_attr</name><argument_list>(<argument><expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Just copy the value */</comment>
						<expr_stmt><expr><name>newValue</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* If it's still external, remember that */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_HAVE_EXTERNAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Not an external value, just copy it */</comment>
					<expr_stmt><expr><name>newValue</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* Remember that we have field(s) that need to be pfree'd */</comment>
				<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_DVALUES_ALLOCED</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Free old field value, if any (not likely, since really we ought
			 * to be inserting into an empty record).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><name><name>dnulls</name><index>[<expr><name>fnumber</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldValue</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>oldValue</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>dvalues</name><index>[<expr><name>fnumber</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Don't try to pfree a part of the original flat record */</comment>
				<if_stmt><if>if <condition>(<expr><name>oldValue</name> <operator>&lt;</operator> <name><name>erh</name><operator>-&gt;</operator><name>fstartptr</name></name> <operator>||</operator> <name>oldValue</name> <operator>&gt;=</operator> <name><name>erh</name><operator>-&gt;</operator><name>fendptr</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* And finally we can insert the new field. */</comment>
		<expr_stmt><expr><name><name>dvalues</name><index>[<expr><name>fnumber</name></expr>]</index></name> <operator>=</operator> <name>newValue</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dnulls</name><index>[<expr><name>fnumber</name></expr>]</index></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Because we don't guarantee atomicity of set_fields(), we can just leave
	 * checking of domain constraints to occur as the final step; if it throws
	 * an error, too bad.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_IS_DOMAIN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We run domain_check in a short-lived context to limit cruft */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_short_term_cxt</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>domain_check</name><argument_list>(<argument><expr><call><name>ExpandedRecordGetRODatum</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					 <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_decltypeid</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>er_domaininfo</name></name></expr></argument>,
					 <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct (or reset) working memory context for short-term operations.
 *
 * This context is used for domain check evaluation and for detoasting.
 *
 * If we don't have a short-lived memory context, make one; if we have one,
 * reset it to get rid of any leftover cruft.  (It is a tad annoying to need a
 * whole context for this, since it will often go unused --- but it's hard to
 * avoid memory leaks otherwise.  We can make the context small, at least.)
 */</comment>
<function><type><specifier>static</specifier> <name>MemoryContext</name></type>
<name>get_short_term_cxt</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name> <operator>=</operator>
			<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>,
								  <argument><expr><literal type="string">"expanded record short-term context"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name><name>erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct "dummy header" for checking domain constraints.
 *
 * Since we don't want to modify the state of the expanded record until
 * we've validated the constraints, our approach is to set up a dummy
 * record header containing the new field value(s) and then pass that to
 * domain_check.  We retain the dummy header as part of the expanded
 * record's state to save palloc cycles, but reinitialize (most of)
 * its contents on each use.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_dummy_expanded_header</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>main_erh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><call><name>expanded_record_get_tupdesc</name><argument_list>(<argument><expr><name>main_erh</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Ensure we have a short-lived context */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_short_term_cxt</name><argument_list>(<argument><expr><name>main_erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate dummy header on first time through, or in the unlikely event
	 * that the number of fields changes (in which case we just leak the old
	 * one).  Include space for its field values in the request.
	 */</comment>
	<expr_stmt><expr><name>erh</name> <operator>=</operator> <name><name>main_erh</name><operator>-&gt;</operator><name>er_dummy_header</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>erh</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>!=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>erh</name> <operator>=</operator> <operator>(</operator><name>ExpandedRecordHeader</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>main_erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>,
							   <argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>
							   <operator>+</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Ensure all header fields are initialized to 0/null */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>erh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We set up the dummy header with an indication that its memory
		 * context is the short-lived context.  This is so that, if any
		 * detoasting of out-of-line values happens due to an attempt to
		 * extract a composite datum from the dummy header, the detoasted
		 * stuff will end up in the short-lived context and not cause a leak.
		 * This is cheating a bit on the expanded-object protocol; but since
		 * we never pass a R/W pointer to the dummy object to any other code,
		 * nothing else is authorized to delete or transfer ownership of the
		 * object's context, so it should be safe enough.
		 */</comment>
		<expr_stmt><expr><call><name>EOH_init_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ER_methods</name></expr></argument>, <argument><expr><name><name>main_erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_magic</name></name> <operator>=</operator> <name>ER_MAGIC</name></expr>;</expr_stmt>

		<comment type="block">/* Set up dvalues/dnulls, with no valid contents as yet */</comment>
		<expr_stmt><expr><name>chunk</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>erh</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExpandedRecordHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <name>chunk</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>chunk</name> <operator>+</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The fields we just set are assumed to remain constant through
		 * multiple uses of the dummy header to check domain constraints.  All
		 * other dummy header fields should be explicitly reset below, to
		 * ensure there's not accidental effects of one check on the next one.
		 */</comment>

		<expr_stmt><expr><name><name>main_erh</name><operator>-&gt;</operator><name>er_dummy_header</name></name> <operator>=</operator> <name>erh</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If anything inquires about the dummy header's declared type, it should
	 * report the composite base type, not the domain type (since the VALUE in
	 * a domain check constraint is of the base type not the domain).  Hence
	 * we do not transfer over the IS_DOMAIN flag, nor indeed any of the main
	 * header's flags, since the dummy header is empty of data at this point.
	 * But don't forget to mark header as dummy.
	 */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>ER_FLAG_IS_DUMMY</name></expr>;</expr_stmt>

	<comment type="block">/* Copy composite-type identification info */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_decltypeid</name></name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_typeid</name></name> <operator>=</operator> <name><name>main_erh</name><operator>-&gt;</operator><name>er_typeid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_typmod</name></name> <operator>=</operator> <name><name>main_erh</name><operator>-&gt;</operator><name>er_typmod</name></name></expr>;</expr_stmt>

	<comment type="block">/* Dummy header does not need its own tupdesc refcount */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name> <operator>=</operator> <name><name>main_erh</name><operator>-&gt;</operator><name>er_tupdesc_id</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's tempting to copy over whatever we know about the flat size, but
	 * there's no point since we're surely about to modify the dummy record's
	 * field(s).  Instead just clear anything left over from a previous usage
	 * cycle.
	 */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>flat_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Copy over fvalue if we have it, so that system columns are available */</comment>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>fvalue</name></name> <operator>=</operator> <name><name>main_erh</name><operator>-&gt;</operator><name>fvalue</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>fstartptr</name></name> <operator>=</operator> <name><name>main_erh</name><operator>-&gt;</operator><name>fstartptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>erh</name><operator>-&gt;</operator><name>fendptr</name></name> <operator>=</operator> <name><name>main_erh</name><operator>-&gt;</operator><name>fendptr</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Precheck domain constraints for a set_field operation
 */</comment>
<function><type><specifier>static</specifier> <name>pg_noinline</name> <name>void</name></type>
<name>check_domain_for_new_field</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fnumber</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name></type> <name>newValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>dummy_erh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Construct dummy header to contain proposed new field set */</comment>
	<expr_stmt><expr><call><name>build_dummy_expanded_header</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dummy_erh</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_dummy_header</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If record isn't empty, just deconstruct it (if needed) and copy over
	 * the existing field values.  If it is empty, just fill fields with nulls
	 * manually --- don't call deconstruct_expanded_record prematurely.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExpandedRecordIsEmpty</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>deconstruct_expanded_record</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>,
			   <argument><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>, <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>,
			   <argument><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* There might be some external values in there... */</comment>
		<expr_stmt><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name><name>erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ER_FLAG_HAVE_EXTERNAL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>dvalues</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>dnulls</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>nfields</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Either way, we now have valid dvalues */</comment>
	<expr_stmt><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_DVALUES_VALID</name></expr>;</expr_stmt>

	<comment type="block">/* Caller error if fnumber is system column or nonexistent column */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>fnumber</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fnumber</name> <operator>&gt;</operator> <name><name>dummy_erh</name><operator>-&gt;</operator><name>nfields</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot assign to field %d of expanded record"</literal></expr></argument>, <argument><expr><name>fnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Insert proposed new value into dummy field array */</comment>
	<expr_stmt><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>dvalues</name><index>[<expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>dnulls</name><index>[<expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>isnull</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The proposed new value might be external, in which case we'd better set
	 * the flag for that in dummy_erh.  (This matters in case something in the
	 * domain check expressions tries to extract a flat value from the dummy
	 * header.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_tupdesc</name></name></expr></argument>, <argument><expr><name>fnumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>&amp;&amp;</operator> <name><name>attr</name><operator>-&gt;</operator><name>attlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_HAVE_EXTERNAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We call domain_check in the short-lived context, so that any cruft
	 * leaked by expression evaluation can be reclaimed.
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And now we can apply the check.  Note we use main header's domain cache
	 * space, so that caching carries across repeated uses.
	 */</comment>
	<expr_stmt><expr><call><name>domain_check</name><argument_list>(<argument><expr><call><name>ExpandedRecordGetRODatum</name><argument_list>(<argument><expr><name>dummy_erh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				 <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_decltypeid</name></name></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>er_domaininfo</name></name></expr></argument>,
				 <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We might as well clean up cruft immediately. */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Precheck domain constraints for a set_tuple operation
 */</comment>
<function><type><specifier>static</specifier> <name>pg_noinline</name> <name>void</name></type>
<name>check_domain_for_new_tuple</name><parameter_list>(<parameter><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>erh</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExpandedRecordHeader</name> <modifier>*</modifier></type><name>dummy_erh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* If we're being told to set record to empty, just see if NULL is OK */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We run domain_check in a short-lived context to limit cruft */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>get_short_term_cxt</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>domain_check</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>,
					 <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_decltypeid</name></name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>er_domaininfo</name></name></expr></argument>,
					 <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We might as well clean up cruft immediately. */</comment>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Construct dummy header to contain replacement tuple */</comment>
	<expr_stmt><expr><call><name>build_dummy_expanded_header</name><argument_list>(<argument><expr><name>erh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dummy_erh</name> <operator>=</operator> <name><name>erh</name><operator>-&gt;</operator><name>er_dummy_header</name></name></expr>;</expr_stmt>

	<comment type="block">/* Insert tuple, but don't bother to deconstruct its fields for now */</comment>
	<expr_stmt><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>fvalue</name></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>fstartptr</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>fendptr</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name><operator>)</operator> <operator>+</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_FVALUE_VALID</name></expr>;</expr_stmt>

	<comment type="block">/* Remember if we have any out-of-line field values */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleHasExternal</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dummy_erh</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ER_FLAG_HAVE_EXTERNAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We call domain_check in the short-lived context, so that any cruft
	 * leaked by expression evaluation can be reclaimed.
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And now we can apply the check.  Note we use main header's domain cache
	 * space, so that caching carries across repeated uses.
	 */</comment>
	<expr_stmt><expr><call><name>domain_check</name><argument_list>(<argument><expr><call><name>ExpandedRecordGetRODatum</name><argument_list>(<argument><expr><name>dummy_erh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
				 <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_decltypeid</name></name></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name><name>erh</name><operator>-&gt;</operator><name>er_domaininfo</name></name></expr></argument>,
				 <argument><expr><name><name>erh</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>eoh_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We might as well clean up cruft immediately. */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>erh</name><operator>-&gt;</operator><name>er_short_term_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
