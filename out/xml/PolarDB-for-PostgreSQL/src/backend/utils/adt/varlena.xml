<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/adt/varlena.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * varlena.c
 *	  Functions for the variable-length built-in types.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/varlena.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/hyperloglog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bswap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regex/regex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/bytea.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sortsupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>


<comment type="block">/* GUC variable */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>bytea_output</name> <init>= <expr><name>BYTEA_OUTPUT_HEX</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><name><name>struct</name> <name>varlena</name></name></type> <name>unknown</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>varlena</name></name></type> <name>VarString</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_wchar</name></decl>;</decl_stmt>		<comment type="block">/* T if multibyte encoding */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str1</name></decl>;</decl_stmt>			<comment type="block">/* use these if not use_wchar */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str2</name></decl>;</decl_stmt>			<comment type="block">/* note: these point to original texts */</comment>
	<decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>wstr1</name></decl>;</decl_stmt>			<comment type="block">/* use these if use_wchar */</comment>
	<decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>wstr2</name></decl>;</decl_stmt>			<comment type="block">/* note: these are palloc'd */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>;</decl_stmt>			<comment type="block">/* string lengths in logical characters */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>len2</name></decl>;</decl_stmt>
	<comment type="block">/* Skip table for Boyer-Moore-Horspool search algorithm: */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>skiptablemask</name></decl>;</decl_stmt>	<comment type="block">/* mask for ANDing with skiptable subscripts */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>skiptable</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* skip distance for given mismatched char */</comment>
}</block></struct></type> <name>TextPositionState</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf1</name></decl>;</decl_stmt>			<comment type="block">/* 1st string, or abbreviation original string
								 * buf */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf2</name></decl>;</decl_stmt>			<comment type="block">/* 2nd string, or abbreviation strxfrm() buf */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>buflen1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>buflen2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>last_len1</name></decl>;</decl_stmt>		<comment type="block">/* Length of last buf1 string/strxfrm() input */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>last_len2</name></decl>;</decl_stmt>		<comment type="block">/* Length of last buf2 string/strxfrm() blob */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>last_returned</name></decl>;</decl_stmt>	<comment type="block">/* Last comparison result (cache) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cache_blob</name></decl>;</decl_stmt>		<comment type="block">/* Does buf2 contain strxfrm() blob, etc? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>collate_c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bpchar</name></decl>;</decl_stmt>			<comment type="block">/* Sorting bpchar, not varchar/text/bytea? */</comment>
	<decl_stmt><decl><type><name>hyperLogLogState</name></type> <name>abbr_card</name></decl>;</decl_stmt> <comment type="block">/* Abbreviated key cardinality state */</comment>
	<decl_stmt><decl><type><name>hyperLogLogState</name></type> <name>full_card</name></decl>;</decl_stmt> <comment type="block">/* Full key cardinality state */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>prop_card</name></decl>;</decl_stmt>		<comment type="block">/* Required cardinality proportion */</comment>
	<decl_stmt><decl><type><name>pg_locale_t</name></type> <name>locale</name></decl>;</decl_stmt>
}</block></struct></type> <name>VarStringSortSupport</name>;</typedef>

<comment type="block">/*
 * This should be large enough that most strings will fit, but small enough
 * that we feel comfortable putting it on the stack
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEXTBUFLEN</name></cpp:macro>		<cpp:value>1024</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DatumGetUnknownP</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>((unknown *) PG_DETOAST_DATUM(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DatumGetUnknownPCopy</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((unknown *) PG_DETOAST_DATUM_COPY(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_GETARG_UNKNOWN_P</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>DatumGetUnknownP(PG_GETARG_DATUM(n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_GETARG_UNKNOWN_P_COPY</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetUnknownPCopy(PG_GETARG_DATUM(n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_RETURN_UNKNOWN_P</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>PG_RETURN_POINTER(x)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DatumGetVarStringP</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((VarString *) PG_DETOAST_DATUM(X))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DatumGetVarStringPP</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((VarString *) PG_DETOAST_DATUM_PACKED(X))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>varstrfastcmp_c</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>bpcharfastcmp_c</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>varstrfastcmp_locale</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>varstrcmp_abbrev</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>varstr_abbrev_convert</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>original</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>varstr_abbrev_abort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>memtupcount</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>text_length</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>text_catenate</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>text_substring</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>str</name></decl></parameter>,
			   <parameter><decl><type><name>int32</name></type> <name>start</name></decl></parameter>,
			   <parameter><decl><type><name>int32</name></type> <name>length</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>length_not_specified</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>text_overlay</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>text_position</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>text_position_setup</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>, <parameter><decl><type><name>TextPositionState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>text_position_next</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>start_pos</name></decl></parameter>, <parameter><decl><type><name>TextPositionState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>text_position_cleanup</name><parameter_list>(<parameter><decl><type><name>TextPositionState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>text_cmp</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bytea</name> <modifier>*</modifier></type><name>bytea_catenate</name><parameter_list>(<parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bytea</name> <modifier>*</modifier></type><name>bytea_substring</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>str</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>S</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>L</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>length_not_specified</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bytea</name> <modifier>*</modifier></type><name>bytea_overlay</name><parameter_list>(<parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendStringInfoText</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>text</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>text_to_array_internal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>array_to_text_internal</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fldsep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>null_string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>makeStringAggState</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>text_format_parse_digits</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end_ptr</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text_format_parse_format</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start_ptr</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end_ptr</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argpos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>widthpos</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>width</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>text_format_string_conversion</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>conversion</name></decl></parameter>,
							  <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>typOutputInfo</name></decl></parameter>,
							  <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>text_format_append_string</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 CONVERSION ROUTINES EXPORTED FOR USE BY C CODE							 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * cstring_to_text
 *
 * Create a text value from a null-terminated C string.
 *
 * The new text value is freshly palloc'd with a full-size VARHDR.
 */</comment>
<function><type><name>text</name> <modifier>*</modifier></type>
<name>cstring_to_text</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cstring_to_text_with_len
 *
 * Same as cstring_to_text except the caller specifies the string length;
 * the string need not be null_terminated.
 */</comment>
<function><type><name>text</name> <modifier>*</modifier></type>
<name>cstring_to_text_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * text_to_cstring
 *
 * Create a palloc'd, null-terminated C string from a text value.
 *
 * We support being passed a compressed or toasted text value.
 * This is a bit bogus since such values shouldn't really be referred to as
 * "text *", but it seems useful for robustness.  If we didn't handle that
 * case here, we'd need another routine that did, anyway.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>text_to_cstring</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>text</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* must cast away the const, unfortunately */</comment>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>tunpacked</name> <init>= <expr><call><name>pg_detoast_datum_packed</name><argument_list>(<argument><expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>tunpacked</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>tunpacked</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tunpacked</name> <operator>!=</operator> <name>t</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tunpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * text_to_cstring_buffer
 *
 * Copy a text value into a caller-supplied buffer of size dst_len.
 *
 * The text string is truncated if necessary to fit.  The result is
 * guaranteed null-terminated (unless dst_len == 0).
 *
 * We support being passed a compressed or toasted text value.
 * This is a bit bogus since such values shouldn't really be referred to as
 * "text *", but it seems useful for robustness.  If we didn't handle that
 * case here, we'd need another routine that did, anyway.
 */</comment>
<function><type><name>void</name></type>
<name>text_to_cstring_buffer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>text</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dst_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* must cast away the const, unfortunately */</comment>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>srcunpacked</name> <init>= <expr><call><name>pg_detoast_datum_packed</name><argument_list>(<argument><expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>src_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>srcunpacked</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>dst_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dst_len</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>dst_len</name> <operator>&gt;=</operator> <name>src_len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dst_len</name> <operator>=</operator> <name>src_len</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>					<comment type="block">/* ensure truncation is encoding-safe */</comment>
			<expr_stmt><expr><name>dst_len</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>srcunpacked</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>src_len</name></expr></argument>, <argument><expr><name>dst_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>srcunpacked</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dst_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dst</name><index>[<expr><name>dst_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>srcunpacked</name> <operator>!=</operator> <name>src</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>srcunpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *	 USER I/O ROUTINES														 *
 *****************************************************************************/</comment>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAL</name><parameter_list>(<parameter><type><name>CH</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>((CH) - '0')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIG</name><parameter_list>(<parameter><type><name>VAL</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((VAL) + '0')</cpp:value></cpp:define>

<comment type="block">/*
 *		byteain			- converts from printable representation of byte array
 *
 *		Non-printable characters must be passed as '\nnn' (octal) and are
 *		converted to internal form.  '\' must be passed as '\\'.
 *		ereport(ERROR, ...) if bad form.
 *
 *		BUGS:
 *				The input is scanned twice.
 *				The error checking of input is minimal.
 */</comment>
<function><type><name>Datum</name></type>
<name>byteain</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>inputText</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Recognize hex input */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>inputText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>inputText</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>inputText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>bc</name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>	<comment type="block">/* maximum possible length */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bc</name> <operator>=</operator> <call><name>hex_decode</name><argument_list>(<argument><expr><name>inputText</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>bc</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* actual length */</comment>

		<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else, it's the traditional escaped style */</comment>
	<for>for <control>(<init><expr><name>bc</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>tp</name> <operator>=</operator> <name>inputText</name></expr>;</init> <condition><expr><operator>*</operator><name>tp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>bc</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>tp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'3'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>tp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'7'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>tp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'7'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tp</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * one backslash, not followed by another or ### valid octal
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"bytea"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>bc</name> <operator>+=</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <name>inputText</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rp</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>tp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>tp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>tp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'3'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>tp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'7'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>tp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'7'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bc</name> <operator>=</operator> <call><name>VAL</name><argument_list>(<argument><expr><name><name>tp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bc</name> <operator>&lt;&lt;=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>bc</name> <operator>+=</operator> <call><name>VAL</name><argument_list>(<argument><expr><name><name>tp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bc</name> <operator>&lt;&lt;=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <name>bc</name> <operator>+</operator> <call><name>VAL</name><argument_list>(<argument><expr><name><name>tp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tp</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>tp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>tp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * We should never get here. The first pass should not allow it.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"bytea"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		byteaout		- converts to printable representation of byte array
 *
 *		In the traditional escaped format, non-printable characters are
 *		printed as '\nnn' (octal) and '\' as '\\'.
 */</comment>
<function><type><name>Datum</name></type>
<name>byteaout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>vlena</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>bytea_output</name> <operator>==</operator> <name>BYTEA_OUTPUT_HEX</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Print hex format */</comment>
		<expr_stmt><expr><name>rp</name> <operator>=</operator> <name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>vlena</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>rp</name> <operator>+=</operator> <call><name>hex_encode</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>vlena</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>vlena</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>bytea_output</name> <operator>==</operator> <name>BYTEA_OUTPUT_ESCAPE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Print traditional escaped format */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>vp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>				<comment type="block">/* empty string has 1 char */</comment>
		<expr_stmt><expr><name>vp</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>vlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>vlena</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>vp</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>vp</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name><name>vp</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x20</literal> <operator>||</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>vp</name></expr></argument> &gt;</argument_list></name> <literal type="number">0x7e</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>rp</name> <operator>=</operator> <name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vp</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>vlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>vlena</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr><operator>,</operator> <expr><name>vp</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>vp</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name><name>vp</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x20</literal> <operator>||</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>vp</name></expr></argument> &gt;</argument_list></name> <literal type="number">0x7e</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>	<comment type="block">/* holds unprintable chars */</comment>

				<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>*</operator><name>vp</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>DIG</name><argument_list>(<argument><expr><name>val</name> <operator>&amp;</operator> <literal type="number">07</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>val</name> <operator>&gt;&gt;=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>DIG</name><argument_list>(<argument><expr><name>val</name> <operator>&amp;</operator> <literal type="number">07</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>val</name> <operator>&gt;&gt;=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DIG</name><argument_list>(<argument><expr><name>val</name> <operator>&amp;</operator> <literal type="number">03</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rp</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>rp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>vp</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized bytea_output setting: %d"</literal></expr></argument>,
			 <argument><expr><name>bytea_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rp</name> <operator>=</operator> <name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>rp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		bytearecv			- converts external binary format to bytea
 */</comment>
<function><type><name>Datum</name></type>
<name>bytearecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>nbytes</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_copymsgbytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		byteasend			- converts bytea to binary format
 *
 * This is a special case: just copy the input...
 */</comment>
<function><type><name>Datum</name></type>
<name>byteasend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>vlena</name> <init>= <expr><call><name>PG_GETARG_BYTEA_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>vlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bytea_string_agg_transfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Append the value unless null. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* On the first time through, we ignore the delimiter. */</comment>
		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makeStringAggState</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>delim</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The transition type for string_agg() is declared to be "internal",
	 * which is a pass-by-value type the same size as a pointer.
	 */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bytea_string_agg_finalfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>state</name></decl>;</decl_stmt>

	<comment type="block">/* cannot be called directly because of internal-type argument */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		textin			- converts "..." to internal representation
 */</comment>
<function><type><name>Datum</name></type>
<name>textin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>inputText</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>inputText</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		textout			- converts internal representation to "..."
 */</comment>
<function><type><name>Datum</name></type>
<name>textout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>txt</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		textrecv			- converts external binary format to text
 */</comment>
<function><type><name>Datum</name></type>
<name>textrecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pq_getmsgtext</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		textsend			- converts text to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>textsend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *		unknownin			- converts "..." to internal representation
 */</comment>
<function><type><name>Datum</name></type>
<name>unknownin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* representation is same as cstring */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		unknownout			- converts internal representation to "..."
 */</comment>
<function><type><name>Datum</name></type>
<name>unknownout</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* representation is same as cstring */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		unknownrecv			- converts external binary format to unknown
 */</comment>
<function><type><name>Datum</name></type>
<name>unknownrecv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pq_getmsgtext</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* representation is same as cstring */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		unknownsend			- converts unknown to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>unknownsend</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* representation is same as cstring */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ========== PUBLIC ROUTINES ========== */</comment>

<comment type="block">/*
 * textlen -
 *	  returns the logical length of a text*
 *	   (which is less than the VARSIZE of the text*)
 */</comment>
<function><type><name>Datum</name></type>
<name>textlen</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>str</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* try to avoid decompressing argument */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>text_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * text_length -
 *	Does the real work for textlen()
 *
 *	This is broken out so it can be called directly by other string processing
 *	functions.  Note that the argument is passed as a Datum, to indicate that
 *	it may still be in compressed form.  We can avoid decompressing it at all
 *	in some cases.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>text_length</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* fastpath when max encoding length is one */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * textoctetlen -
 *	  returns the physical length of a text*
 *	   (which is less than the VARSIZE of the text*)
 */</comment>
<function><type><name>Datum</name></type>
<name>textoctetlen</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>str</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We need not detoast the input at all */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * textcat -
 *	  takes two text* and returns a text* that is the concatenation of
 *	  the two.
 *
 * Rewritten by Sapa, sapa@hq.icb.chel.su. 8-Jul-96.
 * Updated by Thomas, Thomas.Lockhart@jpl.nasa.gov 1997-07-10.
 * Allocate space for output in all cases.
 * XXX - thomas 1997-07-10
 */</comment>
<function><type><name>Datum</name></type>
<name>textcat</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>text_catenate</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * text_catenate
 *	Guts of textcat(), broken out so it can be used by other functions
 *
 * Arguments can be in short-header form, but not compressed or out-of-line
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>text_catenate</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>,
				<decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* paranoia ... probably should throw error instead? */</comment>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>len1</name> <operator>+</operator> <name>len2</name> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set size of result string... */</comment>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill data field of result string... */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>len1</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * charlen_to_bytelen()
 *	Compute the number of bytes occupied by n characters starting at *p
 *
 * It is caller's responsibility that there actually are n characters;
 * the string need not be null-terminated.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>charlen_to_bytelen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Optimization for single-byte encodings */</comment>
		<return>return <expr><name>n</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<return>return <expr><name>s</name> <operator>-</operator> <name>p</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * text_substr()
 * Return a substring starting at the specified position.
 * - thomas 1997-12-31
 *
 * Input:
 *	- string
 *	- starting position (is one-based)
 *	- string length
 *
 * If the starting position is zero or less, then return from the start of the string
 *	adjusting the length to be consistent with the "negative start" per SQL.
 * If the length is less than zero, return the remaining string.
 *
 * Added multibyte support.
 * - Tatsuo Ishii 1998-4-21
 * Changed behavior if starting position is less than one to conform to SQL behavior.
 * Formerly returned the entire string; now returns a portion.
 * - Thomas Lockhart 1998-12-10
 * Now uses faster TOAST-slicing interface
 * - John Gray 2002-02-22
 * Remove "#ifdef MULTIBYTE" and test for encoding_max_length instead. Change
 * behaviors conflicting with SQL to meet SQL (if E = S + L &lt; S throw
 * error; if E &lt; 1, return '', not entire string). Fixed MB related bug when
 * S &gt; LC and &lt; LC + 4 sometimes garbage characters are returned.
 * - Joe Conway 2002-08-10
 */</comment>
<function><type><name>Datum</name></type>
<name>text_substr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>text_substring</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * text_substr_no_len -
 *	  Wrapper to avoid opr_sanity failure due to
 *	  one function accepting a different number of args.
 */</comment>
<function><type><name>Datum</name></type>
<name>text_substr_no_len</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>text_substring</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * text_substring -
 *	Does the real work for text_substr() and text_substr_no_len()
 *
 *	This is broken out so it can be called directly by other string processing
 *	functions.  Note that the argument is passed as a Datum, to indicate that
 *	it may still be in compressed/toasted form.  We can avoid detoasting all
 *	of it in some cases.
 *
 *	The result is always a freshly palloc'd datum.
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>text_substring</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>length_not_specified</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>eml</name> <init>= <expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>S</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* start position */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>S1</name></decl>;</decl_stmt>				<comment type="block">/* adjusted start position */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>L1</name></decl>;</decl_stmt>				<comment type="block">/* adjusted substring length */</comment>

	<comment type="block">/* life is easy if the encoding max length is 1 */</comment>
	<if_stmt><if>if <condition>(<expr><name>eml</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>S1</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>length_not_specified</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* special case - get length to end of
									 * string */</comment>
			<expr_stmt><expr><name>L1</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* end position */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>E</name> <init>= <expr><name>S</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * A negative value for L is the only way for the end position to
			 * be before the start. SQL99 says to throw an error.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>E</name> <operator>&lt;</operator> <name>S</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SUBSTRING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"negative substring length not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * A zero or negative value for the end position can happen if the
			 * start was negative or one. SQL99 says to return a zero-length
			 * string.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>E</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>L1</name> <operator>=</operator> <name>E</name> <operator>-</operator> <name>S1</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If the start position is past the end of the string, SQL99 says to
		 * return a zero-length string -- PG_GETARG_TEXT_P_SLICE() will do
		 * that for us. Convert to zero-based starting position
		 */</comment>
		<return>return <expr><call><name>DatumGetTextPSlice</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>S1</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>L1</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>eml</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When encoding max length is &gt; 1, we can't get LC without
		 * detoasting, so we'll grab a conservatively large slice now and go
		 * back later to do the right thing
		 */</comment>
		<decl_stmt><decl><type><name>int32</name></type>		<name>slice_start</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>slice_size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>slice_strlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>E1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * if S is past the end of the string, the tuple toaster will return a
		 * zero-length string to us
		 */</comment>
		<expr_stmt><expr><name>S1</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need to start at position zero because there is no way to know
		 * in advance which byte offset corresponds to the supplied start
		 * position.
		 */</comment>
		<expr_stmt><expr><name>slice_start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>length_not_specified</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* special case - get length to end of
									 * string */</comment>
			<expr_stmt><expr><name>slice_size</name> <operator>=</operator> <name>L1</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>E</name> <init>= <expr><name>S</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * A negative value for L is the only way for the end position to
			 * be before the start. SQL99 says to throw an error.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>E</name> <operator>&lt;</operator> <name>S</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SUBSTRING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"negative substring length not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * A zero or negative value for the end position can happen if the
			 * start was negative or one. SQL99 says to return a zero-length
			 * string.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>E</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * if E is past the end of the string, the tuple toaster will
			 * truncate the length for us
			 */</comment>
			<expr_stmt><expr><name>L1</name> <operator>=</operator> <name>E</name> <operator>-</operator> <name>S1</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Total slice size in bytes can't be any longer than the start
			 * position plus substring length times the encoding max length.
			 */</comment>
			<expr_stmt><expr><name>slice_size</name> <operator>=</operator> <operator>(</operator><name>S1</name> <operator>+</operator> <name>L1</name><operator>)</operator> <operator>*</operator> <name>eml</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we're working with an untoasted source, no need to do an extra
		 * copying step.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_COMPRESSED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>slice</name> <operator>=</operator> <call><name>DatumGetTextPSlice</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>slice_start</name></expr></argument>, <argument><expr><name>slice_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>slice</name> <operator>=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* see if we got back an empty string */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>slice</name> <operator>!=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Now we can get the actual length of the slice in MB characters */</comment>
		<expr_stmt><expr><name>slice_strlen</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check that the start position wasn't &gt; slice_strlen. If so, SQL99
		 * says to return a zero-length string.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>S1</name> <operator>&gt;</operator> <name>slice_strlen</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>slice</name> <operator>!=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Adjust L1 and E1 now that we know the slice string length. Again
		 * remember that S1 is one based, and slice_start is zero based.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>L1</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>E1</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>S1</name> <operator>+</operator> <name>L1</name></expr></argument>, <argument><expr><name>slice_start</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>slice_strlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>E1</name> <operator>=</operator> <name>slice_start</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>slice_strlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Find the start position in the slice; remember S1 is not zero based
		 */</comment>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>S1</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/* hang onto a pointer to our start position */</comment>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Count the actual bytes used by the substring of the requested
		 * length.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>S1</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>E1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>p</name> <operator>-</operator> <name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slice</name> <operator>!=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>ret</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid backend encoding: encoding max length &lt; 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* not reached: suppress compiler warning */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * textoverlay
 *	Replace specified substring of first string with second
 *
 * The SQL standard defines OVERLAY() in terms of substring and concatenation.
 * This code is a direct implementation of what the standard says.
 */</comment>
<function><type><name>Datum</name></type>
<name>textoverlay</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sp</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* substring start position */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sl</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* substring length */</comment>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>text_overlay</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>textoverlay_no_len</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sp</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* substring start position */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sl</name> <operator>=</operator> <call><name>text_length</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* defaults to length(t2) */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>text_overlay</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>text_overlay</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>s1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sp_pl_sl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check for possible integer-overflow cases.  For negative sp, throw a
	 * "substring length" error because that's what should be expected
	 * according to the spec's definition of OVERLAY().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SUBSTRING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"negative substring length not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_add_s32_overflow</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sp_pl_sl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>text_substring</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>sp</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>text_substring</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp_pl_sl</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>text_catenate</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>text_catenate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * textpos -
 *	  Return the position of the specified substring.
 *	  Implements the SQL POSITION() function.
 *	  Ref: A Guide To The SQL Standard, Date &amp; Darwen, 1997
 * - thomas 1997-07-27
 */</comment>
<function><type><name>Datum</name></type>
<name>textpos</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>search_str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <call><name>text_position</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>search_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * text_position -
 *	Does the real work for textpos()
 *
 * Inputs:
 *		t1 - string to be searched
 *		t2 - pattern to match within t1
 * Result:
 *		Character index of the first matched char, starting from 1,
 *		or 0 if no match.
 *
 *	This is broken out so it can be called directly by other string processing
 *	functions.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>text_position</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TextPositionState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>text_position_setup</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>text_position_next</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>text_position_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * text_position_setup, text_position_next, text_position_cleanup -
 *	Component steps of text_position()
 *
 * These are broken out so that a string can be efficiently searched for
 * multiple occurrences of the same pattern.  text_position_next may be
 * called multiple times with increasing values of start_pos, which is
 * the 1-based character position to start the search from.  The "state"
 * variable is normally just a local variable in the caller.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>text_position_setup</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>, <parameter><decl><type><name>TextPositionState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len2</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* simple case - single byte encoding */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>use_wchar</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>str1</name></name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>str2</name></name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>len1</name></name> <operator>=</operator> <name>len1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>len2</name></name> <operator>=</operator> <name>len2</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* not as simple - multibyte encoding */</comment>
		<decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>p1</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>p1</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>len1</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>pg_mb2wchar_with_len</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p2</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>len2</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>pg_mb2wchar_with_len</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>use_wchar</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wstr1</name></name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>wstr2</name></name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>len1</name></name> <operator>=</operator> <name>len1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>len2</name></name> <operator>=</operator> <name>len2</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Prepare the skip table for Boyer-Moore-Horspool searching.  In these
	 * notes we use the terminology that the "haystack" is the string to be
	 * searched (t1) and the "needle" is the pattern being sought (t2).
	 *
	 * If the needle is empty or bigger than the haystack then there is no
	 * point in wasting cycles initializing the table.  We also choose not to
	 * use B-M-H for needles of length 1, since the skip table can't possibly
	 * save anything in that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&gt;=</operator> <name>len2</name> <operator>&amp;&amp;</operator> <name>len2</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>searchlength</name> <init>= <expr><name>len1</name> <operator>-</operator> <name>len2</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>skiptablemask</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>last</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * First we must determine how much of the skip table to use.  The
		 * declaration of TextPositionState allows up to 256 elements, but for
		 * short search problems we don't really want to have to initialize so
		 * many elements --- it would take too long in comparison to the
		 * actual search time.  So we choose a useful skip table size based on
		 * the haystack length minus the needle length.  The closer the needle
		 * length is to the haystack length the less useful skipping becomes.
		 *
		 * Note: since we use bit-masking to select table elements, the skip
		 * table size MUST be a power of 2, and so the mask must be 2^N-1.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>searchlength</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>skiptablemask</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>searchlength</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>skiptablemask</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>searchlength</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>skiptablemask</name> <operator>=</operator> <literal type="number">15</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>searchlength</name> <operator>&lt;</operator> <literal type="number">512</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>skiptablemask</name> <operator>=</operator> <literal type="number">31</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>searchlength</name> <operator>&lt;</operator> <literal type="number">2048</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>skiptablemask</name> <operator>=</operator> <literal type="number">63</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>searchlength</name> <operator>&lt;</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>skiptablemask</name> <operator>=</operator> <literal type="number">127</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>skiptablemask</name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skiptablemask</name></name> <operator>=</operator> <name>skiptablemask</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize the skip table.  We set all elements to the needle
		 * length, since this is the correct skip distance for any character
		 * not found in the needle.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>skiptablemask</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skiptable</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>len2</name></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/*
		 * Now examine the needle.  For each character except the last one,
		 * set the corresponding table element to the appropriate skip
		 * distance.  Note that when two characters share the same skip table
		 * entry, the one later in the needle must determine the skip
		 * distance.
		 */</comment>
		<expr_stmt><expr><name>last</name> <operator>=</operator> <name>len2</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>use_wchar</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str2</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>str2</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>last</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skiptable</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>str2</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>skiptablemask</name></expr>]</index></name> <operator>=</operator> <name>last</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>wstr2</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>wstr2</name></name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>last</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>skiptable</name><index>[<expr><name><name>wstr2</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>skiptablemask</name></expr>]</index></name> <operator>=</operator> <name>last</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>text_position_next</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>start_pos</name></decl></parameter>, <parameter><decl><type><name>TextPositionState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>haystack_len</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>len1</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>needle_len</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>len2</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>skiptablemask</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>skiptablemask</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start_pos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* else caller error */</comment>

	<if_stmt><if>if <condition>(<expr><name>needle_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>start_pos</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* result for empty pattern */</comment>

	<expr_stmt><expr><name>start_pos</name><operator>--</operator></expr>;</expr_stmt>				<comment type="block">/* adjust for zero based arrays */</comment>

	<comment type="block">/* Done if the needle can't possibly fit */</comment>
	<if_stmt><if>if <condition>(<expr><name>haystack_len</name> <operator>&lt;</operator> <name>start_pos</name> <operator>+</operator> <name>needle_len</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>use_wchar</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* simple case - single byte encoding */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>haystack</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>str1</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>needle</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>str2</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>haystack_end</name> <init>= <expr><operator>&amp;</operator><name><name>haystack</name><index>[<expr><name>haystack_len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hptr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>needle_len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No point in using B-M-H for a one-character needle */</comment>
			<decl_stmt><decl><type><name>char</name></type>		<name>nchar</name> <init>= <expr><operator>*</operator><name>needle</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>hptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>haystack</name><index>[<expr><name>start_pos</name></expr>]</index></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>hptr</name> <operator>&lt;</operator> <name>haystack_end</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>hptr</name> <operator>==</operator> <name>nchar</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>hptr</name> <operator>-</operator> <name>haystack</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>hptr</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>needle_last</name> <init>= <expr><operator>&amp;</operator><name><name>needle</name><index>[<expr><name>needle_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Start at startpos plus the length of the needle */</comment>
			<expr_stmt><expr><name>hptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>haystack</name><index>[<expr><name>start_pos</name> <operator>+</operator> <name>needle_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>hptr</name> <operator>&lt;</operator> <name>haystack_end</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Match the needle scanning *backward* */</comment>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nptr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>nptr</name> <operator>=</operator> <name>needle_last</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <name>hptr</name></expr>;</expr_stmt>
				<while>while <condition>(<expr><operator>*</operator><name>nptr</name> <operator>==</operator> <operator>*</operator><name>p</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Matched it all?	If so, return 1-based position */</comment>
					<if_stmt><if>if <condition>(<expr><name>nptr</name> <operator>==</operator> <name>needle</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>p</name> <operator>-</operator> <name>haystack</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>nptr</name><operator>--</operator></expr><operator>,</operator> <expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></while>

				<comment type="block">/*
				 * No match, so use the haystack char at hptr to decide how
				 * far to advance.  If the needle had any occurrence of that
				 * character (or more precisely, one sharing the same
				 * skiptable entry) before its last character, then we advance
				 * far enough to align the last such needle character with
				 * that haystack position.  Otherwise we can advance by the
				 * whole needle length.
				 */</comment>
				<expr_stmt><expr><name>hptr</name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>skiptable</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>hptr</name> <operator>&amp;</operator> <name>skiptablemask</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* The multibyte char version. This works exactly the same way. */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>haystack</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>wstr1</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>needle</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>wstr2</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>haystack_end</name> <init>= <expr><operator>&amp;</operator><name><name>haystack</name><index>[<expr><name>haystack_len</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>hptr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>needle_len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No point in using B-M-H for a one-character needle */</comment>
			<decl_stmt><decl><type><name>pg_wchar</name></type>	<name>nchar</name> <init>= <expr><operator>*</operator><name>needle</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>hptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>haystack</name><index>[<expr><name>start_pos</name></expr>]</index></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>hptr</name> <operator>&lt;</operator> <name>haystack_end</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>hptr</name> <operator>==</operator> <name>nchar</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>hptr</name> <operator>-</operator> <name>haystack</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>hptr</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>needle_last</name> <init>= <expr><operator>&amp;</operator><name><name>needle</name><index>[<expr><name>needle_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Start at startpos plus the length of the needle */</comment>
			<expr_stmt><expr><name>hptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>haystack</name><index>[<expr><name>start_pos</name> <operator>+</operator> <name>needle_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>hptr</name> <operator>&lt;</operator> <name>haystack_end</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Match the needle scanning *backward* */</comment>
				<decl_stmt><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>nptr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>pg_wchar</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>nptr</name> <operator>=</operator> <name>needle_last</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <name>hptr</name></expr>;</expr_stmt>
				<while>while <condition>(<expr><operator>*</operator><name>nptr</name> <operator>==</operator> <operator>*</operator><name>p</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Matched it all?	If so, return 1-based position */</comment>
					<if_stmt><if>if <condition>(<expr><name>nptr</name> <operator>==</operator> <name>needle</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>p</name> <operator>-</operator> <name>haystack</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>nptr</name><operator>--</operator></expr><operator>,</operator> <expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></while>

				<comment type="block">/*
				 * No match, so use the haystack char at hptr to decide how
				 * far to advance.  If the needle had any occurrence of that
				 * character (or more precisely, one sharing the same
				 * skiptable entry) before its last character, then we advance
				 * far enough to align the last such needle character with
				 * that haystack position.  Otherwise we can advance by the
				 * whole needle length.
				 */</comment>
				<expr_stmt><expr><name>hptr</name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>skiptable</name><index>[<expr><operator>*</operator><name>hptr</name> <operator>&amp;</operator> <name>skiptablemask</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* not found */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>text_position_cleanup</name><parameter_list>(<parameter><decl><type><name>TextPositionState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>use_wchar</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>wstr1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>wstr2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* varstr_cmp()
 * Comparison function for text strings with given lengths.
 * Includes locale support, but must copy strings to temporary memory
 *	to allow null-termination for inputs to strcoll().
 * Returns an integer less than, equal to, or greater than zero, indicating
 * whether arg1 is less than, equal to, or greater than arg2.
 */</comment>
<function><type><name>int</name></type>
<name>varstr_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len2</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Unfortunately, there is no strncoll(), so in the non-C locale case we
	 * have to do some memory copying.  This turns out to be significantly
	 * slower, so we optimize the case where LC_COLLATE is C.  We also try to
	 * optimize relatively-short strings by avoiding palloc/pfree overhead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lc_collate_is_c</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>len1</name> <operator>!=</operator> <name>len2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>len1</name> <operator>&lt;</operator> <name>len2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>a1buf</name><index>[<expr><name>TEXTBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>a2buf</name><index>[<expr><name>TEXTBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>a1p</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>a2p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_locale_t</name></type> <name>mylocale</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>collid</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This typically means that the parser could not resolve a
				 * conflict of implicit collations, so report it that way.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for string comparison"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>mylocale</name> <operator>=</operator> <call><name>pg_newlocale_from_collation</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * memcmp() can't tell us which of two unequal strings sorts first,
		 * but it's a cheap way to tell if they're equal.  Testing shows that
		 * memcmp() followed by strcoll() is only trivially slower than
		 * strcoll() by itself, so we don't lose much if this doesn't work out
		 * very often, and if it does - for example, because there are many
		 * equal strings in the input - then we win big by avoiding expensive
		 * collation-aware comparisons.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>==</operator> <name>len2</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<comment type="block">/* Win32 does not have UTF-8, so we need to map to UTF-16 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PG_UTF8</name>
			<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>mylocale</name> <operator>||</operator> <name><name>mylocale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_LIBC</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>a1len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>a2len</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&gt;=</operator> <name>TEXTBUFLEN</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>a1len</name> <operator>=</operator> <name>len1</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>a1p</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>a1len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>a1len</name> <operator>=</operator> <name>TEXTBUFLEN</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>a1p</name> <operator>=</operator> <name>a1buf</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>&gt;=</operator> <name>TEXTBUFLEN</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>a2len</name> <operator>=</operator> <name>len2</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>a2p</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>a2len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>a2len</name> <operator>=</operator> <name>TEXTBUFLEN</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>a2p</name> <operator>=</operator> <name>a2buf</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* stupid Microsloth API does not work for zero-length input */</comment>
			<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>,
										<argument><expr><operator>(</operator><name>LPWSTR</name><operator>)</operator> <name>a1p</name></expr></argument>, <argument><expr><name>a1len</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not convert string to UTF-16: error code %lu"</literal></expr></argument>,
									<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>LPWSTR</name><operator>)</operator> <name>a1p</name><operator>)</operator><index>[<expr><name>r</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>,
										<argument><expr><operator>(</operator><name>LPWSTR</name><operator>)</operator> <name>a2p</name></expr></argument>, <argument><expr><name>a2len</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not convert string to UTF-16: error code %lu"</literal></expr></argument>,
									<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>LPWSTR</name><operator>)</operator> <name>a2p</name><operator>)</operator><index>[<expr><name>r</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>mylocale</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>wcscoll_l</name><argument_list>(<argument><expr><operator>(</operator><name>LPWSTR</name><operator>)</operator> <name>a1p</name></expr></argument>, <argument><expr><operator>(</operator><name>LPWSTR</name><operator>)</operator> <name>a2p</name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>wcscoll</name><argument_list>(<argument><expr><operator>(</operator><name>LPWSTR</name><operator>)</operator> <name>a1p</name></expr></argument>, <argument><expr><operator>(</operator><name>LPWSTR</name><operator>)</operator> <name>a2p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">2147483647</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* _NLSCMPERROR; missing from mingw
										 * headers */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not compare Unicode strings: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * In some locales wcscoll() can claim that nonidentical strings
			 * are equal.  Believing that would be bad news for a number of
			 * reasons, so we follow Perl's lead and sort "equal" strings
			 * according to strcmp (on the UTF-8 representation).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>len1</name> <operator>!=</operator> <name>len2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>len1</name> <operator>&lt;</operator> <name>len2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>a1p</name> <operator>!=</operator> <name>a1buf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>a2p</name> <operator>!=</operator> <name>a2buf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>a2p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

		<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&gt;=</operator> <name>TEXTBUFLEN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>a1p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>a1p</name> <operator>=</operator> <name>a1buf</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>&gt;=</operator> <name>TEXTBUFLEN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>a2p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>a2p</name> <operator>=</operator> <name>a2buf</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a1p</name><index>[<expr><name>len1</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a2p</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a2p</name><index>[<expr><name>len2</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>mylocale</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>mylocale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UCOL_STRCOLLUTF8</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PG_UTF8</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ucol_strcollUTF8</name><argument_list>(<argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>icu</name><operator>.</operator><name>ucol</name></name></expr></argument>,
											  <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>,
											  <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation failed: %s"</literal></expr></argument>, <argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int32_t</name></type>		<name>ulen1</name></decl>,
								<decl><type ref="prev"/><name>ulen2</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>UChar</name>	   <modifier>*</modifier></type><name>uchar1</name></decl>,
							   <decl><type ref="prev"><modifier>*</modifier></type><name>uchar2</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>ulen1</name> <operator>=</operator> <call><name>icu_to_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uchar1</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ulen2</name> <operator>=</operator> <call><name>icu_to_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uchar2</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ucol_strcoll</name><argument_list>(<argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>icu</name><operator>.</operator><name>ucol</name></name></expr></argument>,
										  <argument><expr><name>uchar1</name></expr></argument>, <argument><expr><name>ulen1</name></expr></argument>,
										  <argument><expr><name>uchar2</name></expr></argument>, <argument><expr><name>ulen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>uchar1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>uchar2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* not USE_ICU */</comment>
				<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported collprovider: %c"</literal></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>provider</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_ICU */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strcoll_l</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>a2p</name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported collprovider: %c"</literal></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>provider</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strcoll</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>a2p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * In some locales strcoll() can claim that nonidentical strings are
		 * equal.  Believing that would be bad news for a number of reasons,
		 * so we follow Perl's lead and sort "equal" strings according to
		 * strcmp().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>a2p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>a1p</name> <operator>!=</operator> <name>a1buf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>a2p</name> <operator>!=</operator> <name>a2buf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>a2p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* text_cmp()
 * Internal comparison function for text strings.
 * Returns -1, 0 or 1
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>text_cmp</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>a1p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>a2p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>a1p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>a2p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>varstr_cmp</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>, <argument><expr><name>a2p</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison functions for text strings.
 *
 * Note: btree indexes need these routines not to leak memory; therefore,
 * be careful to free working copies of toasted datums.  Most places don't
 * need to be so careful.
 */</comment>

<function><type><name>Datum</name></type>
<name>texteq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since we only care about equality or not-equality, we can avoid all the
	 * expense of strcoll() here, and just do bitwise comparison.  In fact, we
	 * don't even have to do a bitwise comparison if we can show the lengths
	 * of the strings are unequal; which might save us from having to detoast
	 * one or both values.
	 */</comment>
	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>!=</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>targ1</name> <init>= <expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>targ2</name> <init>= <expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>targ1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>targ2</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>len1</name> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>targ1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>targ2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>textne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

	<comment type="block">/* See comment in texteq() */</comment>
	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>!=</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>targ1</name> <init>= <expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>targ2</name> <init>= <expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>targ1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>targ2</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>len1</name> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>targ1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>targ2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>text_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>text_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>text_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>text_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>text_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>text_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>text_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>text_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>text_starts_with</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>&gt;</operator> <name>len1</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>targ1</name> <init>= <expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>targ2</name> <init>= <expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>targ1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>targ2</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>targ2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>targ1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>targ2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bttextcmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>text_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bttextsortsupport</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name> <init>= <expr><operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name> <init>= <expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_collation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use generic string SortSupport */</comment>
	<expr_stmt><expr><call><name>varstr_sortsupport</name><argument_list>(<argument><expr><name>ssup</name></expr></argument>, <argument><expr><name>collid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generic sortsupport interface for character type's operator classes.
 * Includes locale support, and support for BpChar semantics (i.e. removing
 * trailing spaces before comparison).
 *
 * Relies on the assumption that text, VarChar, BpChar, and bytea all have the
 * same representation.  Callers that always use the C collation (e.g.
 * non-collatable type callers like bytea) may have NUL bytes in their strings;
 * this will not work with any other collation, though.
 */</comment>
<function><type><name>void</name></type>
<name>varstr_sortsupport</name><parameter_list>(<parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>bpchar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>abbreviate</name> <init>= <expr><name><name>ssup</name><operator>-&gt;</operator><name>abbreviate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>collate_c</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarStringSortSupport</name> <modifier>*</modifier></type><name>sss</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_locale_t</name></type> <name>locale</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If possible, set ssup-&gt;comparator to a function which can be used to
	 * directly compare two datums.  If we can do this, we'll avoid the
	 * overhead of a trip through the fmgr layer for every comparison, which
	 * can be substantial.
	 *
	 * Most typically, we'll set the comparator to varstrfastcmp_locale, which
	 * uses strcoll() to perform comparisons and knows about the special
	 * requirements of BpChar callers.  However, if LC_COLLATE = C, we can
	 * make things quite a bit faster with varstrfastcmp_c or bpcharfastcmp_c,
	 * both of which use memcmp() rather than strcoll().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lc_collate_is_c</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bpchar</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>varstrfastcmp_c</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>bpcharfastcmp_c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>collate_c</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We need a collation-sensitive comparison.  To make things faster,
		 * we'll figure out the collation based on the locale id and cache the
		 * result.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>collid</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This typically means that the parser could not resolve a
				 * conflict of implicit collations, so report it that way.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for string comparison"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>locale</name> <operator>=</operator> <call><name>pg_newlocale_from_collation</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * There is a further exception on Windows.  When the database
		 * encoding is UTF-8 and we are not using the C collation, complex
		 * hacks are required.  We don't currently have a comparator that
		 * handles that case, so we fall back on the slow method of having the
		 * sort code invoke bttextcmp() (in the case of text) via the fmgr
		 * trampoline.  ICU locales work just the same on Windows, however.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PG_UTF8</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name>locale</name> <operator>&amp;&amp;</operator> <name><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>varstrfastcmp_locale</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Unfortunately, it seems that abbreviation for non-C collations is
	 * broken on many common platforms; testing of multiple versions of glibc
	 * reveals that, for many locales, strcoll() and strxfrm() do not return
	 * consistent results, which is fatal to this optimization.  While no
	 * other libc other than Cygwin has so far been shown to have a problem,
	 * we take the conservative course of action for right now and disable
	 * this categorically.  (Users who are certain this isn't a problem on
	 * their system can define TRUST_STRXFRM.)
	 *
	 * Even apart from the risk of broken locales, it's possible that there
	 * are platforms where the use of abbreviated keys should be disabled at
	 * compile time.  Having only 4 byte datums could make worst-case
	 * performance drastically more likely, for example.  Moreover, macOS's
	 * strxfrm() implementation is known to not effectively concentrate a
	 * significant amount of entropy from the original string in earlier
	 * transformed blobs.  It's possible that other supported platforms are
	 * similarly encumbered.  So, if we ever get past disabling this
	 * categorically, we may still want or need to disable it for particular
	 * platforms.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TRUST_STRXFRM</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>collate_c</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>locale</name> <operator>&amp;&amp;</operator> <name><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>abbreviate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If we're using abbreviated keys, or if we're using a locale-aware
	 * comparison, we need to initialize a StringSortSupport object.  Both
	 * cases will make use of the temporary buffers we initialize here for
	 * scratch space (and to detect requirement for BpChar semantics from
	 * caller), and the abbreviation case requires additional state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>abbreviate</name> <operator>||</operator> <operator>!</operator><name>collate_c</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sss</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VarStringSortSupport</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>TEXTBUFLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen1</name></name> <operator>=</operator> <name>TEXTBUFLEN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>TEXTBUFLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name> <operator>=</operator> <name>TEXTBUFLEN</name></expr>;</expr_stmt>
		<comment type="block">/* Start with invalid values */</comment>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>last_len1</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>last_len2</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<comment type="block">/* Initialize */</comment>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>last_returned</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name></name> <operator>=</operator> <name>locale</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * To avoid somehow confusing a strxfrm() blob and an original string,
		 * constantly keep track of the variety of data that buf1 and buf2
		 * currently contain.
		 *
		 * Comparisons may be interleaved with conversion calls.  Frequently,
		 * conversions and comparisons are batched into two distinct phases,
		 * but the correctness of caching cannot hinge upon this.  For
		 * comparison caching, buffer state is only trusted if cache_blob is
		 * found set to false, whereas strxfrm() caching only trusts the state
		 * when cache_blob is found set to true.
		 *
		 * Arbitrarily initialize cache_blob to true.
		 */</comment>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>cache_blob</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>collate_c</name></name> <operator>=</operator> <name>collate_c</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>bpchar</name></name> <operator>=</operator> <name>bpchar</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_extra</name></name> <operator>=</operator> <name>sss</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If possible, plan to use the abbreviated keys optimization.  The
		 * core code may switch back to authoritative comparator should
		 * abbreviation be aborted.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>abbreviate</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>prop_card</name></name> <operator>=</operator> <literal type="number">0.20</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sss</name><operator>-&gt;</operator><name>abbr_card</name></name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>initHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sss</name><operator>-&gt;</operator><name>full_card</name></name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>abbrev_full_comparator</name></name> <operator>=</operator> <name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>comparator</name></name> <operator>=</operator> <name>varstrcmp_abbrev</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>abbrev_converter</name></name> <operator>=</operator> <name>varstr_abbrev_convert</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ssup</name><operator>-&gt;</operator><name>abbrev_abort</name></name> <operator>=</operator> <name>varstr_abbrev_abort</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * sortsupport comparison func (for C locale case)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>varstrfastcmp_c</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarString</name>  <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>DatumGetVarStringPP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarString</name>  <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>DatumGetVarStringPP</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>a1p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>a2p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>,
				<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>a1p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>a2p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>a2p</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>len1</name> <operator>!=</operator> <name>len2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>len1</name> <operator>&lt;</operator> <name>len2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We can't afford to leak memory here. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>x</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>y</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * sortsupport comparison func (for BpChar C locale case)
 *
 * BpChar outsources its sortsupport to this module.  Specialization for the
 * varstr_sortsupport BpChar case, modeled on
 * internal_bpchar_pattern_compare().
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bpcharfastcmp_c</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BpChar</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>DatumGetBpCharPP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BpChar</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>DatumGetBpCharPP</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>a1p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>a2p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>,
				<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>a1p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>a2p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>bpchartruelen</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>bpchartruelen</name><argument_list>(<argument><expr><name>a2p</name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>a2p</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>result</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>len1</name> <operator>!=</operator> <name>len2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>len1</name> <operator>&lt;</operator> <name>len2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We can't afford to leak memory here. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>x</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>y</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * sortsupport comparison func (for locale case)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>varstrfastcmp_locale</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarString</name>  <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>DatumGetVarStringPP</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarString</name>  <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>DatumGetVarStringPP</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>arg1_match</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarStringSortSupport</name> <modifier>*</modifier></type><name>sss</name> <init>= <expr><operator>(</operator><name>VarStringSortSupport</name> <operator>*</operator><operator>)</operator> <name><name>ssup</name><operator>-&gt;</operator><name>ssup_extra</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* working state */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>a1p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>a2p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>,
				<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>a1p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>a2p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fast pre-check for equality, as discussed in varstr_cmp() */</comment>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>==</operator> <name>len2</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>a2p</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No change in buf1 or buf2 contents, so avoid changing last_len1 or
		 * last_len2.  Existing contents of buffers might still be used by
		 * next call.
		 *
		 * It's fine to allow the comparison of BpChar padding bytes here,
		 * even though that implies that the memcmp() will usually be
		 * performed for BpChar callers (though multibyte characters could
		 * still prevent that from occurring).  The memcmp() is still very
		 * cheap, and BpChar's funny semantics have us remove trailing spaces
		 * (not limited to padding), so we need make no distinction between
		 * padding space characters and "real" space characters.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sss</name><operator>-&gt;</operator><name>bpchar</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get true number of bytes, ignoring trailing spaces */</comment>
		<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>bpchartruelen</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>bpchartruelen</name><argument_list>(<argument><expr><name>a2p</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&gt;=</operator> <name><name>sss</name><operator>-&gt;</operator><name>buflen1</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen1</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>len1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen1</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>MaxAllocSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_cxt</name></name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>&gt;=</operator> <name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>len2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>MaxAllocSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_cxt</name></name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We're likely to be asked to compare the same strings repeatedly, and
	 * memcmp() is so much cheaper than strcoll() that it pays to try to cache
	 * comparisons, even though in general there is no reason to think that
	 * that will work out (every string datum may be unique).  Caching does
	 * not slow things down measurably when it doesn't work out, and can speed
	 * things up by rather a lot when it does.  In part, this is because the
	 * memcmp() compares data from cachelines that are needed in L1 cache even
	 * when the last comparison's result cannot be reused.
	 */</comment>
	<expr_stmt><expr><name>arg1_match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>!=</operator> <name><name>sss</name><operator>-&gt;</operator><name>last_len1</name></name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>, <argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>arg1_match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>, <argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name><index>[<expr><name>len1</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>last_len1</name></name> <operator>=</operator> <name>len1</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we're comparing the same two strings as last time, we can return the
	 * same answer without calling strcoll() again.  This is more likely than
	 * it seems (at least with moderate to low cardinality sets), because
	 * quicksort compares the same pivot against many values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>!=</operator> <name><name>sss</name><operator>-&gt;</operator><name>last_len2</name></name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>, <argument><expr><name>a2p</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>, <argument><expr><name>a2p</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name><index>[<expr><name>len2</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>last_len2</name></name> <operator>=</operator> <name>len2</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>arg1_match</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sss</name><operator>-&gt;</operator><name>cache_blob</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use result cached following last actual strcoll() call */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>sss</name><operator>-&gt;</operator><name>last_returned</name></name></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UCOL_STRCOLLUTF8</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PG_UTF8</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ucol_strcollUTF8</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>icu</name><operator>.</operator><name>ucol</name></name></expr></argument>,
										  <argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>,
										  <argument><expr><name>a2p</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation failed: %s"</literal></expr></argument>, <argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int32_t</name></type>		<name>ulen1</name></decl>,
							<decl><type ref="prev"/><name>ulen2</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>UChar</name>	   <modifier>*</modifier></type><name>uchar1</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>uchar2</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>ulen1</name> <operator>=</operator> <call><name>icu_to_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uchar1</name></expr></argument>, <argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ulen2</name> <operator>=</operator> <call><name>icu_to_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uchar2</name></expr></argument>, <argument><expr><name>a2p</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ucol_strcoll</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>icu</name><operator>.</operator><name>ucol</name></name></expr></argument>,
									  <argument><expr><name>uchar1</name></expr></argument>, <argument><expr><name>ulen1</name></expr></argument>,
									  <argument><expr><name>uchar2</name></expr></argument>, <argument><expr><name>ulen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>uchar1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>uchar2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* not USE_ICU */</comment>
			<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported collprovider: %c"</literal></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>provider</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* not USE_ICU */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strcoll_l</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported collprovider: %c"</literal></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>provider</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strcoll</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * In some locales strcoll() can claim that nonidentical strings are
	 * equal. Believing that would be bad news for a number of reasons, so we
	 * follow Perl's lead and sort "equal" strings according to strcmp().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Cache result, perhaps saving an expensive strcoll() call next time */</comment>
	<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>cache_blob</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>last_returned</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
<label><name>done</name>:</label>
	<comment type="block">/* We can't afford to leak memory here. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>x</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>y</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Abbreviated key comparison func
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>varstrcmp_abbrev</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * When 0 is returned, the core system will call varstrfastcmp_c()
	 * (bpcharfastcmp_c() in BpChar case) or varstrfastcmp_locale().  Even a
	 * strcmp() on two non-truncated strxfrm() blobs cannot indicate *equality*
	 * authoritatively, for the same reason that there is a strcoll()
	 * tie-breaker call to strcmp() in varstr_cmp().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <name>y</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>x</name> <operator>==</operator> <name>y</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Conversion routine for sortsupport.  Converts original to abbreviated key
 * representation.  Our encoding strategy is simple -- pack the first 8 bytes
 * of a strxfrm() blob into a Datum (on little-endian machines, the 8 bytes are
 * stored in reverse order), and treat it as an unsigned integer.  When the "C"
 * locale is used, or in case of bytea, just memcpy() from original instead.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>varstr_abbrev_convert</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>original</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarStringSortSupport</name> <modifier>*</modifier></type><name>sss</name> <init>= <expr><operator>(</operator><name>VarStringSortSupport</name> <operator>*</operator><operator>)</operator> <name><name>ssup</name><operator>-&gt;</operator><name>ssup_extra</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarString</name>  <modifier>*</modifier></type><name>authoritative</name> <init>= <expr><call><name>DatumGetVarStringPP</name><argument_list>(<argument><expr><name>original</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>authoritative_data</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>authoritative</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* working state */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hash</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pres</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>res</name></expr>;</expr_stmt>
	<comment type="block">/* memset(), so any non-overwritten bytes are NUL */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pres</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>authoritative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get number of bytes, ignoring trailing spaces */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sss</name><operator>-&gt;</operator><name>bpchar</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>bpchartruelen</name><argument_list>(<argument><expr><name>authoritative_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we're using the C collation, use memcpy(), rather than strxfrm(), to
	 * abbreviate keys.  The full comparator for the C locale is always
	 * memcmp().  It would be incorrect to allow bytea callers (callers that
	 * always force the C collation -- bytea isn't a collatable type, but this
	 * approach is convenient) to use strxfrm().  This is because bytea
	 * strings may contain NUL bytes.  Besides, this should be faster, too.
	 *
	 * More generally, it's okay that bytea callers can have NUL bytes in
	 * strings because varstrcmp_abbrev() need not make a distinction between
	 * terminating NUL bytes, and NUL bytes representing actual NULs in the
	 * authoritative representation.  Hopefully a comparison at or past one
	 * abbreviated key's terminating NUL byte will resolve the comparison
	 * without consulting the authoritative representation; specifically, some
	 * later non-NUL byte in the longer string can resolve the comparison
	 * against a subsequent terminating NUL in the shorter string.  There will
	 * usually be what is effectively a "length-wise" resolution there and
	 * then.
	 *
	 * If that doesn't work out -- if all bytes in the longer string
	 * positioned at or past the offset of the smaller string's (first)
	 * terminating NUL are actually representative of NUL bytes in the
	 * authoritative binary string (perhaps with some *terminating* NUL bytes
	 * towards the end of the longer string iff it happens to still be small)
	 * -- then an authoritative tie-breaker will happen, and do the right
	 * thing: explicitly consider string length.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sss</name><operator>-&gt;</operator><name>collate_c</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pres</name></expr></argument>, <argument><expr><name>authoritative_data</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>bsize</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
		<decl_stmt><decl><type><name>int32_t</name></type>		<name>ulen</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>UChar</name>	   <modifier>*</modifier></type><name>uchar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * We're not using the C collation, so fall back on strxfrm or ICU
		 * analogs.
		 */</comment>

		<comment type="block">/* By convention, we use buffer 1 to store and NUL-terminate */</comment>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name><name>sss</name><operator>-&gt;</operator><name>buflen1</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen1</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen1</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>MaxAllocSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Might be able to reuse strxfrm() blob from last call */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sss</name><operator>-&gt;</operator><name>last_len1</name></name> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>sss</name><operator>-&gt;</operator><name>cache_blob</name></name> <operator>&amp;&amp;</operator>
			<call><name>memcmp</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>, <argument><expr><name>authoritative_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pres</name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>last_len2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* No change affecting cardinality, so no hashing required */</comment>
			<goto>goto <name>done</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>, <argument><expr><name>authoritative_data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Just like strcoll(), strxfrm() expects a NUL-terminated string. Not
		 * necessary for ICU, but doesn't hurt.
		 */</comment>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>last_len1</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
		<comment type="block">/* When using ICU and not UTF8, convert string to UChar. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name></name> <operator>&amp;&amp;</operator> <name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name> <operator>&amp;&amp;</operator>
			<call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>PG_UTF8</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ulen</name> <operator>=</operator> <call><name>icu_to_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uchar</name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Loop: Call strxfrm() or ucol_getSortKey(), possibly enlarge buffer,
		 * and try again.  Both of these functions have the result buffer
		 * content undefined if the result did not fit, so we need to retry
		 * until everything fits, even though we only need the first few bytes
		 * in the end.  When using ucol_nextSortKeyPart(), however, we only
		 * ask for as many bytes as we actually need.
		 */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name></name> <operator>&amp;&amp;</operator> <name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * When using UTF8, use the iteration interface so we only
				 * need to produce as many bytes as we actually need.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PG_UTF8</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>UCharIterator</name></type> <name>iter</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>uint32_t</name></type>	<name><name>state</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>uiter_setUTF8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* won't need that again */</comment>
					<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>bsize</name> <operator>=</operator> <call><name>ucol_nextSortKeyPart</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>icu</name><operator>.</operator><name>ucol</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>,
												 <argument><expr><name>state</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>,
												 <argument><expr><call><name>Min</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sort key generation failed: %s"</literal></expr></argument>,
										<argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>bsize</name> <operator>=</operator> <call><name>ucol_getSortKey</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>icu</name><operator>.</operator><name>ucol</name></name></expr></argument>,
											<argument><expr><name>uchar</name></expr></argument>, <argument><expr><name>ulen</name></expr></argument>,
											<argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			if <condition>(<expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name></name> <operator>&amp;&amp;</operator> <name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_LIBC</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>bsize</name> <operator>=</operator> <call><name>strxfrm_l</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>,
								  <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>bsize</name> <operator>=</operator> <call><name>strxfrm</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf1</name></name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>last_len2</name></name> <operator>=</operator> <name>bsize</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>bsize</name> <operator>&lt;</operator> <name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Grow buffer and retry.
			 */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>bsize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>MaxAllocSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buflen2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Every Datum byte is always compared.  This is safe because the
		 * strxfrm() blob is itself NUL terminated, leaving no danger of
		 * misinterpreting any NUL bytes not intended to be interpreted as
		 * logically representing termination.
		 *
		 * (Actually, even if there were NUL bytes in the blob it would be
		 * okay.  See remarks on bytea case above.)
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pres</name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>buf2</name></name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>uchar</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>uchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Maintain approximate cardinality of both abbreviated keys and original,
	 * authoritative keys using HyperLogLog.  Used as cheap insurance against
	 * the worst case, where we do many string transformations for no saving
	 * in full strcoll()-based comparisons.  These statistics are used by
	 * varstr_abbrev_abort().
	 *
	 * First, Hash key proper, or a significant fraction of it.  Mix in length
	 * in order to compensate for cases where differences are past
	 * PG_CACHE_LINE_SIZE bytes, so as to limit the overhead of hashing.
	 */</comment>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>authoritative_data</name></expr></argument>,
								   <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>PG_CACHE_LINE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>PG_CACHE_LINE_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hash</name> <operator>^=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>addHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sss</name><operator>-&gt;</operator><name>full_card</name></name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Hash abbreviated key */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_DATUM</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>lohalf</name></decl>,
					<decl><type ref="prev"/><name>hihalf</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lohalf</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>res</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hihalf</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>res</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name>lohalf</name> <operator>^</operator> <name>hihalf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* SIZEOF_DATUM != 8 */</comment>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>addHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sss</name><operator>-&gt;</operator><name>abbr_card</name></name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Cache result, perhaps saving an expensive strxfrm() call next time */</comment>
	<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>cache_blob</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<label><name>done</name>:</label>

	<comment type="block">/*
	 * Byteswap on little-endian machines.
	 *
	 * This is needed so that varstrcmp_abbrev() (an unsigned integer 3-way
	 * comparator) works correctly on all platforms.  If we didn't do this,
	 * the comparator would have to call memcmp() with a pair of pointers to
	 * the first byte of each abbreviated key, which is slower.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>DatumBigEndianToNative</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't leak memory here */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>authoritative</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>original</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>authoritative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Callback for estimating effectiveness of abbreviated key optimization, using
 * heuristic rules.  Returns value indicating if the abbreviation optimization
 * should be aborted, based on its projected effectiveness.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>varstr_abbrev_abort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>memtupcount</name></decl></parameter>, <parameter><decl><type><name>SortSupport</name></type> <name>ssup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarStringSortSupport</name> <modifier>*</modifier></type><name>sss</name> <init>= <expr><operator>(</operator><name>VarStringSortSupport</name> <operator>*</operator><operator>)</operator> <name><name>ssup</name><operator>-&gt;</operator><name>ssup_extra</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>abbrev_distinct</name></decl>,
				<decl><type ref="prev"/><name>key_distinct</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ssup</name><operator>-&gt;</operator><name>abbreviate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Have a little patience */</comment>
	<if_stmt><if>if <condition>(<expr><name>memtupcount</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>abbrev_distinct</name> <operator>=</operator> <call><name>estimateHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sss</name><operator>-&gt;</operator><name>abbr_card</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>key_distinct</name> <operator>=</operator> <call><name>estimateHyperLogLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sss</name><operator>-&gt;</operator><name>full_card</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clamp cardinality estimates to at least one distinct value.  While
	 * NULLs are generally disregarded, if only NULL values were seen so far,
	 * that might misrepresent costs if we failed to clamp.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>abbrev_distinct</name> <operator>&lt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>abbrev_distinct</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>key_distinct</name> <operator>&lt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>key_distinct</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * In the worst case all abbreviated keys are identical, while at the same
	 * time there are differences within full key strings not captured in
	 * abbreviations.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>norm_abbrev_card</name> <init>= <expr><name>abbrev_distinct</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>memtupcount</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"varstr_abbrev: abbrev_distinct after %d: %f "</literal>
			 <literal type="string">"(key_distinct: %f, norm_abbrev_card: %f, prop_card: %f)"</literal></expr></argument>,
			 <argument><expr><name>memtupcount</name></expr></argument>, <argument><expr><name>abbrev_distinct</name></expr></argument>, <argument><expr><name>key_distinct</name></expr></argument>, <argument><expr><name>norm_abbrev_card</name></expr></argument>,
			 <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>prop_card</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If the number of distinct abbreviated keys approximately matches the
	 * number of distinct authoritative original keys, that's reason enough to
	 * proceed.  We can win even with a very low cardinality set if most
	 * tie-breakers only memcmp().  This is by far the most important
	 * consideration.
	 *
	 * While comparisons that are resolved at the abbreviated key level are
	 * considerably cheaper than tie-breakers resolved with memcmp(), both of
	 * those two outcomes are so much cheaper than a full strcoll() once
	 * sorting is underway that it doesn't seem worth it to weigh abbreviated
	 * cardinality against the overall size of the set in order to more
	 * accurately model costs.  Assume that an abbreviated comparison, and an
	 * abbreviated comparison with a cheap memcmp()-based authoritative
	 * resolution are equivalent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>abbrev_distinct</name> <operator>&gt;</operator> <name>key_distinct</name> <operator>*</operator> <name><name>sss</name><operator>-&gt;</operator><name>prop_card</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When we have exceeded 10,000 tuples, decay required cardinality
		 * aggressively for next call.
		 *
		 * This is useful because the number of comparisons required on
		 * average increases at a linearithmic rate, and at roughly 10,000
		 * tuples that factor will start to dominate over the linear costs of
		 * string transformation (this is a conservative estimate).  The decay
		 * rate is chosen to be a little less aggressive than halving -- which
		 * (since we're called at points at which memtupcount has doubled)
		 * would never see the cost model actually abort past the first call
		 * following a decay.  This decay rate is mostly a precaution against
		 * a sudden, violent swing in how well abbreviated cardinality tracks
		 * full key cardinality.  The decay also serves to prevent a marginal
		 * case from being aborted too late, when too much has already been
		 * invested in string transformation.
		 *
		 * It's possible for sets of several million distinct strings with
		 * mere tens of thousands of distinct abbreviated keys to still
		 * benefit very significantly.  This will generally occur provided
		 * each abbreviated key is a proxy for a roughly uniform number of the
		 * set's full keys. If it isn't so, we hope to catch that early and
		 * abort.  If it isn't caught early, by the time the problem is
		 * apparent it's probably not worth aborting.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>memtupcount</name> <operator>&gt;</operator> <literal type="number">10000</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sss</name><operator>-&gt;</operator><name>prop_card</name></name> <operator>*=</operator> <literal type="number">0.65</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Abort abbreviation strategy.
	 *
	 * The worst case, where all abbreviated keys are identical while all
	 * original strings differ will typically only see a regression of about
	 * 10% in execution time for small to medium sized lists of strings.
	 * Whereas on modern CPUs where cache stalls are the dominant cost, we can
	 * often expect very large improvements, particularly with sets of strings
	 * of moderately high to high abbreviated cardinality.  There is little to
	 * lose but much to gain, which our strategy reflects.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SORT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>trace_sort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"varstr_abbrev: aborted abbreviation at %d "</literal>
			 <literal type="string">"(abbrev_distinct: %f, key_distinct: %f, prop_card: %f)"</literal></expr></argument>,
			 <argument><expr><name>memtupcount</name></expr></argument>, <argument><expr><name>abbrev_distinct</name></expr></argument>, <argument><expr><name>key_distinct</name></expr></argument>, <argument><expr><name><name>sss</name><operator>-&gt;</operator><name>prop_card</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>text_larger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>text_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>arg1</name></expr> </then><else>: <expr><name>arg2</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>text_smaller</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>text_cmp</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>arg1</name></expr> </then><else>: <expr><name>arg2</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * The following operators support character-by-character comparison
 * of text datums, to allow building indexes suitable for LIKE clauses.
 * Note that the regular texteq/textne comparison operators, and regular
 * support functions 1 and 2 with "C" collation are assumed to be
 * compatible with these!
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_text_pattern_compare</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>len1</name> <operator>&lt;</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>len1</name> <operator>&gt;</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>text_pattern_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>internal_text_pattern_compare</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>text_pattern_le</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>internal_text_pattern_compare</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>text_pattern_ge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>internal_text_pattern_compare</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>text_pattern_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>internal_text_pattern_compare</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>bttext_pattern_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>internal_text_pattern_compare</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>bttext_pattern_sortsupport</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name> <init>= <expr><operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use generic string SortSupport, forcing "C" collation */</comment>
	<expr_stmt><expr><call><name>varstr_sortsupport</name><argument_list>(<argument><expr><name>ssup</name></expr></argument>, <argument><expr><name>C_COLLATION_OID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------
 * byteaoctetlen
 *
 * get the number of bytes contained in an instance of type 'bytea'
 *-------------------------------------------------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>byteaoctetlen</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>str</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We need not detoast the input at all */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * byteacat -
 *	  takes two bytea* and returns a bytea* that is the concatenation of
 *	  the two.
 *
 * Cloned from textcat and modified as required.
 */</comment>
<function><type><name>Datum</name></type>
<name>byteacat</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>t1</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>t2</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>bytea_catenate</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bytea_catenate
 *	Guts of byteacat(), broken out so it can be used by other functions
 *
 * Arguments can be in short-header form, but not compressed or out-of-line
 */</comment>
<function><type><specifier>static</specifier> <name>bytea</name> <modifier>*</modifier></type>
<name>bytea_catenate</name><parameter_list>(<parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>,
				<decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* paranoia ... probably should throw error instead? */</comment>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>len1</name> <operator>+</operator> <name>len2</name> <operator>+</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set size of result string... */</comment>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill data field of result string... */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>len1</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_STR_GET_BYTEA</name><parameter_list>(<parameter><type><name>str_</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>DatumGetByteaPP(DirectFunctionCall1(byteain, CStringGetDatum(str_)))</cpp:value></cpp:define>

<comment type="block">/*
 * bytea_substr()
 * Return a substring starting at the specified position.
 * Cloned from text_substr and modified as required.
 *
 * Input:
 *	- string
 *	- starting position (is one-based)
 *	- string length (optional)
 *
 * If the starting position is zero or less, then return from the start of the string
 * adjusting the length to be consistent with the "negative start" per SQL.
 * If the length is less than zero, an ERROR is thrown. If no third argument
 * (length) is provided, the length to the end of the string is assumed.
 */</comment>
<function><type><name>Datum</name></type>
<name>bytea_substr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>bytea_substring</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bytea_substr_no_len -
 *	  Wrapper to avoid opr_sanity failure due to
 *	  one function accepting a different number of args.
 */</comment>
<function><type><name>Datum</name></type>
<name>bytea_substr_no_len</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>bytea_substring</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bytea</name> <modifier>*</modifier></type>
<name>bytea_substring</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>str</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>S</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>L</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>length_not_specified</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>S1</name></decl>;</decl_stmt>				<comment type="block">/* adjusted start position */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>L1</name></decl>;</decl_stmt>				<comment type="block">/* adjusted substring length */</comment>

	<expr_stmt><expr><name>S1</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>length_not_specified</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Not passed a length - DatumGetByteaPSlice() grabs everything to the
		 * end of the string if we pass it a negative value for length.
		 */</comment>
		<expr_stmt><expr><name>L1</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* end position */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>E</name> <init>= <expr><name>S</name> <operator>+</operator> <name>L</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * A negative value for L is the only way for the end position to be
		 * before the start. SQL99 says to throw an error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>E</name> <operator>&lt;</operator> <name>S</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SUBSTRING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"negative substring length not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * A zero or negative value for the end position can happen if the
		 * start was negative or one. SQL99 says to return a zero-length
		 * string.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>E</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>PG_STR_GET_BYTEA</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>L1</name> <operator>=</operator> <name>E</name> <operator>-</operator> <name>S1</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the start position is past the end of the string, SQL99 says to
	 * return a zero-length string -- DatumGetByteaPSlice() will do that for
	 * us. Convert to zero-based starting position
	 */</comment>
	<return>return <expr><call><name>DatumGetByteaPSlice</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>S1</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>L1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * byteaoverlay
 *	Replace specified substring of first string with second
 *
 * The SQL standard defines OVERLAY() in terms of substring and concatenation.
 * This code is a direct implementation of what the standard says.
 */</comment>
<function><type><name>Datum</name></type>
<name>byteaoverlay</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>t1</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>t2</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sp</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* substring start position */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sl</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* substring length */</comment>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>bytea_overlay</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>byteaoverlay_no_len</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>t1</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>t2</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sp</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* substring start position */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sl</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* defaults to length(t2) */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>bytea_overlay</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bytea</name> <modifier>*</modifier></type>
<name>bytea_overlay</name><parameter_list>(<parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>s1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sp_pl_sl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check for possible integer-overflow cases.  For negative sp, throw a
	 * "substring length" error because that's what should be expected
	 * according to the spec's definition of OVERLAY().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SUBSTRING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"negative substring length not allowed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_add_s32_overflow</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sp_pl_sl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"integer out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>bytea_substring</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>sp</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>bytea_substring</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sp_pl_sl</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bytea_catenate</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bytea_catenate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * byteapos -
 *	  Return the position of the specified substring.
 *	  Implements the SQL POSITION() function.
 * Cloned from textpos and modified as required.
 */</comment>
<function><type><name>Datum</name></type>
<name>byteapos</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>t1</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>t2</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>px</name></decl>,
				<decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p1</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len2</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* result for empty pattern */</comment>

	<expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>px</name> <operator>=</operator> <operator>(</operator><name>len1</name> <operator>-</operator> <name>len2</name><operator>)</operator></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name> <operator>&lt;=</operator> <name>px</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p2</name> <operator>==</operator> <operator>*</operator><name>p1</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
		<expr_stmt><expr><name>p1</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for><empty_stmt>;</empty_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------
 * byteaGetByte
 *
 * this routine treats "bytea" as an array of bytes.
 * It returns the Nth byte (a number between 0 and 255).
 *-------------------------------------------------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>byteaGetByte</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>byte</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index %d out of valid range, 0..%d"</literal></expr></argument>,
						<argument><expr><name>n</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><name>n</name></expr>]</index></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------
 * byteaGetBit
 *
 * This routine treats a "bytea" type like an array of bits.
 * It returns the value of the Nth bit (0 or 1).
 *
 *-------------------------------------------------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>byteaGetBit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>byteNo</name></decl>,
				<decl><type ref="prev"/><name>bitNo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>byte</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do comparison arithmetic in int64 in case len exceeds INT_MAX/8 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>len</name> <operator>*</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index %d out of valid range, 0..%d"</literal></expr></argument>,
						<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>len</name> <operator>*</operator> <literal type="number">8</literal> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>byteNo</name> <operator>=</operator> <name>n</name> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitNo</name> <operator>=</operator> <name>n</name> <operator>%</operator> <literal type="number">8</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><name>byteNo</name></expr>]</index></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>byte</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitNo</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------
 * byteaSetByte
 *
 * Given an instance of type 'bytea' creates a new one with
 * the Nth byte set to the given value.
 *
 *-------------------------------------------------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>byteaSetByte</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>PG_GETARG_BYTEA_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>newByte</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index %d out of valid range, 0..%d"</literal></expr></argument>,
						<argument><expr><name>n</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now set the byte.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><name>n</name></expr>]</index> <operator>=</operator> <name>newByte</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*-------------------------------------------------------------
 * byteaSetBit
 *
 * Given an instance of type 'bytea' creates a new one with
 * the Nth bit set to the given value.
 *
 *-------------------------------------------------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>byteaSetBit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>PG_GETARG_BYTEA_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>newBit</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldByte</name></decl>,
				<decl><type ref="prev"/><name>newByte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>byteNo</name></decl>,
				<decl><type ref="prev"/><name>bitNo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>

	<comment type="block">/* Do comparison arithmetic in int64 in case len exceeds INT_MAX/8 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>len</name> <operator>*</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index %d out of valid range, 0..%d"</literal></expr></argument>,
						<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>len</name> <operator>*</operator> <literal type="number">8</literal> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>byteNo</name> <operator>=</operator> <name>n</name> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitNo</name> <operator>=</operator> <name>n</name> <operator>%</operator> <literal type="number">8</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * sanity check!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newBit</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>newBit</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"new bit must be 0 or 1"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Update the byte.
	 */</comment>
	<expr_stmt><expr><name>oldByte</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><name>byteNo</name></expr>]</index></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>newBit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newByte</name> <operator>=</operator> <name>oldByte</name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitNo</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newByte</name> <operator>=</operator> <name>oldByte</name> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitNo</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><name>byteNo</name></expr>]</index> <operator>=</operator> <name>newByte</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* text_name()
 * Converts a text type to a Name type.
 */</comment>
<function><type><name>Datum</name></type>
<name>text_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Truncate oversize input */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We use palloc0 here to ensure result is zero-padded */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Name</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NAME</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* name_text()
 * Converts a Name type to a text type.
 */</comment>
<function><type><name>Datum</name></type>
<name>name_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Name</name></type>		<name>s</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * textToQualifiedNameList - convert a text object to list of names
 *
 * This implements the input parsing needed by nextval() and other
 * functions that take a text parameter representing a qualified name.
 * We split the name at dots, downcase if not double-quoted, and
 * truncate names if they're too long.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>textToQualifiedNameList</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>textval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Convert to C string (handles possible detoasting). */</comment>
	<comment type="block">/* Note we rely on being able to modify rawname below. */</comment>
	<expr_stmt><expr><name>rawname</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>textval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid name syntax"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>namelist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_NAME</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid name syntax"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>namelist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SplitIdentifierString --- parse a string containing identifiers
 *
 * This is the guts of textToQualifiedNameList, and is exported for use in
 * other situations such as parsing GUC variables.  In the GUC case, it's
 * important to avoid memory leaks, so the API is designed to minimize the
 * amount of stuff that needs to be allocated and freed.
 *
 * Inputs:
 *	rawstring: the input string; must be overwritable!	On return, it's
 *			   been modified to contain the separated identifiers.
 *	separator: the separator punctuation expected between identifiers
 *			   (typically '.' or ',').  Whitespace may also appear around
 *			   identifiers.
 * Outputs:
 *	namelist: filled with a palloc'd list of pointers to identifiers within
 *			  rawstring.  Caller should list_free() this even on error return.
 *
 * Returns true if okay, false if there is a syntax error in the string.
 *
 * Note that an empty string is considered okay here, though not in
 * textToQualifiedNameList.
 */</comment>
<function><type><name>bool</name></type>
<name>SplitIdentifierString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rawstring</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>separator</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>namelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nextp</name> <init>= <expr><name>rawstring</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>namelist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>				<comment type="block">/* skip leading whitespace */</comment>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* allow empty string */</comment>

	<comment type="block">/* At the top of the loop, we are at start of a new identifier. */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Quoted name --- collapse quote-quote pairs, no downcasing */</comment>
			<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>nextp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>nextp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* mismatched quotes */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>endp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* found end of quoted name */</comment>
				<comment type="block">/* Collapse adjacent quotes into one quote, and look again */</comment>
				<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>endp</name></expr></argument>, <argument><expr><name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>endp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nextp</name> <operator>=</operator> <name>endp</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<comment type="block">/* endp now points at the terminating quote */</comment>
			<expr_stmt><expr><name>nextp</name> <operator>=</operator> <name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Unquoted name --- extends to separator or whitespace */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>downname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>*</operator><name>nextp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nextp</name> <operator>!=</operator> <name>separator</name> <operator>&amp;&amp;</operator>
				   <operator>!</operator><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>nextp</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* empty unquoted name not allowed */</comment>

			<comment type="block">/*
			 * Downcase the identifier, using same code as main lexer does.
			 *
			 * XXX because we want to overwrite the input in-place, we cannot
			 * support a downcasing transformation that increases the string
			 * length.  This is not a problem given the current implementation
			 * of downcase_truncate_identifier, but we'll probably have to do
			 * something about this someday.
			 */</comment>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <name>endp</name> <operator>-</operator> <name>curname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>downname</name> <operator>=</operator> <call><name>downcase_truncate_identifier</name><argument_list>(<argument><expr><name>curname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>downname</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>curname</name></expr></argument>, <argument><expr><name>downname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* strncpy is required here */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>downname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<while>while <condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>			<comment type="block">/* skip trailing whitespace */</comment>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <name>separator</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>		<comment type="block">/* skip leading whitespace for next */</comment>
			<comment type="block">/* we expect another name, so done remains false */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>		<comment type="block">/* invalid syntax */</comment>

		<comment type="block">/* Now safe to overwrite separator with a null */</comment>
		<expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* Truncate name if it's overlength */</comment>
		<expr_stmt><expr><call><name>truncate_identifier</name><argument_list>(<argument><expr><name>curname</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Finished isolating current name --- add it to list
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>namelist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>namelist</name></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Loop back if we didn't reach end of string */</comment>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SplitDirectoriesString --- parse a string containing file/directory names
 *
 * This works fine on file names too; the function name is historical.
 *
 * This is similar to SplitIdentifierString, except that the parsing
 * rules are meant to handle pathnames instead of identifiers: there is
 * no downcasing, embedded spaces are allowed, the max length is MAXPGPATH-1,
 * and we apply canonicalize_path() to each extracted string.  Because of the
 * last, the returned strings are separately palloc'd rather than being
 * pointers into rawstring --- but we still scribble on rawstring.
 *
 * Inputs:
 *	rawstring: the input string; must be modifiable!
 *	separator: the separator punctuation expected between directories
 *			   (typically ',' or ';').  Whitespace may also appear around
 *			   directories.
 * Outputs:
 *	namelist: filled with a palloc'd list of directory names.
 *			  Caller should list_free_deep() this even on error return.
 *
 * Returns true if okay, false if there is a syntax error in the string.
 *
 * Note that an empty string is considered okay here.
 */</comment>
<function><type><name>bool</name></type>
<name>SplitDirectoriesString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rawstring</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>separator</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>namelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nextp</name> <init>= <expr><name>rawstring</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>namelist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>				<comment type="block">/* skip leading whitespace */</comment>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* allow empty string */</comment>

	<comment type="block">/* At the top of the loop, we are at start of a new directory. */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Quoted name --- collapse quote-quote pairs */</comment>
			<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>nextp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>nextp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* mismatched quotes */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>endp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* found end of quoted name */</comment>
				<comment type="block">/* Collapse adjacent quotes into one quote, and look again */</comment>
				<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>endp</name></expr></argument>, <argument><expr><name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>endp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nextp</name> <operator>=</operator> <name>endp</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<comment type="block">/* endp now points at the terminating quote */</comment>
			<expr_stmt><expr><name>nextp</name> <operator>=</operator> <name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Unquoted name --- extends to separator or end of string */</comment>
			<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>endp</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>*</operator><name>nextp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nextp</name> <operator>!=</operator> <name>separator</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* trailing whitespace should not be included in name */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>nextp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* empty unquoted name not allowed */</comment>
		</block_content>}</block></else></if_stmt>

		<while>while <condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>			<comment type="block">/* skip trailing whitespace */</comment>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <name>separator</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>		<comment type="block">/* skip leading whitespace for next */</comment>
			<comment type="block">/* we expect another name, so done remains false */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>		<comment type="block">/* invalid syntax */</comment>

		<comment type="block">/* Now safe to overwrite separator with a null */</comment>
		<expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* Truncate path if it's overlength */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>MAXPGPATH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>curname</name><index>[<expr><name>MAXPGPATH</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Finished isolating current name --- add it to list
		 */</comment>
		<expr_stmt><expr><name>curname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>namelist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>namelist</name></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Loop back if we didn't reach end of string */</comment>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SplitGUCList --- parse a string containing identifiers or file names
 *
 * This is used to split the value of a GUC_LIST_QUOTE GUC variable, without
 * presuming whether the elements will be taken as identifiers or file names.
 * We assume the input has already been through flatten_set_variable_args(),
 * so that we need never downcase (if appropriate, that was done already).
 * Nor do we ever truncate, since we don't know the correct max length.
 * We disallow embedded whitespace for simplicity (it shouldn't matter,
 * because any embedded whitespace should have led to double-quoting).
 * Otherwise the API is identical to SplitIdentifierString.
 *
 * XXX it's annoying to have so many copies of this string-splitting logic.
 * However, it's not clear that having one function with a bunch of option
 * flags would be much better.
 *
 * XXX there is a version of this function in src/bin/pg_dump/dumputils.c.
 * Be sure to update that if you have to change this.
 *
 * Inputs:
 *	rawstring: the input string; must be overwritable!	On return, it's
 *			   been modified to contain the separated identifiers.
 *	separator: the separator punctuation expected between identifiers
 *			   (typically '.' or ',').  Whitespace may also appear around
 *			   identifiers.
 * Outputs:
 *	namelist: filled with a palloc'd list of pointers to identifiers within
 *			  rawstring.  Caller should list_free() this even on error return.
 *
 * Returns true if okay, false if there is a syntax error in the string.
 */</comment>
<function><type><name>bool</name></type>
<name>SplitGUCList</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rawstring</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>separator</name></decl></parameter>,
			 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>namelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nextp</name> <init>= <expr><name>rawstring</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>namelist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>				<comment type="block">/* skip leading whitespace */</comment>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* allow empty string */</comment>

	<comment type="block">/* At the top of the loop, we are at start of a new identifier. */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Quoted name --- collapse quote-quote pairs */</comment>
			<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>nextp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>nextp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>endp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* mismatched quotes */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>endp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* found end of quoted name */</comment>
				<comment type="block">/* Collapse adjacent quotes into one quote, and look again */</comment>
				<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>endp</name></expr></argument>, <argument><expr><name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>endp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nextp</name> <operator>=</operator> <name>endp</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<comment type="block">/* endp now points at the terminating quote */</comment>
			<expr_stmt><expr><name>nextp</name> <operator>=</operator> <name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Unquoted name --- extends to separator or whitespace */</comment>
			<expr_stmt><expr><name>curname</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>*</operator><name>nextp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nextp</name> <operator>!=</operator> <name>separator</name> <operator>&amp;&amp;</operator>
				   <operator>!</operator><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>nextp</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>curname</name> <operator>==</operator> <name>nextp</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* empty unquoted name not allowed */</comment>
		</block_content>}</block></else></if_stmt>

		<while>while <condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>			<comment type="block">/* skip trailing whitespace */</comment>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <name>separator</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>scanner_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>nextp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nextp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>		<comment type="block">/* skip leading whitespace for next */</comment>
			<comment type="block">/* we expect another name, so done remains false */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>nextp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>		<comment type="block">/* invalid syntax */</comment>

		<comment type="block">/* Now safe to overwrite separator with a null */</comment>
		<expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Finished isolating current name --- add it to list
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>namelist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>namelist</name></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Loop back if we didn't reach end of string */</comment>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *	Comparison Functions used for bytea
 *
 * Note: btree indexes need these routines not to leak memory; therefore,
 * be careful to free working copies of toasted datums.  Most places don't
 * need to be so careful.
 *****************************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>byteaeq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can use a fast path for unequal lengths, which might save us from
	 * having to detoast one or both values.
	 */</comment>
	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>!=</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>barg1</name> <init>= <expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>barg2</name> <init>= <expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>barg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>barg2</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>len1</name> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>barg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>barg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>byteane</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg1</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg2</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can use a fast path for unequal lengths, which might save us from
	 * having to detoast one or both values.
	 */</comment>
	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>!=</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>barg1</name> <init>= <expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>barg2</name> <init>= <expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>barg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>barg2</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>len1</name> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>barg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>barg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bytealt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>(</operator><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>len1</name> <operator>&lt;</operator> <name>len2</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>byteale</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>(</operator><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>len1</name> <operator>&lt;=</operator> <name>len2</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>byteagt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>(</operator><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>len1</name> <operator>&gt;</operator> <name>len2</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>byteage</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><operator>(</operator><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>len1</name> <operator>&gt;=</operator> <name>len2</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>byteacmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len1</name></decl>,
				<decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>len1</name> <operator>!=</operator> <name>len2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>len1</name> <operator>&lt;</operator> <name>len2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>bytea_sortsupport</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortSupport</name></type> <name>ssup</name> <init>= <expr><operator>(</operator><name>SortSupport</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ssup</name><operator>-&gt;</operator><name>ssup_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use generic string SortSupport, forcing "C" collation */</comment>
	<expr_stmt><expr><call><name>varstr_sortsupport</name><argument_list>(<argument><expr><name>ssup</name></expr></argument>, <argument><expr><name>C_COLLATION_OID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * appendStringInfoText
 *
 * Append a text to str.
 * Like appendStringInfoString(str, text_to_cstring(t)) but faster.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendStringInfoText</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>text</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * replace_text
 * replace all occurrences of 'old_sub_str' in 'orig_str'
 * with 'new_sub_str' to form 'new_str'
 *
 * returns 'orig_str' if 'old_sub_str' == '' or 'orig_str' == ''
 * otherwise returns 'new_str'
 */</comment>
<function><type><name>Datum</name></type>
<name>replace_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>src_text</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>from_sub_text</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>to_sub_text</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>src_text_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>from_sub_text_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TextPositionState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>ret_text</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>start_posn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>curr_posn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>chunk_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>text_position_setup</name><argument_list>(<argument><expr><name>src_text</name></expr></argument>, <argument><expr><name>from_sub_text</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we check the converted string length, not the original, because
	 * they could be different if the input contained invalid encoding.
	 */</comment>
	<expr_stmt><expr><name>src_text_len</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>len1</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>from_sub_text_len</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>len2</name></name></expr>;</expr_stmt>

	<comment type="block">/* Return unmodified source string if empty source or pattern */</comment>
	<if_stmt><if>if <condition>(<expr><name>src_text_len</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>from_sub_text_len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>text_position_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>src_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>start_posn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>curr_posn</name> <operator>=</operator> <call><name>text_position_next</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* When the from_sub_text is not found, there is nothing to do. */</comment>
	<if_stmt><if>if <condition>(<expr><name>curr_posn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>text_position_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>src_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* start_ptr points to the start_posn'th character of src_text */</comment>
	<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>src_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* copy the data skipped over by last text_position_next() */</comment>
		<expr_stmt><expr><name>chunk_len</name> <operator>=</operator> <call><name>charlen_to_bytelen</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>curr_posn</name> <operator>-</operator> <name>start_posn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>chunk_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>to_sub_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>start_posn</name> <operator>=</operator> <name>curr_posn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>start_ptr</name> <operator>+=</operator> <name>chunk_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>start_posn</name> <operator>+=</operator> <name>from_sub_text_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>start_ptr</name> <operator>+=</operator> <call><name>charlen_to_bytelen</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>from_sub_text_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>curr_posn</name> <operator>=</operator> <call><name>text_position_next</name><argument_list>(<argument><expr><name>start_posn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	while <condition>(<expr><name>curr_posn</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

	<comment type="block">/* copy trailing data */</comment>
	<expr_stmt><expr><name>chunk_len</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>src_text</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>src_text</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>-</operator> <name>start_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>chunk_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>text_position_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret_text</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>ret_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_replace_text_has_escape_char
 *
 * check whether replace_text contains escape char.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_replace_text_has_escape_char</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>text</name> <modifier>*</modifier></type><name>replace_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>replace_text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p_end</name> <init>= <expr><name>p</name> <operator>+</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>replace_text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>p_end</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>p_end</name></expr>;</condition> <incr><expr><name>p</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * appendStringInfoRegexpSubstr
 *
 * Append replace_text to str, substituting regexp back references for
 * \n escapes.  start_ptr is the start of the match in the source string,
 * at logical character position data_pos.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendStringInfoRegexpSubstr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>replace_text</name></decl></parameter>,
							 <parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>pmatch</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>data_pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>replace_text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p_end</name> <init>= <expr><name>p</name> <operator>+</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>replace_text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>eml</name> <init>= <expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>chunk_start</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>so</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>eo</name></decl>;</decl_stmt>

		<comment type="block">/* Find next escape char. */</comment>
		<if_stmt><if>if <condition>(<expr><name>eml</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>p_end</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				 <comment type="block">/* nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>p_end</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>;</condition> <incr><expr><name>p</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
				 <comment type="block">/* nothing */</comment> <empty_stmt>;</empty_stmt></block_content></block></for>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Copy the text we just scanned over, if any. */</comment>
		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>chunk_start</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>chunk_start</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>chunk_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Done if at end of string, else advance over escape char. */</comment>
		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>p_end</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>p_end</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Escape at very end of input.  Treat same as unexpected char */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Use the back reference of regexp. */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>idx</name> <init>= <expr><operator>*</operator><name>p</name> <operator>-</operator> <literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>so</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>rm_so</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>eo</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Use the entire matched string. */</comment>
			<expr_stmt><expr><name>so</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>eo</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* \\ means transfer one \ to output. */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If escape char is not followed by any expected char, just treat
			 * it as ordinary data to copy.  (XXX would it be better to throw
			 * an error?)
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>so</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>eo</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Copy the text that is back reference of regexp.  Note so and eo
			 * are counted in characters not bytes.
			 */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>chunk_start</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>chunk_len</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>so</name> <operator>&gt;=</operator> <name>data_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>chunk_start</name> <operator>=</operator> <name>start_ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>chunk_start</name> <operator>+=</operator> <call><name>charlen_to_bytelen</name><argument_list>(<argument><expr><name>chunk_start</name></expr></argument>, <argument><expr><name>so</name> <operator>-</operator> <name>data_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>chunk_len</name> <operator>=</operator> <call><name>charlen_to_bytelen</name><argument_list>(<argument><expr><name>chunk_start</name></expr></argument>, <argument><expr><name>eo</name> <operator>-</operator> <name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>chunk_start</name></expr></argument>, <argument><expr><name>chunk_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGEXP_REPLACE_BACKREF_CNT</name></cpp:macro>		<cpp:value>10</cpp:value></cpp:define>

<comment type="block">/*
 * replace_text_regexp
 *
 * replace text that matches to regexp in src_text to replace_text.
 *
 * Note: to avoid having to include regex.h in builtins.h, we declare
 * the regexp argument as void *, but really it's regex_t *.
 */</comment>
<function><type><name>text</name> <modifier>*</modifier></type>
<name>replace_text_regexp</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>src_text</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>regexp</name></decl></parameter>,
					<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>replace_text</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>glob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>ret_text</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>regex_t</name>    <modifier>*</modifier></type><name>re</name> <init>= <expr><operator>(</operator><name>regex_t</name> <operator>*</operator><operator>)</operator> <name>regexp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>src_text_len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>src_text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>regmatch_t</name></type>	<name><name>pmatch</name><index>[<expr><name>REGEXP_REPLACE_BACKREF_CNT</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_wchar</name>   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>data_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>search_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>data_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_escape</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert data string to wide characters. */</comment>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>src_text_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_wchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>pg_mb2wchar_with_len</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>src_text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>src_text_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check whether replace_text has escape char. */</comment>
	<expr_stmt><expr><name>have_escape</name> <operator>=</operator> <call><name>check_replace_text_has_escape_char</name><argument_list>(<argument><expr><name>replace_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* start_ptr points to the data_pos'th character of src_text */</comment>
	<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>src_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>data_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>search_start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>search_start</name> <operator>&lt;=</operator> <name>data_len</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>regexec_result</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>regexec_result</name> <operator>=</operator> <call><name>pg_regexec</name><argument_list>(<argument><expr><name>re</name></expr></argument>,
									<argument><expr><name>data</name></expr></argument>,
									<argument><expr><name>data_len</name></expr></argument>,
									<argument><expr><name>search_start</name></expr></argument>,
									<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no details */</comment>
									<argument><expr><name>REGEXP_REPLACE_BACKREF_CNT</name></expr></argument>,
									<argument><expr><name>pmatch</name></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>regexec_result</name> <operator>==</operator> <name>REG_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>regexec_result</name> <operator>!=</operator> <name>REG_OKAY</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>errMsg</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_regerror</name><argument_list>(<argument><expr><name>regexec_result</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name>errMsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errMsg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_REGULAR_EXPRESSION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"regular expression failed: %s"</literal></expr></argument>, <argument><expr><name>errMsg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Copy the text to the left of the match position.  Note we are given
		 * character not byte indexes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>-</operator> <name>data_pos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>chunk_len</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>chunk_len</name> <operator>=</operator> <call><name>charlen_to_bytelen</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>,
										   <argument><expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>-</operator> <name>data_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>chunk_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Advance start_ptr over that text, to avoid multiple rescans of
			 * it if the replace_text contains multiple back-references.
			 */</comment>
			<expr_stmt><expr><name>start_ptr</name> <operator>+=</operator> <name>chunk_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>data_pos</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Copy the replace_text. Process back references when the
		 * replace_text has escape characters.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>have_escape</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoRegexpSubstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>replace_text</name></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>,
										 <argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>data_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoText</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>replace_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Advance start_ptr and data_pos over the matched text. */</comment>
		<expr_stmt><expr><name>start_ptr</name> <operator>+=</operator> <call><name>charlen_to_bytelen</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>,
										<argument><expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>-</operator> <name>data_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data_pos</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * When global option is off, replace the first instance only.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>glob</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Advance search position.  Normally we start the next search at the
		 * end of the previous match; but if the match was of zero length, we
		 * have to advance by one character, or we'd just find the same match
		 * again.
		 */</comment>
		<expr_stmt><expr><name>search_start</name> <operator>=</operator> <name>data_pos</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>==</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>search_start</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Copy the text to the right of the last match.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>data_pos</name> <operator>&lt;</operator> <name>data_len</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>chunk_len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>chunk_len</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>src_text</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>src_text</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>-</operator> <name>start_ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>chunk_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ret_text</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret_text</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * split_text
 * parse input string
 * return ord item (1 based)
 * based on provided field separator
 */</comment>
<function><type><name>Datum</name></type>
<name>split_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>inputstring</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fldsep</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fldnum</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inputstring_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fldsep_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TextPositionState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>start_posn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>end_posn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result_text</name></decl>;</decl_stmt>

	<comment type="block">/* field number is 1 based */</comment>
	<if_stmt><if>if <condition>(<expr><name>fldnum</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"field position must be greater than zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>text_position_setup</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>, <argument><expr><name>fldsep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we check the converted string length, not the original, because
	 * they could be different if the input contained invalid encoding.
	 */</comment>
	<expr_stmt><expr><name>inputstring_len</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>len1</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fldsep_len</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>len2</name></name></expr>;</expr_stmt>

	<comment type="block">/* return empty string for empty input string */</comment>
	<if_stmt><if>if <condition>(<expr><name>inputstring_len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>text_position_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* empty field separator */</comment>
	<if_stmt><if>if <condition>(<expr><name>fldsep_len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>text_position_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if first field, return input string, else empty string */</comment>
		<if_stmt><if>if <condition>(<expr><name>fldnum</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* identify bounds of first field */</comment>
	<expr_stmt><expr><name>start_posn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_posn</name> <operator>=</operator> <call><name>text_position_next</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* special case if fldsep not found at all */</comment>
	<if_stmt><if>if <condition>(<expr><name>end_posn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>text_position_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if field 1 requested, return input string, else empty string */</comment>
		<if_stmt><if>if <condition>(<expr><name>fldnum</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>end_posn</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>--</operator><name>fldnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* identify bounds of next field */</comment>
		<expr_stmt><expr><name>start_posn</name> <operator>=</operator> <name>end_posn</name> <operator>+</operator> <name>fldsep_len</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>end_posn</name> <operator>=</operator> <call><name>text_position_next</name><argument_list>(<argument><expr><name>start_posn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>text_position_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fldnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* N'th field separator not found */</comment>
		<comment type="block">/* if last field requested, return it, else empty string */</comment>
		<if_stmt><if>if <condition>(<expr><name>fldnum</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result_text</name> <operator>=</operator> <call><name>text_substring</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>start_posn</name></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result_text</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* non-last field requested */</comment>
		<expr_stmt><expr><name>result_text</name> <operator>=</operator> <call><name>text_substring</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>start_posn</name></expr></argument>,
									 <argument><expr><name>end_posn</name> <operator>-</operator> <name>start_posn</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convenience function to return true when two text params are equal.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>text_isequal</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>txt1</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>txt2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>texteq</name></expr></argument>,
											<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>txt1</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>txt2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * text_to_array
 * parse input string and return text array of elements,
 * based on provided field separator
 */</comment>
<function><type><name>Datum</name></type>
<name>text_to_array</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>text_to_array_internal</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * text_to_array_null
 * parse input string and return text array of elements,
 * based on provided field separator and null string
 *
 * This is a separate entry point only to prevent the regression tests from
 * complaining about different argument sets for the same internal function.
 */</comment>
<function><type><name>Datum</name></type>
<name>text_to_array_null</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>text_to_array_internal</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * common code for text_to_array and text_to_array_null functions
 *
 * These are not strict so we have to test for null inputs explicitly.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>text_to_array_internal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>inputstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fldsep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>null_string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inputstring_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fldsep_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result_text</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_null</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* when input string is NULL, then result is NULL too */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>inputstring</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fldsep can be NULL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fldsep</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fldsep</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* null_string can be NULL or omitted */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>null_string</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>null_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fldsep</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Normal case with non-null fldsep.  Use the text_position machinery
		 * to search for occurrences of fldsep.
		 */</comment>
		<decl_stmt><decl><type><name>TextPositionState</name></type> <name>state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>fldnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>start_posn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>end_posn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>chunk_len</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>text_position_setup</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>, <argument><expr><name>fldsep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note: we check the converted string length, not the original,
		 * because they could be different if the input contained invalid
		 * encoding.
		 */</comment>
		<expr_stmt><expr><name>inputstring_len</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>len1</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fldsep_len</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>len2</name></name></expr>;</expr_stmt>

		<comment type="block">/* return empty array for empty input string */</comment>
		<if_stmt><if>if <condition>(<expr><name>inputstring_len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>text_position_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * empty field separator: return the input string as a one-element
		 * array
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fldsep_len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name><name>elems</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name><name>dims</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name><name>lbs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>text_position_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* single element can be a NULL too */</comment>
			<expr_stmt><expr><name>is_null</name> <operator>=</operator> <ternary><condition><expr><name>null_string</name></expr> ?</condition><then> <expr><call><name>text_isequal</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>, <argument><expr><name>null_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>elems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>is_null</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lbs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<comment type="block">/* XXX: this hardcodes assumptions about the text type */</comment>
			<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>construct_md_array</name><argument_list>(<argument><expr><name>elems</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
													 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>lbs</name></expr></argument>,
													 <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>start_posn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<comment type="block">/* start_ptr points to the start_posn'th character of inputstring */</comment>
		<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>fldnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init><condition>;</condition> <incr><expr><name>fldnum</name><operator>++</operator></expr></incr>)</control> <comment type="block">/* field number is 1 based */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>end_posn</name> <operator>=</operator> <call><name>text_position_next</name><argument_list>(<argument><expr><name>start_posn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>end_posn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* fetch last field */</comment>
				<expr_stmt><expr><name>chunk_len</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>inputstring</name> <operator>+</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>-</operator> <name>start_ptr</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* fetch non-last field */</comment>
				<expr_stmt><expr><name>chunk_len</name> <operator>=</operator> <call><name>charlen_to_bytelen</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>end_posn</name> <operator>-</operator> <name>start_posn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* must build a temp text datum to pass to accumArrayResult */</comment>
			<expr_stmt><expr><name>result_text</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>chunk_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_null</name> <operator>=</operator> <ternary><condition><expr><name>null_string</name></expr> ?</condition><then> <expr><call><name>text_isequal</name><argument_list>(<argument><expr><name>result_text</name></expr></argument>, <argument><expr><name>null_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/* stash away this field */</comment>
			<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result_text</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>is_null</name></expr></argument>,
									  <argument><expr><name>TEXTOID</name></expr></argument>,
									  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>result_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>end_posn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>start_posn</name> <operator>=</operator> <name>end_posn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>start_ptr</name> <operator>+=</operator> <name>chunk_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>start_posn</name> <operator>+=</operator> <name>fldsep_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>start_ptr</name> <operator>+=</operator> <call><name>charlen_to_bytelen</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>fldsep_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>text_position_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * When fldsep is NULL, each character in the inputstring becomes an
		 * element in the result array.  The separator is effectively the
		 * space between characters.
		 */</comment>
		<expr_stmt><expr><name>inputstring_len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* return empty array for empty input string */</comment>
		<if_stmt><if>if <condition>(<expr><name>inputstring_len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>inputstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>inputstring_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>chunk_len</name> <init>= <expr><call><name>pg_mblen</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* must build a temp text datum to pass to accumArrayResult */</comment>
			<expr_stmt><expr><name>result_text</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>chunk_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_null</name> <operator>=</operator> <ternary><condition><expr><name>null_string</name></expr> ?</condition><then> <expr><call><name>text_isequal</name><argument_list>(<argument><expr><name>result_text</name></expr></argument>, <argument><expr><name>null_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/* stash away this field */</comment>
			<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>result_text</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>is_null</name></expr></argument>,
									  <argument><expr><name>TEXTOID</name></expr></argument>,
									  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>result_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>start_ptr</name> <operator>+=</operator> <name>chunk_len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>inputstring_len</name> <operator>-=</operator> <name>chunk_len</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>makeArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>,
										  <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_to_text
 * concatenate Cstring representation of input array elements
 * using provided field separator
 */</comment>
<function><type><name>Datum</name></type>
<name>array_to_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fldsep</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>array_to_text_internal</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>fldsep</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * array_to_text_null
 * concatenate Cstring representation of input array elements
 * using provided field separator and null string
 *
 * This version is not strict so we have to test for null inputs explicitly.
 */</comment>
<function><type><name>Datum</name></type>
<name>array_to_text_null</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fldsep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>null_string</name></decl>;</decl_stmt>

	<comment type="block">/* returns NULL when first or second parameter is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fldsep</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NULL null string is passed through as a null pointer */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>null_string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>null_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>array_to_text_internal</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>fldsep</name></expr></argument>, <argument><expr><name>null_string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * common code for array_to_text and array_to_text_null functions
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>array_to_text_internal</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fldsep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>null_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>dims</name></decl>,
				<decl><type ref="prev"/><name>ndims</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>printed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits8</name>	   <modifier>*</modifier></type><name>bitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayMetaState</name> <modifier>*</modifier></type><name>my_extra</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ndims</name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dims</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if there are no elements, return an empty string */</comment>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>element_type</name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We arrange to look up info about element type, including its output
	 * conversion proc, only once per series of calls, assuming the element
	 * type doesn't change underneath us.
	 */</comment>
	<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>my_extra</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
													  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayMetaState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>my_extra</name> <operator>=</operator> <operator>(</operator><name>ArrayMetaState</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <operator>~</operator><name>element_type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>!=</operator> <name>element_type</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Get info about element type, including its output conversion proc
		 */</comment>
		<expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typdelim</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typioparam</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>my_extra</name><operator>-&gt;</operator><name>typiofunc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>,
					  <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>my_extra</name><operator>-&gt;</operator><name>element_type</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>typlen</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typbyval</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>typalign</name> <operator>=</operator> <name><name>my_extra</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <call><name>ARR_NULLBITMAP</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>itemvalue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

		<comment type="block">/* Get source element, checking for NULL */</comment>
		<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>bitmap</name> <operator>&amp;</operator> <name>bitmask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if null_string is NULL, we just ignore null elements */</comment>
			<if_stmt><if>if <condition>(<expr><name>null_string</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>printed</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>fldsep</name></expr></argument>, <argument><expr><name>null_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>null_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>printed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>itemvalue</name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>my_extra</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name>itemvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>printed</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>fldsep</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>printed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>att_addlength_pointer</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* advance bitmap pointer if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>bitmap</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bitmask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>bitmask</name> <operator>==</operator> <literal type="number">0x100</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>bitmap</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitmask</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEXBASE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<comment type="block">/*
 * Convert an int32 to a string containing a base 16 (hex) representation of
 * the number.
 */</comment>
<function><type><name>Datum</name></type>
<name>to_hex32</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>value</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><literal type="string">"0123456789abcdef"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* bigger than needed, but reasonable */</comment>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><operator>--</operator><name>ptr</name> <operator>=</operator> <name><name>digits</name><index>[<expr><name>value</name> <operator>%</operator> <name>HEXBASE</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> <operator>/=</operator> <name>HEXBASE</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <name>buf</name> <operator>&amp;&amp;</operator> <name>value</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an int64 to a string containing a base 16 (hex) representation of
 * the number.
 */</comment>
<function><type><name>Datum</name></type>
<name>to_hex64</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>value</name> <init>= <expr><operator>(</operator><name>uint64</name><operator>)</operator> <call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>digits</name> <init>= <expr><literal type="string">"0123456789abcdef"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* bigger than needed, but reasonable */</comment>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><operator>--</operator><name>ptr</name> <operator>=</operator> <name><name>digits</name><index>[<expr><name>value</name> <operator>%</operator> <name>HEXBASE</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>value</name> <operator>/=</operator> <name>HEXBASE</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <name>buf</name> <operator>&amp;&amp;</operator> <name>value</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the size of a datum, possibly compressed
 *
 * Works on any data type
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_column_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name></decl>;</decl_stmt>

	<comment type="block">/* On first call, get the input type's typlen, and save at *fn_extra */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Lookup the datatype of the supplied argument */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>argtypeid</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>typlen</name> <operator>=</operator> <call><name>get_typlen</name><argument_list>(<argument><expr><name>argtypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>argtypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
													  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name><operator>)</operator> <operator>=</operator> <name>typlen</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>typlen</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* varlena type, possibly toasted */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>toast_datum_size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cstring */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* ordinary fixed-width type */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>typlen</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * string_agg - Concatenates values and returns string.
 *
 * Syntax: string_agg(value text, delimiter text) RETURNS text
 *
 * Note: Any NULL values are ignored. The first-call delimiter isn't
 * actually used at all, and on subsequent calls the delimiter precedes
 * the associated value.
 */</comment>

<comment type="block">/* subroutine to initialize state */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>makeStringAggState</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>aggcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggcontext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cannot be called directly because of internal-type argument */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"string_agg_transfn called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Create state in aggregate context.  It'll stay there across subsequent
	 * calls.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>aggcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>string_agg_transfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Append the value unless null. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* On the first time through, we ignore the delimiter. */</comment>
		<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makeStringAggState</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoText</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* delimiter */</comment>

		<expr_stmt><expr><call><name>appendStringInfoText</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* value */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The transition type for string_agg() is declared to be "internal",
	 * which is a pass-by-value type the same size as a pointer.
	 */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>string_agg_finalfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>state</name></decl>;</decl_stmt>

	<comment type="block">/* cannot be called directly because of internal-type argument */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare cache with fmgr info for the output functions of the datatypes of
 * the arguments of a concat-like function, beginning with argument "argidx".
 * (Arguments before that will have corresponding slots in the resulting
 * FmgrInfo array, but we don't fill those slots.)
 */</comment>
<function><type><specifier>static</specifier> <name>FmgrInfo</name> <modifier>*</modifier></type>
<name>build_concat_foutcache</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>foutcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* We keep the info in fn_mcxt so it survives across calls */</comment>
	<expr_stmt><expr><name>foutcache</name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>,
												<argument><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>argidx</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PG_NARGS</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>valtype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typOutput</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>typIsVarlena</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>valtype</name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>valtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not determine data type of concat() input"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>typOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>foutcache</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <name>foutcache</name></expr>;</expr_stmt>

	<return>return <expr><name>foutcache</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Implementation of both concat() and concat_ws().
 *
 * sepstr is the separator string to place between values.
 * argidx identifies the first argument to concatenate (counting from zero);
 * note that this must be constant across any one series of calls.
 *
 * Returns NULL if result should be NULL, else text value.
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>concat_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sepstr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argidx</name></decl></parameter>,
				<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>foutcache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_arg</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * concat(VARIADIC some-array) is essentially equivalent to
	 * array_to_text(), ie concat the array elements with the given separator.
	 * So we just pass the case off to that code.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_fn_expr_variadic</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>

		<comment type="block">/* Should have just the one argument */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>argidx</name> <operator>==</operator> <call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* concat(VARIADIC NULL) is defined as NULL */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>argidx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Non-null argument had better be an array.  We assume that any call
		 * context that could let get_fn_expr_variadic return true will have
		 * checked that a VARIADIC-labeled parameter actually is an array.  So
		 * it should be okay to just Assert that it's an array rather than
		 * doing a full-fledged error check.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>argidx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* OK, safe to fetch the array value */</comment>
		<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>argidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * And serialize the array.  We tell array_to_text to ignore null
		 * elements, which matches the behavior of the loop below.
		 */</comment>
		<return>return <expr><call><name>array_to_text_internal</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>arr</name></expr></argument>, <argument><expr><name>sepstr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Normal case without explicit VARIADIC marker */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get output function info, building it if first time through */</comment>
	<expr_stmt><expr><name>foutcache</name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>foutcache</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>foutcache</name> <operator>=</operator> <call><name>build_concat_foutcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>argidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>argidx</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PG_NARGS</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* add separator if appropriate */</comment>
			<if_stmt><if>if <condition>(<expr><name>first_arg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>first_arg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>sepstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* call the appropriate type output function, append the result */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
								   <argument><expr><call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>foutcache</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Concatenate all arguments. NULL arguments are ignored.
 */</comment>
<function><type><name>Datum</name></type>
<name>text_concat</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>concat_internal</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Concatenate all but first argument value with separators. The first
 * parameter is used as the separator. NULL arguments are ignored.
 */</comment>
<function><type><name>Datum</name></type>
<name>text_concat_ws</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* return NULL when separator is NULL */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>concat_internal</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return first n characters in the string. When n is negative,
 * return all but last |n| characters.
 */</comment>
<function><type><name>Datum</name></type>
<name>text_left</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rlen</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rlen</name> <operator>=</operator> <call><name>pg_mbcharcliplen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return last n characters in the string. When n is negative,
 * return all but first |n| characters.
 */</comment>
<function><type><name>Datum</name></type>
<name>text_right</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>off</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><name>n</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>n</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>pg_mbcharcliplen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return reversed string
 */</comment>
<function><type><name>Datum</name></type>
<name>text_reverse</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endp</name> <init>= <expr><name>p</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dst</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* multibyte version */</comment>
		<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>sz</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dst</name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* single byte version */</comment>
		<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>dst</name><operator>)</operator> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Support macros for text_format()
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEXT_FORMAT_FLAG_MINUS</name></cpp:macro>	<cpp:value>0x0001</cpp:value></cpp:define>	<comment type="block">/* is minus flag present? */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADVANCE_PARSE_POINTER</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>,<parameter><type><name>end_ptr</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (++(ptr) &gt;= (end_ptr)) \
			ereport(ERROR, \
					(errcode(ERRCODE_INVALID_PARAMETER_VALUE), \
					 errmsg("unterminated format() type specifier"), \
					 errhint("For a single \"%%\" use \"%%%%\"."))); \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/*
 * Returns a formatted string
 */</comment>
<function><type><name>Datum</name></type>
<name>text_format</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>funcvariadic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elements</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>prev_type</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>prev_width_type</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>typoutputfinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>typoutputinfo_width</name></decl>;</decl_stmt>

	<comment type="block">/* When format string is null, immediately return null */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If argument is marked VARIADIC, expand array into elements */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_fn_expr_variadic</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>elmlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>elmbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>elmalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>

		<comment type="block">/* Should have just the one argument */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If argument is NULL, we treat it as zero-length array */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nitems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Non-null argument had better be an array.  We assume that any
			 * call context that could let get_fn_expr_variadic return true
			 * will have checked that a VARIADIC-labeled parameter actually is
			 * an array.  So it should be okay to just Assert that it's an
			 * array rather than doing a full-fledged error check.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* OK, safe to fetch the array value */</comment>
			<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Get info about array element type */</comment>
			<expr_stmt><expr><name>element_type</name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Extract all array elements */</comment>
			<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arr</name></expr></argument>, <argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>elements</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>nargs</name> <operator>=</operator> <name>nitems</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcvariadic</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Non-variadic case, we'll process the arguments individually */</comment>
		<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>PG_NARGS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcvariadic</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Setup for main loop. */</comment>
	<expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <name>start_ptr</name> <operator>+</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>					<comment type="block">/* next argument position to print */</comment>

	<comment type="block">/* Scan format string, looking for conversion specifiers. */</comment>
	<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>start_ptr</name></expr>;</init> <condition><expr><name>cp</name> <operator>&lt;</operator> <name>end_ptr</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>argpos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>widthpos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>width</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If it's not the start of a conversion specifier, just copy it to
		 * the output buffer.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ADVANCE_PARSE_POINTER</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Easy case: %% outputs a single % */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Parse the optional portions of the format specifier */</comment>
		<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>text_format_parse_format</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>argpos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>widthpos</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Next we should see the main conversion specifier.  Whether or not
		 * an argument position was present, it's known that at least one
		 * character remains in the string at this point.  Experience suggests
		 * that it's worth checking that that character is one of the expected
		 * ones before we try to fetch arguments, so as to produce the least
		 * confusing response to a mis-formatted specifier.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"sIL"</literal></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized format() type specifier \"%c\""</literal></expr></argument>,
							<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"For a single \"%%\" use \"%%%%\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If indirect width was specified, get its value */</comment>
		<if_stmt><if>if <condition>(<expr><name>widthpos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Collect the specified or next argument position */</comment>
			<if_stmt><if>if <condition>(<expr><name>widthpos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>widthpos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&gt;=</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too few arguments for format()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Get the value and type of the selected argument */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>funcvariadic</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isNull</name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>typid</name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>elements</name><index>[<expr><name>arg</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>isNull</name> <operator>=</operator> <name><name>nulls</name><index>[<expr><name>arg</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>typid</name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not determine data type of format() input"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>arg</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* We can treat NULL width the same as zero */</comment>
			<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>typid</name> <operator>==</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>typid</name> <operator>==</operator> <name>INT2OID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* For less-usual datatypes, convert to text then to int */</comment>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>!=</operator> <name>prev_width_type</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutputfunc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>typIsVarlena</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutputfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>typoutputfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutputinfo_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>prev_width_type</name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typoutputinfo_width</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* pg_atoi will complain about bad data or overflow */</comment>
				<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>pg_atoi</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Collect the specified or next argument position */</comment>
		<if_stmt><if>if <condition>(<expr><name>argpos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>argpos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&gt;=</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too few arguments for format()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Get the value and type of the selected argument */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>funcvariadic</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>isNull</name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>typid</name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>elements</name><index>[<expr><name>arg</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>isNull</name> <operator>=</operator> <name><name>nulls</name><index>[<expr><name>arg</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>typid</name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not determine data type of format() input"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>arg</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the appropriate typOutput function, reusing previous one if
		 * same type as previous argument.  That's particularly useful in the
		 * variadic-array case, but often saves work even for ordinary calls.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>!=</operator> <name>prev_type</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutputfunc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>typIsVarlena</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutputfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>typoutputfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutputfinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev_type</name> <operator>=</operator> <name>typid</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * And now we can format the value.
		 */</comment>
		<switch>switch <condition>(<expr><operator>*</operator><name>cp</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
			<case>case <expr><literal type="char">'I'</literal></expr>:</case>
			<case>case <expr><literal type="char">'L'</literal></expr>:</case>
				<expr_stmt><expr><call><name>text_format_string_conversion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>*</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoutputfinfo</name></expr></argument>,
											  <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>,
											  <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* should not get here, because of previous check */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized format() type specifier \"%c\""</literal></expr></argument>,
								<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"For a single \"%%\" use \"%%%%\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<comment type="block">/* Don't need deconstruct_array results anymore. */</comment>
	<if_stmt><if>if <condition>(<expr><name>elements</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nulls</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Generate results. */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse contiguous digits as a decimal number.
 *
 * Returns true if some digits could be parsed.
 * The value is returned into *value, and *ptr is advanced to the next
 * character to be parsed.
 *
 * Note parsing invariant: at least one character is known available before
 * string end (end_ptr) at entry, and this is still true at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>text_format_parse_digits</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>cp</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int8</name></type>		<name>digit</name> <init>= <expr><operator>(</operator><operator>*</operator><name>cp</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>pg_mul_s32_overflow</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>unlikely</name><argument_list>(<argument><expr><call><name>pg_add_s32_overflow</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>digit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ADVANCE_PARSE_POINTER</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse a format specifier (generally following the SUS printf spec).
 *
 * We have already advanced over the initial '%', and we are looking for
 * [argpos][flags][width]type (but the type character is not consumed here).
 *
 * Inputs are start_ptr (the position after '%') and end_ptr (string end + 1).
 * Output parameters:
 *	argpos: argument position for value to be printed.  -1 means unspecified.
 *	widthpos: argument position for width.  Zero means the argument position
 *			was unspecified (ie, take the next arg) and -1 means no width
 *			argument (width was omitted or specified as a constant).
 *	flags: bitmask of flags.
 *	width: directly-specified width value.  Zero means the width was omitted
 *			(note it's not necessary to distinguish this case from an explicit
 *			zero width value).
 *
 * The function result is the next character position to be parsed, ie, the
 * location where the type character is/should be.
 *
 * Note parsing invariant: at least one character is known available before
 * string end (end_ptr) at entry, and this is still true at exit.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>text_format_parse_format</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start_ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end_ptr</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argpos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>widthpos</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>width</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>start_ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<comment type="block">/* set defaults for output parameters */</comment>
	<expr_stmt><expr><operator>*</operator><name>argpos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>widthpos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* try to identify first number */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>text_format_parse_digits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Must be just a width and a type, so we're done */</comment>
			<expr_stmt><expr><operator>*</operator><name>width</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
			<return>return <expr><name>cp</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* The number was argument position */</comment>
		<expr_stmt><expr><operator>*</operator><name>argpos</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
		<comment type="block">/* Explicit 0 for argument index is immediately refused */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"format specifies argument 0, but arguments are numbered from 1"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ADVANCE_PARSE_POINTER</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Handle flags (only minus is supported now) */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>TEXT_FORMAT_FLAG_MINUS</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADVANCE_PARSE_POINTER</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Handle indirect width */</comment>
		<expr_stmt><expr><call><name>ADVANCE_PARSE_POINTER</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>text_format_parse_digits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* number in this position must be closed by $ */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"width argument position must be ended by \"$\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* The number was width argument position */</comment>
			<expr_stmt><expr><operator>*</operator><name>widthpos</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
			<comment type="block">/* Explicit 0 for argument index is immediately refused */</comment>
			<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"format specifies argument 0, but arguments are numbered from 1"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ADVANCE_PARSE_POINTER</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>widthpos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>		<comment type="block">/* width's argument position is unspecified */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Check for direct width specification */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>text_format_parse_digits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><name>end_ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>width</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* cp should now be pointing at type character */</comment>
	<return>return <expr><name>cp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Format a %s, %I, or %L conversion
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>text_format_string_conversion</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>conversion</name></decl></parameter>,
							  <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>typOutputInfo</name></decl></parameter>,
							  <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<comment type="block">/* Handle NULL arguments before trying to stringify the value. */</comment>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>conversion</name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>text_format_append_string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>conversion</name> <operator>==</operator> <literal type="char">'L'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>text_format_append_string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>conversion</name> <operator>==</operator> <literal type="char">'I'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null values cannot be formatted as an SQL identifier"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Stringify. */</comment>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><name>typOutputInfo</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Escape. */</comment>
	<if_stmt><if>if <condition>(<expr><name>conversion</name> <operator>==</operator> <literal type="char">'I'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* quote_identifier may or may not allocate a new string. */</comment>
		<expr_stmt><expr><call><name>text_format_append_string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>conversion</name> <operator>==</operator> <literal type="char">'L'</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qstr</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>text_format_append_string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>qstr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* quote_literal_cstr() always allocates a new string */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>qstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>text_format_append_string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append str to buf, padding as directed by flags/width
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>text_format_append_string</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>align_to_left</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<comment type="block">/* fast path for typical easy case */</comment>
	<if_stmt><if>if <condition>(<expr><name>width</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>width</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Negative width: implicit '-' flag, then take absolute value */</comment>
		<expr_stmt><expr><name>align_to_left</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* -INT_MIN is undefined */</comment>
		<if_stmt><if>if <condition>(<expr><name>width</name> <operator>&lt;=</operator> <name>INT_MIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>width</name> <operator>=</operator> <operator>-</operator><name>width</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>TEXT_FORMAT_FLAG_MINUS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>align_to_left</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_mbstrlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>align_to_left</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* left justify */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>width</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* right justify */</comment>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>width</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>width</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * text_format_nv - nonvariadic wrapper for text_format function.
 *
 * note: this wrapper is necessary to pass the sanity check in opr_sanity,
 * which checks that all built-in functions that share the implementing C
 * function take the same number of arguments.
 */</comment>
<function><type><name>Datum</name></type>
<name>text_format_nv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>text_format</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function for Levenshtein distance functions. Faster than memcmp(),
 * for this use case.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>rest_of_char_same</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>s1</name><index>[<expr><name>len</name></expr>]</index></name> <operator>!=</operator> <name><name>s2</name><index>[<expr><name>len</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Expand each Levenshtein distance variant */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"levenshtein.c"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVENSHTEIN_LESS_EQUAL</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"levenshtein.c"</cpp:file></cpp:include>
</unit>
