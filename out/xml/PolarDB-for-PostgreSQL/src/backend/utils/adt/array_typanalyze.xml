<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/adt/array_typanalyze.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * array_typanalyze.c
 *	  Functions for gathering statistics from array columns
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/array_typanalyze.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * To avoid consuming too much memory, IO and CPU load during analysis, and/or
 * too much space in the resulting pg_statistic rows, we ignore arrays that
 * are wider than ARRAY_WIDTH_THRESHOLD (after detoasting!).  Note that this
 * number is considerably more than the similar WIDTH_THRESHOLD limit used
 * in analyze.c's standard typanalyze code.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARRAY_WIDTH_THRESHOLD</name></cpp:macro> <cpp:value>0x10000</cpp:value></cpp:define>

<comment type="block">/* Extra data for compute_array_stats function */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* Information about array element type */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>type_id</name></decl>;</decl_stmt>		<comment type="block">/* element type's OID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_opr</name></decl>;</decl_stmt>			<comment type="block">/* default equality operator's OID */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>		<comment type="block">/* physical properties of element type */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Lookup data for element type's comparison and hash functions (these are
	 * in the type's typcache entry, which we expect to remain valid over the
	 * lifespan of the ANALYZE run)
	 */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>cmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>hash</name></decl>;</decl_stmt>

	<comment type="block">/* Saved state from std_typanalyze() */</comment>
	<decl_stmt><decl><type><name>AnalyzeAttrComputeStatsFunc</name></type> <name>std_compute_stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>std_extra_data</name></decl>;</decl_stmt>
}</block></struct></type> <name>ArrayAnalyzeExtraData</name>;</typedef>

<comment type="block">/*
 * While compute_array_stats is running, we keep a pointer to the extra data
 * here for use by assorted subroutines.  compute_array_stats doesn't
 * currently need to be re-entrant, so avoiding this is not worth the extra
 * notational cruft that would be needed.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ArrayAnalyzeExtraData</name> <modifier>*</modifier></type><name>array_extra_data</name></decl>;</decl_stmt>

<comment type="block">/* A hash table entry for the Lossy Counting algorithm */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Datum</name></type>		<name>key</name></decl>;</decl_stmt>			<comment type="block">/* This is 'e' from the LC algorithm. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>frequency</name></decl>;</decl_stmt>		<comment type="block">/* This is 'f'. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>delta</name></decl>;</decl_stmt>			<comment type="block">/* And this is 'delta'. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>last_container</name></decl>;</decl_stmt> <comment type="block">/* For de-duplication of array elements. */</comment>
}</block></struct></type> <name>TrackItem</name>;</typedef>

<comment type="block">/* A hash table entry for distinct-elements counts */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>			<comment type="block">/* Count of distinct elements in an array */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>frequency</name></decl>;</decl_stmt>		<comment type="block">/* Number of arrays seen with this count */</comment>
}</block></struct></type> <name>DECountItem</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_array_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
					<parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prune_element_hashtable</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>elements_tab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b_current</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>element_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>element_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>element_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>trackitem_compare_frequencies_desc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>trackitem_compare_element</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>countitem_compare_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * array_typanalyze -- typanalyze function for array columns
 */</comment>
<function><type><name>Datum</name></type>
<name>array_typanalyze</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name> <init>= <expr><operator>(</operator><name>VacAttrStats</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_typeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayAnalyzeExtraData</name> <modifier>*</modifier></type><name>extra_data</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Call the standard typanalyze function.  It may fail to find needed
	 * operators, in which case we also can't do anything, so just fail.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>std_typanalyze</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check attribute data type is a varlena array (or a domain over one).
	 */</comment>
	<expr_stmt><expr><name>element_typeid</name> <operator>=</operator> <call><name>get_base_element_type</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"array_typanalyze was invoked for non-array type %u"</literal></expr></argument>,
			 <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>attrtypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Gather information about the element type.  If we fail to find
	 * something, return leaving the state from std_typanalyze() in place.
	 */</comment>
	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>,
								 <argument><expr><name>TYPECACHE_EQ_OPR</name> <operator>|</operator>
								 <name>TYPECACHE_CMP_PROC_FINFO</name> <operator>|</operator>
								 <name>TYPECACHE_HASH_PROC_FINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Store our findings for use by compute_array_stats() */</comment>
	<expr_stmt><expr><name>extra_data</name> <operator>=</operator> <operator>(</operator><name>ArrayAnalyzeExtraData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayAnalyzeExtraData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extra_data</name><operator>-&gt;</operator><name>type_id</name></name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>type_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extra_data</name><operator>-&gt;</operator><name>eq_opr</name></name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extra_data</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extra_data</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extra_data</name><operator>-&gt;</operator><name>typalign</name></name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extra_data</name><operator>-&gt;</operator><name>cmp</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc_finfo</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extra_data</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>typentry</name><operator>-&gt;</operator><name>hash_proc_finfo</name></name></expr>;</expr_stmt>

	<comment type="block">/* Save old compute_stats and extra_data for scalar statistics ... */</comment>
	<expr_stmt><expr><name><name>extra_data</name><operator>-&gt;</operator><name>std_compute_stats</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extra_data</name><operator>-&gt;</operator><name>std_extra_data</name></name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name></expr>;</expr_stmt>

	<comment type="block">/* ... and replace with our info */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>compute_stats</name></name> <operator>=</operator> <name>compute_array_stats</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name> <operator>=</operator> <name>extra_data</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note we leave stats-&gt;minrows set as std_typanalyze set it.  Should it
	 * be increased for array analysis purposes?
	 */</comment>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * compute_array_stats() -- compute statistics for an array column
 *
 * This function computes statistics useful for determining selectivity of
 * the array operators &lt;@, &amp;&amp;, and @&gt;.  It is invoked by ANALYZE via the
 * compute_stats hook after sample rows have been collected.
 *
 * We also invoke the standard compute_stats function, which will compute
 * "scalar" statistics relevant to the btree-style array comparison operators.
 * However, exact duplicates of an entire array may be rare despite many
 * arrays sharing individual elements.  This especially afflicts long arrays,
 * which are also liable to lack all scalar statistics due to the low
 * WIDTH_THRESHOLD used in analyze.c.  So, in addition to the standard stats,
 * we find the most common array elements and compute a histogram of distinct
 * element counts.
 *
 * The algorithm used is Lossy Counting, as proposed in the paper "Approximate
 * frequency counts over data streams" by G. S. Manku and R. Motwani, in
 * Proceedings of the 28th International Conference on Very Large Data Bases,
 * Hong Kong, China, August 2002, section 4.2. The paper is available at
 * http://www.vldb.org/conf/2002/S10P03.pdf
 *
 * The Lossy Counting (aka LC) algorithm goes like this:
 * Let s be the threshold frequency for an item (the minimum frequency we
 * are interested in) and epsilon the error margin for the frequency. Let D
 * be a set of triples (e, f, delta), where e is an element value, f is that
 * element's frequency (actually, its current occurrence count) and delta is
 * the maximum error in f. We start with D empty and process the elements in
 * batches of size w. (The batch size is also known as "bucket size" and is
 * equal to 1/epsilon.) Let the current batch number be b_current, starting
 * with 1. For each element e we either increment its f count, if it's
 * already in D, or insert a new triple into D with values (e, 1, b_current
 * - 1). After processing each batch we prune D, by removing from it all
 * elements with f + delta &lt;= b_current.  After the algorithm finishes we
 * suppress all elements from D that do not satisfy f &gt;= (s - epsilon) * N,
 * where N is the total number of elements in the input.  We emit the
 * remaining elements with estimated frequency f/N.  The LC paper proves
 * that this algorithm finds all elements with true frequency at least s,
 * and that no frequency is overestimated or is underestimated by more than
 * epsilon.  Furthermore, given reasonable assumptions about the input
 * distribution, the required table size is no more than about 7 times w.
 *
 * In the absence of a principled basis for other particular values, we
 * follow ts_typanalyze() and use parameters s = 0.07/K, epsilon = s/10.
 * But we leave out the correction for stopwords, which do not apply to
 * arrays.  These parameters give bucket width w = K/0.007 and maximum
 * expected hashtable size of about 1000 * K.
 *
 * Elements may repeat within an array.  Since duplicates do not change the
 * behavior of &lt;@, &amp;&amp; or @&gt;, we want to count each element only once per
 * array.  Therefore, we store in the finished pg_statistic entry each
 * element's frequency as the fraction of all non-null rows that contain it.
 * We divide the raw counts by nonnull_cnt to get those figures.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_array_stats</name><parameter_list>(<parameter><decl><type><name>VacAttrStats</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>AnalyzeAttrFetchFunc</name></type> <name>fetchfunc</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>samplerows</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>totalrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayAnalyzeExtraData</name> <modifier>*</modifier></type><name>extra_data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_mcelem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>null_elem_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>analyzed_rows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* This is D from the LC algorithm. */</comment>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>elements_tab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>elem_hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan_status</name></decl>;</decl_stmt>

	<comment type="block">/* This is the current bucket number from the LC algorithm */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>b_current</name></decl>;</decl_stmt>

	<comment type="block">/* This is 'w' from the LC algorithm */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>bucket_width</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>array_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>element_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrackItem</name>  <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slot_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>count_tab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>count_hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DECountItem</name> <modifier>*</modifier></type><name>count_item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>extra_data</name> <operator>=</operator> <operator>(</operator><name>ArrayAnalyzeExtraData</name> <operator>*</operator><operator>)</operator> <name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Invoke analyze.c's standard analysis function to create scalar-style
	 * stats for the column.  It will expect its own extra_data pointer, so
	 * temporarily install that.
	 */</comment>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name> <operator>=</operator> <name><name>extra_data</name><operator>-&gt;</operator><name>std_extra_data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>extra_data</name><operator>-&gt;</operator><name>std_compute_stats</name></name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>fetchfunc</name></expr></argument>, <argument><expr><name>samplerows</name></expr></argument>, <argument><expr><name>totalrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>extra_data</name></name> <operator>=</operator> <name>extra_data</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up static pointer for use by subroutines.  We wait till here in
	 * case std_compute_stats somehow recursively invokes us (probably not
	 * possible, but ...)
	 */</comment>
	<expr_stmt><expr><name>array_extra_data</name> <operator>=</operator> <name>extra_data</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We want statistics_target * 10 elements in the MCELEM array. This
	 * multiplier is pretty arbitrary, but is meant to reflect the fact that
	 * the number of individual elements tracked in pg_statistic ought to be
	 * more than the number of values for a simple scalar column.
	 */</comment>
	<expr_stmt><expr><name>num_mcelem</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * We set bucket width equal to num_mcelem / 0.007 as per the comment
	 * above.
	 */</comment>
	<expr_stmt><expr><name>bucket_width</name> <operator>=</operator> <name>num_mcelem</name> <operator>*</operator> <literal type="number">1000</literal> <operator>/</operator> <literal type="number">7</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the hashtable. It will be in local memory, so we don't need to
	 * worry about overflowing the initial size. Also we don't need to pay any
	 * attention to locking and memory management.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elem_hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>elem_hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elem_hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elem_hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TrackItem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elem_hash_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>element_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elem_hash_ctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>element_match</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>elem_hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>elements_tab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Analyzed elements table"</literal></expr></argument>,
							   <argument><expr><name>num_mcelem</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>elem_hash_ctl</name></expr></argument>,
							   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* hashtable for array distinct elements counts */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>count_hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>count_hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>count_hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>count_hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DECountItem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>count_hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>count_tab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Array distinct element count table"</literal></expr></argument>,
							<argument><expr><literal type="number">64</literal></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>count_hash_ctl</name></expr></argument>,
							<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize counters. */</comment>
	<expr_stmt><expr><name>b_current</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>element_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Loop over the arrays. */</comment>
	<for>for <control>(<init><expr><name>array_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>array_no</name> <operator>&lt;</operator> <name>samplerows</name></expr>;</condition> <incr><expr><name>array_no</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_elems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>null_present</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>prev_element_no</name> <init>= <expr><name>element_no</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>distinct_count</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>count_item_found</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fetchfunc</name><argument_list>(<argument><expr><name>stats</name></expr></argument>, <argument><expr><name>array_no</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* array is null, just count that */</comment>
			<expr_stmt><expr><name>null_cnt</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Skip too-large values. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>toast_raw_datum_size</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>ARRAY_WIDTH_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>analyzed_rows</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Now detoast the array if needed, and deconstruct into datums.
		 */</comment>
		<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>extra_data</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>,
						  <argument><expr><name><name>extra_data</name><operator>-&gt;</operator><name>type_id</name></name></expr></argument>,
						  <argument><expr><name><name>extra_data</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
						  <argument><expr><name><name>extra_data</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
						  <argument><expr><name><name>extra_data</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We loop through the elements in the array and add them to our
		 * tracking hashtable.
		 */</comment>
		<expr_stmt><expr><name>null_present</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>elem_value</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

			<comment type="block">/* No null element processing other than flag setting here */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>elem_nulls</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>null_present</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Lookup current element in hashtable, adding it if new */</comment>
			<expr_stmt><expr><name>elem_value</name> <operator>=</operator> <name><name>elem_values</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>TrackItem</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>elements_tab</name></expr></argument>,
											 <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>elem_value</name></expr></argument>,
											 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* The element value is already on the tracking list */</comment>

				<comment type="block">/*
				 * The operators we assist ignore duplicate array elements, so
				 * count a given distinct element only once per array.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>last_container</name></name> <operator>==</operator> <name>array_no</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>last_container</name></name> <operator>=</operator> <name>array_no</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Initialize new tracking list element */</comment>

				<comment type="block">/*
				 * If element type is pass-by-reference, we must copy it into
				 * palloc'd space, so that we can release the array below. (We
				 * do this so that the space needed for element values is
				 * limited by the size of the hashtable; if we kept all the
				 * array values around, it could be much more.)
				 */</comment>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>elem_value</name></expr></argument>,
									  <argument><expr><name><name>extra_data</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
									  <argument><expr><name><name>extra_data</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>delta</name></name> <operator>=</operator> <name>b_current</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>last_container</name></name> <operator>=</operator> <name>array_no</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* element_no is the number of elements processed (ie N) */</comment>
			<expr_stmt><expr><name>element_no</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* We prune the D structure after processing each bucket */</comment>
			<if_stmt><if>if <condition>(<expr><name>element_no</name> <operator>%</operator> <name>bucket_width</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>prune_element_hashtable</name><argument_list>(<argument><expr><name>elements_tab</name></expr></argument>, <argument><expr><name>b_current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>b_current</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Count null element presence once per array. */</comment>
		<if_stmt><if>if <condition>(<expr><name>null_present</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>null_elem_cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Update frequency of the particular array distinct element count. */</comment>
		<expr_stmt><expr><name>distinct_count</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>element_no</name> <operator>-</operator> <name>prev_element_no</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>count_item</name> <operator>=</operator> <operator>(</operator><name>DECountItem</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>count_tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>distinct_count</name></expr></argument>,
												 <argument><expr><name>HASH_ENTER</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>count_item_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>count_item_found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>count_item</name><operator>-&gt;</operator><name>frequency</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>count_item</name><operator>-&gt;</operator><name>frequency</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Free memory allocated while detoasting. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elem_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elem_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Skip pg_statistic slots occupied by standard statistics */</comment>
	<expr_stmt><expr><name>slot_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>slot_idx</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name> <operator>&amp;&amp;</operator> <name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><name>slot_idx</name> <operator>&gt;</operator> <name>STATISTIC_NUM_SLOTS</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"insufficient pg_statistic slots for array stats"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We can only compute real stats if we found some non-null values. */</comment>
	<if_stmt><if>if <condition>(<expr><name>analyzed_rows</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>nonnull_cnt</name> <init>= <expr><name>analyzed_rows</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>count_items_count</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TrackItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>sort_table</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>track_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>cutoff_freq</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>minfreq</name></decl>,
					<decl><type ref="prev"/><name>maxfreq</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We assume the standard stats code already took care of setting
		 * stats_valid, stanullfrac, stawidth, stadistinct.  We'd have to
		 * re-compute those values if we wanted to not store the standard
		 * stats.
		 */</comment>

		<comment type="block">/*
		 * Construct an array of the interesting hashtable items, that is,
		 * those meeting the cutoff frequency (s - epsilon)*N.  Also identify
		 * the minimum and maximum frequencies among these items.
		 *
		 * Since epsilon = s/10 and bucket_width = 1/epsilon, the cutoff
		 * frequency is 9*N / bucket_width.
		 */</comment>
		<expr_stmt><expr><name>cutoff_freq</name> <operator>=</operator> <literal type="number">9</literal> <operator>*</operator> <name>element_no</name> <operator>/</operator> <name>bucket_width</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>elements_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* surely enough space */</comment>
		<expr_stmt><expr><name>sort_table</name> <operator>=</operator> <operator>(</operator><name>TrackItem</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrackItem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name>elements_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>track_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>minfreq</name> <operator>=</operator> <name>element_no</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxfreq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>item</name> <operator>=</operator> <operator>(</operator><name>TrackItem</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name> <operator>&gt;</operator> <name>cutoff_freq</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sort_table</name><index>[<expr><name>track_len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>minfreq</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>minfreq</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>maxfreq</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxfreq</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>track_len</name> <operator>&lt;=</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* emit some statistics for debug purposes */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"compute_array_stats: target # mces = %d, "</literal>
			 <literal type="string">"bucket width = %d, "</literal>
			 <literal type="string">"# elements = "</literal> <name>INT64_FORMAT</name> <literal type="string">", hashtable size = %d, "</literal>
			 <literal type="string">"usable entries = %d"</literal></expr></argument>,
			 <argument><expr><name>num_mcelem</name></expr></argument>, <argument><expr><name>bucket_width</name></expr></argument>, <argument><expr><name>element_no</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>track_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we obtained more elements than we really want, get rid of those
		 * with least frequencies.  The easiest way is to qsort the array into
		 * descending frequency order and truncate the array.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_mcelem</name> <operator>&lt;</operator> <name>track_len</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sort_table</name></expr></argument>, <argument><expr><name>track_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrackItem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>trackitem_compare_frequencies_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* reset minfreq to the smallest frequency we're keeping */</comment>
			<expr_stmt><expr><name>minfreq</name> <operator>=</operator> <name><name>sort_table</name><index>[<expr><name>num_mcelem</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>frequency</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>num_mcelem</name> <operator>=</operator> <name>track_len</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Generate MCELEM slot entry */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_mcelem</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_context</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>mcelem_values</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>mcelem_freqs</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We want to store statistics sorted on the element value using
			 * the element type's default comparison function.  This permits
			 * fast binary searches in selectivity estimation functions.
			 */</comment>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sort_table</name></expr></argument>, <argument><expr><name>num_mcelem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TrackItem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>trackitem_compare_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Must copy the target values into anl_context */</comment>
			<expr_stmt><expr><name>old_context</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We sorted statistics on the element value, but we want to be
			 * able to find the minimal and maximal frequencies without going
			 * through all the values.  We also want the frequency of null
			 * elements.  Store these three values at the end of mcelem_freqs.
			 */</comment>
			<expr_stmt><expr><name>mcelem_values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num_mcelem</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>mcelem_freqs</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>num_mcelem</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * See comments above about use of nonnull_cnt as the divisor for
			 * the final frequency estimates.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_mcelem</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TrackItem</name>  <modifier>*</modifier></type><name>item</name> <init>= <expr><name><name>sort_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>mcelem_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
											 <argument><expr><name><name>extra_data</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
											 <argument><expr><name><name>extra_data</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mcelem_freqs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>item</name><operator>-&gt;</operator><name>frequency</name></name> <operator>/</operator>
					<operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>mcelem_freqs</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>minfreq</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mcelem_freqs</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>maxfreq</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mcelem_freqs</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>null_elem_cnt</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_MCELEM</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>extra_data</name><operator>-&gt;</operator><name>eq_opr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>mcelem_freqs</name></expr>;</expr_stmt>
			<comment type="block">/* See above comment about extra stanumber entries */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_mcelem</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stavalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>mcelem_values</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numvalues</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_mcelem</name></expr>;</expr_stmt>
			<comment type="block">/* We are storing values of element type */</comment>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypid</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>extra_data</name><operator>-&gt;</operator><name>type_id</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statyplen</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>extra_data</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypbyval</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>extra_data</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>statypalign</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>extra_data</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Generate DECHIST slot entry */</comment>
		<expr_stmt><expr><name>count_items_count</name> <operator>=</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>count_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>count_items_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>num_hist</name> <init>= <expr><name><name>stats</name><operator>-&gt;</operator><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DECountItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>sorted_count_items</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>delta</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type>		<name>frac</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float4</name>	   <modifier>*</modifier></type><name>hist</name></decl>;</decl_stmt>

			<comment type="block">/* num_hist must be at least 2 for the loop below to work */</comment>
			<expr_stmt><expr><name>num_hist</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>num_hist</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Create an array of DECountItem pointers, and sort them into
			 * increasing count order.
			 */</comment>
			<expr_stmt><expr><name>sorted_count_items</name> <operator>=</operator> <operator>(</operator><name>DECountItem</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DECountItem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count_items_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name>count_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>count_item</name> <operator>=</operator> <operator>(</operator><name>DECountItem</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sorted_count_items</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>count_item</name></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sorted_count_items</name></expr></argument>, <argument><expr><name>count_items_count</name></expr></argument>,
				  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DECountItem</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>countitem_compare_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Prepare to fill stanumbers with the histogram, followed by the
			 * average count.  This array must be stored in anl_context.
			 */</comment>
			<expr_stmt><expr><name>hist</name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>stats</name><operator>-&gt;</operator><name>anl_context</name></name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>float4</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>num_hist</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hist</name><index>[<expr><name>num_hist</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>element_no</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>nonnull_cnt</name></expr>;</expr_stmt>

			<comment type="block">/*----------
			 * Construct the histogram of distinct-element counts (DECs).
			 *
			 * The object of this loop is to copy the min and max DECs to
			 * hist[0] and hist[num_hist - 1], along with evenly-spaced DECs
			 * in between (where "evenly-spaced" is with reference to the
			 * whole input population of arrays).  If we had a complete sorted
			 * array of DECs, one per analyzed row, the i'th hist value would
			 * come from DECs[i * (analyzed_rows - 1) / (num_hist - 1)]
			 * (compare the histogram-making loop in compute_scalar_stats()).
			 * But instead of that we have the sorted_count_items[] array,
			 * which holds unique DEC values with their frequencies (that is,
			 * a run-length-compressed version of the full array).  So we
			 * control advancing through sorted_count_items[] with the
			 * variable "frac", which is defined as (x - y) * (num_hist - 1),
			 * where x is the index in the notional DECs array corresponding
			 * to the start of the next sorted_count_items[] element's run,
			 * and y is the index in DECs from which we should take the next
			 * histogram value.  We have to advance whenever x &lt;= y, that is
			 * frac &lt;= 0.  The x component is the sum of the frequencies seen
			 * so far (up through the current sorted_count_items[] element),
			 * and of course y * (num_hist - 1) = i * (analyzed_rows - 1),
			 * per the subscript calculation above.  (The subscript calculation
			 * implies dropping any fractional part of y; in this formulation
			 * that's handled by not advancing until frac reaches 1.)
			 *
			 * Even though frac has a bounded range, it could overflow int32
			 * when working with very large statistics targets, so we do that
			 * math in int64.
			 *----------
			 */</comment>
			<expr_stmt><expr><name>delta</name> <operator>=</operator> <name>analyzed_rows</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* current index in sorted_count_items */</comment>
			<comment type="block">/* Initialize frac for sorted_count_items[0]; y is initially 0 */</comment>
			<expr_stmt><expr><name>frac</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>sorted_count_items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>frequency</name> <operator>*</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_hist</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<while>while <condition>(<expr><name>frac</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Advance, and update x component of frac */</comment>
					<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>frac</name> <operator>+=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>sorted_count_items</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>frequency</name> <operator>*</operator> <operator>(</operator><name>num_hist</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block></while>
				<expr_stmt><expr><name><name>hist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sorted_count_items</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>count</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>frac</name> <operator>-=</operator> <name>delta</name></expr>;</expr_stmt>	<comment type="block">/* update y for upcoming i increment */</comment>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>==</operator> <name>count_items_count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stakind</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>STATISTIC_KIND_DECHIST</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>staop</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name><name>extra_data</name><operator>-&gt;</operator><name>eq_opr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stanumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>hist</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>numnumbers</name><index>[<expr><name>slot_idx</name></expr>]</index></name> <operator>=</operator> <name>num_hist</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>slot_idx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We don't need to bother cleaning up any of our temporary palloc's. The
	 * hashtable should also go away, as it used a child memory context.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * A function to prune the D structure from the Lossy Counting algorithm.
 * Consult compute_tsvector_stats() for wider explanation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prune_element_hashtable</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>elements_tab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b_current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan_status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TrackItem</name>  <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name>elements_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>item</name> <operator>=</operator> <operator>(</operator><name>TrackItem</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>frequency</name></name> <operator>+</operator> <name><name>item</name><operator>-&gt;</operator><name>delta</name></name> <operator>&lt;=</operator> <name>b_current</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>key</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>elements_tab</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
							<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* We should free memory if element is not passed by value */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>array_extra_data</name><operator>-&gt;</operator><name>typbyval</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Hash function for elements.
 *
 * We use the element type's default hash opclass, and the default collation
 * if the type is collation-sensitive.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>element_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Datum</name> <operator>*</operator><operator>)</operator> <name>key</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>h</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>FunctionCall1Coll</name><argument_list>(<argument><expr><name><name>array_extra_data</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Matching function for elements, to be used in hashtable lookups.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>element_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* The keysize parameter is superfluous here */</comment>
	<return>return <expr><call><name>element_compare</name><argument_list>(<argument><expr><name>key1</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison function for elements.
 *
 * We use the element type's default btree opclass, and the default collation
 * if the type is collation-sensitive.
 *
 * XXX consider using SortSupport infrastructure
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>element_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d1</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Datum</name> <operator>*</operator><operator>)</operator> <name>key1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>d2</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Datum</name> <operator>*</operator><operator>)</operator> <name>key2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name><name>array_extra_data</name><operator>-&gt;</operator><name>cmp</name></name></expr></argument>, <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>, <argument><expr><name>d1</name></expr></argument>, <argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort() comparator for sorting TrackItems by frequencies (descending sort)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>trackitem_compare_frequencies_desc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TrackItem</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>t1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TrackItem</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>e1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TrackItem</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>t2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TrackItem</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>e2</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><operator>(</operator><operator>*</operator><name>t2</name><operator>)</operator><operator>-&gt;</operator><name>frequency</name></name> <operator>-</operator> <name><operator>(</operator><operator>*</operator><name>t1</name><operator>)</operator><operator>-&gt;</operator><name>frequency</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort() comparator for sorting TrackItems by element values
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>trackitem_compare_element</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TrackItem</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>t1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TrackItem</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>e1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>TrackItem</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>t2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TrackItem</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>e2</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>element_compare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>t1</name><operator>)</operator><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>t2</name><operator>)</operator><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort() comparator for sorting DECountItems by count
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>countitem_compare_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DECountItem</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>t1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>DECountItem</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>e1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DECountItem</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>t2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>DECountItem</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>e2</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>t1</name><operator>)</operator><operator>-&gt;</operator><name>count</name></name> <operator>&lt;</operator> <name><operator>(</operator><operator>*</operator><name>t2</name><operator>)</operator><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>t1</name><operator>)</operator><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <name><operator>(</operator><operator>*</operator><name>t2</name><operator>)</operator><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
