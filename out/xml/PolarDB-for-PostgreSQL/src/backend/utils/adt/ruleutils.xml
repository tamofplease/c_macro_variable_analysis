<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/adt/ruleutils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ruleutils.c
 *	  Functions to convert stored expressions/querytrees back to
 *	  source text
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/ruleutils.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_partitioned_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/keywords.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteSupport.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/xml.h"</cpp:file></cpp:include>


<comment type="block">/* ----------
 * Pretty formatting constants
 * ----------
 */</comment>

<comment type="block">/* Indent counts */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYINDENT_STD</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYINDENT_JOIN</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYINDENT_VAR</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYINDENT_LIMIT</name></cpp:macro>		<cpp:value>40</cpp:value></cpp:define>	<comment type="block">/* wrap limit */</comment>

<comment type="block">/* Pretty flags */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYFLAG_PAREN</name></cpp:macro>		<cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYFLAG_INDENT</name></cpp:macro>		<cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTYFLAG_SCHEMA</name></cpp:macro>		<cpp:value>0x0004</cpp:value></cpp:define>

<comment type="block">/* Default line length for pretty-print wrapping: 0 means wrap always */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRAP_COLUMN_DEFAULT</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* macros to test if pretty action needed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTY_PAREN</name><parameter_list>(<parameter><type><name>context</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((context)-&gt;prettyFlags &amp; PRETTYFLAG_PAREN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTY_INDENT</name><parameter_list>(<parameter><type><name>context</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((context)-&gt;prettyFlags &amp; PRETTYFLAG_INDENT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRETTY_SCHEMA</name><parameter_list>(<parameter><type><name>context</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((context)-&gt;prettyFlags &amp; PRETTYFLAG_SCHEMA)</cpp:value></cpp:define>


<comment type="block">/* ----------
 * Local data types
 * ----------
 */</comment>

<comment type="block">/* Context info needed for invoking a recursive querytree display routine */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name></decl>;</decl_stmt>			<comment type="block">/* output buffer to append to */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namespaces</name></decl>;</decl_stmt>		<comment type="block">/* List of deparse_namespace nodes */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>windowClause</name></decl>;</decl_stmt>	<comment type="block">/* Current query level's WINDOW clause */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>windowTList</name></decl>;</decl_stmt>	<comment type="block">/* targetlist for resolving WINDOW clause */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>	<comment type="block">/* enabling of pretty-print functions */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>wrapColumn</name></decl>;</decl_stmt>		<comment type="block">/* max line length, or -1 for no limit */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>indentLevel</name></decl>;</decl_stmt>	<comment type="block">/* current indent level for prettyprint */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>varprefix</name></decl>;</decl_stmt>		<comment type="block">/* true to print prefixes on Vars */</comment>
	<decl_stmt><decl><type><name>ParseExprKind</name></type> <name>special_exprkind</name></decl>;</decl_stmt> <comment type="block">/* set only for exprkinds needing special
									 * handling */</comment>
}</block></struct></type> <name>deparse_context</name>;</typedef>

<comment type="block">/*
 * Each level of query context around a subtree needs a level of Var namespace.
 * A Var having varlevelsup=N refers to the N'th item (counting from 0) in
 * the current context's namespaces list.
 *
 * The rangetable is the list of actual RTEs from the query tree, and the
 * cte list is the list of actual CTEs.
 *
 * rtable_names holds the alias name to be used for each RTE (either a C
 * string, or NULL for nameless RTEs such as unnamed joins).
 * rtable_columns holds the column alias names to be used for each RTE.
 *
 * In some cases we need to make names of merged JOIN USING columns unique
 * across the whole query, not only per-RTE.  If so, unique_using is true
 * and using_names is a list of C strings representing names already assigned
 * to USING columns.
 *
 * When deparsing plan trees, there is always just a single item in the
 * deparse_namespace list (since a plan tree never contains Vars with
 * varlevelsup &gt; 0).  We store the PlanState node that is the immediate
 * parent of the expression to be deparsed, as well as a list of that
 * PlanState's ancestors.  In addition, we store its outer and inner subplan
 * state nodes, as well as their plan nodes' targetlists, and the index tlist
 * if the current plan node might contain INDEX_VAR Vars.  (These fields could
 * be derived on-the-fly from the current PlanState, but it seems notationally
 * clearer to set them up as separate fields.)
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rtable</name></decl>;</decl_stmt>			<comment type="block">/* List of RangeTblEntry nodes */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rtable_names</name></decl>;</decl_stmt>	<comment type="block">/* Parallel list of names for RTEs */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rtable_columns</name></decl>;</decl_stmt> <comment type="block">/* Parallel list of deparse_columns structs */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ctes</name></decl>;</decl_stmt>			<comment type="block">/* List of CommonTableExpr nodes */</comment>
	<comment type="block">/* Workspace for column alias assignment: */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>unique_using</name></decl>;</decl_stmt>	<comment type="block">/* Are we making USING names globally unique */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>using_names</name></decl>;</decl_stmt>	<comment type="block">/* List of assigned names for USING columns */</comment>
	<comment type="block">/* Remaining fields are used only when deparsing a Plan tree: */</comment>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>planstate</name></decl>;</decl_stmt>		<comment type="block">/* immediate parent of current expression */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ancestors</name></decl>;</decl_stmt>		<comment type="block">/* ancestors of planstate */</comment>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>outer_planstate</name></decl>;</decl_stmt>	<comment type="block">/* outer subplan state, or NULL if none */</comment>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>inner_planstate</name></decl>;</decl_stmt>	<comment type="block">/* inner subplan state, or NULL if none */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>outer_tlist</name></decl>;</decl_stmt>	<comment type="block">/* referent for OUTER_VAR Vars */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inner_tlist</name></decl>;</decl_stmt>	<comment type="block">/* referent for INNER_VAR Vars */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>index_tlist</name></decl>;</decl_stmt>	<comment type="block">/* referent for INDEX_VAR Vars */</comment>
}</block></struct></type> <name>deparse_namespace</name>;</typedef>

<comment type="block">/*
 * Per-relation data about column alias names.
 *
 * Selecting aliases is unreasonably complicated because of the need to dump
 * rules/views whose underlying tables may have had columns added, deleted, or
 * renamed since the query was parsed.  We must nonetheless print the rule/view
 * in a form that can be reloaded and will produce the same results as before.
 *
 * For each RTE used in the query, we must assign column aliases that are
 * unique within that RTE.  SQL does not require this of the original query,
 * but due to factors such as *-expansion we need to be able to uniquely
 * reference every column in a decompiled query.  As long as we qualify all
 * column references, per-RTE uniqueness is sufficient for that.
 *
 * However, we can't ensure per-column name uniqueness for unnamed join RTEs,
 * since they just inherit column names from their input RTEs, and we can't
 * rename the columns at the join level.  Most of the time this isn't an issue
 * because we don't need to reference the join's output columns as such; we
 * can reference the input columns instead.  That approach can fail for merged
 * JOIN USING columns, however, so when we have one of those in an unnamed
 * join, we have to make that column's alias globally unique across the whole
 * query to ensure it can be referenced unambiguously.
 *
 * Another problem is that a JOIN USING clause requires the columns to be
 * merged to have the same aliases in both input RTEs, and that no other
 * columns in those RTEs or their children conflict with the USING names.
 * To handle that, we do USING-column alias assignment in a recursive
 * traversal of the query's jointree.  When descending through a JOIN with
 * USING, we preassign the USING column names to the child columns, overriding
 * other rules for column alias assignment.  We also mark each RTE with a list
 * of all USING column names selected for joins containing that RTE, so that
 * when we assign other columns' aliases later, we can avoid conflicts.
 *
 * Another problem is that if a JOIN's input tables have had columns added or
 * deleted since the query was parsed, we must generate a column alias list
 * for the join that matches the current set of input columns --- otherwise, a
 * change in the number of columns in the left input would throw off matching
 * of aliases to columns of the right input.  Thus, positions in the printable
 * column alias list are not necessarily one-for-one with varattnos of the
 * JOIN, so we need a separate new_colnames[] array for printing purposes.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/*
	 * colnames is an array containing column aliases to use for columns that
	 * existed when the query was parsed.  Dropped columns have NULL entries.
	 * This array can be directly indexed by varattno to get a Var's name.
	 *
	 * Non-NULL entries are guaranteed unique within the RTE, *except* when
	 * this is for an unnamed JOIN RTE.  In that case we merely copy up names
	 * from the two input RTEs.
	 *
	 * During the recursive descent in set_using_names(), forcible assignment
	 * of a child RTE's column name is represented by pre-setting that element
	 * of the child's colnames array.  So at that stage, NULL entries in this
	 * array just mean that no name has been preassigned, not necessarily that
	 * the column is dropped.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_cols</name></decl>;</decl_stmt>		<comment type="block">/* length of colnames[] array */</comment>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>colnames</name></decl>;</decl_stmt>		<comment type="block">/* array of C strings and NULLs */</comment>

	<comment type="block">/*
	 * new_colnames is an array containing column aliases to use for columns
	 * that would exist if the query was re-parsed against the current
	 * definitions of its base tables.  This is what to print as the column
	 * alias list for the RTE.  This array does not include dropped columns,
	 * but it will include columns added since original parsing.  Indexes in
	 * it therefore have little to do with current varattno values.  As above,
	 * entries are unique unless this is for an unnamed JOIN RTE.  (In such an
	 * RTE, we never actually print this array, but we must compute it anyway
	 * for possible use in computing column names of upper joins.) The
	 * parallel array is_new_col marks which of these columns are new since
	 * original parsing.  Entries with is_new_col false must match the
	 * non-NULL colnames entries one-for-one.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_new_cols</name></decl>;</decl_stmt>	<comment type="block">/* length of new_colnames[] array */</comment>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>new_colnames</name></decl>;</decl_stmt>	<comment type="block">/* array of C strings */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>is_new_col</name></decl>;</decl_stmt>		<comment type="block">/* array of bool flags */</comment>

	<comment type="block">/* This flag tells whether we should actually print a column alias list */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>printaliases</name></decl>;</decl_stmt>

	<comment type="block">/* This list has all names used as USING names in joins above this RTE */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parentUsing</name></decl>;</decl_stmt>	<comment type="block">/* names assigned to parent merged columns */</comment>

	<comment type="block">/*
	 * If this struct is for a JOIN RTE, we fill these fields during the
	 * set_using_names() pass to describe its relationship to its child RTEs.
	 *
	 * leftattnos and rightattnos are arrays with one entry per existing
	 * output column of the join (hence, indexable by join varattno).  For a
	 * simple reference to a column of the left child, leftattnos[i] is the
	 * child RTE's attno and rightattnos[i] is zero; and conversely for a
	 * column of the right child.  But for merged columns produced by JOIN
	 * USING/NATURAL JOIN, both leftattnos[i] and rightattnos[i] are nonzero.
	 * Also, if the column has been dropped, both are zero.
	 *
	 * If it's a JOIN USING, usingNames holds the alias names selected for the
	 * merged columns (these might be different from the original USING list,
	 * if we had to modify names to achieve uniqueness).
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>leftrti</name></decl>;</decl_stmt>		<comment type="block">/* rangetable index of left child */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>rightrti</name></decl>;</decl_stmt>		<comment type="block">/* rangetable index of right child */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>leftattnos</name></decl>;</decl_stmt>		<comment type="block">/* left-child varattnos of join cols, or 0 */</comment>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>rightattnos</name></decl>;</decl_stmt>	<comment type="block">/* right-child varattnos of join cols, or 0 */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>usingNames</name></decl>;</decl_stmt>		<comment type="block">/* names assigned to merged columns */</comment>
}</block></struct></type> <name>deparse_columns</name>;</typedef>

<comment type="block">/* This macro is analogous to rt_fetch(), but for deparse_columns structs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>deparse_columns_fetch</name><parameter_list>(<parameter><type><name>rangetable_index</name></type></parameter>, <parameter><type><name>dpns</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((deparse_columns *) list_nth((dpns)-&gt;rtable_columns, (rangetable_index)-1))</cpp:value></cpp:define>

<comment type="block">/*
 * Entry in set_rtable_names' hash table
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* Hash key --- must be first */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>counter</name></decl>;</decl_stmt>		<comment type="block">/* Largest addition used so far for name */</comment>
}</block></struct></type> <name>NameHashEntry</name>;</typedef>


<comment type="block">/* ----------
 * Global data
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SPIPlanPtr</name></type> <name>plan_getrulebyoid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_getrulebyoid</name> <init>= <expr><literal type="string">"SELECT * FROM pg_catalog.pg_rewrite WHERE oid = $1"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SPIPlanPtr</name></type> <name>plan_getviewrule</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_getviewrule</name> <init>= <expr><literal type="string">"SELECT * FROM pg_catalog.pg_rewrite WHERE ev_class = $1 AND rulename = $2"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* GUC parameters */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>quote_all_identifiers</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* ----------
 * Local functions
 *
 * Most of these functions used to use fixed-size buffers to build their
 * results.  Now, they take an (already initialized) StringInfo object
 * as a parameter, and append their text output to its contents.
 * ----------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>deparse_expression_pretty</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dpcontext</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>forceprefix</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_get_viewdef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>viewoid</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrapColumn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_get_triggerdef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>trigid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pretty</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>decompile_column_index_array</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>column_index_array</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>,
							 <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_get_ruledef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ruleoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_get_indexdef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexrelid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colno</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>excludeOps</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>attrsOnly</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keysOnly</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>showTblSpc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inherits</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_get_statisticsobj_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>statextid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_get_partkeydef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>attrsOnly</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_get_constraintdef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>constraintId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fullCommand</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>pg_get_expr_worker</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>print_function_arguments</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>proctup</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>print_table_args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>print_defaults</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_function_rettype</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>proctup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_function_trftypes</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>proctup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_rtable_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parent_namespaces</name></decl></parameter>,
				 <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>rels_used</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_deparse_for_query</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parent_namespaces</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_simple_column_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>has_dangerous_join_using</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_using_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentUsing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_relation_column_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
						  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
						  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_join_column_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>colname_is_unique</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
				  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>make_colname_unique</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
					<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expand_colnames_array_to</name><parameter_list>(<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>identify_join_columns</name><parameter_list>(<parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>j</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>jrte</name></decl></parameter>,
					  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flatten_join_using_qual</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>leftvars</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>rightvars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_rtable_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_deparse_planstate</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>push_child_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>,
				<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pop_child_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
			   <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>push_ancestor_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>ancestor_cell</name></decl></parameter>,
				   <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pop_ancestor_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
				  <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_ruledef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>ruletup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>rulettc</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_viewdef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>ruletup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>rulettc</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrapColumn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentnamespace</name></decl></parameter>,
			  <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrapColumn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_values_def</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>values_lists</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_with_clause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_select_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					 <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_insert_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_update_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_update_query_targetlist_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
								<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
								<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_delete_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_utility_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_basic_select_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_target_list</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				<parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_setop_query</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
				<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				<parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>get_rule_sortgroupclause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>,
						 <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_groupingset</name><parameter_list>(<parameter><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gset</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>omit_parens</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_orderby</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orderList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_windowclause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_windowspec</name><parameter_list>(<parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
					<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_variable</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>istoplevel</name></decl></parameter>,
			 <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_special_variable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resolve_special_varno</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private</name></decl></parameter>,
					  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>callback</name>) <parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>find_param_referent</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier><modifier>*</modifier></type><name>dpns_p</name></decl></parameter>, <parameter><decl><type><name>ListCell</name> <modifier>*</modifier><modifier>*</modifier></type><name>ancestor_cell_p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_parameter</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_simple_binary_op_name</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isSimpleNode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>appendContextKeyword</name><parameter_list>(<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>indentBefore</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indentAfter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indentPlus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>removeStringInfoSpaces</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_expr_toplevel</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_rule_expr_funccall</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>looks_like_function</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_oper_expr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_func_expr</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_agg_expr</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			 <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>original_aggref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_agg_combine_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_windowfunc_expr</name><parameter_list>(<parameter><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_coercion_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>resulttype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>resulttypmod</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_const_expr</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>showtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_const_collation</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>simple_quote_literal</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_sublink_expr</name><parameter_list>(<parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_tablefunc</name><parameter_list>(<parameter><decl><type><name>TableFunc</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_from_clause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
				<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_from_clause_item</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					 <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_column_alias_list</name><parameter_list>(<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>,
					  <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_from_clause_coldeflist</name><parameter_list>(<parameter><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name></decl></parameter>,
						   <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>,
						   <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_tablesample_def</name><parameter_list>(<parameter><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tablesample</name></decl></parameter>,
					<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_opclass_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>,
				 <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>processIndirection</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printSubscripts</name><parameter_list>(<parameter><decl><type><name>ArrayRef</name> <modifier>*</modifier></type><name>aref</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_relation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_relation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespaces</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_qualified_relation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_function_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>argnames</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>has_variadic</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>use_variadic_p</name></decl></parameter>,
					   <parameter><decl><type><name>ParseExprKind</name></type> <name>special_exprkind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_operator_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>arg2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_cast_to</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_qualified_type_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>string_to_text</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>flatten_reloptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>only_marker</name><parameter_list>(<parameter><type><name>rte</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((rte)-&gt;inh ? "" : "ONLY ")</cpp:value></cpp:define>


<comment type="block">/* ----------
 * get_ruledef			- Do it all and return a text
 *				  that could be used as a statement
 *				  to recreate the rule
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_ruledef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ruleoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <name>PRETTYFLAG_INDENT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_ruledef_worker</name><argument_list>(<argument><expr><name>ruleoid</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>pg_get_ruledef_ext</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ruleoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pretty</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <ternary><condition><expr><name>pretty</name></expr> ?</condition><then> <expr><operator>(</operator><name>PRETTYFLAG_PAREN</name> <operator>|</operator> <name>PRETTYFLAG_INDENT</name> <operator>|</operator> <name>PRETTYFLAG_SCHEMA</name><operator>)</operator></expr> </then><else>: <expr><name>PRETTYFLAG_INDENT</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_ruledef_worker</name><argument_list>(<argument><expr><name>ruleoid</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pg_get_ruledef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ruleoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spirc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ruletup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>rulettc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do this first so that string is alloc'd in outer context not SPI's.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Connect to SPI manager
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On the first call prepare the plan to lookup pg_rewrite. We read
	 * pg_rewrite over the SPI manager instead of using the syscache to be
	 * checked for read access on pg_rewrite.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plan_getrulebyoid</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OIDOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name>query_getrulebyoid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare failed for \"%s\""</literal></expr></argument>, <argument><expr><name>query_getrulebyoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>SPI_keepplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>plan_getrulebyoid</name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the pg_rewrite tuple for this rule
	 */</comment>
	<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>ruleoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>spirc</name> <operator>=</operator> <call><name>SPI_execute_plan</name><argument_list>(<argument><expr><name>plan_getrulebyoid</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>spirc</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to get pg_rewrite tuple for rule %u"</literal></expr></argument>, <argument><expr><name>ruleoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There is no tuple data available here, just keep the output buffer
		 * empty.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Get the rule's definition and put it into executor's memory
		 */</comment>
		<expr_stmt><expr><name>ruletup</name> <operator>=</operator> <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rulettc</name> <operator>=</operator> <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>make_ruledef</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Disconnect from SPI manager
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_viewdef			- Mainly the same thing, but we
 *				  only return the SELECT part of a view
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_viewdef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* By OID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>viewoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <name>PRETTYFLAG_INDENT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_viewdef_worker</name><argument_list>(<argument><expr><name>viewoid</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>WRAP_COLUMN_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>pg_get_viewdef_ext</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* By OID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>viewoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pretty</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <ternary><condition><expr><name>pretty</name></expr> ?</condition><then> <expr><operator>(</operator><name>PRETTYFLAG_PAREN</name> <operator>|</operator> <name>PRETTYFLAG_INDENT</name> <operator>|</operator> <name>PRETTYFLAG_SCHEMA</name><operator>)</operator></expr> </then><else>: <expr><name>PRETTYFLAG_INDENT</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_viewdef_worker</name><argument_list>(<argument><expr><name>viewoid</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>WRAP_COLUMN_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_get_viewdef_wrap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* By OID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>viewoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wrap</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/* calling this implies we want pretty printing */</comment>
	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <name>PRETTYFLAG_PAREN</name> <operator>|</operator> <name>PRETTYFLAG_INDENT</name> <operator>|</operator> <name>PRETTYFLAG_SCHEMA</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_viewdef_worker</name><argument_list>(<argument><expr><name>viewoid</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>wrap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_get_viewdef_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* By qualified name */</comment>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>viewname</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>viewrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>viewoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <name>PRETTYFLAG_INDENT</name></expr>;</expr_stmt>

	<comment type="block">/* Look up view name.  Can't lock it - we might not have privileges. */</comment>
	<expr_stmt><expr><name>viewrel</name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><call><name>textToQualifiedNameList</name><argument_list>(<argument><expr><name>viewname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>viewoid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>viewrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_viewdef_worker</name><argument_list>(<argument><expr><name>viewoid</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>WRAP_COLUMN_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>pg_get_viewdef_name_ext</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* By qualified name */</comment>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>viewname</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pretty</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>viewrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>viewoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <ternary><condition><expr><name>pretty</name></expr> ?</condition><then> <expr><operator>(</operator><name>PRETTYFLAG_PAREN</name> <operator>|</operator> <name>PRETTYFLAG_INDENT</name> <operator>|</operator> <name>PRETTYFLAG_SCHEMA</name><operator>)</operator></expr> </then><else>: <expr><name>PRETTYFLAG_INDENT</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Look up view name.  Can't lock it - we might not have privileges. */</comment>
	<expr_stmt><expr><name>viewrel</name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><call><name>textToQualifiedNameList</name><argument_list>(<argument><expr><name>viewname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>viewoid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>viewrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_viewdef_worker</name><argument_list>(<argument><expr><name>viewoid</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>WRAP_COLUMN_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Common code for by-OID and by-name variants of pg_get_viewdef
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pg_get_viewdef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>viewoid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrapColumn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spirc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ruletup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>rulettc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do this first so that string is alloc'd in outer context not SPI's.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Connect to SPI manager
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On the first call prepare the plan to lookup pg_rewrite. We read
	 * pg_rewrite over the SPI manager instead of using the syscache to be
	 * checked for read access on pg_rewrite.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plan_getviewrule</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OIDOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NAMEOID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name>query_getviewrule</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare failed for \"%s\""</literal></expr></argument>, <argument><expr><name>query_getviewrule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>SPI_keepplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>plan_getviewrule</name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get the pg_rewrite tuple for the view's SELECT rule
	 */</comment>
	<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>viewoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>ViewSelectRuleName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>spirc</name> <operator>=</operator> <call><name>SPI_execute_plan</name><argument_list>(<argument><expr><name>plan_getviewrule</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>spirc</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to get pg_rewrite tuple for view %u"</literal></expr></argument>, <argument><expr><name>viewoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There is no tuple data available here, just keep the output buffer
		 * empty.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Get the rule's definition and put it into executor's memory
		 */</comment>
		<expr_stmt><expr><name>ruletup</name> <operator>=</operator> <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rulettc</name> <operator>=</operator> <name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>make_viewdef</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>wrapColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Disconnect from SPI manager
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_triggerdef			- Get the definition of a trigger
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_triggerdef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>trigid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_triggerdef_worker</name><argument_list>(<argument><expr><name>trigid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_get_triggerdef_ext</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>trigid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pretty</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_triggerdef_worker</name><argument_list>(<argument><expr><name>trigid</name></expr></argument>, <argument><expr><name>pretty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pg_get_triggerdef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>trigid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pretty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_trig</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>trigrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>tgrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>findx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tgname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tgoldtable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tgnewtable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* dummy */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fetch the pg_trigger tuple by the Oid of the trigger
	 */</comment>
	<expr_stmt><expr><name>tgrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>trigid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tgscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ht_trig</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_trig</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>trigrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_trig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start the trigger definition. Note that the trigger's name should never
	 * be schema-qualified, but the trigger rel's name may be.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tgname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CREATE %sTRIGGER %s "</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgconstraint</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"CONSTRAINT "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>tgname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_BEFORE</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"BEFORE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FOR_AFTER</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"AFTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FOR_INSTEAD</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INSTEAD OF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected tgtype value: %d"</literal></expr></argument>, <argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_INSERT</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_DELETE</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>findx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OR DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>findx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OR UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* tgattr is first var-width field, so OK to access directly */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgattr</name><operator>.</operator><name>dim1</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OF "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigrec</name><operator>-&gt;</operator><name>tgattr</name><operator>.</operator><name>dim1</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgrelid</name></name></expr></argument>,
									  <argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgattr</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_TRUNCATE</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>findx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OR TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>findx</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In non-pretty mode, always schema-qualify the target table name for
	 * safety.  In pretty mode, schema-qualify only if not visible.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON %s "</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>pretty</name></expr> ?</condition><then>
					 <expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgrelid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr> </then><else>:
					 <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgrelid</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgconstraint</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgconstrrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FROM %s "</literal></expr></argument>,
							 <argument><expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgconstrrelid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trigrec</name><operator>-&gt;</operator><name>tgdeferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DEFERRABLE INITIALLY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trigrec</name><operator>-&gt;</operator><name>tginitdeferred</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DEFERRED "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"IMMEDIATE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>ht_trig</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgoldtable</name></expr></argument>,
						<argument><expr><name><name>tgrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tgoldtable</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tgoldtable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>ht_trig</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgnewtable</name></expr></argument>,
						<argument><expr><name><name>tgrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tgnewtable</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tgnewtable</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>tgoldtable</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>tgnewtable</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"REFERENCING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tgoldtable</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OLD TABLE AS %s "</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>tgoldtable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>tgnewtable</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NEW TABLE AS %s "</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>tgnewtable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FOR EACH ROW "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FOR EACH STATEMENT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* If the trigger has a WHEN qualification, add that */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>ht_trig</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgqual</name></expr></argument>,
						<argument><expr><name><name>tgrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_context</name></type> <name>context</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>dpns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>oldrte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>newrte</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"WHEN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build minimal OLD and NEW RTEs for the rel */</comment>
		<expr_stmt><expr><name>oldrte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldrte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldrte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>trigrec</name><operator>-&gt;</operator><name>tgrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldrte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldrte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name><name>oldrte</name><operator>-&gt;</operator><name>alias</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldrte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldrte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oldrte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newrte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>trigrec</name><operator>-&gt;</operator><name>tgrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name><name>newrte</name><operator>-&gt;</operator><name>alias</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Build two-element rtable */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dpns</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dpns</name><operator>.</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>oldrte</name></expr></argument>, <argument><expr><name>newrte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dpns</name><operator>.</operator><name>ctes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_rtable_names</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_simple_column_names</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up context with one-deep namespace stack */</comment>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <operator>&amp;</operator><name>buf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>namespaces</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowTList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varprefix</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>prettyFlags</name></name> <operator>=</operator> <ternary><condition><expr><name>pretty</name></expr> ?</condition><then> <expr><operator>(</operator><name>PRETTYFLAG_PAREN</name> <operator>|</operator> <name>PRETTYFLAG_INDENT</name> <operator>|</operator> <name>PRETTYFLAG_SCHEMA</name><operator>)</operator></expr> </then><else>: <expr><name>PRETTYFLAG_INDENT</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>wrapColumn</name></name> <operator>=</operator> <name>WRAP_COLUMN_DEFAULT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>indentLevel</name></name> <operator>=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>special_exprkind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXECUTE PROCEDURE %s("</literal></expr></argument>,
					 <argument><expr><call><name>generate_function_name</name><argument_list>(<argument><expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgfoid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>trigrec</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>ht_trig</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgargs</name></expr></argument>,
							<argument><expr><name><name>tgrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tgargs is null for trigger %u"</literal></expr></argument>, <argument><expr><name>trigid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigrec</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* advance p to next string embedded in tgargs */</comment>
			<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We deliberately do not put semi-colon at end */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_indexdef			- Get the definition of an index
 *
 * In the extended version, there is a colno argument as well as pretty bool.
 *	if colno == 0, we want a complete index definition.
 *	if colno &gt; 0, we only want the Nth index key's variable or expression.
 *
 * Note that the SQL-function versions of this omit any info about the
 * index tablespace; this is intentional because pg_dump wants it that way.
 * However pg_get_indexdef_string() includes the index tablespace.
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_indexdef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexrelid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <name>PRETTYFLAG_INDENT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_indexdef_worker</name><argument_list>(<argument><expr><name>indexrelid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_get_indexdef_ext</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indexrelid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>colno</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pretty</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <ternary><condition><expr><name>pretty</name></expr> ?</condition><then> <expr><operator>(</operator><name>PRETTYFLAG_PAREN</name> <operator>|</operator> <name>PRETTYFLAG_INDENT</name> <operator>|</operator> <name>PRETTYFLAG_SCHEMA</name><operator>)</operator></expr> </then><else>: <expr><name>PRETTYFLAG_INDENT</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_indexdef_worker</name><argument_list>(<argument><expr><name>indexrelid</name></expr></argument>, <argument><expr><name>colno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>colno</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Internal version for use by ALTER TABLE.
 * Includes a tablespace clause in the result.
 * Returns a palloc'd C string; no pretty-printing.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_indexdef_string</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_get_indexdef_worker</name><argument_list>(<argument><expr><name>indexrelid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Internal version that just reports the key-column definitions */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_indexdef_columns</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexrelid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pretty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <ternary><condition><expr><name>pretty</name></expr> ?</condition><then> <expr><operator>(</operator><name>PRETTYFLAG_PAREN</name> <operator>|</operator> <name>PRETTYFLAG_INDENT</name> <operator>|</operator> <name>PRETTYFLAG_SCHEMA</name><operator>)</operator></expr> </then><else>: <expr><name>PRETTYFLAG_INDENT</name></expr></else></ternary></expr>;</expr_stmt>

	<return>return <expr><call><name>pg_get_indexdef_worker</name><argument_list>(<argument><expr><name>indexrelid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Internal workhorse to decompile an index definition.
 *
 * This is now used for exclusion constraints as well: if excludeOps is not
 * NULL then it points to an array of exclusion operator OIDs.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pg_get_indexdef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexrelid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>colno</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>excludeOps</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>attrsOnly</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keysOnly</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>showTblSpc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inherits</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* might want a separate isConstraint parameter later */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isConstraint</name> <init>= <expr><operator>(</operator><name>excludeOps</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_idxrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_am</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>idxrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>idxrelrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_am</name></type>	<name>amrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>indcollDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>indclassDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>indoptionDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int2vector</name> <modifier>*</modifier></type><name>indoption</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Fetch the pg_index tuple by the Oid of the index
	 */</comment>
	<expr_stmt><expr><name>ht_idx</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>idxrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indrelid</name> <operator>=</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>indexrelid</name> <operator>==</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must get indcollation, indclass, and indoption the hard way */</comment>
	<expr_stmt><expr><name>indcollDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
								   <argument><expr><name>Anum_pg_index_indcollation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indcollation</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indcollDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
									<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indoptionDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
									 <argument><expr><name>Anum_pg_index_indoption</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indoption</name> <operator>=</operator> <operator>(</operator><name>int2vector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indoptionDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch the pg_class tuple of the index relation
	 */</comment>
	<expr_stmt><expr><name>ht_idxrel</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>indexrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>idxrelrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch the pg_am tuple of the index' access method
	 */</comment>
	<expr_stmt><expr><name>ht_am</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_am</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for access method %u"</literal></expr></argument>,
			 <argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>amrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_am</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch the index AM's API struct */</comment>
	<expr_stmt><expr><name>amroutine</name> <operator>=</operator> <call><name>GetIndexAmRoutine</name><argument_list>(<argument><expr><name><name>amrec</name><operator>-&gt;</operator><name>amhandler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the index expressions, if any.  (NOTE: we do not use the relcache
	 * versions of the expressions and predicate, because we want to display
	 * non-const-folded expressions.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>, <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>exprsDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprsString</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>exprsDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
									 <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exprsString</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>exprsDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexprs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>exprsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>exprsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>indexprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>indexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>deparse_context_for</name><argument_list>(<argument><expr><call><name>get_relation_name</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start the index definition.  Note that the index's name should never be
	 * schema-qualified, but the indexed rel's name may be.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrsOnly</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isConstraint</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CREATE %sINDEX %s ON %s%s USING %s ("</literal></expr></argument>,
							 <argument><expr><ternary><condition><expr><name><name>idxrec</name><operator>-&gt;</operator><name>indisunique</name></name></expr> ?</condition><then> <expr><literal type="string">"UNIQUE "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><ternary><condition><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name>
							 <operator>&amp;&amp;</operator> <operator>!</operator><name>inherits</name></expr> ?</condition><then> <expr><literal type="string">"ONLY "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
							 <argument><expr><ternary><condition><expr><operator>(</operator><name>prettyFlags</name> <operator>&amp;</operator> <name>PRETTYFLAG_SCHEMA</name><operator>)</operator></expr> ?</condition><then>
							 <expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr> </then><else>:
							 <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>amrec</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>					<comment type="block">/* currently, must be EXCLUDE constraint */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXCLUDE USING %s ("</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>amrec</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Report the indexed attributes
	 */</comment>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>idxrec</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>keycoltype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>keycolcollation</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore non-key attributes if told to.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>keysOnly</name> <operator>&amp;&amp;</operator> <name>keyno</name> <operator>&gt;=</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Otherwise, print INCLUDE to divide key and non-key attrs. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>colno</name> <operator>&amp;&amp;</operator> <name>keyno</name> <operator>==</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") INCLUDE ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>colno</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple index column */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>keycoltypmod</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>colno</name> <operator>||</operator> <name>colno</name> <operator>==</operator> <name>keyno</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>keycoltype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keycoltypmod</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>keycolcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* expressional index */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in indexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Deparse */</comment>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>deparse_expression_pretty</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											<argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>colno</name> <operator>||</operator> <name>colno</name> <operator>==</operator> <name>keyno</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Need parens if it's not a bare function call */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>looks_like_function</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>keycoltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>keycolcollation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Print additional decoration for (selected) key columns */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrsOnly</name> <operator>&amp;&amp;</operator> <name>keyno</name> <operator>&lt;</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indnkeyatts</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>!</operator><name>colno</name> <operator>||</operator> <name>colno</name> <operator>==</operator> <name>keyno</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int16</name></type>		<name>opt</name> <init>= <expr><name><name>indoption</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>indcoll</name> <init>= <expr><name><name>indcollation</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Add collation, if not default for column */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indcoll</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>indcoll</name> <operator>!=</operator> <name>keycolcollation</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
								 <argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><operator>(</operator><name>indcoll</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Add the operator class name, if not default */</comment>
			<expr_stmt><expr><call><name>get_opclass_name</name><argument_list>(<argument><expr><name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>, <argument><expr><name>keycoltype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add options if relevant */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>amroutine</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* if it supports sort ordering, report DESC and NULLS opts */</comment>
				<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_DESC</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* NULLS FIRST is the default in this case */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_NULLS_FIRST</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_NULLS_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Add the exclusion operator if relevant */</comment>
			<if_stmt><if>if <condition>(<expr><name>excludeOps</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WITH %s"</literal></expr></argument>,
								 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>excludeOps</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>,
														<argument><expr><name>keycoltype</name></expr></argument>,
														<argument><expr><name>keycoltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrsOnly</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it has options, append "WITH (options)"
		 */</comment>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>flatten_reloptions</name><argument_list>(<argument><expr><name>indexrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WITH (%s)"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Print tablespace, but only if requested
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>showTblSpc</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>tblspc</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tblspc</name> <operator>=</operator> <call><name>get_rel_tablespace</name><argument_list>(<argument><expr><name>indexrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tblspc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tblspc</name> <operator>=</operator> <name>MyDatabaseTableSpace</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>isConstraint</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" USING INDEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" TABLESPACE %s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tblspc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If it's a partial index, decompile and append the predicate
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>, <argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>predDatum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>predString</name></decl>;</decl_stmt>

			<comment type="block">/* Convert text string to node tree */</comment>
			<expr_stmt><expr><name>predDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
										<argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>predString</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>predDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>predString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>predString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Deparse */</comment>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>deparse_expression_pretty</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											<argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isConstraint</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE (%s)"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE %s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_am</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_get_statisticsobjdef
 *		Get the definition of an extended statistics object
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_statisticsobjdef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>statextid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_statisticsobj_worker</name><argument_list>(<argument><expr><name>statextid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Internal workhorse to decompile an extended statistics object.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pg_get_statisticsobj_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>statextid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_statistic_ext</name></type> <name>statextrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>statexttup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>enabled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ndistinct_enabled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dependencies_enabled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>statexttup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>statextid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>statexttup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for statistics object %u"</literal></expr></argument>, <argument><expr><name>statextid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>statextrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic_ext</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>statexttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>statextrec</name><operator>-&gt;</operator><name>stxnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CREATE STATISTICS %s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>,
												<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>statextrec</name><operator>-&gt;</operator><name>stxname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decode the stxkind column so that we know which stats types to print.
	 */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><name>statexttup</name></expr></argument>,
							<argument><expr><name>Anum_pg_statistic_ext_stxkind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CHAROID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stxkind is not a 1-D char array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>enabled</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ndistinct_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dependencies_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>enabled</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>STATS_EXT_NDISTINCT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ndistinct_enabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>enabled</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>STATS_EXT_DEPENDENCIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dependencies_enabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If any option is disabled, then we'll need to append the types clause
	 * to show which options are enabled.  We omit the types clause on purpose
	 * when all options are enabled, so a pg_dump/pg_restore will create all
	 * statistics types on a newer postgres version, if the statistics had all
	 * options enabled on the original version.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ndistinct_enabled</name> <operator>||</operator> <operator>!</operator><name>dependencies_enabled</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ndistinct_enabled</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ndistinct"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>dependencies_enabled</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"dependencies"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>colno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>colno</name> <operator>&lt;</operator> <name><name>statextrec</name><operator>-&gt;</operator><name>stxkeys</name><operator>.</operator><name>dim1</name></name></expr>;</condition> <incr><expr><name>colno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>statextrec</name><operator>-&gt;</operator><name>stxkeys</name><operator>.</operator><name>values</name><index>[<expr><name>colno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>colno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>statextrec</name><operator>-&gt;</operator><name>stxrelid</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FROM %s"</literal></expr></argument>,
					 <argument><expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name><name>statextrec</name><operator>-&gt;</operator><name>stxrelid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>statexttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_get_partkeydef
 *
 * Returns the partition key specification, ie, the following:
 *
 * PARTITION BY { RANGE | LIST | HASH } (column opt_collation opt_opclass [, ...])
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_partkeydef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_partkeydef_worker</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>PRETTYFLAG_INDENT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Internal version that just reports the column definitions */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_partkeydef_columns</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pretty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <ternary><condition><expr><name>pretty</name></expr> ?</condition><then> <expr><operator>(</operator><name>PRETTYFLAG_PAREN</name> <operator>|</operator> <name>PRETTYFLAG_INDENT</name> <operator>|</operator> <name>PRETTYFLAG_SCHEMA</name><operator>)</operator></expr> </then><else>: <expr><name>PRETTYFLAG_INDENT</name></expr></else></ternary></expr>;</expr_stmt>

	<return>return <expr><call><name>pg_get_partkeydef_worker</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Internal workhorse to decompile a partition key definition.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pg_get_partkeydef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>attrsOnly</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_partitioned_table</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>partclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>partcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>partexpr_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for partition key of %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_partitioned_table</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>form</name><operator>-&gt;</operator><name>partrelid</name></name> <operator>==</operator> <name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must get partclass and partcollation the hard way */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_partitioned_table_partclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_partitioned_table_partcollation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partcollation</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * Get the expressions, if any.  (NOTE: we do not use the relcache
	 * versions of the expressions, because we want to display
	 * non-const-folded expressions.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_partitioned_table_partexprs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>exprsDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprsString</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>exprsDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
									 <argument><expr><name>Anum_pg_partitioned_table_partexprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exprsString</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>exprsDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partexprs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>exprsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>partexprs</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected node type found in partexprs: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>partexprs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>exprsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>partexprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>partexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>partexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>deparse_context_for</name><argument_list>(<argument><expr><call><name>get_relation_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>form</name><operator>-&gt;</operator><name>partstrat</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrsOnly</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"HASH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrsOnly</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LIST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrsOnly</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"RANGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>form</name><operator>-&gt;</operator><name>partstrat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrsOnly</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>form</name><operator>-&gt;</operator><name>partnatts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>form</name><operator>-&gt;</operator><name>partattrs</name><operator>.</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>keycoltype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>keycolcollation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>partcoll</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple attribute reference */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>keycoltypmod</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>keycoltype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keycoltypmod</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>keycolcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Expression */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>partkey</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>partexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in partexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>partkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>partexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>partexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Deparse */</comment>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>deparse_expression_pretty</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											<argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Need parens if it's not a bare function call */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>looks_like_function</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>keycoltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>keycolcollation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Add collation, if not default for column */</comment>
		<expr_stmt><expr><name>partcoll</name> <operator>=</operator> <name><name>partcollation</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrsOnly</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>partcoll</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>partcoll</name> <operator>!=</operator> <name>keycolcollation</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
							 <argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><operator>(</operator><name>partcoll</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Add the operator class name, if not default */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrsOnly</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_opclass_name</name><argument_list>(<argument><expr><name><name>partclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>, <argument><expr><name>keycoltype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attrsOnly</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_get_partition_constraintdef
 *
 * Returns partition constraint expression as a string for the input relation
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_partition_constraintdef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>constr_expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>consrc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>constr_expr</name> <operator>=</operator> <call><name>get_partition_qual_relid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Quick exit if no partition constraint */</comment>
	<if_stmt><if>if <condition>(<expr><name>constr_expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Deparse and return the constraint expression.
	 */</comment>
	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <name>PRETTYFLAG_INDENT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>deparse_context_for</name><argument_list>(<argument><expr><call><name>get_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>consrc</name> <operator>=</operator> <call><name>deparse_expression_pretty</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>constr_expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>consrc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_get_constraintdef
 *
 * Returns the definition for the constraint, ie, everything that needs to
 * appear after "ALTER TABLE ... ADD CONSTRAINT &lt;constraintname&gt;".
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_constraintdef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <name>PRETTYFLAG_INDENT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_constraintdef_worker</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_get_constraintdef_ext</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pretty</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <ternary><condition><expr><name>pretty</name></expr> ?</condition><then> <expr><operator>(</operator><name>PRETTYFLAG_PAREN</name> <operator>|</operator> <name>PRETTYFLAG_INDENT</name> <operator>|</operator> <name>PRETTYFLAG_SCHEMA</name><operator>)</operator></expr> </then><else>: <expr><name>PRETTYFLAG_INDENT</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_get_constraintdef_worker</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Internal version that returns a full ALTER TABLE ... ADD CONSTRAINT command
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_get_constraintdef_command</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>constraintId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pg_get_constraintdef_worker</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * As of 9.4, we now use an MVCC snapshot for this.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pg_get_constraintdef_worker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>constraintId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fullCommand</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>conForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name> <init>= <expr><call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
								  <argument><expr><name>ConstraintOidIndexId</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>snapshot</name></expr></argument>,
								  <argument><expr><literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We later use the tuple with SysCacheGetAttr() as if we had obtained it
	 * via SearchSysCache, which works fine.
	 */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for constraint %u"</literal></expr></argument>, <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>conForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fullCommand</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Currently, callers want ALTER TABLE (without ONLY) for CHECK
			 * constraints, and other types of constraints don't inherit
			 * anyway so it doesn't matter whether we say ONLY or not. Someday
			 * we might need to let callers specify whether to put ONLY in the
			 * command.
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s ADD CONSTRAINT %s "</literal></expr></argument>,
							 <argument><expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Must be a domain constraint */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>contypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ALTER DOMAIN %s ADD CONSTRAINT %s "</literal></expr></argument>,
							 <argument><expr><call><name>generate_qualified_type_name</name><argument_list>(<argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>contypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>conForm</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONSTRAINT_FOREIGN</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>

				<comment type="block">/* Start off the constraint definition */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN KEY ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Fetch and build referencing-column list */</comment>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
									  <argument><expr><name>Anum_pg_constraint_conkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conkey for constraint %u"</literal></expr></argument>,
						 <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>decompile_column_index_array</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* add foreign relation name */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") REFERENCES %s("</literal></expr></argument>,
								 <argument><expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>,
														<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Fetch and build referenced-column list */</comment>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
									  <argument><expr><name>Anum_pg_constraint_confkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null confkey for constraint %u"</literal></expr></argument>,
						 <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>decompile_column_index_array</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Add match type */</comment>
				<switch>switch <condition>(<expr><name><name>conForm</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>FKCONSTR_MATCH_FULL</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">" MATCH FULL"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>FKCONSTR_MATCH_PARTIAL</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">" MATCH PARTIAL"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>FKCONSTR_MATCH_SIMPLE</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized confmatchtype: %d"</literal></expr></argument>,
							 <argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
						<break>break;</break>
				</block_content>}</block></switch>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Add ON UPDATE and ON DELETE clauses, if needed */</comment>
				<switch>switch <condition>(<expr><name><name>conForm</name><operator>-&gt;</operator><name>confupdtype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>FKCONSTR_ACTION_NOACTION</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* suppress default */</comment>
						<break>break;</break>
					<case>case <expr><name>FKCONSTR_ACTION_RESTRICT</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">"RESTRICT"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>FKCONSTR_ACTION_CASCADE</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">"CASCADE"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>FKCONSTR_ACTION_SETNULL</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">"SET NULL"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>FKCONSTR_ACTION_SETDEFAULT</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">"SET DEFAULT"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized confupdtype: %d"</literal></expr></argument>,
							 <argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>confupdtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
						<break>break;</break>
				</block_content>}</block></switch>
				<if_stmt><if>if <condition>(<expr><name>string</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON UPDATE %s"</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<switch>switch <condition>(<expr><name><name>conForm</name><operator>-&gt;</operator><name>confdeltype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>FKCONSTR_ACTION_NOACTION</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* suppress default */</comment>
						<break>break;</break>
					<case>case <expr><name>FKCONSTR_ACTION_RESTRICT</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">"RESTRICT"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>FKCONSTR_ACTION_CASCADE</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">"CASCADE"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>FKCONSTR_ACTION_SETNULL</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">"SET NULL"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>FKCONSTR_ACTION_SETDEFAULT</name></expr>:</case>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <literal type="string">"SET DEFAULT"</literal></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized confdeltype: %d"</literal></expr></argument>,
							 <argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>confdeltype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
						<break>break;</break>
				</block_content>}</block></switch>
				<if_stmt><if>if <condition>(<expr><name>string</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON DELETE %s"</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>CONSTRAINT_PRIMARY</name></expr>:</case>
		<case>case <expr><name>CONSTRAINT_UNIQUE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>indexId</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>keyatts</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indtup</name></decl>;</decl_stmt>

				<comment type="block">/* Start off the constraint definition */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conForm</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_PRIMARY</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"PRIMARY KEY ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UNIQUE ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/* Fetch and build target column list */</comment>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
									  <argument><expr><name>Anum_pg_constraint_conkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conkey for constraint %u"</literal></expr></argument>,
						 <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>keyatts</name> <operator>=</operator> <call><name>decompile_column_index_array</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>indexId</name> <operator>=</operator> <call><name>get_constraint_index</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Build including column list (from pg_index.indkeys) */</comment>
				<expr_stmt><expr><name>indtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>indtup</name></expr></argument>,
									  <argument><expr><name>Anum_pg_index_indnatts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null indnatts for index %u"</literal></expr></argument>, <argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>keyatts</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Datum</name></type>		<name>cols</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>nKeys</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" INCLUDE ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>cols</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>indtup</name></expr></argument>,
										   <argument><expr><name>Anum_pg_index_indkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null indkey for index %u"</literal></expr></argument>, <argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>keys</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>keyatts</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nKeys</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colName</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>colName</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>,
											  <argument><expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>keyatts</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>

					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* XXX why do we only print these bits if fullCommand? */</comment>
				<if_stmt><if>if <condition>(<expr><name>fullCommand</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>options</name> <init>= <expr><call><name>flatten_reloptions</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>tblspc</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>options</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WITH (%s)"</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>tblspc</name> <operator>=</operator> <call><name>get_rel_tablespace</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tblspc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" USING INDEX TABLESPACE %s"</literal></expr></argument>,
										 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>tblspc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>CONSTRAINT_CHECK</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>conbin</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>consrc</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>

				<comment type="block">/* Fetch constraint expression in parsetree form */</comment>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
									  <argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conbin for constraint %u"</literal></expr></argument>,
						 <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>conbin</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>conbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Set up deparsing context for Var nodes in constraint */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conForm</name><operator>-&gt;</operator><name>conrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* relation constraint */</comment>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>deparse_context_for</name><argument_list>(<argument><expr><call><name>get_relation_name</name><argument_list>(<argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* domain constraint --- can't have Vars */</comment>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>consrc</name> <operator>=</operator> <call><name>deparse_expression_pretty</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												   <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Now emit the constraint definition, adding NO INHERIT if
				 * necessary.
				 *
				 * There are cases where the constraint expression will be
				 * fully parenthesized and we don't need the outer parens ...
				 * but there are other cases where we do need 'em.  Be
				 * conservative for now.
				 *
				 * Note that simply checking for leading '(' and trailing ')'
				 * would NOT be good enough, consider "(x &gt; 0) AND (y &gt; 0)".
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CHECK (%s)%s"</literal></expr></argument>,
								 <argument><expr><name>consrc</name></expr></argument>,
								 <argument><expr><ternary><condition><expr><name><name>conForm</name><operator>-&gt;</operator><name>connoinherit</name></name></expr> ?</condition><then> <expr><literal type="string">" NO INHERIT"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>CONSTRAINT_TRIGGER</name></expr>:</case>

			<comment type="block">/*
			 * There isn't an ALTER TABLE syntax for creating a user-defined
			 * constraint trigger, but it seems better to print something than
			 * throw an error; if we throw error then this function couldn't
			 * safely be applied to all rows of pg_constraint.
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"TRIGGER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CONSTRAINT_EXCLUSION</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name> <init>= <expr><name><name>conForm</name><operator>-&gt;</operator><name>conindid</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elems</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nElems</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>operators</name></decl>;</decl_stmt>

				<comment type="block">/* Extract operator OIDs from the pg_constraint tuple */</comment>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>,
									  <argument><expr><name>Anum_pg_constraint_conexclop</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conexclop for constraint %u"</literal></expr></argument>,
						 <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>elems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>operators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nElems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nElems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>operators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

				<comment type="block">/* pg_get_indexdef_worker does the rest */</comment>
				<comment type="block">/* suppress tablespace because pg_dump wants it that way */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
									   <argument><expr><call><name>pg_get_indexdef_worker</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>,
															  <argument><expr><literal type="number">0</literal></expr></argument>,
															  <argument><expr><name>operators</name></expr></argument>,
															  <argument><expr><name>false</name></expr></argument>,
															  <argument><expr><name>false</name></expr></argument>,
															  <argument><expr><name>false</name></expr></argument>,
															  <argument><expr><name>false</name></expr></argument>,
															  <argument><expr><name>prettyFlags</name></expr></argument>,
															  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid constraint type \"%c\""</literal></expr></argument>, <argument><expr><name><name>conForm</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>conForm</name><operator>-&gt;</operator><name>condeferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DEFERRABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conForm</name><operator>-&gt;</operator><name>condeferred</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" INITIALLY DEFERRED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conForm</name><operator>-&gt;</operator><name>convalidated</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NOT VALID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Cleanup */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Convert an int16[] Datum into a comma-separated list of column names
 * for the indicated relation; append the list to buf.  Returns the number
 * of keys.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>decompile_column_index_array</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>column_index_array</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>,
							 <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>keys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nKeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<comment type="block">/* Extract data from array of int16 */</comment>
	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>column_index_array</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>keys</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nKeys</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colName</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>colName</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>nKeys</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_expr			- Decompile an expression tree
 *
 * Input: an expression tree in nodeToString form, and a relation OID
 *
 * Output: reverse-listed expression
 *
 * Currently, the expression can only refer to a single relation, namely
 * the one specified by the second parameter.  This is sufficient for
 * partial indexes, column default expressions, etc.  We also support
 * Var-free expressions, for which the OID can be InvalidOid.
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_expr</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <name>PRETTYFLAG_INDENT</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get the name for the relation */</comment>
		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the OID isn't actually valid, don't throw an error, just return
		 * NULL.  This is a bit questionable, but it's what we've done
		 * historically, and it can help avoid unwanted failures when
		 * examining catalog entries for just-deleted relations.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>relname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>pg_get_expr_worker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_get_expr_ext</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>pretty</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>prettyFlags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>prettyFlags</name> <operator>=</operator> <ternary><condition><expr><name>pretty</name></expr> ?</condition><then> <expr><operator>(</operator><name>PRETTYFLAG_PAREN</name> <operator>|</operator> <name>PRETTYFLAG_INDENT</name> <operator>|</operator> <name>PRETTYFLAG_SCHEMA</name><operator>)</operator></expr> </then><else>: <expr><name>PRETTYFLAG_INDENT</name></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get the name for the relation */</comment>
		<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* See notes above */</comment>
		<if_stmt><if>if <condition>(<expr><name>relname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>relname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>pg_get_expr_worker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>pg_get_expr_worker</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<comment type="block">/* Convert input TEXT object to C string */</comment>
	<expr_stmt><expr><name>exprstr</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert expression to node tree */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>exprstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>exprstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare deparse context if needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>deparse_context_for</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>context</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Deparse */</comment>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>deparse_expression_pretty</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									<argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_userbyid			- Get a user name by roleid and
 *				  fallback to 'unknown (OID=n)'
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_userbyid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>roletup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_authid</name></type> <name>role_rec</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate space for the result
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Name</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the pg_authid entry and print the result
	 */</comment>
	<expr_stmt><expr><name>roletup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>roletup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>role_rec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>roletup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>role_rec</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>roletup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"unknown (OID=%u)"</literal></expr></argument>, <argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NAME</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_get_serial_sequence
 *		Get the name of the sequence used by an identity or serial column,
 *		formatted suitably for passing to setval, nextval or currval.
 *		First parameter is not treated as double-quoted, second parameter
 *		is --- see documentation for reason.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_serial_sequence</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>tablename</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>columnname</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>tablerv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tableOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>column</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sequenceId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>depRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/* Look up table name.  Can't lock it - we might not have privileges. */</comment>
	<expr_stmt><expr><name>tablerv</name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><call><name>textToQualifiedNameList</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tableOid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>tablerv</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the number of the column */</comment>
	<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>columnname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><name>column</name></expr></argument>, <argument><expr><name><name>tablerv</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Search the dependency table for the dependent sequence */</comment>
	<expr_stmt><expr><name>depRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>deprec</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Look for an auto dependency (serial column) or internal dependency
		 * (identity column) of a sequence on a column.  (We need the relkind
		 * test because indexes can also have auto dependencies on columns.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>deprec</name><operator>-&gt;</operator><name>classid</name></name> <operator>==</operator> <name>RelationRelationId</name> <operator>&amp;&amp;</operator>
			<name><name>deprec</name><operator>-&gt;</operator><name>objsubid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>deprec</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_AUTO</name> <operator>||</operator>
			 <name><name>deprec</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_INTERNAL</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>deprec</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sequenceId</name> <operator>=</operator> <name><name>deprec</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_get_functiondef
 *		Returns the complete "CREATE OR REPLACE FUNCTION ..." statement for
 *		the specified function.
 *
 * Note: if you change the output format of this function, be careful not
 * to break psql's rules (in \ef and \sf) for identifying the start of the
 * function body.  To wit: the function body starts on a line that begins
 * with "AS ", and no preceding line will look like that.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_functiondef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>dq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isfunction</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prosrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nsp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>procost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldlen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the function */</comment>
	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_AGGREGATE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is an aggregate function"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>isfunction</name> <operator>=</operator> <operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>prokind</name></name> <operator>!=</operator> <name>PROKIND_PROCEDURE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * We always qualify the function name, to ensure the right function gets
	 * replaced.
	 */</comment>
	<expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE %s %s("</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>isfunction</name></expr> ?</condition><then> <expr><literal type="string">"FUNCTION"</literal></expr> </then><else>: <expr><literal type="string">"PROCEDURE"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>print_function_arguments</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isfunction</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" RETURNS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_function_rettype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>print_function_trftypes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" LANGUAGE %s\n"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_language_name</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>prolang</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Emit some miscellaneous options on one line */</comment>
	<expr_stmt><expr><name>oldlen</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_WINDOW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WINDOW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>provolatile</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PROVOLATILE_IMMUTABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IMMUTABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROVOLATILE_STABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" STABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROVOLATILE_VOLATILE</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>

	<switch>switch <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>proparallel</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PROPARALLEL_SAFE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" PARALLEL SAFE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROPARALLEL_RESTRICTED</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" PARALLEL RESTRICTED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PROPARALLEL_UNSAFE</name></expr>:</case>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>proisstrict</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" STRICT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>prosecdef</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" SECURITY DEFINER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>proleakproof</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" LEAKPROOF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* This code for the default cost and rows should match functioncmds.c */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>prolang</name></name> <operator>==</operator> <name>INTERNALlanguageId</name> <operator>||</operator>
		<name><name>proc</name><operator>-&gt;</operator><name>prolang</name></name> <operator>==</operator> <name>ClanguageId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>procost</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>procost</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>procost</name></name> <operator>!=</operator> <name>procost</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COST %g"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>procost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>prorows</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>proc</name><operator>-&gt;</operator><name>prorows</name></name> <operator>!=</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ROWS %g"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>prorows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldlen</name> <operator>!=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Emit any proconfig options, one per line */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proconfig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>array_ref</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
						  <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
						  <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> ,
						  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>configitem</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>configitem</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>pos</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" SET %s TO "</literal></expr></argument>,
								 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>configitem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Variables that are marked GUC_LIST_QUOTE were already fully
				 * quoted by flatten_set_variable_args() before they were put
				 * into the proconfig array.  However, because the quoting
				 * rules used there aren't exactly like SQL's, we have to
				 * break the list value apart and then quote the elements as
				 * string literals.  (The elements may be double-quoted as-is,
				 * but we can't just feed them to the SQL parser; it would do
				 * the wrong thing with elements that are zero-length or
				 * longer than NAMEDATALEN.)
				 *
				 * Variables that are not so marked should just be emitted as
				 * simple string literals.  If the variable is not known to
				 * guc.c, we'll do that; this makes it unsafe to use
				 * GUC_LIST_QUOTE for extension variables.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>GetConfigOptionFlags</name><argument_list>(<argument><expr><name>configitem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>GUC_LIST_QUOTE</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

					<comment type="block">/* Parse string into list of identifiers */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitGUCList</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelist</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* this shouldn't fail really */</comment>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid list syntax in proconfig item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>namelist</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>curname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* And finally the function definition ... */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>, <argument><expr><name>Anum_pg_proc_probin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* assume prosrc isn't null */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>, <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>prosrc</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We always use dollar quoting.  Figure out a suitable delimiter.
	 *
	 * Since the user is likely to be editing the function body string, we
	 * shouldn't use a short delimiter that he might easily create a conflict
	 * with.  Hence prefer "$function$"/"$procedure$", but extend if needed.
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dq</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dq</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>isfunction</name></expr> ?</condition><then> <expr><literal type="string">"function"</literal></expr> </then><else>: <expr><literal type="string">"procedure"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>prosrc</name></expr></argument>, <argument><expr><name><name>dq</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dq</name></expr></argument>, <argument><expr><literal type="char">'x'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dq</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>dq</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>prosrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>dq</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_get_function_arguments
 *		Get a nicely-formatted list of arguments for a function.
 *		This is everything that would go between the parentheses in
 *		CREATE FUNCTION.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_function_arguments</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>print_function_arguments</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_get_function_identity_arguments
 *		Get a formatted list of arguments for a function.
 *		This is everything that would go between the parentheses in
 *		ALTER FUNCTION, etc.  In particular, don't print defaults.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_function_identity_arguments</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>print_function_arguments</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_get_function_result
 *		Get a nicely-formatted version of the result type of a function.
 *		This is what would appear after RETURNS in CREATE FUNCTION.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_function_result</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>prokind</name> <operator>==</operator> <name>PROKIND_PROCEDURE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>print_function_rettype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Guts of pg_get_function_result: append the function's return type
 * to the specified buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_function_rettype</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>proctup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proc</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntabargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>rbuf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>proretset</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It might be a table function; try to print the arguments */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rbuf</name></expr></argument>, <argument><expr><literal type="string">"TABLE("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ntabargs</name> <operator>=</operator> <call><name>print_function_arguments</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rbuf</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ntabargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rbuf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ntabargs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Not a table function, so do the normal thing */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>proretset</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rbuf</name></expr></argument>, <argument><expr><literal type="string">"SETOF "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rbuf</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>rbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Common code for pg_get_function_arguments and pg_get_function_result:
 * append the desired subset of arguments to buf.  We print only TABLE
 * arguments when print_table_args is true, and all the others when it's false.
 * We print argument defaults only if print_defaults is true.
 * Function return value is the number of arguments printed.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>print_function_arguments</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>proctup</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>print_table_args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>print_defaults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proc</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>insertorderbyat</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>argsprinted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inputargno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nlackdefaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nextargdefault</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>numargs</name> <operator>=</operator> <call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nlackdefaults</name> <operator>=</operator> <name>numargs</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>print_defaults</name> <operator>&amp;&amp;</operator> <name><name>proc</name><operator>-&gt;</operator><name>pronargdefaults</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>proargdefaults</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>proargdefaults</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>,
										 <argument><expr><name>Anum_pg_proc_proargdefaults</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argdefaults</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>proargdefaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>argdefaults</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nextargdefault</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>argdefaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* nlackdefaults counts only *input* arguments lacking defaults */</comment>
			<expr_stmt><expr><name>nlackdefaults</name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>-</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>argdefaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check for special treatment of ordered-set aggregates */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_AGGREGATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>aggtup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>agg</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aggtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for aggregate %u"</literal></expr></argument>,
				 <argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>agg</name> <operator>=</operator> <operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>insertorderbyat</name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggnumdirectargs</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>argsprinted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>inputargno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name> <init>= <expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argname</name> <init>= <expr><ternary><condition><expr><name>argnames</name></expr> ?</condition><then> <expr><name><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>argmode</name> <init>= <expr><ternary><condition><expr><name>argmodes</name></expr> ?</condition><then> <expr><name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>PROARGMODE_IN</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modename</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isinput</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>argmode</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PROARGMODE_IN</name></expr>:</case>
				<expr_stmt><expr><name>modename</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>isinput</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PROARGMODE_INOUT</name></expr>:</case>
				<expr_stmt><expr><name>modename</name> <operator>=</operator> <literal type="string">"INOUT "</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>isinput</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PROARGMODE_OUT</name></expr>:</case>
				<expr_stmt><expr><name>modename</name> <operator>=</operator> <literal type="string">"OUT "</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>isinput</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PROARGMODE_VARIADIC</name></expr>:</case>
				<expr_stmt><expr><name>modename</name> <operator>=</operator> <literal type="string">"VARIADIC "</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>isinput</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PROARGMODE_TABLE</name></expr>:</case>
				<expr_stmt><expr><name>modename</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>isinput</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid parameter mode '%c'"</literal></expr></argument>, <argument><expr><name>argmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>modename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
				<expr_stmt><expr><name>isinput</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<if_stmt><if>if <condition>(<expr><name>isinput</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inputargno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* this is a 1-based counter */</comment>

		<if_stmt><if>if <condition>(<expr><name>print_table_args</name> <operator>!=</operator> <operator>(</operator><name>argmode</name> <operator>==</operator> <name>PROARGMODE_TABLE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>argsprinted</name> <operator>==</operator> <name>insertorderbyat</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>argsprinted</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>argsprinted</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>modename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>argname</name> <operator>&amp;&amp;</operator> <name><name>argname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>argname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>print_defaults</name> <operator>&amp;&amp;</operator> <name>isinput</name> <operator>&amp;&amp;</operator> <name>inputargno</name> <operator>&gt;</operator> <name>nlackdefaults</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nextargdefault</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>nextargdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nextargdefault</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>nextargdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT %s"</literal></expr></argument>,
							 <argument><expr><call><name>deparse_expression</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>argsprinted</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* nasty hack: print the last arg twice for variadic ordered-set agg */</comment>
		<if_stmt><if>if <condition>(<expr><name>argsprinted</name> <operator>==</operator> <name>insertorderbyat</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>numargs</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
			<comment type="block">/* aggs shouldn't have defaults anyway, but just to be sure ... */</comment>
			<expr_stmt><expr><name>print_defaults</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>argsprinted</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_input_argument</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nth</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argmodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>!</operator><name>argmodes</name>
			<operator>||</operator> <name><name>argmodes</name><index>[<expr><name>nth</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_IN</name>
			<operator>||</operator> <name><name>argmodes</name><index>[<expr><name>nth</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_INOUT</name>
			<operator>||</operator> <name><name>argmodes</name><index>[<expr><name>nth</name></expr>]</index></name> <operator>==</operator> <name>PROARGMODE_VARIADIC</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Append used transformed types to specified buffer
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_function_trftypes</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>proctup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>trftypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntypes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ntypes</name> <operator>=</operator> <call><name>get_func_trftypes</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trftypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ntypes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n TRANSFORM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntypes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FOR TYPE %s"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>trftypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get textual representation of a function argument's default value.  The
 * second argument of this function is the argument number among all arguments
 * (i.e. proallargtypes, *not* proargtypes), starting with 1, because that's
 * how information_schema.sql uses it.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_get_function_arg_default</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nth_arg</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argdefaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nth_inputarg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>proargdefaults</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nth_default</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numargs</name> <operator>=</operator> <call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>nth_arg</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>nth_arg</name></expr></argument> &gt;</argument_list></name> <name>numargs</name> <operator>||</operator> <operator>!</operator><call><name>is_input_argument</name><argument_list>(<argument><expr><name>nth_arg</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>argmodes</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>nth_inputarg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nth_arg</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>is_input_argument</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>argmodes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nth_inputarg</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

	<expr_stmt><expr><name>proargdefaults</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>,
									 <argument><expr><name>Anum_pg_proc_proargdefaults</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>proargdefaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>argdefaults</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate index into proargdefaults: proargdefaults corresponds to the
	 * last N input arguments, where N = pronargdefaults.
	 */</comment>
	<expr_stmt><expr><name>nth_default</name> <operator>=</operator> <name>nth_inputarg</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>-</operator> <name><name>proc</name><operator>-&gt;</operator><name>pronargdefaults</name></name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nth_default</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>nth_default</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>argdefaults</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>argdefaults</name></expr></argument>, <argument><expr><name>nth_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>string_to_text</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * deparse_expression			- General utility for deparsing expressions
 *
 * calls deparse_expression_pretty with all prettyPrinting disabled
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>deparse_expression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dpcontext</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>forceprefix</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>deparse_expression_pretty</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>dpcontext</name></expr></argument>, <argument><expr><name>forceprefix</name></expr></argument>,
									 <argument><expr><name>showimplicit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * deparse_expression_pretty	- General utility for deparsing expressions
 *
 * expr is the node tree to be deparsed.  It must be a transformed expression
 * tree (ie, not the raw output of gram.y).
 *
 * dpcontext is a list of deparse_namespace nodes representing the context
 * for interpreting Vars in the node tree.  It can be NIL if no Vars are
 * expected.
 *
 * forceprefix is true to force all Vars to be prefixed with their table names.
 *
 * showimplicit is true to force all implicit casts to be shown explicitly.
 *
 * Tries to pretty up the output according to prettyFlags and startIndent.
 *
 * The result is a palloc'd string.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>deparse_expression_pretty</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dpcontext</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>forceprefix</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <operator>&amp;</operator><name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>namespaces</name></name> <operator>=</operator> <name>dpcontext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowTList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varprefix</name></name> <operator>=</operator> <name>forceprefix</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>prettyFlags</name></name> <operator>=</operator> <name>prettyFlags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>wrapColumn</name></name> <operator>=</operator> <name>WRAP_COLUMN_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>indentLevel</name></name> <operator>=</operator> <name>startIndent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>special_exprkind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * deparse_context_for			- Build deparse context for a single relation
 *
 * Given the reference name (alias) and OID of a relation, build deparsing
 * context for an expression referencing only that relation (as varno 1,
 * varlevelsup 0).  This is sufficient for many uses of deparse_expression.
 * ----------
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>deparse_context_for</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aliasname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deparse_namespace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a minimal RTE for the rel */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>	<comment type="block">/* no need for exactness here */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>alias</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Build one-element rtable */</comment>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>ctes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_rtable_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_simple_column_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return a one-deep namespace stack */</comment>
	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * deparse_context_for_plan_rtable - Build deparse context for a plan's rtable
 *
 * When deparsing an expression in a Plan tree, we use the plan's rangetable
 * to resolve names of simple Vars.  The initialization of column names for
 * this is rather expensive if the rangetable is large, and it'll be the same
 * for every expression in the Plan tree; so we do it just once and re-use
 * the result of this function for each expression.  (Note that the result
 * is not usable until set_deparse_context_planstate() is applied to it.)
 *
 * In addition to the plan's rangetable list, pass the per-RTE alias names
 * assigned by a previous call to select_rtable_names_for_explain.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>deparse_context_for_plan_rtable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable_names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deparse_namespace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize fields that stay the same across the whole plan tree */</comment>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name>rtable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name> <operator>=</operator> <name>rtable_names</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>ctes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up column name aliases.  We will get rather bogus results for join
	 * RTEs, but that doesn't matter because plan trees don't contain any join
	 * alias Vars.
	 */</comment>
	<expr_stmt><expr><call><name>set_simple_column_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return a one-deep namespace stack */</comment>
	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_deparse_context_planstate	- Specify Plan node containing expression
 *
 * When deparsing an expression in a Plan tree, we might have to resolve
 * OUTER_VAR, INNER_VAR, or INDEX_VAR references.  To do this, the caller must
 * provide the parent PlanState node.  Then OUTER_VAR and INNER_VAR references
 * can be resolved by drilling down into the left and right child plans.
 * Similarly, INDEX_VAR references can be resolved by reference to the
 * indextlist given in a parent IndexOnlyScan node, or to the scan tlist in
 * ForeignScan and CustomScan nodes.  (Note that we don't currently support
 * deparsing of indexquals in regular IndexScan or BitmapIndexScan nodes;
 * for those, we can only deparse the indexqualorig fields, which won't
 * contain INDEX_VAR Vars.)
 *
 * Note: planstate really ought to be declared as "PlanState *", but we use
 * "Node *" to avoid having to include execnodes.h in ruleutils.h.
 *
 * The ancestors list is a list of the PlanState's parent PlanStates, the
 * most-closely-nested first.  This is needed to resolve PARAM_EXEC Params.
 * Note we assume that all the PlanStates share the same rtable.
 *
 * Once this function has been called, deparse_expression() can be called on
 * subsidiary expression(s) of the specified PlanState node.  To deparse
 * expressions of a different Plan node in the same Plan tree, re-call this
 * function to identify the new parent Plan node.
 *
 * The result is the same List passed in; this is a notational convenience.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>set_deparse_context_planstate</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dpcontext</name></decl></parameter>,
							  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>

	<comment type="block">/* Should always have one-entry namespace list for Plan deparsing */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>dpcontext</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>dpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set our attention on the specific plan node passed in */</comment>
	<expr_stmt><expr><call><name>set_deparse_planstate</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name> <operator>=</operator> <name>ancestors</name></expr>;</expr_stmt>

	<return>return <expr><name>dpcontext</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * select_rtable_names_for_explain	- Select RTE aliases for EXPLAIN
 *
 * Determine the relation aliases we'll use during an EXPLAIN operation.
 * This is just a frontend to set_rtable_names.  We have to expose the aliases
 * to EXPLAIN because EXPLAIN needs to know the right alias names to print.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>select_rtable_names_for_explain</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>rels_used</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>dpns</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dpns</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>.</operator><name>rtable</name></name> <operator>=</operator> <name>rtable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>.</operator><name>ctes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_rtable_names</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>rels_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We needn't bother computing column aliases yet */</comment>

	<return>return <expr><name><name>dpns</name><operator>.</operator><name>rtable_names</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_rtable_names: select RTE aliases to be used in printing a query
 *
 * We fill in dpns-&gt;rtable_names with a list of names that is one-for-one with
 * the already-filled dpns-&gt;rtable list.  Each RTE name is unique among those
 * in the new namespace plus any ancestor namespaces listed in
 * parent_namespaces.
 *
 * If rels_used isn't NULL, only RTE indexes listed in it are given aliases.
 *
 * Note that this function is only concerned with relation names, not column
 * names.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_rtable_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parent_namespaces</name></decl></parameter>,
				 <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>rels_used</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>names_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameHashEntry</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rtindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<comment type="block">/* nothing more to do if empty rtable */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We use a hash table to hold known names, so that this process is O(N)
	 * not O(N^2) for N names.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NameHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>names_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"set_rtable_names names"</literal></expr></argument>,
							 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
							 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Preload the hash table with names appearing in parent_namespaces */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parent_namespaces</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>olddpns</name> <init>= <expr><operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>olddpns-&gt;rtable_names</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>oldname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>NameHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>names_hash</name></expr></argument>,
												   <argument><expr><name>oldname</name></expr></argument>,
												   <argument><expr><name>HASH_ENTER</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we do not complain about duplicate names in parent namespaces */</comment>
			<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/* Now we can scan the rtable */</comment>
	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>dpns-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name></decl>;</decl_stmt>

		<comment type="block">/* Just in case this takes an unreasonable amount of time ... */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rels_used</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>rels_used</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Ignore unreferenced RTE */</comment>
			<expr_stmt><expr><name>refname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If RTE has a user-defined alias, prefer that */</comment>
			<expr_stmt><expr><name>refname</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Use the current actual name of the relation */</comment>
			<expr_stmt><expr><name>refname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Unnamed join has no refname */</comment>
			<expr_stmt><expr><name>refname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Otherwise use whatever the parser assigned */</comment>
			<expr_stmt><expr><name>refname</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If the selected name isn't unique, append digits to make it so, and
		 * make a new hash entry for it once we've got a unique name.  For a
		 * very long input name, we might have to truncate to stay within
		 * NAMEDATALEN.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>refname</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>NameHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>names_hash</name></expr></argument>,
												   <argument><expr><name>refname</name></expr></argument>,
												   <argument><expr><name>HASH_ENTER</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Name already in use, must choose a new one */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>refnamelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>modname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>refnamelen</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>NameHashEntry</name> <modifier>*</modifier></type><name>hentry2</name></decl>;</decl_stmt>

				<do>do
				<block>{<block_content>
					<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>counter</name></name><operator>++</operator></expr>;</expr_stmt>
					<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
					<block>{<block_content>
						<comment type="block">/*
						 * We avoid using %.*s here because it can misbehave
						 * if the data is not valid in what libc thinks is the
						 * prevailing encoding.
						 */</comment>
						<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr><name>refname</name></expr></argument>, <argument><expr><name>refnamelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>modname</name> <operator>+</operator> <name>refnamelen</name></expr></argument>, <argument><expr><literal type="string">"_%d"</literal></expr></argument>, <argument><expr><name><name>hentry</name><operator>-&gt;</operator><name>counter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<comment type="block">/* drop chars from refname to keep all the digits */</comment>
						<expr_stmt><expr><name>refnamelen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>refnamelen</name></expr></argument>,
												  <argument><expr><name>refnamelen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><name>hentry2</name> <operator>=</operator> <operator>(</operator><name>NameHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>names_hash</name></expr></argument>,
															<argument><expr><name>modname</name></expr></argument>,
															<argument><expr><name>HASH_ENTER</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block> while <condition>(<expr><name>found</name></expr>)</condition>;</do>
				<expr_stmt><expr><name><name>hentry2</name><operator>-&gt;</operator><name>counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* init new hash entry */</comment>
				<expr_stmt><expr><name>refname</name> <operator>=</operator> <name>modname</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Name not previously used, need only initialize hentry */</comment>
				<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name></expr></argument>, <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rtindex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>names_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_deparse_for_query: set up deparse_namespace for deparsing a Query tree
 *
 * For convenience, this is defined to initialize the deparse_namespace struct
 * from scratch.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_deparse_for_query</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parent_namespaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize *dpns and fill rtable/ctes links */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deparse_namespace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>ctes</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>cteList</name></name></expr>;</expr_stmt>

	<comment type="block">/* Assign a unique relation alias to each RTE */</comment>
	<expr_stmt><expr><call><name>set_rtable_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>parent_namespaces</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize dpns-&gt;rtable_columns to contain zeroed structs */</comment>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name></expr></argument>,
									   <argument><expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deparse_columns</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* If it's a utility query, it won't have a jointree */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Detect whether global uniqueness of USING names is needed */</comment>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>unique_using</name></name> <operator>=</operator>
			<call><name>has_dangerous_join_using</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Select names for columns merged by USING, via a recursive pass over
		 * the query jointree.
		 */</comment>
		<expr_stmt><expr><call><name>set_using_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now assign remaining column aliases for each RTE.  We do this in a
	 * linear scan of the rtable, so as to process RTEs whether or not they
	 * are in the jointree (we mustn't miss NEW.*, INSERT target relations,
	 * etc).  JOIN RTEs must be processed after their children, but this is
	 * okay because they appear later in the rtable list than their children
	 * (cf Asserts in identify_join_columns()).
	 */</comment>
	<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>dpns-&gt;rtable</argument>, <argument>lc2</argument>, <argument>dpns-&gt;rtable_columns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name> <init>= <expr><operator>(</operator><name>deparse_columns</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_join_column_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_relation_column_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * set_simple_column_names: fill in column aliases for non-query situations
 *
 * This handles EXPLAIN and cases where we only have relation RTEs.  Without
 * a join tree, we can't do anything smart about join RTEs, but we don't
 * need to (note that EXPLAIN should never see join alias Vars anyway).
 * If we do hit a join RTE we'll just process it like a non-table base RTE.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_simple_column_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize dpns-&gt;rtable_columns to contain zeroed structs */</comment>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_columns</name></name></expr></argument>,
									   <argument><expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deparse_columns</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Assign unique column aliases within each RTE */</comment>
	<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>dpns-&gt;rtable</argument>, <argument>lc2</argument>, <argument>dpns-&gt;rtable_columns</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name> <init>= <expr><operator>(</operator><name>deparse_columns</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>set_relation_column_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * has_dangerous_join_using: search jointree for unnamed JOIN USING
 *
 * Merged columns of a JOIN USING may act differently from either of the input
 * columns, either because they are merged with COALESCE (in a FULL JOIN) or
 * because an implicit coercion of the underlying input column is required.
 * In such a case the column must be referenced as a column of the JOIN not as
 * a column of either input.  And this is problematic if the join is unnamed
 * (alias-less): we cannot qualify the column's name with an RTE name, since
 * there is none.  (Forcibly assigning an alias to the join is not a solution,
 * since that will prevent legal references to tables below the join.)
 * To ensure that every column in the query is unambiguously referenceable,
 * we must assign such merged columns names that are globally unique across
 * the whole query, aliasing other columns out of the way as necessary.
 *
 * Because the ensuing re-aliasing is fairly damaging to the readability of
 * the query, we don't do this unless we have to.  So, we must pre-scan
 * the join tree to see if we have to, before starting set_using_names().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>has_dangerous_join_using</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do here */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>has_dangerous_join_using</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Is it an unnamed JOIN with USING? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Yes, so check each join alias var to see if any of them are not
			 * simple references to underlying columns.  If so, we have a
			 * dangerous situation and must pick unique aliases.
			 */</comment>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>jrte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>jrte-&gt;joinaliasvars</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>aliasvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>aliasvar</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Nope, but inspect children */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>has_dangerous_join_using</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>has_dangerous_join_using</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_using_names: select column aliases to be used for merged USING columns
 *
 * We do this during a recursive descent of the query jointree.
 * dpns-&gt;unique_using must already be set to determine the global strategy.
 *
 * Column alias info is saved in the dpns-&gt;rtable_columns list, which is
 * assumed to be filled with pre-zeroed deparse_columns structs.
 *
 * parentUsing is a list of all USING aliases assigned in parent joins of
 * the current jointree node.  (The passed-in list must not be modified.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_using_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentUsing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do now */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
			<expr_stmt><expr><call><name>set_using_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parentUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name> <init>= <expr><call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>leftattnos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>rightattnos</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>leftcolinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>rightcolinfo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* Get info about the shape of the join */</comment>
		<expr_stmt><expr><call><name>identify_join_columns</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>leftattnos</name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rightattnos</name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name></name></expr>;</expr_stmt>

		<comment type="block">/* Look up the not-yet-filled-in child deparse_columns structs */</comment>
		<expr_stmt><expr><name>leftcolinfo</name> <operator>=</operator> <call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rightcolinfo</name> <operator>=</operator> <call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this join is unnamed, then we cannot substitute new aliases at
		 * this level, so any name requirements pushed down to here must be
		 * pushed down again to the children.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* Push down to left column, unless it's a system column */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>leftcolinfo</name></expr></argument>, <argument><expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>leftcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Same on the righthand side */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>rightcolinfo</name></expr></argument>, <argument><expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rightcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there's a USING clause, select the USING column names and push
		 * those names down to the children.  We have two strategies:
		 *
		 * If dpns-&gt;unique_using is true, we force all USING names to be
		 * unique across the whole query level.  In principle we'd only need
		 * the names of dangerous USING columns to be globally unique, but to
		 * safely assign all USING names in a single pass, we have to enforce
		 * the same uniqueness rule for all of them.  However, if a USING
		 * column's name has been pushed down from the parent, we should use
		 * it as-is rather than making a uniqueness adjustment.  This is
		 * necessary when we're at an unnamed join, and it creates no risk of
		 * ambiguity.  Also, if there's a user-written output alias for a
		 * merged column, we prefer to use that rather than the input name;
		 * this simplifies the logic and seems likely to lead to less aliasing
		 * overall.
		 *
		 * If dpns-&gt;unique_using is false, we only need USING names to be
		 * unique within their own join RTE.  We still need to honor
		 * pushed-down names, though.
		 *
		 * Though significantly different in results, these two strategies are
		 * implemented by the same code, with only the difference of whether
		 * to put assigned names into dpns-&gt;using_names.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Copy the input parentUsing list so we don't modify it */</comment>
			<expr_stmt><expr><name>parentUsing</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>parentUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* USING names must correspond to the first join output columns */</comment>
			<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>colinfo</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>j-&gt;usingClause</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Assert it's a merged column */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Adopt passed-down name if any, else select unique name */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>colname</name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Prefer user-written output alias if any */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* Make it appropriately unique */</comment>
					<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>make_colname_unique</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>dpns</name><operator>-&gt;</operator><name>unique_using</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>using_names</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>using_names</name></name></expr></argument>,
													<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* Save it as output column name, too */</comment>
					<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* Remember selected names for use later */</comment>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>usingNames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>usingNames</name></name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>parentUsing</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>parentUsing</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Push down to left column, unless it's a system column */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>leftcolinfo</name></expr></argument>, <argument><expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>leftcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Same on the righthand side */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>rightcolinfo</name></expr></argument>, <argument><expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rightcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Mark child deparse_columns structs with correct parentUsing info */</comment>
		<expr_stmt><expr><name><name>leftcolinfo</name><operator>-&gt;</operator><name>parentUsing</name></name> <operator>=</operator> <name>parentUsing</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rightcolinfo</name><operator>-&gt;</operator><name>parentUsing</name></name> <operator>=</operator> <name>parentUsing</name></expr>;</expr_stmt>

		<comment type="block">/* Now recursively assign USING column names in children */</comment>
		<expr_stmt><expr><call><name>set_using_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>parentUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_using_names</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>parentUsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_relation_column_names: select column aliases for a non-join RTE
 *
 * Column alias info is saved in *colinfo, which is assumed to be pre-zeroed.
 * If any colnames entries are already filled in, those override local
 * choices.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_relation_column_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
						  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>real_colnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed_any</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>noldcolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Extract the RTE's "real" column names.  This is comparable to
	 * get_rte_attribute_name, except that it's important to disregard dropped
	 * columns.  We put NULL into the array for a dropped column.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Relation --- look to the system catalogs for up-to-date info */</comment>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>real_colnames</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>real_colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>real_colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Otherwise use the column names from eref */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>real_colnames</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;eref-&gt;colnames</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * If the column name shown in eref is an empty string, then it's
			 * a column that was dropped at the time of parsing the query, so
			 * treat it as dropped.
			 */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>real_colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Ensure colinfo-&gt;colnames has a slot for each column.  (It could be long
	 * enough already, if we pushed down a name for the last column.)  Note:
	 * it's possible that there are now more columns than there were when the
	 * query was parsed, ie colnames could be longer than rte-&gt;eref-&gt;colnames.
	 * We must assign unique aliases to the new columns too, else there could
	 * be unresolved conflicts when the view/rule is reloaded.
	 */</comment>
	<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>colinfo</name></expr></argument>, <argument><expr><name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>==</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sufficiently large new_colnames and is_new_col arrays, too.
	 *
	 * Note: because we leave colinfo-&gt;num_new_cols zero until after the loop,
	 * colname_is_unique will not consult that array, which is fine because it
	 * would only be duplicate effort.
	 */</comment>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ncolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan the columns, select a unique alias for each one, and store it in
	 * colinfo-&gt;colnames and colinfo-&gt;new_colnames.  The former array has NULL
	 * entries for dropped columns, the latter omits them.  Also mark
	 * new_colnames entries as to whether they are new since parse time; this
	 * is the case for entries beyond the length of rte-&gt;eref-&gt;colnames.
	 */</comment>
	<expr_stmt><expr><name>noldcolumns</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>real_colname</name> <init>= <expr><name><name>real_colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Skip dropped columns */</comment>
		<if_stmt><if>if <condition>(<expr><name>real_colname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>colname</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* colnames[i] is already NULL */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If alias already assigned, that's what to use */</comment>
		<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If user wrote an alias, prefer that over real column name */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>real_colname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Unique-ify and insert into colinfo */</comment>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>make_colname_unique</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Put names of non-dropped columns in new_colnames[] too */</comment>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
		<comment type="block">/* And mark them as new or not */</comment>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>&gt;=</operator> <name>noldcolumns</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Remember if any assigned aliases differ from "real" name */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed_any</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>real_colname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Set correct length for new_colnames[] array.  (Note: if columns have
	 * been added, colinfo-&gt;num_cols includes them, which is not really quite
	 * right but is harmless, since any new columns must be at the end where
	 * they won't affect varattnos of pre-existing columns.)
	 */</comment>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For a relation RTE, we need only print the alias column names if any
	 * are different from the underlying "real" names.  For a function RTE,
	 * always emit a complete column alias list; this is to protect against
	 * possible instability of the default column names (eg, from altering
	 * parameter names).  For tablefunc RTEs, we never print aliases, because
	 * the column names are part of the clause itself.  For other RTE types,
	 * print if we changed anything OR if there were user-written column
	 * aliases (since the latter would be part of the underlying "reality").
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>changed_any</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_TABLEFUNC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>changed_any</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_join_column_names: select column aliases for a join RTE
 *
 * Column alias info is saved in *colinfo, which is assumed to be pre-zeroed.
 * If any colnames entries are already filled in, those override local
 * choices.  Also, names for USING columns were already chosen by
 * set_using_names().  We further expect that column alias selection has been
 * completed for both input RTEs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_join_column_names</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>leftcolinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>rightcolinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>changed_any</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>noldcolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnewcolumns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>leftmerged</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>rightmerged</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>jc</name></decl>;</decl_stmt>

	<comment type="block">/* Look up the previously-filled-in child deparse_columns structs */</comment>
	<expr_stmt><expr><name>leftcolinfo</name> <operator>=</operator> <call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightcolinfo</name> <operator>=</operator> <call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure colinfo-&gt;colnames has a slot for each column.  (It could be long
	 * enough already, if we pushed down a name for the last column.)  Note:
	 * it's possible that one or both inputs now have more columns than there
	 * were when the query was parsed, but we'll deal with that below.  We
	 * only need entries in colnames for pre-existing columns.
	 */</comment>
	<expr_stmt><expr><name>noldcolumns</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expand_colnames_array_to</name><argument_list>(<argument><expr><name>colinfo</name></expr></argument>, <argument><expr><name>noldcolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>==</operator> <name>noldcolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan the join output columns, select an alias for each one, and store
	 * it in colinfo-&gt;colnames.  If there are USING columns, set_using_names()
	 * already selected their names, so we can start the loop at the first
	 * non-merged column.
	 */</comment>
	<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>usingNames</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noldcolumns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>real_colname</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore dropped column (only possible for non-merged column) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>colname</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get the child column name */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>real_colname</name> <operator>=</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>real_colname</name> <operator>=</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* We're joining system columns --- use eref name */</comment>
			<expr_stmt><expr><name>real_colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>real_colname</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* In an unnamed join, just report child column names as-is */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>real_colname</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If alias already assigned, that's what to use */</comment>
		<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If user wrote an alias, prefer that over real column name */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>real_colname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Unique-ify and insert into colinfo */</comment>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>make_colname_unique</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>colname</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Remember if any assigned aliases differ from "real" name */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed_any</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>real_colname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Calculate number of columns the join would have if it were re-parsed
	 * now, and create storage for the new_colnames and is_new_col arrays.
	 *
	 * Note: colname_is_unique will be consulting new_colnames[] during the
	 * loops below, so its not-yet-filled entries must be zeroes.
	 */</comment>
	<expr_stmt><expr><name>nnewcolumns</name> <operator>=</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name> <operator>+</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name> <operator>-</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>usingNames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name> <operator>=</operator> <name>nnewcolumns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nnewcolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nnewcolumns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generating the new_colnames array is a bit tricky since any new columns
	 * added since parse time must be inserted in the right places.  This code
	 * must match the parser, which will order a join's columns as merged
	 * columns first (in USING-clause order), then non-merged columns from the
	 * left input (in attnum order), then non-merged columns from the right
	 * input (ditto).  If one of the inputs is itself a join, its columns will
	 * be ordered according to the same rule, which means newly-added columns
	 * might not be at the end.  We can figure out what's what by consulting
	 * the leftattnos and rightattnos arrays plus the input is_new_col arrays.
	 *
	 * In these loops, i indexes leftattnos/rightattnos (so it's join varattno
	 * less one), j indexes new_colnames/is_new_col, and ic/jc have similar
	 * meanings for the current child RTE.
	 */</comment>

	<comment type="block">/* Handle merged columns; they are first and can't be new */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>noldcolumns</name> <operator>&amp;&amp;</operator>
		   <name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* column name is already determined and known unique */</comment>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* build bitmapsets of child attnums of merged columns */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>leftmerged</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>leftmerged</name></expr></argument>, <argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rightmerged</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>rightmerged</name></expr></argument>, <argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Handle non-merged left-child columns */</comment>
	<expr_stmt><expr><name>ic</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>jc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>jc</name> <operator>&lt;</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name></expr>;</condition> <incr><expr><name>jc</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>child_colname</name> <init>= <expr><name><name>leftcolinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>jc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>leftcolinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>jc</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Advance ic to next non-dropped old column of left child */</comment>
			<while>while <condition>(<expr><name>ic</name> <operator>&lt;</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>&amp;&amp;</operator>
				   <name><name>leftcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>ic</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ic</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ic</name> <operator>&lt;</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ic</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* If it is a merged column, we already processed it */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>ic</name></expr></argument>, <argument><expr><name>leftmerged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* Else, advance i to the corresponding existing join column */</comment>
			<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>&amp;&amp;</operator>
				   <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ic</name> <operator>==</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Use the already-assigned name of this column */</comment>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Unique-ify the new child column name and assign, unless we're
			 * in an unnamed join, in which case just copy
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator>
					<call><name>make_colname_unique</name><argument_list>(<argument><expr><name>child_colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed_any</name> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>child_colname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>child_colname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>leftcolinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>jc</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Handle non-merged right-child columns in exactly the same way */</comment>
	<expr_stmt><expr><name>ic</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>jc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>jc</name> <operator>&lt;</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name></expr>;</condition> <incr><expr><name>jc</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>child_colname</name> <init>= <expr><name><name>rightcolinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>jc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rightcolinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>jc</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Advance ic to next non-dropped old column of right child */</comment>
			<while>while <condition>(<expr><name>ic</name> <operator>&lt;</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>&amp;&amp;</operator>
				   <name><name>rightcolinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>ic</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ic</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ic</name> <operator>&lt;</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ic</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* If it is a merged column, we already processed it */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>ic</name></expr></argument>, <argument><expr><name>rightmerged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* Else, advance i to the corresponding existing join column */</comment>
			<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>&amp;&amp;</operator>
				   <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ic</name> <operator>==</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Use the already-assigned name of this column */</comment>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Unique-ify the new child column name and assign, unless we're
			 * in an unnamed join, in which case just copy
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator>
					<call><name>make_colname_unique</name><argument_list>(<argument><expr><name>child_colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>changed_any</name> <operator>&amp;&amp;</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>child_colname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>changed_any</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>child_colname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rightcolinfo</name><operator>-&gt;</operator><name>is_new_col</name><index>[<expr><name>jc</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Assert we processed the right number of columns */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>&amp;&amp;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>j</name> <operator>==</operator> <name>nnewcolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * For a named join, print column aliases if we changed any from the child
	 * names.  Unnamed joins cannot print aliases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>changed_any</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * colname_is_unique: is colname distinct from already-chosen column names?
 *
 * dpns is query-wide info, colinfo is for the column's RTE
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>colname_is_unique</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
				  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Check against already-assigned column aliases within RTE */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>oldname</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we're building a new_colnames array, check that too (this will be
	 * partially but not completely redundant with the previous checks)
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>oldname</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Also check against USING-column names that must be globally unique */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>dpns-&gt;using_names</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Also check against names already assigned for parent-join USING cols */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colinfo-&gt;parentUsing</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oldname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_colname_unique: modify colname if necessary to make it unique
 *
 * dpns is query-wide info, colinfo is for the column's RTE
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>make_colname_unique</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>,
					<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the selected name isn't unique, append digits to make it so.  For a
	 * very long input name, we might have to truncate to stay within
	 * NAMEDATALEN.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>colname_is_unique</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>colnamelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>modname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>colnamelen</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<do>do
		<block>{<block_content>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<comment type="block">/*
				 * We avoid using %.*s here because it can misbehave if the
				 * data is not valid in what libc thinks is the prevailing
				 * encoding.
				 */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>colnamelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>modname</name> <operator>+</operator> <name>colnamelen</name></expr></argument>, <argument><expr><literal type="string">"_%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<comment type="block">/* drop chars from colname to keep all the digits */</comment>
				<expr_stmt><expr><name>colnamelen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>colnamelen</name></expr></argument>,
										  <argument><expr><name>colnamelen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>colname_is_unique</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
		<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>modname</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>colname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * expand_colnames_array_to: make colinfo-&gt;colnames at least n items long
 *
 * Any added array entries are initialized to zero.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_colnames_array_to</name><parameter_list>(<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>,
												   <argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name></name> <operator>+</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				   <argument><expr><operator>(</operator><name>n</name> <operator>-</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * identify_join_columns: figure out where columns of a join come from
 *
 * Fills the join-specific fields of the colinfo struct, except for
 * usingNames which is filled later.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>identify_join_columns</name><parameter_list>(<parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>j</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>jrte</name></decl></parameter>,
					  <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numjoincols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Extract left/right child RT indexes */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>larg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>larg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type in jointree: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>rarg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>rarg</name></name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type in jointree: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Assert children will be processed earlier than join in second pass */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name> <operator>&lt;</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name> <operator>&lt;</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize result arrays with zeroes */</comment>
	<expr_stmt><expr><name>numjoincols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>jrte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numjoincols</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>jrte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numjoincols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numjoincols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan the joinaliasvars list to identify simple column references */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>jrte-&gt;joinaliasvars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>aliasvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* get rid of any implicit coercion above the Var */</comment>
		<expr_stmt><expr><name>aliasvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>aliasvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>aliasvar</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* It's a dropped column; nothing to do here */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aliasvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aliasvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>aliasvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>aliasvar</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>aliasvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>aliasvar</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected varno %d in JOIN RTE"</literal></expr></argument>,
					 <argument><expr><name><name>aliasvar</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * It's a merged column in FULL JOIN USING.  Ignore it for now and
			 * let the code below identify the merged columns.
			 */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type in join alias vars: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there's a USING clause, deconstruct the join quals to identify the
	 * merged columns.  This is a tad painful but if we cannot rely on the
	 * column names, there is no other representation of which columns were
	 * joined by USING.  (Unless the join type is FULL, we can't tell from the
	 * joinaliasvars list which columns are merged.)  Note: we assume that the
	 * merged columns are the first output column(s) of the join.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>leftvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rightvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<comment type="block">/* Extract left- and right-side Vars from the qual expression */</comment>
		<expr_stmt><expr><call><name>flatten_join_using_qual</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftvars</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>leftvars</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>rightvars</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Mark the output columns accordingly */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>leftvars</argument>, <argument>lc2</argument>, <argument>rightvars</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>leftvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>rightvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leftvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leftvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>leftvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>leftrti</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected varno %d in JOIN USING qual"</literal></expr></argument>,
					 <argument><expr><name><name>leftvar</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>leftattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>leftvar</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rightvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rightvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rightvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>rightrti</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected varno %d in JOIN USING qual"</literal></expr></argument>,
					 <argument><expr><name><name>rightvar</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>colinfo</name><operator>-&gt;</operator><name>rightattnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>rightvar</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * flatten_join_using_qual: extract Vars being joined from a JOIN/USING qual
 *
 * We assume that transformJoinUsingClause won't have produced anything except
 * AND nodes, equality operator nodes, and possibly implicit coercions, and
 * that the AND node inputs match left-to-right with the original USING list.
 *
 * Caller must initialize the result lists to NIL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flatten_join_using_qual</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>leftvars</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>rightvars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Handle AND nodes by recursion */</comment>
		<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>AND_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>b-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>flatten_join_using_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>leftvars</name></expr></argument>, <argument><expr><name>rightvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Otherwise we should have an equality operator */</comment>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected unary operator in JOIN/USING qual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Arguments should be Vars with perhaps implicit coercions */</comment>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected node type in JOIN/USING qual: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>leftvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>leftvars</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected node type in JOIN/USING qual: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>rightvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>rightvars</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Perhaps we have an implicit coercion to boolean? */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>q</name> <operator>!=</operator> <name>qual</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>flatten_join_using_qual</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>leftvars</name></expr></argument>, <argument><expr><name>rightvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected node type in JOIN/USING qual: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rtable_name: convenience function to get a previously assigned RTE alias
 *
 * The RTE must belong to the topmost namespace level in "context".
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_rtable_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name> <init>= <expr><operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rtindex</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rtindex</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name></expr></argument>, <argument><expr><name>rtindex</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * set_deparse_planstate: set up deparse_namespace to parse subexpressions
 * of a given PlanState node
 *
 * This sets the planstate, outer_planstate, inner_planstate, outer_tlist,
 * inner_tlist, and index_tlist fields.  Caller is responsible for adjusting
 * the ancestors list if necessary.  Note that the rtable and ctes fields do
 * not need to change when shifting attention to different plan nodes in a
 * single plan tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_deparse_planstate</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>planstate</name></name> <operator>=</operator> <name>ps</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We special-case Append and MergeAppend to pretend that the first child
	 * plan is the OUTER referent; we have to interpret OUTER Vars in their
	 * tlists according to one of the children, and the first one is the most
	 * natural choice.  Likewise special-case ModifyTable to pretend that the
	 * first child plan is the OUTER referent; this is to support RETURNING
	 * lists containing references to non-target relations.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>AppendState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_planstate</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>ps</name><operator>)</operator><operator>-&gt;</operator><name><name>appendplans</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>SequenceState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*
		 * POLAR px
		 * A Sequence node returns tuples from the *last* child node only.
		 * The other subplans can even have a different, incompatible tuple
		 * descriptor. A typical case is to have a PartitionSelector node
		 * as the first subplan, and the Dynamic Table Scan as the second
		 * subplan.
		 */</comment>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_planstate</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SequenceState</name> <operator>*</operator><operator>)</operator> <name>ps</name><operator>)</operator><operator>-&gt;</operator><name><name>subplans</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>MergeAppendState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_planstate</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>ps</name><operator>)</operator><operator>-&gt;</operator><name><name>mergeplans</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>ModifyTableState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_planstate</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>ps</name><operator>)</operator><operator>-&gt;</operator><name><name>mt_plans</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_planstate</name></name> <operator>=</operator> <call><name>outerPlanState</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_planstate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name> <operator>=</operator> <name><name>dpns</name><operator>-&gt;</operator><name>outer_planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * For a SubqueryScan, pretend the subplan is INNER referent.  (We don't
	 * use OUTER because that could someday conflict with the normal meaning.)
	 * Likewise, for a CteScan, pretend the subquery's plan is INNER referent.
	 * For ON CONFLICT .. UPDATE we just need the inner tlist to point to the
	 * excluded expression's tlist. (Similar to the SubqueryScan we don't want
	 * to reuse OUTER, it's used for RETURNING in some modify table cases,
	 * although not INSERT .. CONFLICT).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>SubqueryScanState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>ps</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>CteScanState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CteScanState</name> <operator>*</operator><operator>)</operator> <name>ps</name><operator>)</operator><operator>-&gt;</operator><name>cteplanstate</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>SequenceState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*
		 * POLAR px
		 * Set the inner_plan to a sequences first child only if it is a
		 * partition selector. This is a specific fix to enable Explainâs of
		 * query plans that have a Partition Selector
		 */</comment>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SequenceState</name> <operator>*</operator><operator>)</operator> <name>ps</name><operator>)</operator><operator>-&gt;</operator><name><name>subplans</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>ModifyTableState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name> <operator>=</operator> <name>ps</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name> <operator>=</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>ModifyTableState</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>ps</name><operator>)</operator><operator>-&gt;</operator><name>mt_excludedtlist</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name> <operator>=</operator> <name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Set up referent for INDEX_VAR Vars, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name><name>ps</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>indextlist</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>ps</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>fdw_scan_tlist</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name><name>ps</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>custom_scan_tlist</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * push_child_plan: temporarily transfer deparsing attention to a child plan
 *
 * When expanding an OUTER_VAR or INNER_VAR reference, we must adjust the
 * deparse context in case the referenced expression itself uses
 * OUTER_VAR/INNER_VAR.  We modify the top stack entry in-place to avoid
 * affecting levelsup issues (although in a Plan tree there really shouldn't
 * be any).
 *
 * Caller must provide a local deparse_namespace variable to save the
 * previous state for pop_child_plan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_child_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>,
				<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Save state for restoration later */</comment>
	<expr_stmt><expr><operator>*</operator><name>save_dpns</name> <operator>=</operator> <operator>*</operator><name>dpns</name></expr>;</expr_stmt>

	<comment type="block">/* Link current plan node into ancestors list */</comment>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>planstate</name></name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set attention on selected child */</comment>
	<expr_stmt><expr><call><name>set_deparse_planstate</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pop_child_plan: undo the effects of push_child_plan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pop_child_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ancestors</name></decl>;</decl_stmt>

	<comment type="block">/* Get rid of ancestors list cell added by push_child_plan */</comment>
	<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore fields changed by push_child_plan */</comment>
	<expr_stmt><expr><operator>*</operator><name>dpns</name> <operator>=</operator> <operator>*</operator><name>save_dpns</name></expr>;</expr_stmt>

	<comment type="block">/* Make sure dpns-&gt;ancestors is right (may be unnecessary) */</comment>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name> <operator>=</operator> <name>ancestors</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * push_ancestor_plan: temporarily transfer deparsing attention to an
 * ancestor plan
 *
 * When expanding a Param reference, we must adjust the deparse context
 * to match the plan node that contains the expression being printed;
 * otherwise we'd fail if that expression itself contains a Param or
 * OUTER_VAR/INNER_VAR/INDEX_VAR variable.
 *
 * The target ancestor is conveniently identified by the ListCell holding it
 * in dpns-&gt;ancestors.
 *
 * Caller must provide a local deparse_namespace variable to save the
 * previous state for pop_ancestor_plan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_ancestor_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>ancestor_cell</name></decl></parameter>,
				   <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>ps</name> <init>= <expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ancestor_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ancestors</name></decl>;</decl_stmt>

	<comment type="block">/* Save state for restoration later */</comment>
	<expr_stmt><expr><operator>*</operator><name>save_dpns</name> <operator>=</operator> <operator>*</operator><name>dpns</name></expr>;</expr_stmt>

	<comment type="block">/* Build a new ancestor list with just this node's ancestors */</comment>
	<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>ancestor_cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>ancestor_cell</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ancestors</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ancestors</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ancestor_cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name> <operator>=</operator> <name>ancestors</name></expr>;</expr_stmt>

	<comment type="block">/* Set attention on selected ancestor */</comment>
	<expr_stmt><expr><call><name>set_deparse_planstate</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pop_ancestor_plan: undo the effects of push_ancestor_plan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pop_ancestor_plan</name><parameter_list>(<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl></parameter>, <parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>save_dpns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Free the ancestor list made in push_ancestor_plan */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>ancestors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore fields changed by push_ancestor_plan */</comment>
	<expr_stmt><expr><operator>*</operator><name>dpns</name> <operator>=</operator> <operator>*</operator><name>save_dpns</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * make_ruledef			- reconstruct the CREATE RULE command
 *				  for a given pg_rewrite tuple
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_ruledef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>ruletup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>rulettc</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rulename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>ev_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ev_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_instead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ev_qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ev_action</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>actions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>ev_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>viewResultDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>dat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the attribute values from the rules tuple
	 */</comment>
	<expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>rulettc</name></expr></argument>, <argument><expr><literal type="string">"rulename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dat</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rulename</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>dat</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>rulettc</name></expr></argument>, <argument><expr><literal type="string">"ev_type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dat</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ev_type</name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>dat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>rulettc</name></expr></argument>, <argument><expr><literal type="string">"ev_class"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dat</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ev_class</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>dat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>rulettc</name></expr></argument>, <argument><expr><literal type="string">"is_instead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dat</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_instead</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>dat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* these could be nulls */</comment>
	<expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>rulettc</name></expr></argument>, <argument><expr><literal type="string">"ev_qual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ev_qual</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>rulettc</name></expr></argument>, <argument><expr><literal type="string">"ev_action"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ev_action</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ev_action</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>actions</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>ev_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ev_relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ev_class</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the rules definition text
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CREATE RULE %s AS"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>rulename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prettyFlags</name> <operator>&amp;</operator> <name>PRETTYFLAG_INDENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n    ON "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* The event the rule is fired for */</comment>
	<switch>switch <condition>(<expr><name>ev_type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'1'</literal></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>viewResultDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ev_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'2'</literal></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'3'</literal></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="char">'4'</literal></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rule \"%s\" has unsupported event type %d"</literal></expr></argument>,
							<argument><expr><name>rulename</name></expr></argument>, <argument><expr><name>ev_type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* The relation the rule is fired on */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" TO %s"</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><operator>(</operator><name>prettyFlags</name> <operator>&amp;</operator> <name>PRETTYFLAG_SCHEMA</name><operator>)</operator></expr> ?</condition><then>
					 <expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name>ev_class</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr> </then><else>:
					 <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>ev_class</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the rule has an event qualification, add it */</comment>
	<if_stmt><if>if <condition>(<expr><name>ev_qual</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ev_qual</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>ev_qual</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>ev_qual</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_context</name></type> <name>context</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>dpns</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>prettyFlags</name> <operator>&amp;</operator> <name>PRETTYFLAG_INDENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>ev_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We need to make a context for recognizing any Vars in the qual
		 * (which can only be references to OLD and NEW).  Use the rtable of
		 * the first query in the action list for this purpose.
		 */</comment>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the action is INSERT...SELECT, OLD/NEW have been pushed down
		 * into the SELECT, and that's what we need to look at. (Ugly kluge
		 * ... try to fix this when we redesign querytrees.)
		 */</comment>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>getInsertSelectQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Must acquire locks right away; see notes in get_query_def() */</comment>
		<expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>namespaces</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowTList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varprefix</name></name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>prettyFlags</name></name> <operator>=</operator> <name>prettyFlags</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>wrapColumn</name></name> <operator>=</operator> <name>WRAP_COLUMN_DEFAULT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>indentLevel</name></name> <operator>=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>special_exprkind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>set_deparse_for_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DO "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The INSTEAD keyword (if so) */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_instead</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INSTEAD "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Finally the rules actions */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>action</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>action</argument>, <argument>actions</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>viewResultDesc</name></expr></argument>,
						  <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>WRAP_COLUMN_DEFAULT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>prettyFlags</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">");"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOTHING;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>viewResultDesc</name></expr></argument>,
					  <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>WRAP_COLUMN_DEFAULT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ev_relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * make_viewdef			- reconstruct the SELECT part of a
 *				  view rewrite rule
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_viewdef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>ruletup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>rulettc</name></decl></parameter>,
			 <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrapColumn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>ev_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ev_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_instead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ev_qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ev_action</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>actions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>ev_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>dat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the attribute values from the rules tuple
	 */</comment>
	<expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>rulettc</name></expr></argument>, <argument><expr><literal type="string">"ev_type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dat</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ev_type</name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>dat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>rulettc</name></expr></argument>, <argument><expr><literal type="string">"ev_class"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dat</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ev_class</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>dat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>rulettc</name></expr></argument>, <argument><expr><literal type="string">"is_instead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dat</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_instead</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>dat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* these could be nulls */</comment>
	<expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>rulettc</name></expr></argument>, <argument><expr><literal type="string">"ev_qual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ev_qual</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fno</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>rulettc</name></expr></argument>, <argument><expr><literal type="string">"ev_action"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ev_action</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>ruletup</name></expr></argument>, <argument><expr><name>rulettc</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ev_action</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>actions</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>ev_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* keep output buffer empty and leave */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ev_type</name> <operator>!=</operator> <literal type="char">'1'</literal> <operator>||</operator> <operator>!</operator><name>is_instead</name> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name>ev_qual</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* keep output buffer empty and leave */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ev_relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ev_class</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ev_relation</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>prettyFlags</name></expr></argument>, <argument><expr><name>wrapColumn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ev_relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_query_def			- Parse back one query parsetree
 *
 * If resultDesc is not NULL, then it is the output tuple descriptor for
 * the view represented by a SELECT query.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentnamespace</name></decl></parameter>,
			  <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wrapColumn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>dpns</name></decl>;</decl_stmt>

	<comment type="block">/* Guard against excessively long or deeply-nested queries */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Before we begin to examine the query, acquire locks on referenced
	 * relations, and fix up deleted columns in JOIN RTEs.  This ensures
	 * consistent results.  Note we assume it's OK to scribble on the passed
	 * querytree!
	 *
	 * We are only deparsing the query (we are not about to execute it), so we
	 * only need AccessShareLock on the relations it mentions.
	 */</comment>
	<expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>namespaces</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>parentnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>windowTList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varprefix</name></name> <operator>=</operator> <operator>(</operator><name>parentnamespace</name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
						 <call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>prettyFlags</name></name> <operator>=</operator> <name>prettyFlags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>wrapColumn</name></name> <operator>=</operator> <name>wrapColumn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>indentLevel</name></name> <operator>=</operator> <name>startIndent</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>special_exprkind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>set_deparse_for_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>parentnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>
			<expr_stmt><expr><call><name>get_select_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>get_update_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>get_insert_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>get_delete_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_NOTHING</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOTHING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CMD_UTILITY</name></expr>:</case>
			<expr_stmt><expr><call><name>get_utility_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized query command type: %d"</literal></expr></argument>,
				 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_values_def			- Parse back a VALUES list
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_values_def</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>values_lists</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first_list</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>vtl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VALUES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>vtl</argument>, <argument>values_lists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>vtl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>first_col</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>first_list</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>first_list</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sublist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>first_col</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>first_col</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Print the value.  Whole-row Vars need special treatment.
			 */</comment>
			<expr_stmt><expr><call><name>get_rule_expr_toplevel</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_with_clause			- Parse back a WITH clause
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_with_clause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>cteList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasRecursive</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">"WITH RECURSIVE "</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">"WITH "</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cte</name><operator>-&gt;</operator><name>aliascolnames</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>col</argument>, <argument>cte-&gt;aliascolnames</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
									   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>cte</name><operator>-&gt;</operator><name>ctematerialized</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CTEMaterializeDefault</name></expr>:</case>
				<break>break;</break>
			<case>case <expr><name>CTEMaterializeAlways</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"MATERIALIZED "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CTEMaterializeNever</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOT MATERIALIZED "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>-=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_select_query_def			- Parse back a SELECT parsetree
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_select_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					 <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_windowclause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_windowtlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>force_colno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Insert the WITH clause if given */</comment>
	<expr_stmt><expr><call><name>get_with_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up context for possible window functions */</comment>
	<expr_stmt><expr><name>save_windowclause</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>windowClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_windowtlist</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>windowTList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>windowTList</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the Query node has a setOperations tree, then it's the top level of
	 * a UNION/INTERSECT/EXCEPT query; only the WITH, ORDER BY and LIMIT
	 * fields are interesting in the top query itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_setop_query</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ORDER BY clauses must be simple in this case */</comment>
		<expr_stmt><expr><name>force_colno</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_basic_select_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>force_colno</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Add the ORDER BY clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_orderby</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
						 <argument><expr><name>force_colno</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add the LIMIT clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" OFFSET "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" LIMIT "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add FOR [KEY] UPDATE/SHARE clauses if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasForUpdate</name></name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;rowMarks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* don't print implicit clauses */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>pushedDown</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<switch>switch <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>LCS_NONE</name></expr>:</case>
					<comment type="block">/* we intentionally throw an error for LCS_NONE */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized LockClauseStrength %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" FOR KEY SHARE"</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" FOR SHARE"</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" FOR NO KEY UPDATE"</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" FOR UPDATE"</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OF %s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rtable_name</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>,
															  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>==</operator> <name>LockWaitError</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NOWAIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>==</operator> <name>LockWaitSkip</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" SKIP LOCKED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name>save_windowclause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>windowTList</name></name> <operator>=</operator> <name>save_windowtlist</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether query looks like SELECT ... FROM VALUES(),
 * with no need to rename the output columns of the VALUES RTE.
 * If so, return the VALUES RTE.  Otherwise return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>get_simple_values_rte</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We want to detect a match even if the Query also contains OLD or NEW
	 * rule RTEs.  So the idea is to scan the rtable and see if there is only
	 * one inFromCl RTE that is a VALUES RTE.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* multiple VALUES (probably not possible) */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if>			<comment type="block">/* ignore rule entries */</comment>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>		<comment type="block">/* something else -&gt; not simple VALUES */</comment>
	</block_content>}</block>

	<comment type="block">/*
	 * We don't need to check the targetlist in any great detail, because
	 * parser/analyze.c will never generate a "bare" VALUES RTE --- they only
	 * appear inside auto-generated sub-queries with very restricted
	 * structure.  However, DefineView might have modified the tlist by
	 * injecting new column aliases, or we might have some other column
	 * aliases forced by a resultDesc.  We can only simplify if the RTE's
	 * column names match the names that get_target_list() would select.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>colno</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* this probably cannot happen */</comment>
		<expr_stmt><expr><name>colno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;targetList</argument>, <argument>lcn</argument>, <argument>result-&gt;eref-&gt;colnames</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* this probably cannot happen */</comment>

			<comment type="block">/* compute name that get_target_list would use for column */</comment>
			<expr_stmt><expr><name>colno</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>resultDesc</name> <operator>&amp;&amp;</operator> <name>colno</name> <operator>&lt;=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>, <argument><expr><name>colno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* does it match the VALUES RTE? */</comment>
			<if_stmt><if>if <condition>(<expr><name>colname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>colname</name></expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* column name has been changed */</comment>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_basic_select_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>values_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the query looks like SELECT * FROM (VALUES ...), then print just the
	 * VALUES part.  This reverses what transformValuesClause() did at parse
	 * time.
	 */</comment>
	<expr_stmt><expr><name>values_rte</name> <operator>=</operator> <call><name>get_simple_values_rte</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>values_rte</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_values_def</name><argument_list>(<argument><expr><name><name>values_rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build up the query string - first we say SELECT
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the DISTINCT clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasDistinctOn</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DISTINCT ON ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;distinctClause</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>srt</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_sortgroupclause</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DISTINCT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Then we tell what to select (the targetlist) */</comment>
	<expr_stmt><expr><call><name>get_target_list</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the FROM clause if needed */</comment>
	<expr_stmt><expr><call><name>get_from_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" FROM "</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the WHERE clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add the GROUP BY clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParseExprKind</name></type> <name>save_exprkind</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" GROUP BY "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>save_exprkind</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name> <operator>=</operator> <name>EXPR_KIND_GROUP_BY</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;groupClause</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_sortgroupclause</name><argument_list>(<argument><expr><name><name>grp</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;groupingSets</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_groupingset</name><argument_list>(<argument><expr><name>grp</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name> <operator>=</operator> <name>save_exprkind</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add the HAVING clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" HAVING "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add the WINDOW clause if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_rule_windowclause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_target_list			- Parse back a SELECT target list
 *
 * This is also used for RETURNING lists in INSERT/UPDATE/DELETE.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_target_list</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				<parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>targetbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>last_was_multiline</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>colno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* we use targetbuf to hold each TLE's text temporarily */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>colno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk entries */</comment>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>colno</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Put the new field text into targetbuf so we can decide after we've
		 * got it whether or not it needs to go on a new line.
		 */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <operator>&amp;</operator><name>targetbuf</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We special-case Var nodes rather than using get_rule_expr. This is
		 * needed because get_rule_expr will display a whole-row Var as
		 * "foo.*", which is the preferred notation in most contexts, but at
		 * the top level of a SELECT list it's not right (the parser will
		 * expand that notation into multiple columns, yielding behavior
		 * different from a whole-row Var).  We need to call get_variable
		 * directly so that we can tell it to do the right thing, and so that
		 * we can get the attribute name which is the default AS label.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_variable</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* We'll show the AS name unless it's this: */</comment>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <literal type="string">"?column?"</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Figure out what the result column should be called.  In the context
		 * of a view, use the view's tuple descriptor (so as to pick up the
		 * effects of any column RENAME that's been done on the view).
		 * Otherwise, just use what we can find in the TLE.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>resultDesc</name> <operator>&amp;&amp;</operator> <name>colno</name> <operator>&lt;=</operator> <name><name>resultDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>resultDesc</name></expr></argument>, <argument><expr><name>colno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Show AS unless the column's name is correct as-is */</comment>
		<if_stmt><if>if <condition>(<expr><name>colname</name></expr>)</condition>			<comment type="block">/* resname could be NULL */</comment>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>attname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>attname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetbuf</name></expr></argument>, <argument><expr><literal type="string">" AS %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Restore context's output buffer */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

		<comment type="block">/* Consider line-wrapping if enabled */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>leading_nl_pos</name></decl>;</decl_stmt>

			<comment type="block">/* Does the new field start with a new line? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>targetbuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>targetbuf</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>leading_nl_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>leading_nl_pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* If so, we shouldn't add anything */</comment>
			<if_stmt><if>if <condition>(<expr><name>leading_nl_pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* instead, remove any trailing spaces currently in buf */</comment>
				<expr_stmt><expr><call><name>removeStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>trailing_nl</name></decl>;</decl_stmt>

				<comment type="block">/* Locate the start of the current line in the output buffer */</comment>
				<expr_stmt><expr><name>trailing_nl</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>trailing_nl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>trailing_nl</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>trailing_nl</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/*
				 * Add a newline, plus some indentation, if the new field is
				 * not the first and either the new field would cause an
				 * overflow or the last field used more than one line.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>colno</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>trailing_nl</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>targetbuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name><operator>)</operator> <operator>||</operator>
					 <name>last_was_multiline</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
										 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Remember this field's multiline status for next iteration */</comment>
			<expr_stmt><expr><name>last_was_multiline</name> <operator>=</operator>
				<operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><name><name>targetbuf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name>leading_nl_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Add the new field */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>targetbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* clean up */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>targetbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_setop_query</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOp</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				<parameter><decl><type><name>TupleDesc</name></type> <name>resultDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren</name></decl>;</decl_stmt>

	<comment type="block">/* Guard against excessively long or deeply-nested queries */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subquery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Need parens if WITH, ORDER BY, FOR UPDATE, or LIMIT; see gram.y */</comment>
		<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <operator>(</operator><name><name>subquery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>||</operator>
					  <name><name>subquery</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator>
					  <name><name>subquery</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>||</operator>
					  <name><name>subquery</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
					  <name><name>subquery</name><operator>-&gt;</operator><name>limitCount</name></name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>setOp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>subindent</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We force parens when nesting two SetOperationStmts, except when the
		 * lefthand input is another setop of the same kind.  Syntactically,
		 * we could omit parens in rather more cases, but it seems best to use
		 * parens to flag cases where the setop operator changes.  If we use
		 * parens, we also increase the indentation level for the child query.
		 *
		 * There are some cases in which parens are needed around a leaf query
		 * too, but those are more easily handled at the next level down (see
		 * code above).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>lop</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name><name>lop</name><operator>-&gt;</operator><name>op</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>all</name></name> <operator>==</operator> <name><name>lop</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subindent</name> <operator>=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>subindent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>subindent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>get_setop_query</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>, <argument><expr><operator>-</operator><name>subindent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>-</operator><name>subindent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SETOP_UNION</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UNION "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SETOP_INTERSECT</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INTERSECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SETOP_EXCEPT</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXCEPT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized set op: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>op</name><operator>-&gt;</operator><name>op</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ALL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Always parenthesize if RHS is another setop */</comment>
		<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The indentation code here is deliberately a bit different from that
		 * for the lefthand input, because we want the line breaks in
		 * different places.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subindent</name> <operator>=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>subindent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>subindent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_setop_query</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>resultDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>-=</operator> <name>subindent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>setOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Display a sort/group clause.
 *
 * Also returns the expression tree, so caller need not find it again.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>get_rule_sortgroupclause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>ref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>,
						 <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use column-number form if requested by caller.  Otherwise, if
	 * expression is a constant, force it to be dumped with an explicit cast
	 * as decoration --- this is because a simple integer constant is
	 * ambiguous (and will be misinterpreted by findTargetlistEntry()) if we
	 * dump it without any decoration.  If it's anything more complex than a
	 * simple Var, then force extra parens around it, to ensure it can't be
	 * misinterpreted as a cube() or rollup() construct.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>force_colno</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_const_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>expr</name> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We must force parens for function-like expressions even if
		 * PRETTY_PAREN is off, since those are the ones in danger of
		 * misparsing. For other expressions we need to force them only if
		 * PRETTY_PAREN is on, since otherwise the expression will output them
		 * itself. (We can't skip the parens.)
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren</name> <init>= <expr><operator>(</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call>
								  <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call>
								  <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call>
								  <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Display a GroupingSet
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_groupingset</name><parameter_list>(<parameter><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gset</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>omit_parens</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>omit_child_parens</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>gset</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GROUPING_SET_EMPTY</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>

		<case>case <expr><name>GROUPING_SET_SIMPLE</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>omit_parens</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>gset</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>gset-&gt;content</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Index</name></type>		<name>ref</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_sortgroupclause</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
				</block_content>}</block>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>omit_parens</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>gset</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<return>return;</return>

		<case>case <expr><name>GROUPING_SET_ROLLUP</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROLLUP("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GROUPING_SET_CUBE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CUBE("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GROUPING_SET_SETS</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"GROUPING SETS ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>omit_child_parens</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>gset-&gt;content</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_groupingset</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>omit_child_parens</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Display an ORDER BY list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_orderby</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orderList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>force_colno</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>orderList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>srt</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>sortexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>sortcoltype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortexpr</name> <operator>=</operator> <call><name>get_rule_sortgroupclause</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>,
											<argument><expr><name>force_colno</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortcoltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>sortexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* See whether operator is default &lt; or &gt; for datatype */</comment>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>sortcoltype</name></expr></argument>,
									 <argument><expr><name>TYPECACHE_LT_OPR</name> <operator>|</operator> <name>TYPECACHE_GT_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>lt_opr</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ASC is default, so emit nothing for it */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>gt_opr</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* DESC defaults to NULLS FIRST */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>srt</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" USING %s"</literal></expr></argument>,
							 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>srt</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>,
													<argument><expr><name>sortcoltype</name></expr></argument>,
													<argument><expr><name>sortcoltype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* be specific to eliminate ambiguity */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>srt</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Display a WINDOW clause.
 *
 * Note that the windowClause list might contain only anonymous window
 * specifications, in which case we should print nothing here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_windowclause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sep</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;windowClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore anonymous windows */</comment>

		<if_stmt><if>if <condition>(<expr><name>sep</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WINDOW "</literal></expr></argument>,
								 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s AS "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_rule_windowspec</name><argument_list>(<argument><expr><name>wc</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Display a window definition
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_windowspec</name><parameter_list>(<parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
					<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needspace</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>refname</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>needspace</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* partition clauses are always inherited, so only print if no refname */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>wc</name><operator>-&gt;</operator><name>refname</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>needspace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"PARTITION BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>wc-&gt;partitionClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_rule_sortgroupclause</name><argument_list>(<argument><expr><name><name>grp</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>needspace</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* print ordering clause only if not inherited */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>wc</name><operator>-&gt;</operator><name>copiedOrder</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>needspace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_orderby</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>needspace</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* framing clause is never inherited, so print unless it's default */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_NONDEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>needspace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"RANGE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_ROWS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROWS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_GROUPS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"GROUPS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_BETWEEN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"BETWEEN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_START_UNBOUNDED_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UNBOUNDED PRECEDING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_START_CURRENT_ROW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT ROW "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" PRECEDING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_START_OFFSET_FOLLOWING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOLLOWING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_BETWEEN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_END_UNBOUNDED_FOLLOWING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UNBOUNDED FOLLOWING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_END_CURRENT_ROW</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT ROW "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET_PRECEDING</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" PRECEDING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_END_OFFSET_FOLLOWING</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" FOLLOWING "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUDE_CURRENT_ROW</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXCLUDE CURRENT ROW "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUDE_GROUP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXCLUDE GROUP "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>&amp;</operator> <name>FRAMEOPTION_EXCLUDE_TIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXCLUDE TIES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* we will now have a trailing space; remove it */</comment>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_insert_query_def			- Parse back an INSERT parsetree
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_insert_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>select_rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>values_rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>strippedexprs</name></decl>;</decl_stmt>

	<comment type="block">/* Insert the WITH clause if given */</comment>
	<expr_stmt><expr><call><name>get_with_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's an INSERT ... SELECT or multi-row VALUES, there will be a
	 * single RTE for the SELECT or VALUES.  Plain VALUES has neither.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>select_rte</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many subquery RTEs in INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>select_rte</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>values_rte</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many values RTEs in INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>values_rte</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>select_rte</name> <operator>&amp;&amp;</operator> <name>values_rte</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"both subquery and values RTEs in INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Start the query with INSERT INTO relname
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %s "</literal></expr></argument>,
					 <argument><expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* INSERT requires AS keyword for target alias */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"AS %s "</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add the insert-column-names list.  Any indirection decoration needed on
	 * the column names can be inferred from the top targetlist.
	 */</comment>
	<expr_stmt><expr><name>strippedexprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk entries */</comment>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Put out name of target column; look in the catalogs, not at
		 * tle-&gt;resname, since resname will fail to track RENAME.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
															<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
															<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Print any indirection needed (subfields or subscripts), and strip
		 * off the top-level nodes representing the indirection assignments.
		 * Add the stripped expressions to strippedexprs.  (If it's a
		 * single-VALUES statement, the stripped expressions are the VALUES to
		 * print below.  Otherwise they're just Vars and not really
		 * interesting.)
		 */</comment>
		<expr_stmt><expr><name>strippedexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>strippedexprs</name></expr></argument>,
								<argument><expr><call><name>processIndirection</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
												   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>override</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>override</name></name> <operator>==</operator> <name>OVERRIDING_SYSTEM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OVERRIDING SYSTEM VALUE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>override</name></name> <operator>==</operator> <name>OVERRIDING_USER_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OVERRIDING USER VALUE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>select_rte</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add the SELECT */</comment>
		<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name><name>select_rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr></argument>,
					  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>values_rte</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add the multi-VALUES expression lists */</comment>
		<expr_stmt><expr><call><name>get_values_def</name><argument_list>(<argument><expr><name><name>values_rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>strippedexprs</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add the single-VALUES expression list */</comment>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"VALUES ("</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>strippedexprs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* No expressions, so it must be DEFAULT VALUES */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Add ON CONFLICT if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>confl</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON CONFLICT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>confl</name><operator>-&gt;</operator><name>arbiterElems</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Add the single-VALUES expression list */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>confl</name><operator>-&gt;</operator><name>arbiterElems</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add a WHERE clause (for partial indexes) if given */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>confl</name><operator>-&gt;</operator><name>arbiterWhere</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type>		<name>save_varprefix</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Force non-prefixing of Vars, since parser assumes that they
				 * belong to target relation.  WHERE clause does not use
				 * InferenceElem, so this is separately required.
				 */</comment>
				<expr_stmt><expr><name>save_varprefix</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>confl</name><operator>-&gt;</operator><name>arbiterWhere</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>save_varprefix</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>confl</name><operator>-&gt;</operator><name>constraint</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>constraint</name> <init>= <expr><call><name>get_constraint_name</name><argument_list>(<argument><expr><name><name>confl</name><operator>-&gt;</operator><name>constraint</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>constraint</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>,
					 <argument><expr><name><name>confl</name><operator>-&gt;</operator><name>constraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON CONSTRAINT %s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>confl</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_NOTHING</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DO NOTHING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DO UPDATE SET "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Deparse targetlist */</comment>
			<expr_stmt><expr><call><name>get_update_query_targetlist_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>confl</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
											<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add a WHERE clause if given */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>confl</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>confl</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" RETURNING"</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_target_list</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_update_query_def			- Parse back an UPDATE parsetree
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_update_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/* Insert the WITH clause if given */</comment>
	<expr_stmt><expr><call><name>get_with_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start the query with UPDATE relname SET
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UPDATE %s%s"</literal></expr></argument>,
					 <argument><expr><call><name>only_marker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" SET "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Deparse targetlist */</comment>
	<expr_stmt><expr><call><name>get_update_query_targetlist_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add the FROM clause if needed */</comment>
	<expr_stmt><expr><call><name>get_from_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" FROM "</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add a WHERE clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" RETURNING"</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_target_list</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_update_query_targetlist_def			- Parse back an UPDATE targetlist
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_update_query_targetlist_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
								<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next_ma_cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>remaining_ma_columns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>cur_ma_sublink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ma_sublinks</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Prepare to deal with MULTIEXPR assignments: collect the source SubLinks
	 * into a list.  We expect them to appear, in ID order, in resjunk tlist
	 * entries.
	 */</comment>
	<expr_stmt><expr><name>ma_sublinks</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition>		<comment type="block">/* else there can't be any */</comment>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sl</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>sl</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>ma_sublinks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ma_sublinks</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sl</name><operator>-&gt;</operator><name>subLinkId</name></name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>ma_sublinks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>next_ma_cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>ma_sublinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_ma_sublink</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>remaining_ma_columns</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Add the comma separated list of 'attname = value' */</comment>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore junk entries */</comment>

		<comment type="block">/* Emit separator (OK whether we're in multiassignment or not) */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check to see if we're starting a multiassignment group: if so,
		 * output a left paren.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>next_ma_cell</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>cur_ma_sublink</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We must dig down into the expr to see if it's a PARAM_MULTIEXPR
			 * Param.  That could be buried under FieldStores and ArrayRefs
			 * and CoerceToDomains (cf processIndirection()), and underneath
			 * those there could be an implicit type coercion.  Because we
			 * would ignore implicit type coercions anyway, we don't need to
			 * be as careful as processIndirection() is about descending past
			 * implicit CoerceToDomains.
			 */</comment>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>expr</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ArrayRef</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ArrayRef</name>   <modifier>*</modifier></type><name>aref</name> <init>= <expr><operator>(</operator><name>ArrayRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>cdomain</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>cdomain</name><operator>-&gt;</operator><name>coercionformat</name></name> <operator>!=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<break>break;</break></block_content></block></else></if_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>paramkind</name> <operator>==</operator> <name>PARAM_MULTIEXPR</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cur_ma_sublink</name> <operator>=</operator> <operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>next_ma_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>next_ma_cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>next_ma_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>remaining_ma_columns</name> <operator>=</operator> <call><name>count_nonjunk_tlist_entries</name><argument_list>(
																   <argument><expr><operator>(</operator><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cur_ma_sublink</name><operator>-&gt;</operator><name>subselect</name></name><operator>)</operator><operator>-&gt;</operator><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>paramid</name> <operator>==</operator>
					   <operator>(</operator><operator>(</operator><name><name>cur_ma_sublink</name><operator>-&gt;</operator><name>subLinkId</name></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Put out name of target column; look in the catalogs, not at
		 * tle-&gt;resname, since resname will fail to track RENAME.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
							   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
															<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
															<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Print any indirection needed (subfields or subscripts), and strip
		 * off the top-level nodes representing the indirection assignments.
		 */</comment>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>processIndirection</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we're in a multiassignment, skip printing anything more, unless
		 * this is the last column; in which case, what we print should be the
		 * sublink, not the Param.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cur_ma_sublink</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>--</operator><name>remaining_ma_columns</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* not the last column of multiassignment */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cur_ma_sublink</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cur_ma_sublink</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_delete_query_def			- Parse back a DELETE parsetree
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_delete_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/* Insert the WITH clause if given */</comment>
	<expr_stmt><expr><call><name>get_with_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start the query with DELETE FROM relname
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>PRETTYINDENT_STD</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM %s%s"</literal></expr></argument>,
					 <argument><expr><call><name>only_marker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Add the USING clause if given */</comment>
	<expr_stmt><expr><call><name>get_from_clause</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">" USING "</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add a WHERE clause if given */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" WHERE "</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add RETURNING if present */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" RETURNING"</literal></expr></argument>,
							 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_target_list</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_utility_query_def			- Parse back a UTILITY parsetree
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_utility_query_def</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>NotifyStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NotifyStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>NotifyStmt</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOTIFY %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>conditionname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>payload</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Currently only NOTIFY utility commands can appear in rules */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected utility statement type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Display a Var appropriately.
 *
 * In some cases (currently only when recursing into an unnamed join)
 * the Var's varlevelsup has to be interpreted with respect to a context
 * above the current one; levelsup indicates the offset.
 *
 * If istoplevel is true, the Var is at the top level of a SELECT's
 * targetlist, which means we need special treatment of whole-row Vars.
 * Instead of the normal "tab.*", we'll print "tab.*::typename", which is a
 * dirty hack to prevent "tab.*" from being expanded into multiple columns.
 * (The parser will strip the useless coercion, so no inefficiency is added in
 * dump and reload.)  We used to print just "tab" in such cases, but that is
 * ambiguous and will yield the wrong result if "tab" is also a plain column
 * name in the query.
 *
 * Returns the attname of the Var, or NULL if the Var has no attname (because
 * it is a whole-row Var or a subplan output reference).
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_variable</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>istoplevel</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>netlevelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

	<comment type="block">/* Find appropriate nesting depth */</comment>
	<expr_stmt><expr><name>netlevelsup</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>+</operator> <name>levelsup</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>netlevelsup</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varlevelsup: %d offset %d"</literal></expr></argument>,
			 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>, <argument><expr><name>levelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>dpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>,
										  <argument><expr><name>netlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to find the relevant RTE in this rtable.  In a plan tree, it's
	 * likely that varno is OUTER_VAR or INNER_VAR, in which case we must dig
	 * down into the subplans, or INDEX_VAR, which is resolved similarly. Also
	 * find the aliases previously assigned for this RTE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>refname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable_names</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colinfo</name> <operator>=</operator> <call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>resolve_special_varno</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>get_special_variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The planner will sometimes emit Vars referencing resjunk elements of a
	 * subquery's target list (this is currently only possible if it chooses
	 * to generate a "physical tlist" for a SubqueryScan or CteScan node).
	 * Although we prefer to print subquery-referencing Vars using the
	 * subquery's alias, that's not possible for resjunk items since they have
	 * no alias.  So in that case, drill down to the subplan and print the
	 * contents of the referenced tlist item.  This works because in a plan
	 * tree, such Vars can only occur in a SubqueryScan or CteScan node, and
	 * we'll have set dpns-&gt;inner_planstate to reference the child plan node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>||</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>attnum</name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum %d for relation \"%s\""</literal></expr></argument>,
				 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Force parentheses because our caller probably assumed a Var is a
		 * simple expression.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's an unnamed join, look at the expansion of the alias variable.
	 * If it's a simple reference to one of the input vars, then recursively
	 * print the name of that var instead.  When it's not a simple reference,
	 * we have to just print the unqualified join column name.  (This can only
	 * happen with "dangerous" merged columns in a JOIN USING; we took pains
	 * previously to make the unqualified column name unique in such cases.)
	 *
	 * This wouldn't work in decompiling plan trees, because we don't store
	 * joinaliasvars lists after planning; but a plan tree should never
	 * contain a join alias variable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot decompile join alias var in plan tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>aliasvar</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>aliasvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we intentionally don't strip implicit coercions here */</comment>
			<if_stmt><if>if <condition>(<expr><name>aliasvar</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>get_variable</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>+</operator> <name>levelsup</name></expr></argument>,
									<argument><expr><name>istoplevel</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Unnamed join has no refname.  (Note: since it's unnamed, there is
		 * no way the user could have referenced it to create a whole-row Var
		 * for it.  So we don't have to cover that case below.)
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>refname</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get column name to use from the colinfo struct */</comment>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_cols</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum %d for relation \"%s\""</literal></expr></argument>,
				 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>attname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* dropped column? */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid attnum %d for relation \"%s\""</literal></expr></argument>,
				 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* System column - name is fixed, get it from the catalog */</comment>
		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_rte_attribute_name</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>refname</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>||</operator> <name>attname</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>attname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>istoplevel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
							 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
													  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>attname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Deparse a Var which references OUTER_VAR, INNER_VAR, or INDEX_VAR.  This
 * routine is actually a callback for get_special_varno, which handles finding
 * the correct TargetEntry.  We get the expression contained in that
 * TargetEntry and just need to deparse it, a job we can throw back on
 * get_rule_expr.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_special_variable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Force parentheses because our caller probably assumed a Var is a simple
	 * expression.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Chase through plan references to special varnos (OUTER_VAR, INNER_VAR,
 * INDEX_VAR) until we find a real Var or some kind of non-Var node; then,
 * invoke the callback provided.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>resolve_special_varno</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private</name></decl></parameter>,
					  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>callback</name>) <parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>

	<comment type="block">/* If it's not a Var, invoke the callback. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Find appropriate nesting depth */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>,
										  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's a special RTE, so recurse.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>OUTER_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for OUTER_VAR var: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_planstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resolve_special_varno</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>private</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>INNER_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for INNER_VAR var: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resolve_special_varno</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>private</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>INDEX_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for INDEX_VAR var: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>resolve_special_varno</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>private</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varno: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Not special.  Just invoke the callback. */</comment>
	<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the name of a field of an expression of composite type.  The
 * expression is usually a Var, but we handle other cases too.
 *
 * levelsup is an extra offset to interpret the Var's varlevelsup correctly.
 *
 * This is fairly straightforward when the expression has a named composite
 * type; we need only look up the type in the catalogs.  However, the type
 * could also be RECORD.  Since no actual table or view column is allowed to
 * have type RECORD, a Var of type RECORD must refer to a JOIN or FUNCTION RTE
 * or to a subquery output.  We drill down to find the ultimate defining
 * expression and attempt to infer the field name from it.  We ereport if we
 * can't determine the name.
 *
 * Similarly, a PARAM of type RECORD has to refer to some expression of
 * a determinable composite type.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_name_for_var_field</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fieldno</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>levelsup</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>netlevelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's a RowExpr that was expanded from a whole-row Var, use the
	 * column names attached to it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>fieldno</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><name>fieldno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's a Param of type RECORD, try to find what the Param refers to.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ancestor_cell</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>find_param_referent</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ancestor_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>expr</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a match, so recurse to decipher the field name */</comment>
			<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>push_ancestor_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>ancestor_cell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
											<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pop_ancestor_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's a Var of type RECORD, we have to find what the Var refers to;
	 * if not, we can use get_expr_result_tupdesc().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>get_expr_result_tupdesc</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Got the tupdesc, so we can extract the field name */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fieldno</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>fieldno</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>fieldno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Find appropriate nesting depth */</comment>
	<expr_stmt><expr><name>netlevelsup</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>+</operator> <name>levelsup</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>netlevelsup</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varlevelsup: %d offset %d"</literal></expr></argument>,
			 <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></argument>, <argument><expr><name>levelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>dpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>,
										  <argument><expr><name>netlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Try to find the relevant RTE in this rtable.  In a plan tree, it's
	 * likely that varno is OUTER_VAR or INNER_VAR, in which case we must dig
	 * down into the subplans, or INDEX_VAR, which is resolved similarly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>OUTER_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_tlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for OUTER_VAR var: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>outer_planstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
										<argument><expr><name>levelsup</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>INNER_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for INNER_VAR var: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
										<argument><expr><name>levelsup</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>INDEX_VAR</name> <operator>&amp;&amp;</operator> <name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>index_tlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for INDEX_VAR var: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
										<argument><expr><name>levelsup</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varno: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>			<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Var is whole-row reference to RTE, so select the right field */</comment>
		<return>return <expr><call><name>get_rte_attribute_name</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This part has essentially the same logic as the parser's
	 * expandRecordVariable() function, but we are dealing with a different
	 * representation of the input context, and we only need one field name
	 * not a TupleDesc.  Also, we need special cases for finding subquery and
	 * CTE subplans when deparsing Plan trees.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>		<comment type="block">/* default if we can't drill down */</comment>

	<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>

			<comment type="block">/*
			 * This case should not occur: a column of a table, values list,
			 * or ENR shouldn't have type RECORD.  Fall through and fail (most
			 * likely) at the bottom.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<comment type="block">/* Subselect-in-FROM: examine sub-select's output expr */</comment>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ste</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
														<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>ste</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ste</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery %s does not have attribute %d"</literal></expr></argument>,
							 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ste</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Recurse into the sub-select to see what its Var
						 * refers to. We have to build an additional level of
						 * namespace to keep in step with varlevelsup in the
						 * subselect.
						 */</comment>
						<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>mydpns</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>set_deparse_for_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mydpns</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
											  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mydpns</name></expr></argument>,
													<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
														<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name> <operator>=</operator>
							<call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<return>return <expr><name>result</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* else fall through to inspect the expression */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * We're deparsing a Plan tree so we don't have complete
					 * RTE entries (in particular, rte-&gt;subquery is NULL). But
					 * the only place we'd see a Var directly referencing a
					 * SUBQUERY RTE is in a SubqueryScan plan node, and we can
					 * look into the child plan's tlist instead.
					 */</comment>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find plan for subquery %s"</literal></expr></argument>,
							 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for subquery var: %d"</literal></expr></argument>,
							 <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
													<argument><expr><name>levelsup</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<comment type="block">/* Join RTE --- recursively inspect the alias variable */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot decompile join alias var in plan tree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attnum</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we intentionally don't strip implicit coercions here */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
											  <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>+</operator> <name>levelsup</name></expr></argument>,
											  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* else fall through to inspect the expression */</comment>
			<break>break;</break>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>RTE_TABLEFUNCTION</name></expr>:</case>
		<comment type="block">/* POLAR end */</comment>

			<comment type="block">/*
			 * We couldn't get here unless a function is declared with one of
			 * its result columns as RECORD, which is not allowed.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
			<comment type="block">/* CTE reference: examine subquery's output expr */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Index</name></type>		<name>ctelevelsup</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Try to find the referenced CTE using the namespace stack.
				 */</comment>
				<expr_stmt><expr><name>ctelevelsup</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>+</operator> <name>netlevelsup</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ctelevelsup</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>lc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>ctedpns</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>ctedpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator>
						<call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>, <argument><expr><name>ctelevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ctedpns-&gt;ctes</argument>)</argument_list></macro>
					<block>{<block_content>
						<expr_stmt><expr><name>cte</name> <operator>=</operator> <operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>ctequery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ste</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><call><name>GetCTETargetList</name><argument_list>(<argument><expr><name>cte</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>ste</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ste</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery %s does not have attribute %d"</literal></expr></argument>,
							 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ste</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Recurse into the CTE to see what its Var refers to.
						 * We have to build an additional level of namespace
						 * to keep in step with varlevelsup in the CTE.
						 * Furthermore it could be an outer CTE, so we may
						 * have to delete some levels of namespace.
						 */</comment>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_nslist</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_nslist</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>mydpns</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>set_deparse_for_query</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mydpns</name></expr></argument>, <argument><expr><name>ctequery</name></expr></argument>,
											  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>new_nslist</name> <operator>=</operator> <call><name>list_copy_tail</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>,
													<argument><expr><name>ctelevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mydpns</name></expr></argument>, <argument><expr><name>new_nslist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
														<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name> <operator>=</operator> <name>save_nslist</name></expr>;</expr_stmt>

						<return>return <expr><name>result</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* else fall through to inspect the expression */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * We're deparsing a Plan tree so we don't have a CTE
					 * list.  But the only place we'd see a Var directly
					 * referencing a CTE RTE is in a CteScan plan node, and we
					 * can look into the subplan's tlist instead.
					 */</comment>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find plan for CTE %s"</literal></expr></argument>,
							 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_tlist</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus varattno for subquery var: %d"</literal></expr></argument>,
							 <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>netlevelsup</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>push_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name><name>dpns</name><operator>-&gt;</operator><name>inner_planstate</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>fieldno</name></expr></argument>,
													<argument><expr><name>levelsup</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>pop_child_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>result</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>RTE_VOID</name></expr>:</case>
			<comment type="block">/* No references should exist to a deleted RTE. */</comment>
			<break>break;</break>
		<comment type="block">/* POLAR end */</comment>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * We now have an expression we can't expand any more, so see if
	 * get_expr_result_tupdesc() can do anything with it.
	 */</comment>
	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>get_expr_result_tupdesc</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Got the tupdesc, so we can extract the field name */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fieldno</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>fieldno</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><name>fieldno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to find the referenced expression for a PARAM_EXEC Param that might
 * reference a parameter supplied by an upper NestLoop or SubPlan plan node.
 *
 * If successful, return the expression and set *dpns_p and *ancestor_cell_p
 * appropriately for calling push_ancestor_plan().  If no referent can be
 * found, return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>find_param_referent</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					<parameter><decl><type><name>deparse_namespace</name> <modifier>*</modifier><modifier>*</modifier></type><name>dpns_p</name></decl></parameter>, <parameter><decl><type><name>ListCell</name> <modifier>*</modifier><modifier>*</modifier></type><name>ancestor_cell_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Initialize output parameters to prevent compiler warnings */</comment>
	<expr_stmt><expr><operator>*</operator><name>dpns_p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ancestor_cell_p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a PARAM_EXEC parameter, look for a matching NestLoopParam or
	 * SubPlan argument.  This will necessarily be in some ancestor of the
	 * current expression's PlanState.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>child_ps</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>in_same_plan_level</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dpns</name> <operator>=</operator> <operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>child_ps</name> <operator>=</operator> <name><name>dpns</name><operator>-&gt;</operator><name>planstate</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>in_same_plan_level</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>dpns-&gt;ancestors</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>ps</name> <init>= <expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * NestLoops transmit params to their inner child only; also, once
			 * we've crawled up out of a subplan, this couldn't possibly be
			 * the right match.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>NestLoopState</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name>child_ps</name> <operator>==</operator> <call><name>innerPlanState</name><argument_list>(<argument><expr><name>ps</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name>in_same_plan_level</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>nl</name> <init>= <expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name><name>ps</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>nl-&gt;nestParams</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name> <init>= <expr><operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>==</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Found a match, so return it */</comment>
						<expr_stmt><expr><operator>*</operator><name>dpns_p</name> <operator>=</operator> <name>dpns</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>ancestor_cell_p</name> <operator>=</operator> <name>lc</name></expr>;</expr_stmt>
						<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Check to see if we're crawling up from a subplan.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>ps-&gt;subPlan</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>sstate</name><operator>-&gt;</operator><name>subplan</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc4</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>child_ps</name> <operator>!=</operator> <name><name>sstate</name><operator>-&gt;</operator><name>planstate</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* Matched subplan, so check its arguments */</comment>
				<macro><name>forboth</name><argument_list>(<argument>lc3</argument>, <argument>subplan-&gt;parParam</argument>, <argument>lc4</argument>, <argument>subplan-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc4</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>paramid</name> <operator>==</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Found a match, so return it */</comment>
						<expr_stmt><expr><operator>*</operator><name>dpns_p</name> <operator>=</operator> <name>dpns</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>ancestor_cell_p</name> <operator>=</operator> <name>lc</name></expr>;</expr_stmt>
						<return>return <expr><name>arg</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>

				<comment type="block">/* Keep looking, but we are emerging from a subplan. */</comment>
				<expr_stmt><expr><name>in_same_plan_level</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<comment type="block">/*
			 * Likewise check to see if we're emerging from an initplan.
			 * Initplans never have any parParams, so no need to search that
			 * list, but we need to know if we should reset
			 * in_same_plan_level.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>ps-&gt;initPlan</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>child_ps</name> <operator>!=</operator> <name><name>sstate</name><operator>-&gt;</operator><name>planstate</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* No parameters to be had here. */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sstate</name><operator>-&gt;</operator><name>subplan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Keep looking, but we are emerging from an initplan. */</comment>
				<expr_stmt><expr><name>in_same_plan_level</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<comment type="block">/* No luck, crawl up to next ancestor */</comment>
			<expr_stmt><expr><name>child_ps</name> <operator>=</operator> <name>ps</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* No referent found */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Display a Param appropriately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_parameter</name><parameter_list>(<parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ancestor_cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it's a PARAM_EXEC parameter, try to locate the expression from which
	 * the parameter was computed.  Note that failing to find a referent isn't
	 * an error, since the Param might well be a subplan output rather than an
	 * input.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>find_param_referent</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ancestor_cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>expr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Found a match, so print it */</comment>
		<decl_stmt><decl><type><name>deparse_namespace</name></type> <name>save_dpns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>save_varprefix</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren</name></decl>;</decl_stmt>

		<comment type="block">/* Switch attention to the ancestor plan node */</comment>
		<expr_stmt><expr><call><name>push_ancestor_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><name>ancestor_cell</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Force prefixing of Vars, since they won't belong to the relation
		 * being scanned in the original plan node.
		 */</comment>
		<expr_stmt><expr><name>save_varprefix</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * A Param's expansion is typically a Var, Aggref, or upper-level
		 * Param, which wouldn't need extra parentheses.  Otherwise, insert
		 * parens to ensure the expression looks atomic.
		 */</comment>
		<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
					   <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call> <operator>||</operator>
					   <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>save_varprefix</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pop_ancestor_plan</name><argument_list>(<argument><expr><name>dpns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_dpns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Not PARAM_EXEC, or couldn't find referent: just print $N.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_simple_binary_op_name
 *
 * helper function for isSimpleNode
 * will return single char binary operator name, or NULL if it's not
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_simple_binary_op_name</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* binary operator */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>op</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * isSimpleNode - check if given node is simple (doesn't need parenthesizing)
 *
 *	true   : simple in the context of parent node's type
 *	false  : not simple
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isSimpleNode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prettyFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
		<case>case <expr><name>T_Const</name></expr>:</case>
		<case>case <expr><name>T_Param</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<comment type="block">/* single words: always simple */</comment>
			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>T_ArrayRef</name></expr>:</case>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<comment type="block">/* function-like: name(..) or name[..] */</comment>
			<return>return <expr><name>true</name></expr>;</return>

			<comment type="block">/* CASE keywords act as parentheses */</comment>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>T_FieldSelect</name></expr>:</case>

			<comment type="block">/*
			 * appears simple since . has top precedence, unless parent is
			 * T_FieldSelect itself!
			 */</comment>
			<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>IsA</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary><operator>)</operator></expr>;</return>

		<case>case <expr><name>T_FieldStore</name></expr>:</case>

			<comment type="block">/*
			 * treat like FieldSelect (probably doesn't matter)
			 */</comment>
			<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>IsA</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary><operator>)</operator></expr>;</return>

		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<comment type="block">/* maybe simple, check args */</comment>
			<return>return <expr><call><name>isSimpleNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
								<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<return>return <expr><call><name>isSimpleNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
								<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<return>return <expr><call><name>isSimpleNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
								<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<return>return <expr><call><name>isSimpleNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
								<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<return>return <expr><call><name>isSimpleNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>,
								<argument><expr><name>node</name></expr></argument>, <argument><expr><name>prettyFlags</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* depends on parent node type; needs further checking */</comment>
				<if_stmt><if>if <condition>(<expr><name>prettyFlags</name> <operator>&amp;</operator> <name>PRETTYFLAG_PAREN</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parentOp</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>is_lopriop</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>is_hipriop</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>is_lopriparent</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>is_hipriparent</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>get_simple_binary_op_name</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/* We know only the basic operators + - and * / % */</comment>
					<expr_stmt><expr><name>is_lopriop</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"+-"</literal></expr></argument>, <argument><expr><operator>*</operator><name>op</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>is_hipriop</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"*/%"</literal></expr></argument>, <argument><expr><operator>*</operator><name>op</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>is_lopriop</name> <operator>||</operator> <name>is_hipriop</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>parentOp</name> <operator>=</operator> <call><name>get_simple_binary_op_name</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>parentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>parentOp</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>is_lopriparent</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"+-"</literal></expr></argument>, <argument><expr><operator>*</operator><name>parentOp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>is_hipriparent</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"*/%"</literal></expr></argument>, <argument><expr><operator>*</operator><name>parentOp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>is_lopriparent</name> <operator>||</operator> <name>is_hipriparent</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>is_hipriop</name> <operator>&amp;&amp;</operator> <name>is_lopriparent</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* op binds tighter than parent */</comment>

					<if_stmt><if>if <condition>(<expr><name>is_lopriop</name> <operator>&amp;&amp;</operator> <name>is_hipriparent</name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Operators are same priority --- can skip parens only if
					 * we have (a - b) - c, not a - (b - c).
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>parentNode</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* else do the same stuff as for T_SubLink et al. */</comment>
			</block_content>}</block>
			<comment type="block">/* FALLTHROUGH */</comment>

		<case>case <expr><name>T_SubLink</name></expr>:</case>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>T_FuncExpr</name></expr>:</case>
					<block>{<block_content>
						<comment type="block">/* special handling for casts */</comment>
						<decl_stmt><decl><type><name>CoercionForm</name></type> <name>type</name> <init>= <expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>parentNode</name><operator>)</operator><operator>-&gt;</operator><name>funcformat</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>COERCE_EXPLICIT_CAST</name> <operator>||</operator>
							<name>type</name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
						<return>return <expr><name>true</name></expr>;</return>	<comment type="block">/* own parentheses */</comment>
					</block_content>}</block>
				<case>case <expr><name>T_BoolExpr</name></expr>:</case>	<comment type="block">/* lower precedence */</comment>
				<case>case <expr><name>T_ArrayRef</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_ArrayExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_RowExpr</name></expr>:</case> <comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_XmlExpr</name></expr>:</case> <comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_NullIfExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_Aggref</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_WindowFunc</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_CaseExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
					<return>return <expr><name>true</name></expr>;</return>
				<default>default:</default>
					<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></switch>

		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>T_BoolExpr</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>prettyFlags</name> <operator>&amp;</operator> <name>PRETTYFLAG_PAREN</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>BoolExprType</name></type> <name>type</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>BoolExprType</name></type> <name>parentType</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>boolop</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>parentType</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>parentNode</name><operator>)</operator><operator>-&gt;</operator><name>boolop</name></expr>;</expr_stmt>
						<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>NOT_EXPR</name></expr>:</case>
							<case>case <expr><name>AND_EXPR</name></expr>:</case>
								<if_stmt><if>if <condition>(<expr><name>parentType</name> <operator>==</operator> <name>AND_EXPR</name> <operator>||</operator> <name>parentType</name> <operator>==</operator> <name>OR_EXPR</name></expr>)</condition><block type="pseudo"><block_content>
									<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
								<break>break;</break>
							<case>case <expr><name>OR_EXPR</name></expr>:</case>
								<if_stmt><if>if <condition>(<expr><name>parentType</name> <operator>==</operator> <name>OR_EXPR</name></expr>)</condition><block type="pseudo"><block_content>
									<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
								<break>break;</break>
						</block_content>}</block></switch>
					</block_content>}</block></if></if_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				<case>case <expr><name>T_FuncExpr</name></expr>:</case>
					<block>{<block_content>
						<comment type="block">/* special handling for casts */</comment>
						<decl_stmt><decl><type><name>CoercionForm</name></type> <name>type</name> <init>= <expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>parentNode</name><operator>)</operator><operator>-&gt;</operator><name>funcformat</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>COERCE_EXPLICIT_CAST</name> <operator>||</operator>
							<name>type</name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
						<return>return <expr><name>true</name></expr>;</return>	<comment type="block">/* own parentheses */</comment>
					</block_content>}</block>
				<case>case <expr><name>T_ArrayRef</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_ArrayExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_RowExpr</name></expr>:</case> <comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_XmlExpr</name></expr>:</case> <comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_NullIfExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
				<case>case <expr><name>T_Aggref</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_WindowFunc</name></expr>:</case>	<comment type="block">/* own parentheses */</comment>
				<case>case <expr><name>T_CaseExpr</name></expr>:</case>	<comment type="block">/* other separators */</comment>
					<return>return <expr><name>true</name></expr>;</return>
				<default>default:</default>
					<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></switch>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<comment type="block">/* those we don't know: in dubio complexo */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * appendContextKeyword - append a keyword to buffer
 *
 * If prettyPrint is enabled, perform a line break, and adjust indentation.
 * Otherwise, just append the keyword.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>appendContextKeyword</name><parameter_list>(<parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>indentBefore</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indentAfter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indentPlus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>indentAmount</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>indentBefore</name></expr>;</expr_stmt>

		<comment type="block">/* remove any trailing spaces currently in the buffer ... */</comment>
		<expr_stmt><expr><call><name>removeStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ... then add a newline and some spaces */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>&lt;</operator> <name>PRETTYINDENT_LIMIT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>indentAmount</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>indentPlus</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If we're indented more than PRETTYINDENT_LIMIT characters, try
			 * to conserve horizontal space by reducing the per-level
			 * indentation.  For best results the scale factor here should
			 * divide all the indent amounts that get added to indentLevel
			 * (PRETTYINDENT_STD, etc).  It's important that the indentation
			 * not grow unboundedly, else deeply-nested trees use O(N^2)
			 * whitespace; so we also wrap modulo PRETTYINDENT_LIMIT.
			 */</comment>
			<expr_stmt><expr><name>indentAmount</name> <operator>=</operator> <name>PRETTYINDENT_LIMIT</name> <operator>+</operator>
				<operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>-</operator> <name>PRETTYINDENT_LIMIT</name><operator>)</operator> <operator>/</operator>
				<operator>(</operator><name>PRETTYINDENT_STD</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>indentAmount</name> <operator>%=</operator> <name>PRETTYINDENT_LIMIT</name></expr>;</expr_stmt>
			<comment type="block">/* scale/wrap logic affects indentLevel, but not indentPlus */</comment>
			<expr_stmt><expr><name>indentAmount</name> <operator>+=</operator> <name>indentPlus</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>indentAmount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>+=</operator> <name>indentAfter</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * removeStringInfoSpaces - delete trailing spaces from a buffer.
 *
 * Possibly this should move to stringinfo.c at some point.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>removeStringInfoSpaces</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><operator>(</operator><name><name>str</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>


<comment type="block">/*
 * get_rule_expr_paren	- deparse expr using get_rule_expr,
 * embracing the string with parentheses if necessary for prettyPrint.
 *
 * Never embrace if prettyFlags=0, because it's done in the calling node.
 *
 * Any node that does *not* embrace its argument node by sql syntax (with
 * parentheses, non-operator keywords like CASE/WHEN/ON, or comma etc) should
 * use get_rule_expr_paren instead of get_rule_expr so parentheses can be
 * added.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_expr_paren</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>isSimpleNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>parentNode</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_rule_expr			- Parse back an expression
 *
 * Note: showimplicit determines whether we display any implicit cast that
 * is present at the top of the expression tree.  It is a passed argument,
 * not a field of the context struct, because we change the value as we
 * recurse down into the expression.  In general we suppress implicit casts
 * when the result type is known with certainty (eg, the arguments of an
 * OR must be boolean).  We display implicit casts for arguments of functions
 * and operators, since this is needed to be certain that the same function
 * or operator will be chosen when the expression is re-parsed.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against excessively long or deeply-nested queries */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Each level of get_rule_expr must emit an indivisible term
	 * (parenthesized if necessary) to ensure result is reparsed into the same
	 * expression tree.  The only exception is that when the input is a List,
	 * we emit the component items comma-separated with no surrounding
	 * decoration; this is convenient for most callers.
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_variable</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Const</name></expr>:</case>
			<expr_stmt><expr><call><name>get_const_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Param</name></expr>:</case>
			<expr_stmt><expr><call><name>get_parameter</name><argument_list>(<argument><expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<expr_stmt><expr><call><name>get_agg_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>gexpr</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"GROUPING("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>gexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<expr_stmt><expr><call><name>get_windowfunc_expr</name><argument_list>(<argument><expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ArrayRef</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayRef</name>   <modifier>*</modifier></type><name>aref</name> <init>= <expr><operator>(</operator><name>ArrayRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>need_parens</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If the argument is a CaseTestExpr, we must be inside a
				 * FieldStore, ie, we are assigning to an element of an array
				 * within a composite column.  Since we already punted on
				 * displaying the FieldStore's target information, just punt
				 * here too, and display only the assignment source
				 * expression.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Parenthesize the argument unless it's a simple Var or a
				 * FieldSelect.  (In particular, if it's another ArrayRef, we
				 * *must* parenthesize to avoid confusion.)
				 */</comment>
				<expr_stmt><expr><name>need_parens</name> <operator>=</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * If there's a refassgnexpr, we want to print the node in the
				 * format "array[subscripts] := refassgnexpr".  This is not
				 * legal SQL, so decompilation of INSERT or UPDATE statements
				 * should always use processIndirection as part of the
				 * statement-level syntax.  We should only see this when
				 * EXPLAIN tries to print the targetlist of a plan resulting
				 * from such a statement.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>refassgnexpr</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Use processIndirection to print this node's subscripts
					 * as well as any additional field selections or
					 * subscripting in immediate descendants.  It returns the
					 * RHS expr that is actually being "assigned".
					 */</comment>
					<expr_stmt><expr><name>refassgnexpr</name> <operator>=</operator> <call><name>processIndirection</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" := "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>refassgnexpr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Just an ordinary array fetch, so print subscripts */</comment>
					<expr_stmt><expr><call><name>printSubscripts</name><argument_list>(<argument><expr><name>aref</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>get_func_expr</name><argument_list>(<argument><expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>na</name> <init>= <expr><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s =&gt; "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>na</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>na</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>get_oper_expr</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS DISTINCT FROM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullIfExpr</name> <modifier>*</modifier></type><name>nullifexpr</name> <init>= <expr><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULLIF("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nullifexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s %s ("</literal></expr></argument>,
								 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
														<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><ternary><condition><expr><name><name>expr</name><operator>-&gt;</operator><name>useOr</name></name></expr> ?</condition><then> <expr><literal type="string">"ANY"</literal></expr> </then><else>: <expr><literal type="string">"ALL"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * There's inherent ambiguity in "x op ANY/ALL (y)" when y is
				 * a bare sub-SELECT.  Since we're here, the sub-SELECT must
				 * be meant as a scalar sub-SELECT yielding an array value to
				 * be used in ScalarArrayOpExpr; but the grammar will
				 * preferentially interpret such a construct as an ANY/ALL
				 * SubLink.  To prevent misparsing the output that way, insert
				 * a dummy coercion (which will be stripped by parse analysis,
				 * so no inefficiency is added in dump and reload).  This is
				 * indeed most likely what the user wrote to get the construct
				 * accepted in the first place.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>arg2</name><operator>)</operator><operator>-&gt;</operator><name>subLinkType</name> <operator>==</operator> <name>EXPR_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
									 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>,
															  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>first_arg</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>AND_EXPR</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>first_arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<while>while <condition>(<expr><name>arg</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AND "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></while>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>

					<case>case <expr><name>OR_EXPR</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>first_arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<while>while <condition>(<expr><name>arg</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>,
												<argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></while>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>

					<case>case <expr><name>NOT_EXPR</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NOT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>first_arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<break>break;</break>

					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<expr_stmt><expr><call><name>get_sublink_expr</name><argument_list>(<argument><expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * We cannot see an already-planned subplan in rule deparsing,
				 * only while EXPLAINing a query plan.  We don't try to
				 * reconstruct the original SQL, just reference the subplan
				 * that appears elsewhere in EXPLAIN's result.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>useHashTable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(hashed %s)"</literal></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name> <init>= <expr><operator>(</operator><name>AlternativeSubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<comment type="block">/* As above, this can only happen during EXPLAIN */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(alternatives: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>asplan-&gt;subplans</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>splan</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>useHashTable</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"hashed %s"</literal></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" or "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fselect</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fselect</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>fno</name> <init>= <expr><name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fieldname</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>need_parens</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Parenthesize the argument unless it's an ArrayRef or
				 * another FieldSelect.  Note in particular that it would be
				 * WRONG to not parenthesize a Var argument; simplicity is not
				 * the issue here, having the right number of names is.
				 */</comment>
				<expr_stmt><expr><name>need_parens</name> <operator>=</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>ArrayRef</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Get and print the field name.
				 */</comment>
				<expr_stmt><expr><name>fieldname</name> <operator>=</operator> <call><name>get_name_for_var_field</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>, <argument><expr><name>fno</name></expr></argument>,
												   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>fieldname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>need_parens</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * There is no good way to represent a FieldStore as real SQL,
				 * so decompilation of INSERT or UPDATE statements should
				 * always use processIndirection as part of the
				 * statement-level syntax.  We should only get here when
				 * EXPLAIN tries to print the targetlist of a plan resulting
				 * from such a statement.  The plan case is even harder than
				 * ordinary rules would be, because the planner tries to
				 * collapse multiple assignments to the same field or subfield
				 * into one FieldStore; so we can see a list of target fields
				 * not just one, and the arguments could be FieldStores
				 * themselves.  We don't bother to try to print the target
				 * field names; we just print the source arguments, with a
				 * ROW() around them if there's more than one.  This isn't
				 * terribly complete, but it's probably good enough for
				 * EXPLAIN's purposes; especially since anything more would be
				 * either hopelessly confusing or an even poorer
				 * representation of what the plan is actually doing.
				 */</comment>
				<expr_stmt><expr><name>need_parens</name> <operator>=</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROW("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>relabel</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>relabel</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>relabel</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>showimplicit</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* don't show the implicit cast */</comment>
					<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name><name>relabel</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
									  <argument><expr><name><name>relabel</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>,
									  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>iocoerce</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>iocoerce</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>showimplicit</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* don't show the implicit cast */</comment>
					<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
									  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>acoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>acoerce</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>showimplicit</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* don't show the implicit cast */</comment>
					<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
									  <argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>,
									  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>convert</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>convert</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>convert</name><operator>-&gt;</operator><name>convertformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>showimplicit</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* don't show the implicit cast */</comment>
					<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name><name>convert</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>collate</name> <init>= <expr><operator>(</operator><name>CollateExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>collate</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
								 <argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><name><name>collate</name><operator>-&gt;</operator><name>collOid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseexpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"CASE"</literal></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PRETTYINDENT_VAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>caseexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>when</name> <init>= <expr><operator>(</operator><name>CaseWhen</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>caseexpr</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * The parser should have produced WHEN clauses of the
						 * form "CaseTestExpr = RHS", possibly with an
						 * implicit coercion inserted above the CaseTestExpr.
						 * For accurate decompilation of rules it's essential
						 * that we show just the RHS.  However in an
						 * expression that's been through the optimizer, the
						 * WHEN clause could be almost anything (since the
						 * equality operator could have been expanded into an
						 * inline function).  If we don't recognize the form
						 * of the WHEN clause, just punt and display it as-is.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>w</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
								<call><name>IsA</name><argument_list>(<argument><expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"WHEN "</literal></expr></argument>,
										 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" THEN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>when</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"ELSE "</literal></expr></argument>,
									 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"END"</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_VAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Normally we should never get here, since for expressions
				 * that can contain this node type we attempt to avoid
				 * recursing to it.  But in an optimized expression we might
				 * be unable to avoid that (see comments for CaseExpr).  If we
				 * do see one, print it as CASE_TEST_EXPR.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CASE_TEST_EXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrayexpr</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>arrayexpr</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the array isn't empty, we assume its elements are
				 * coerced to the desired type.  If it's empty, though, we
				 * need an explicit coercion to the array type.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>elements</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
									 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>array_typeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If it's a named type and not RECORD, we may have to skip
				 * dropped columns and/or claim there are NULLs for added
				 * columns.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * SQL99 allows "ROW" to be omitted when there is more than
				 * one column, but for simplicity we always print it.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROW("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>rowexpr-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
						<operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* Whole-row Vars need special treatment here */</comment>
						<expr_stmt><expr><call><name>get_rule_expr_toplevel</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></while>

					<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>==</operator> <name>COERCE_EXPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
									 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * SQL99 allows "ROW" to be omitted when there is more than
				 * one column, but for simplicity we always print it.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(ROW("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>rcexpr-&gt;largs</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/*
				 * We assume that the name of the first-column operator will
				 * do for all the rest too.  This is definitely open to
				 * failure, eg if some but not all operators were renamed
				 * since the construct was parsed, but there seems no way to
				 * be perfect.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") %s ROW("</literal></expr></argument>,
								 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opnos</name></name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>rcexpr-&gt;rargs</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesceexpr</name> <init>= <expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"COALESCE("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>coalesceexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>minmaxexpr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>IS_GREATEST</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"GREATEST("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_LEAST</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LEAST("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>minmaxexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SQLValueFunction</name> <modifier>*</modifier></type><name>svf</name> <init>= <expr><operator>(</operator><name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Note: this code knows that typmod for time, timestamp, and
				 * timestamptz just prints as integer.
				 */</comment>
				<switch>switch <condition>(<expr><name><name>svf</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>SVFOP_CURRENT_DATE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_DATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_TIME</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_TIME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_TIME_N</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_TIME(%d)"</literal></expr></argument>, <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_TIMESTAMP</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_TIMESTAMP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_TIMESTAMP_N</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_TIMESTAMP(%d)"</literal></expr></argument>,
										 <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_LOCALTIME</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LOCALTIME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_LOCALTIME_N</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LOCALTIME(%d)"</literal></expr></argument>, <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_LOCALTIMESTAMP</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LOCALTIMESTAMP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_LOCALTIMESTAMP_N</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LOCALTIMESTAMP(%d)"</literal></expr></argument>,
										 <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_ROLE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_ROLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_USER</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_USER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_USER</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"USER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_SESSION_USER</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"SESSION_USER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_CATALOG</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_CATALOG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>SVFOP_CURRENT_SCHEMA</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT_SCHEMA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>needcomma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>narg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>IS_XMLCONCAT</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLCONCAT("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLELEMENT</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLELEMENT("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLFOREST</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLFOREST("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLPARSE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLPARSE("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLPI</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLPI("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLROOT</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLROOT("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_XMLSERIALIZE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLSERIALIZE("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_DOCUMENT</name></expr>:</case>
						<break>break;</break>
				</block_content>}</block></switch>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_XMLPARSE</name> <operator>||</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_XMLSERIALIZE</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>xmloption</name></name> <operator>==</operator> <name>XMLOPTION_DOCUMENT</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DOCUMENT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CONTENT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NAME %s"</literal></expr></argument>,
									 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>map_xml_name_to_sql_identifier</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>needcomma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>named_args</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>IS_XMLFOREST</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>needcomma</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLATTRIBUTES("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>needcomma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<macro><name>forboth</name><argument_list>(<argument>arg</argument>, <argument>xexpr-&gt;named_args</argument>, <argument>narg</argument>, <argument>xexpr-&gt;arg_names</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>needcomma</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS %s"</literal></expr></argument>,
										 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>map_xml_name_to_sql_identifier</name><argument_list>(<argument><expr><name>argname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>needcomma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block>
					<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>IS_XMLFOREST</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>needcomma</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<switch>switch <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>IS_XMLCONCAT</name></expr>:</case>
						<case>case <expr><name>IS_XMLELEMENT</name></expr>:</case>
						<case>case <expr><name>IS_XMLFOREST</name></expr>:</case>
						<case>case <expr><name>IS_XMLPI</name></expr>:</case>
						<case>case <expr><name>IS_XMLSERIALIZE</name></expr>:</case>
							<comment type="block">/* no extra decoration needed */</comment>
							<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_XMLPARSE</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>lsecond_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
													   <argument><expr><literal type="string">" PRESERVE WHITESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
													   <argument><expr><literal type="string">" STRIP WHITESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_XMLROOT</name></expr>:</case>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", VERSION "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
								<name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NO VALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>con</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

							<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>lthird_node</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
								 <comment type="block">/* suppress STANDALONE NO VALUE */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
							<else>else
							<block>{<block_content>
								<switch>switch <condition>(<expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<case>case <expr><name>XML_STANDALONE_YES</name></expr>:</case>
										<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
															   <argument><expr><literal type="string">", STANDALONE YES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<break>break;</break>
									<case>case <expr><name>XML_STANDALONE_NO</name></expr>:</case>
										<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
															   <argument><expr><literal type="string">", STANDALONE NO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<break>break;</break>
									<case>case <expr><name>XML_STANDALONE_NO_VALUE</name></expr>:</case>
										<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
															   <argument><expr><literal type="string">", STANDALONE NO VALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
										<break>break;</break>
									<default>default:</default>
										<break>break;</break>
								</block_content>}</block></switch>
							</block_content>}</block></else></if_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_DOCUMENT</name></expr>:</case>
							<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
					</block_content>}</block></switch>

				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_XMLSERIALIZE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS %s"</literal></expr></argument>,
									 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
															  <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_DOCUMENT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS DOCUMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * For scalar inputs, we prefer to print as IS [NOT] NULL,
				 * which is shorter and traditional.  If it's a rowtype input
				 * but we're applying a scalar test, must print IS [NOT]
				 * DISTINCT FROM NULL to be semantically correct.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>||</operator>
					<operator>!</operator><call><name>type_is_rowtype</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<switch>switch <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>IS_NULL</name></expr>:</case>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_NOT_NULL</name></expr>:</case>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized nulltesttype: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<switch>switch <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>IS_NULL</name></expr>:</case>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT DISTINCT FROM NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<case>case <expr><name>IS_NOT_NULL</name></expr>:</case>
							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS DISTINCT FROM NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						<default>default:</default>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized nulltesttype: %d"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>btest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>IS_TRUE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS TRUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_TRUE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT TRUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_FALSE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS FALSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_FALSE</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT FALSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_UNKNOWN</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS UNKNOWN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>IS_NOT_UNKNOWN</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IS NOT UNKNOWN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized booltesttype: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>ctest</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ctest</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>ctest</name><operator>-&gt;</operator><name>coercionformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>showimplicit</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* don't show the implicit cast */</comment>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
									  <argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>resulttypmod</name></name></expr></argument>,
									  <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_name</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT OF %s"</literal></expr></argument>,
									 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CURRENT OF $%d"</literal></expr></argument>,
									 <argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NextValueExpr</name> <modifier>*</modifier></type><name>nvexpr</name> <init>= <expr><operator>(</operator><name>NextValueExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * This isn't exactly nextval(), but that seems close enough
				 * for EXPLAIN's purposes.
				 */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"nextval("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
									 <argument><expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name><name>nvexpr</name><operator>-&gt;</operator><name>seqid</name></name></expr></argument>,
															<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_InferenceElem</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>InferenceElem</name> <modifier>*</modifier></type><name>iexpr</name> <init>= <expr><operator>(</operator><name>InferenceElem</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>save_varprefix</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>need_parens</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * InferenceElem can only refer to target relation, so a
				 * prefix is not useful, and indeed would cause parse errors.
				 */</comment>
				<expr_stmt><expr><name>save_varprefix</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Parenthesize the element unless it's a simple Var or a bare
				 * function call.  Follows pg_get_indexdef_worker().
				 */</comment>
				<expr_stmt><expr><name>need_parens</name> <operator>=</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>iexpr</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>iexpr</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>iexpr</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>funcformat</name> <operator>==</operator>
					<name>COERCE_EXPLICIT_CALL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>need_parens</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>iexpr</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
							  <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>need_parens</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>varprefix</name></name> <operator>=</operator> <name>save_varprefix</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>iexpr</name><operator>-&gt;</operator><name>infercollid</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
									 <argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><name><name>iexpr</name><operator>-&gt;</operator><name>infercollid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Add the operator class name, if not default */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>iexpr</name><operator>-&gt;</operator><name>inferopclass</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>inferopclass</name> <init>= <expr><name><name>iexpr</name><operator>-&gt;</operator><name>inferopclass</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>inferopcinputtype</name> <init>= <expr><call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name><name>iexpr</name><operator>-&gt;</operator><name>inferopclass</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>get_opclass_name</name><argument_list>(<argument><expr><name>inferopclass</name></expr></argument>, <argument><expr><name>inferopcinputtype</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_PartitionBoundSpec</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name> <init>= <expr><operator>(</operator><name>PartitionBoundSpec</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<switch>switch <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>PARTITION_STRATEGY_HASH</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name> <operator>&gt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FOR VALUES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WITH (modulus %d, remainder %d)"</literal></expr></argument>,
										 <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>PARTITION_STRATEGY_LIST</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>listdatums</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FOR VALUES IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
						<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>get_const_expr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
						</block_content>}</block>

						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>PARTITION_STRATEGY_RANGE</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
							   <name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
							   <call><name>list_length</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
							   <call><name>list_length</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"FOR VALUES FROM %s TO %s"</literal></expr></argument>,
										 <argument><expr><call><name>get_range_partbound_string</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>get_range_partbound_string</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized partition strategy: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_List</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>(List *) node</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_TableFunc</name></expr>:</case>
			<expr_stmt><expr><call><name>get_tablefunc</name><argument_list>(<argument><expr><operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_DMLActionExpr</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DMLAction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<comment type="block">/* POLAR end */</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * get_rule_expr_toplevel		- Parse back a toplevel expression
 *
 * Same as get_rule_expr(), except that if the expr is just a Var, we pass
 * istoplevel = true not false to get_variable().  This causes whole-row Vars
 * to get printed with decoration that will prevent expansion of "*".
 * We need to use this in contexts such as ROW() and VALUES(), where the
 * parser would expand "foo.*" appearing at top level.  (In principle we'd
 * use this in get_target_list() too, but that has additional worries about
 * whether to print AS, so it needs to invoke get_variable() directly anyway.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_expr_toplevel</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>get_variable</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rule_expr_funccall		- Parse back a function-call expression
 *
 * Same as get_rule_expr(), except that we guarantee that the output will
 * look like a function call, or like one of the things the grammar treats as
 * equivalent to a function call (see the func_expr_windowless production).
 * This is needed in places where the grammar uses func_expr_windowless and
 * you can't substitute a parenthesized a_expr.  If what we have isn't going
 * to look like a function call, wrap it in a dummy CAST() expression, which
 * will satisfy the grammar --- and, indeed, is likely what the user wrote to
 * produce such a thing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_rule_expr_funccall</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>looks_like_function</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CAST("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* no point in showing any top-level implicit cast */</comment>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS %s)"</literal></expr></argument>,
						 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to identify node types that satisfy func_expr_windowless.
 * If in doubt, "false" is always a safe answer.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>looks_like_function</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* probably shouldn't happen */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<comment type="block">/* OK, unless it's going to deparse as a cast */</comment>
			<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>funcformat</name> <operator>==</operator> <name>COERCE_EXPLICIT_CALL</name><operator>)</operator></expr>;</return>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<comment type="block">/* these are all accepted by func_expr_common_subexpr */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_oper_expr			- Parse back an OpExpr node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_oper_expr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* binary operator */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s "</literal></expr></argument>,
						 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
												<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* unary operator --- but which side? */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>optup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>optup</name><operator>-&gt;</operator><name>oprkind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>,
								 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
														<argument><expr><name>InvalidOid</name></expr></argument>,
														<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
								 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
														<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus oprkind: %d"</literal></expr></argument>, <argument><expr><name><name>optup</name><operator>-&gt;</operator><name>oprkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_expr			- Parse back a FuncExpr node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_func_expr</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcoid</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_variadic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the function call came from an implicit coercion, then just show the
	 * first argument --- unless caller wants to see implicit coercions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>showimplicit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the function call came from a cast, then show the first argument
	 * plus an explicit cast operation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>==</operator> <name>COERCE_EXPLICIT_CAST</name> <operator>||</operator>
		<name><name>expr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>rettype</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>coercedTypmod</name></decl>;</decl_stmt>

		<comment type="block">/* Get the typmod if this is a length-coercion function */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>exprIsLengthCoercion</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coercedTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>get_coercion_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
						  <argument><expr><name>rettype</name></expr></argument>, <argument><expr><name>coercedTypmod</name></expr></argument>,
						  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Normal function: display as proname(args).  First we need to extract
	 * the argument datatypes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>argnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>argnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>nargs</name></expr>]</index></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nargs</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>isGlobalFunc</name></name></expr>)</condition> 
	<block>{<block_content>
          <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s('%s'"</literal></expr></argument>,
                   		<argument><expr><name>POLAR_GLOBAL_FUNCTION</name></expr></argument>, 
						<argument><expr><call><name>generate_function_name</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
												<argument><expr><name>argnames</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
												<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>use_variadic</name></expr></argument>,
												<argument><expr><name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>,
						<argument><expr><call><name>generate_function_name</name><argument_list>(<argument><expr><name>funcoid</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
												<argument><expr><name>argnames</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
												<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>use_variadic</name></expr></argument>,
												<argument><expr><name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nargs</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>expr</name><operator>-&gt;</operator><name>isGlobalFunc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>use_variadic</name> <operator>&amp;&amp;</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VARIADIC "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_agg_expr			- Parse back an Aggref node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_agg_expr</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
			 <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>original_aggref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_variadic</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For a combining aggregate, we look up and deparse the corresponding
	 * partial aggregate instead.  This is necessary because our input
	 * argument list has been replaced; the new argument list always has just
	 * one element, which will point to a partial Aggref that supplies us with
	 * transition states to combine.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_COMBINE</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resolve_special_varno</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>original_aggref</name></expr></argument>,
							  <argument><expr><name>get_agg_combine_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Mark as PARTIAL, if appropriate.  We look to the original aggref so as
	 * to avoid printing this when recursing from the code just above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name><name>original_aggref</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"PARTIAL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Extract the argument types as seen by the parser */</comment>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>get_aggregate_argtypes</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Print the aggregate name, schema-qualified if needed */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s(%s"</literal></expr></argument>,
					 <argument><expr><call><name>generate_function_name</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
											<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggvariadic</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>use_variadic</name></expr></argument>,
											<argument><expr><name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><ternary><condition><expr><operator>(</operator><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"DISTINCT "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ordered-set aggregates do not use "*" syntax.  Also, we needn't
		 * worry about inserting VARIADIC.  So we can just dump the direct
		 * args as-is.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>aggref</name><operator>-&gt;</operator><name>aggvariadic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") WITHIN GROUP (ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_orderby</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* aggstar can be set only in zero-argument aggregates */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggstar</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>aggref-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>i</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>use_variadic</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"VARIADIC "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_rule_orderby</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") FILTER (WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is a helper function for get_agg_expr().  It's used when we deparse
 * a combining Aggref; resolve_special_varno locates the corresponding partial
 * Aggref and then calls this.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_agg_combine_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>private</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>original_aggref</name> <init>= <expr><name>private</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"combining Aggref does not point to an Aggref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aggref</name> <operator>=</operator> <operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_agg_expr</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>original_aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_windowfunc_expr	- Parse back a WindowFunc node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_windowfunc_expr</name><parameter_list>(<parameter><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>argnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>wfunc-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>argnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>nargs</name></expr>]</index></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nargs</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>,
					 <argument><expr><call><name>generate_function_name</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
											<argument><expr><name>argnames</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name><name>context</name><operator>-&gt;</operator><name>special_exprkind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* winstar can be set only in zero-argument aggregates */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wfunc</name><operator>-&gt;</operator><name>winstar</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>wfunc</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") FILTER (WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") OVER "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>context-&gt;windowClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name> <operator>==</operator> <name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>get_rule_windowspec</name><argument_list>(<argument><expr><name>wc</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>windowTList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>windowClause</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find window clause for winref %u"</literal></expr></argument>,
				 <argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>winref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * In EXPLAIN, we don't have window context information available, so
		 * we have to settle for this:
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(?)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_coercion_expr
 *
 *	Make a string representation of a value coerced to a specific type
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_coercion_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>resulttype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>resulttypmod</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since parse_coerce.c doesn't immediately collapse application of
	 * length-coercion functions to constants, what we'll typically see in
	 * such cases is a Const with typmod -1 and a length-coercion function
	 * right above it.  Avoid generating redundant output. However, beware of
	 * suppressing casts when the user actually wrote something like
	 * 'foo'::text::char(3).
	 *
	 * Note: it might seem that we are missing the possibility of needing to
	 * print a COLLATE clause for such a Const.  However, a Const could only
	 * have nondefault collation in a post-constant-folding tree, in which the
	 * length coercion would have been folded too.  See also the special
	 * handling of CollateExpr in coerce_to_target_type(): any collation
	 * marking will be above the coercion node, not below it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>consttype</name> <operator>==</operator> <name>resulttype</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>consttypmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Show the constant without normal ::typename decoration */</comment>
		<expr_stmt><expr><call><name>get_const_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_rule_expr_paren</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Never emit resulttype(arg) functional notation. A pg_proc entry could
	 * take precedence, and a resulttype in pg_temp would require schema
	 * qualification that format_type_with_typemod() would usually omit. We've
	 * standardized on arg::resulttype, but CAST(arg AS resulttype) notation
	 * would work fine.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
					 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>, <argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_const_expr
 *
 *	Make a string representation of a Const
 *
 * showtype can be -1 to never show "::typename" decoration, or +1 to always
 * show it, or 0 to show it only if the constant wouldn't be assumed to be
 * the right type by default.
 *
 * If the Const's collation isn't default for its type, show that too.
 * We mustn't do this when showtype is -1 (since that means the caller will
 * print "::typename", and we can't put a COLLATE clause in between).  It's
 * caller's responsibility that collation isn't missed in such cases.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_const_expr</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>showtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typIsVarlena</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>extval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needlabel</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>constval</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Always label the type of a NULL constant to prevent misdecisions
		 * about type when reparsing.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>showtype</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
							 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
													  <argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_const_collation</name><argument_list>(<argument><expr><name>constval</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>extval</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typoutput</name></expr></argument>, <argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT4OID</name></expr>:</case>

			<comment type="block">/*
			 * INT4 can be printed without any decoration, unless it is
			 * negative; in that case print it as '-nnn'::integer to ensure
			 * that the output will re-parse as a constant, not as a constant
			 * plus operator.  In most cases we could get away with printing
			 * (-nnn) instead, because of the way that gram.y handles negative
			 * literals; but that doesn't work for INT_MIN, and it doesn't
			 * seem that much prettier anyway.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>extval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* we must attach a cast */</comment>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>NUMERICOID</name></expr>:</case>

			<comment type="block">/*
			 * NUMERIC can be printed without quotes if it looks like a float
			 * constant (not an integer, and not Infinity or NaN) and doesn't
			 * have a leading sign (for the same reason as for INT4).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>extval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>strcspn</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><literal type="string">"eE."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* we must attach a cast */</comment>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>BOOLOID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>extval</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>extval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>showtype</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * For showtype == 0, append ::typename unless the constant will be
	 * implicitly typed as the right type when it is read in.
	 *
	 * XXX this code has to be kept in sync with the behavior of the parser,
	 * especially make_const.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
		<case>case <expr><name>UNKNOWNOID</name></expr>:</case>
			<comment type="block">/* These types can be left unlabeled */</comment>
			<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<comment type="block">/* We determined above whether a label is needed */</comment>
			<break>break;</break>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>

			<comment type="block">/*
			 * Float-looking constants will be typed as numeric, which we
			 * checked above; but if there's a nondefault typmod we need to
			 * show it.
			 */</comment>
			<expr_stmt><expr><name>needlabel</name> <operator>|=</operator> <operator>(</operator><name><name>constval</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>needlabel</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name>needlabel</name> <operator>||</operator> <name>showtype</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>,
						 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
												  <argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_const_collation</name><argument_list>(<argument><expr><name>constval</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * helper for get_const_expr: append COLLATE if needed
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_const_collation</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typcollation</name> <init>= <expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>constval</name><operator>-&gt;</operator><name>constcollid</name></name> <operator>!=</operator> <name>typcollation</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
							 <argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><name><name>constval</name><operator>-&gt;</operator><name>constcollid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * simple_quote_literal - Format a string as a SQL literal, append to buf
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>simple_quote_literal</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>valptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We form the string literal according to the prevailing setting of
	 * standard_conforming_strings; we never use E''. User is responsible for
	 * making sure result is used correctly.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>valptr</name> <operator>=</operator> <name>val</name></expr>;</init> <condition><expr><operator>*</operator><name>valptr</name></expr>;</condition> <incr><expr><name>valptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>valptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SQL_STR_DOUBLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>!</operator><name>standard_conforming_strings</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_sublink_expr			- Parse back a sublink
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_sublink_expr</name><parameter_list>(<parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ARRAY("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Note that we print the name of only the first operator, when there are
	 * multiple combining operators.  This is an approximation that could go
	 * wrong in various scenarios (operators in different schemas, renamed
	 * operators, etc) but there is not a whole lot we can do about it, since
	 * the syntax allows only one operator to be shown.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* single combining operator */</comment>
			<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* multiple combining operators, = or &lt;&gt; cases */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BoolExpr *) sublink-&gt;testexpr)-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opname</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>opname</name> <operator>=</operator> <call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>,
													<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* multiple combining operators, &lt; &lt;= &gt; &gt;= cases */</comment>
			<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <call><name>generate_operator_name</name><argument_list>(<argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opnos</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized testexpr type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXISTS_SUBLINK</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"EXISTS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>ANY_SUBLINK</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opname</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* Represent = ANY as IN */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" IN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s ANY "</literal></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>ALL_SUBLINK</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s ALL "</literal></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>ROWCOMPARE_SUBLINK</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s "</literal></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>EXPR_SUBLINK</name></expr>:</case>
		<case>case <expr><name>MULTIEXPR_SUBLINK</name></expr>:</case>
		<case>case <expr><name>ARRAY_SUBLINK</name></expr>:</case>
			<expr_stmt><expr><name>need_paren</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CTE_SUBLINK</name></expr>:</case>		<comment type="block">/* shouldn't occur in a SubLink */</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized sublink type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr></argument>,
				  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_paren</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * get_tablefunc			- Parse back a table function
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_tablefunc</name><parameter_list>(<parameter><decl><type><name>TableFunc</name> <modifier>*</modifier></type><name>tf</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>showimplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* XMLTABLE is the only existing implementation.  */</comment>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLTABLE("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tf</name><operator>-&gt;</operator><name>ns_uris</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"XMLNAMESPACES ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lc1</argument>, <argument>tf-&gt;ns_uris</argument>, <argument>lc2</argument>, <argument>tf-&gt;ns_names</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>ns_node</name> <init>= <expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>ns_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS %s"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>ns_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"), "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tf</name><operator>-&gt;</operator><name>rowexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") PASSING ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tf</name><operator>-&gt;</operator><name>docexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tf</name><operator>-&gt;</operator><name>colexprs</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l3</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l4</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l5</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>colnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>l2</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>coltypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>l3</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>coltypmods</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>l4</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>colexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>l5</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>tf</name><operator>-&gt;</operator><name>coldefexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLUMNS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l1</argument>, <argument>tf-&gt;colnames</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>colexpr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>coldefexpr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ordinality</name> <init>= <expr><name><name>tf</name><operator>-&gt;</operator><name>ordinalitycol</name></name> <operator>==</operator> <name>colnum</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>notnull</name> <init>= <expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>colnum</name></expr></argument>, <argument><expr><name><name>tf</name><operator>-&gt;</operator><name>notnulls</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>typid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>l2</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>l3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>l3</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>l4</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>coldefexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>l5</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>colnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>colnum</name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>ordinality</name></expr> ?</condition><then> <expr><literal type="string">"FOR ORDINALITY"</literal></expr> </then><else>:
							 <expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ordinality</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>coldefexpr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" DEFAULT ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>coldefexpr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>colexpr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" PATH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>colexpr</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>showimplicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>notnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * get_from_clause			- Parse back a FROM clause
 *
 * "prefix" is the keyword that denotes the start of the list of FROM
 * elements. It is FROM when used to parse back SELECT and UPDATE, but
 * is USING when parsing back DELETE.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_from_clause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use the query's jointree as a guide to what to print.  However, we
	 * must ignore auto-added RTEs that are marked not inFromCl. (These can
	 * only appear at the top level of the jointree, so it's sufficient to
	 * check here.)  This check also ensures we ignore the rule pseudo-RTEs
	 * for NEW and OLD.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>query-&gt;jointree-&gt;fromlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>jtnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>,
								 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>get_from_clause_item</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>itembuf</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Put the new FROM item's text into itembuf so we can decide
			 * after we've got it whether or not it needs to go on a new line.
			 */</comment>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itembuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <operator>&amp;</operator><name>itembuf</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>get_from_clause_item</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Restore context's output buffer */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

			<comment type="block">/* Consider line-wrapping if enabled */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PRETTY_INDENT</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Does the new item start with a new line? */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>itembuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>itembuf</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* If so, we shouldn't add anything */</comment>
					<comment type="block">/* instead, remove any trailing spaces currently in buf */</comment>
					<expr_stmt><expr><call><name>removeStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>trailing_nl</name></decl>;</decl_stmt>

					<comment type="block">/* Locate the start of the current line in the buffer */</comment>
					<expr_stmt><expr><name>trailing_nl</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>trailing_nl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>trailing_nl</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>trailing_nl</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<comment type="block">/*
					 * Add a newline, plus some indentation, if the new item
					 * would cause an overflow.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>trailing_nl</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>itembuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
											 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
											 <argument><expr><name>PRETTYINDENT_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Add the new item */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>itembuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* clean up */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>itembuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_from_clause_item</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name> <init>= <expr><operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>varno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>refname</name> <init>= <expr><call><name>get_rtable_name</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name> <init>= <expr><call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>printalias</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LATERAL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Print the FROM item proper */</comment>
		<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTE_RELATION</name></expr>:</case>
				<comment type="block">/* Normal relation RTE */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
								 <argument><expr><call><name>only_marker</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,	
														<argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
				<comment type="block">/* Subquery RTE */</comment>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_query_def</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>namespaces</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>prettyFlags</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>wrapColumn</name></name></expr></argument>,
							  <argument><expr><name><name>context</name><operator>-&gt;</operator><name>indentLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
				<comment type="block">/* Function RTE */</comment>
				<expr_stmt><expr><name>rtfunc1</name> <operator>=</operator> <operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Omit ROWS FROM() syntax for just one function, unless it
				 * has both a coldeflist and WITH ORDINALITY. If it has both,
				 * we must use ROWS FROM() syntax to avoid ambiguity about
				 * whether the coldeflist includes the ordinality column.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>rtfunc1</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>get_rule_expr_funccall</name><argument_list>(<argument><expr><name><name>rtfunc1</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* we'll print the coldeflist below, if it has one */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>		<name>all_unnest</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * If all the function calls in the list are to unnest,
					 * and none need a coldeflist, then collapse the list back
					 * down to UNNEST(args).  (If we had more than one
					 * built-in unnest function, this would get more
					 * difficult.)
					 *
					 * XXX This is pretty ugly, since it makes not-terribly-
					 * future-proof assumptions about what the parser would do
					 * with the output; but the alternative is to emit our
					 * nonstandard ROWS FROM() notation for what might have
					 * been a perfectly spec-compliant multi-argument
					 * UNNEST().
					 */</comment>
					<expr_stmt><expr><name>all_unnest</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
							<operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name><operator>)</operator><operator>-&gt;</operator><name>funcid</name> <operator>!=</operator> <name>F_ARRAY_UNNEST</name> <operator>||</operator>
							<name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>all_unnest</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>

					<if_stmt><if>if <condition>(<expr><name>all_unnest</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>allargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

						<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></init></decl>;</decl_stmt>

							<expr_stmt><expr><name>allargs</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>allargs</name></expr></argument>, <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block>

						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"UNNEST("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>allargs</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>funcno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"ROWS FROM("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><name>funcno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><call><name>get_rule_expr_funccall</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/* Reconstruct the column definition list */</comment>
								<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" AS "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>get_from_clause_coldeflist</name><argument_list>(<argument><expr><name>rtfunc</name></expr></argument>,
														   <argument><expr><name>NULL</name></expr></argument>,
														   <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<expr_stmt><expr><name>funcno</name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<comment type="block">/* prevent printing duplicate coldeflist below */</comment>
					<expr_stmt><expr><name>rtfunc1</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" WITH ORDINALITY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
				<expr_stmt><expr><call><name>get_tablefunc</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_VALUES</name></expr>:</case>
				<comment type="block">/* Values list RTE */</comment>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_values_def</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_CTE</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* Print the relation alias, if needed */</comment>
		<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Always print alias if user provided one */</comment>
			<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Always print alias if we need to print column aliases */</comment>
			<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No need to print alias if it's same as relation name (this
			 * would normally be the case, but not if set_rtable_names had to
			 * resolve a conflict).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><call><name>get_relation_name</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For a function RTE, always print alias.  This covers possible
			 * renaming of the function and/or instability of the
			 * FigureColname rules for things that aren't simple functions.
			 * Note we'd need to force it anyway for the columndef list case.
			 */</comment>
			<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Alias is syntactically required for VALUES */</comment>
			<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No need to print alias if it's same as CTE name (this would
			 * normally be the case, but not if set_rtable_names had to
			 * resolve a conflict).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>printalias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>printalias</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Print the column definitions or aliases, if needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>rtfunc1</name> <operator>&amp;&amp;</operator> <name><name>rtfunc1</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Reconstruct the columndef list, which is also the aliases */</comment>
			<expr_stmt><expr><call><name>get_from_clause_coldeflist</name><argument_list>(<argument><expr><name>rtfunc1</name></expr></argument>, <argument><expr><name>colinfo</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Else print column aliases as needed */</comment>
			<expr_stmt><expr><call><name>get_column_alias_list</name><argument_list>(<argument><expr><name>colinfo</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Tablesample clause must go after any alias */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>get_tablesample_def</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name> <init>= <expr><call><name>deparse_columns_fetch</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name>dpns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>need_paren_on_right</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>need_paren_on_right</name> <operator>=</operator> <call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>rarg</name></name><operator>)</operator><operator>-&gt;</operator><name>alias</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>j</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>get_from_clause_item</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>JOIN_INNER</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" JOIN "</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
										 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
										 <argument><expr><name>PRETTYINDENT_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" CROSS JOIN "</literal></expr></argument>,
										 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
										 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
										 <argument><expr><name>PRETTYINDENT_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" LEFT JOIN "</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_FULL</name></expr>:</case>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" FULL JOIN "</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
				<expr_stmt><expr><call><name>appendContextKeyword</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">" RIGHT JOIN "</literal></expr></argument>,
									 <argument><expr><operator>-</operator><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_STD</name></expr></argument>,
									 <argument><expr><name>PRETTYINDENT_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>need_paren_on_right</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_from_clause_item</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_paren_on_right</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>usingClause</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" USING ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Use the assigned names, not what's in usingClause */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>colinfo-&gt;usingNames</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_INNER</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If we didn't say CROSS JOIN above, we must provide an ON */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ON TRUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PRETTY_PAREN</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>j</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Yes, it's correct to put alias after the right paren ... */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>alias</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Note that it's correct to emit an alias clause if and only if
			 * there was one originally.  Otherwise we'd be converting a named
			 * join to unnamed or vice versa, which creates semantic
			 * subtleties we don't want.  However, we might print a different
			 * alias name than was there originally.
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>get_rtable_name</name><argument_list>(<argument><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>,
															  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_column_alias_list</name><argument_list>(<argument><expr><name>colinfo</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_column_alias_list - print column alias list for an RTE
 *
 * Caller must already have printed the relation's alias name.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_column_alias_list</name><parameter_list>(<parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Don't print aliases if not needed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>colinfo</name><operator>-&gt;</operator><name>printaliases</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>num_new_cols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><name><name>colinfo</name><operator>-&gt;</operator><name>new_colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_from_clause_coldeflist - reproduce FROM clause coldeflist
 *
 * When printing a top-level coldeflist (which is syntactically also the
 * relation's column alias list), use column names from colinfo.  But when
 * printing a coldeflist embedded inside ROWS FROM(), we prefer to use the
 * original coldeflist's names, which are available in rtfunc-&gt;funccolnames.
 * Pass NULL for colinfo to select the latter behavior.
 *
 * The coldeflist is appended immediately (no space) to buf.  Caller is
 * responsible for ensuring that an alias or AS is present before it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_from_clause_coldeflist</name><parameter_list>(<parameter><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name></decl></parameter>,
						   <parameter><decl><type><name>deparse_columns</name> <modifier>*</modifier></type><name>colinfo</name></decl></parameter>,
						   <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l4</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* there's no forfour(), so must chase one list the hard way */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>l4</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>forthree</name><argument_list>(<argument>l1</argument>, <argument>rtfunc-&gt;funccoltypes</argument>,
			 <argument>l2</argument>, <argument>rtfunc-&gt;funccoltypmods</argument>,
			 <argument>l3</argument>, <argument>rtfunc-&gt;funccolcollations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>atttypid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>atttypmod</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>attcollation</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>colinfo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <name><name>colinfo</name><operator>-&gt;</operator><name>colnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* shouldn't be any dropped columns here */</comment>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>format_type_with_typemod</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>, <argument><expr><name>atttypmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>attcollation</name> <operator>!=</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>,
							 <argument><expr><call><name>generate_collation_name</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>l4</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_tablesample_def			- print a TableSampleClause
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_tablesample_def</name><parameter_list>(<parameter><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tablesample</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We should qualify the handler's function name if it wouldn't be
	 * resolved by lookup in the current search path.
	 */</comment>
	<expr_stmt><expr><name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" TABLESAMPLE %s ("</literal></expr></argument>,
					 <argument><expr><call><name>generate_function_name</name><argument_list>(<argument><expr><name><name>tablesample</name><operator>-&gt;</operator><name>tsmhandler</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
											<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tablesample-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nargs</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tablesample</name><operator>-&gt;</operator><name>repeatable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" REPEATABLE ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tablesample</name><operator>-&gt;</operator><name>repeatable</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_opclass_name			- fetch name of an index operator class
 *
 * The opclass name is appended (after a space) to buf.
 *
 * Output is suppressed if the opclass is the default for the given
 * actual_datatype.  (If you don't want this behavior, just pass
 * InvalidOid for actual_datatype.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_opclass_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>,
				 <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_opc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opcrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ht_opc</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>opcrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>actual_datatype</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>actual_datatype</name></expr></argument>, <argument><expr><name><name>opcrec</name><operator>-&gt;</operator><name>opcmethod</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>opclass</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Okay, we need the opclass name.  Do we need to qualify it? */</comment>
		<expr_stmt><expr><name>opcname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>opcrec</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OpclassIsVisible</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>opcrec</name><operator>-&gt;</operator><name>opcnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s.%s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * processIndirection - take care of array and subfield assignment
 *
 * We strip any top-level FieldStore or assignment ArrayRef nodes that
 * appear in the input, printing them as decoration for the base column
 * name (which we assume the caller just printed).  We might also need to
 * strip CoerceToDomain nodes, but only ones that appear above assignment
 * nodes.
 *
 * Returns the subexpression that's to be assigned.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>processIndirection</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>cdomain</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typrelid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fieldname</name></decl>;</decl_stmt>

			<comment type="block">/* lookup tuple type */</comment>
			<expr_stmt><expr><name>typrelid</name> <operator>=</operator> <call><name>get_typ_typrelid</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"argument type %s of FieldStore is not a tuple type"</literal></expr></argument>,
					 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Print the field name.  There should only be one target field in
			 * stored rules.  There could be more than that in executable
			 * target lists, but this function cannot be used for that case.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>fieldnums</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fieldname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>typrelid</name></expr></argument>,
									<argument><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>fieldnums</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>fieldname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We ignore arg since it should be an uninteresting reference to
			 * the target column or subcolumn.
			 */</comment>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ArrayRef</name>   <modifier>*</modifier></type><name>aref</name> <init>= <expr><operator>(</operator><name>ArrayRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>printSubscripts</name><argument_list>(<argument><expr><name>aref</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We ignore refexpr since it should be an uninteresting reference
			 * to the target column or subcolumn.
			 */</comment>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cdomain</name> <operator>=</operator> <operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
			<comment type="block">/* If it's an explicit domain coercion, we're done */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cdomain</name><operator>-&gt;</operator><name>coercionformat</name></name> <operator>!=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/* Tentatively descend past the CoerceToDomain */</comment>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If we descended past a CoerceToDomain whose argument turned out not to
	 * be a FieldStore or array assignment, back up to the CoerceToDomain.
	 * (This is not enough to be fully correct if there are nested implicit
	 * CoerceToDomains, but such cases shouldn't ever occur.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cdomain</name> <operator>&amp;&amp;</operator> <name>node</name> <operator>==</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cdomain</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cdomain</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>printSubscripts</name><parameter_list>(<parameter><decl><type><name>ArrayRef</name> <modifier>*</modifier></type><name>aref</name></decl></parameter>, <parameter><decl><type><name>deparse_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lowlist_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>uplist_item</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lowlist_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* could be NULL */</comment>
	<macro><name>foreach</name><argument_list>(<argument>uplist_item</argument>, <argument>aref-&gt;refupperindexpr</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lowlist_item</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If subexpression is NULL, get_rule_expr prints nothing */</comment>
			<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lowlist_item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lowlist_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lowlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* If subexpression is NULL, get_rule_expr prints nothing */</comment>
		<expr_stmt><expr><call><name>get_rule_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>uplist_item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * quote_identifier			- Quote an identifier only if needed
 *
 * When quotes are needed, we palloc the required space; slightly
 * space-wasteful but well worth it for notational simplicity.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>quote_identifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Can avoid quoting if ident starts with a lowercase letter or underscore
	 * and contains only lowercase letters, digits, and underscores, *and* is
	 * not any SQL keyword.  Otherwise, supply quotes.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nquotes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>safe</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>optr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * would like to use &lt;ctype.h&gt; macros here, but they might yield unwanted
	 * locale-specific results...
	 */</comment>
	<expr_stmt><expr><name>safe</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>ident</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name><name>ident</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator> <name><name>ident</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal><operator>)</operator></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>ident</name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ch</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>ch</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>ch</name> <operator>==</operator> <literal type="char">'_'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* okay */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>safe</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nquotes</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>quote_all_identifiers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>safe</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>safe</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check for keyword.  We quote keywords except for unreserved ones.
		 * (In some cases we could avoid quoting a col_name or type_func_name
		 * keyword, but it seems much harder than it's worth to tell that.)
		 *
		 * Note: ScanKeywordLookup() does case-insensitive comparison, but
		 * that's fine, since we already know we have all-lower-case.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ScanKeyword</name> <modifier>*</modifier></type><name>keyword</name> <init>= <expr><call><name>ScanKeywordLookup</name><argument_list>(<argument><expr><name>ident</name></expr></argument>,
													   <argument><expr><name>ScanKeywords</name></expr></argument>,
													   <argument><expr><name>NumScanKeywords</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>keyword</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>keyword</name><operator>-&gt;</operator><name>category</name></name> <operator>!=</operator> <name>UNRESERVED_KEYWORD</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>safe</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>safe</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ident</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no change needed */</comment>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>nquotes</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>optr</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>ident</name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>ch</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>optr</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>optr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * quote_qualified_identifier	- Quote a possibly-qualified identifier
 *
 * Return a name of the form qualifier.ident, or just ident if qualifier
 * is NULL, quoting each component if necessary.  The result is palloc'd.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>quote_qualified_identifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qualifier</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>qualifier</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s."</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>qualifier</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_relation_name
 *		Get the unqualified name of a relation specified by OID
 *
 * This differs from the underlying get_rel_name() function in that it will
 * throw error instead of silently returning NULL if the OID is bad.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_relation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>relname</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_relation_name
 *		Compute the name to display for a relation specified by OID
 *
 * The result includes all necessary quoting and schema-prefixing.
 *
 * If namespaces isn't NIL, it must be a list of deparse_namespace nodes.
 * We will forcibly qualify the relation name if it equals any CTE name
 * visible in the namespace list.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>generate_relation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespaces</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_qual</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nslist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for conflicting CTE name */</comment>
	<expr_stmt><expr><name>need_qual</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>nslist</argument>, <argument>namespaces</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>deparse_namespace</name> <modifier>*</modifier></type><name>dpns</name> <init>= <expr><operator>(</operator><name>deparse_namespace</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>nslist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ctlist</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>ctlist</argument>, <argument>dpns-&gt;ctes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ctlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>need_qual</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>need_qual</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Otherwise, qualify the name if not visible in search path */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_qual</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>need_qual</name> <operator>=</operator> <operator>!</operator><call><name>RelationIsVisible</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_qual</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_qualified_relation_name
 *		Compute the name to display for a relation specified by OID
 *
 * As above, but unconditionally schema-qualify the name.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>generate_qualified_relation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for namespace %u"</literal></expr></argument>,
			 <argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_function_name
 *		Compute the name to display for a function specified by OID,
 *		given that it is being called with the specified actual arg names and
 *		types.  (Those matter because of ambiguous-function resolution rules.)
 *
 * If we're dealing with a potentially variadic function (in practice, this
 * means a FuncExpr or Aggref, not some other way of calling a function), then
 * has_variadic must specify whether variadic arguments have been merged,
 * and *use_variadic_p will be set to indicate whether to print VARIADIC in
 * the output.  For non-FuncExpr cases, has_variadic should be false and
 * use_variadic_p can be NULL.
 *
 * The result includes all necessary quoting and schema-prefixing.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>generate_function_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>argnames</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>has_variadic</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>use_variadic_p</name></decl></parameter>,
					   <parameter><decl><type><name>ParseExprKind</name></type> <name>special_exprkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_variadic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncDetailCode</name></type> <name>p_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>p_funcid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>p_rettype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>p_retset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>p_nvargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>p_vatype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>p_true_typeids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>force_qualify</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>proname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Due to parser hacks to avoid needing to reserve CUBE, we need to force
	 * qualification in some special cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>special_exprkind</name> <operator>==</operator> <name>EXPR_KIND_GROUP_BY</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>proname</name></expr></argument>, <argument><expr><literal type="string">"cube"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>proname</name></expr></argument>, <argument><expr><literal type="string">"rollup"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>force_qualify</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine whether VARIADIC should be printed.  We must do this first
	 * since it affects the lookup rules in func_get_detail().
	 *
	 * We always print VARIADIC if the function has a merged variadic-array
	 * argument.  Note that this is always the case for functions taking a
	 * VARIADIC argument type other than VARIADIC ANY.  If we omitted VARIADIC
	 * and printed the array elements as separate arguments, the call could
	 * match a newer non-VARIADIC function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_variadic_p</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Parser should not have set funcvariadic unless fn is variadic */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>has_variadic</name> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>provariadic</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>use_variadic</name> <operator>=</operator> <name>has_variadic</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>use_variadic_p</name> <operator>=</operator> <name>use_variadic</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>has_variadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>use_variadic</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The idea here is to schema-qualify only if the parser would fail to
	 * resolve the correct function given the unqualified func name with the
	 * specified argtypes and VARIADIC flag.  But if we already decided to
	 * force qualification, then we can skip the lookup and pretend we didn't
	 * find it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_qualify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p_result</name> <operator>=</operator> <call><name>func_get_detail</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>,
								   <argument><expr><operator>!</operator><name>use_variadic</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>p_funcid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p_rettype</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>p_retset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p_nvargs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p_vatype</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>p_true_typeids</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>p_result</name> <operator>=</operator> <name>FUNCDETAIL_NOTFOUND</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p_funcid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p_result</name> <operator>==</operator> <name>FUNCDETAIL_NORMAL</name> <operator>||</operator>
		 <name>p_result</name> <operator>==</operator> <name>FUNCDETAIL_AGGREGATE</name> <operator>||</operator>
		 <name>p_result</name> <operator>==</operator> <name>FUNCDETAIL_WINDOWFUNC</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>p_funcid</name> <operator>==</operator> <name>funcid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_operator_name
 *		Compute the name to display for an operator specified by OID,
 *		given that it is being called with the specified actual arg types.
 *		(Arg types matter because of ambiguous-operator resolution rules.
 *		Pass InvalidOid for unused arg of a unary operator.)
 *
 * The result includes all necessary quoting and schema-prefixing,
 * plus the OPERATOR() decoration needed to use a qualified operator name
 * in an expression.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>generate_operator_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Operator</name></type>	<name>p_result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>operid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>operform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The idea here is to schema-qualify only if the parser would fail to
	 * resolve the correct operator given the unqualified op name with the
	 * specified argtypes.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>operform</name><operator>-&gt;</operator><name>oprkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'b'</literal></expr>:</case>
			<expr_stmt><expr><name>p_result</name> <operator>=</operator> <call><name>oper</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>,
							<argument><expr><name>true</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'l'</literal></expr>:</case>
			<expr_stmt><expr><name>p_result</name> <operator>=</operator> <call><name>left_oper</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg2</name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'r'</literal></expr>:</case>
			<expr_stmt><expr><name>p_result</name> <operator>=</operator> <call><name>right_oper</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg1</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized oprkind: %d"</literal></expr></argument>, <argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p_result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>p_result</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>oprid</name><argument_list>(<argument><expr><name>p_result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>operid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"OPERATOR(%s."</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>p_result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>p_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_operator_clause --- generate a binary-operator WHERE clause
 *
 * This is used for internally-generated-and-executed SQL queries, where
 * precision is essential and readability is secondary.  The basic
 * requirement is to append "leftop op rightop" to buf, where leftop and
 * rightop are given as strings and are assumed to yield types leftoptype
 * and rightoptype; the operator is identified by OID.  The complexity
 * comes from needing to be sure that the parser will select the desired
 * operator when the query is parsed.  We always name the operator using
 * OPERATOR(schema.op) syntax, so as to avoid search-path uncertainties.
 * We have to emit casts too, if either input isn't already the input type
 * of the operator; else we are at the mercy of the parser's heuristics for
 * ambiguous-operator resolution.  The caller must ensure that leftop and
 * rightop are suitable arguments for a cast operation; it's best to insert
 * parentheses if they aren't just variables or parameters.
 */</comment>
<function><type><name>void</name></type>
<name>generate_operator_clause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>leftop</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>leftoptype</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>opoid</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rightop</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rightoptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>opoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>operform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprkind</name></name> <operator>==</operator> <literal type="char">'b'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>leftop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>leftoptype</name> <operator>!=</operator> <name><name>operform</name><operator>-&gt;</operator><name>oprleft</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>add_cast_to</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprleft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" OPERATOR(%s."</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">") %s"</literal></expr></argument>, <argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rightoptype</name> <operator>!=</operator> <name><name>operform</name><operator>-&gt;</operator><name>oprright</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>add_cast_to</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprright</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a cast specification to buf.  We spell out the type name the hard way,
 * intentionally not using format_type_be().  This is to avoid corner cases
 * for CHARACTER, BIT, and perhaps other types, where specifying the type
 * using SQL-standard syntax results in undesirable data truncation.  By
 * doing it this way we can be certain that the cast will have default (-1)
 * target typmod.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_cast_to</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typetup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typetup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typetup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typetup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>typform</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>typform</name><operator>-&gt;</operator><name>typnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"::%s.%s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typetup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * generate_qualified_type_name
 *		Compute the name to display for a type specified by OID
 *
 * This is different from format_type_be() in that we unconditionally
 * schema-qualify the name.  That also means no special syntax for
 * SQL-standard type names ... although in current usage, this should
 * only get used for domains, so such cases wouldn't occur anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>generate_qualified_type_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typtup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>typtup</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>typtup</name><operator>-&gt;</operator><name>typnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for namespace %u"</literal></expr></argument>,
			 <argument><expr><name><name>typtup</name><operator>-&gt;</operator><name>typnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_collation_name
 *		Compute the name to display for a collation specified by OID
 *
 * The result includes all necessary quoting and schema-prefixing.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>generate_collation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>colltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>colltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>colltup</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CollationIsVisible</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>colltup</name><operator>-&gt;</operator><name>collnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a C string, produce a TEXT datum.
 *
 * We assume that the input was palloc'd and may be freed.
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>string_to_text</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a C string representing a relation's reloptions, or NULL if none.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>flatten_reloptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>reloptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reloptions</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
								 <argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>noptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>noptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noptions</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>option</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>separator</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Each array element should have the form name=value.  If the "="
			 * is missing for some reason, treat it like an empty value.
			 */</comment>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <name>option</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>separator</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>separator</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>separator</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <name>separator</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s="</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In general we need to quote the value; but to avoid unnecessary
			 * clutter, do not quote if it is an identifier that would not
			 * need quoting.  (We could also allow numbers, but that is a bit
			 * trickier than it looks --- for example, are leading zeroes
			 * significant?  We don't want to assume very much here about what
			 * custom reloptions might mean.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>simple_quote_literal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_one_range_partition_bound_string
 *		A C string representation of one range partition bound
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_range_partbound_string</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bound_datums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>deparse_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deparse_context</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>bound_datums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>datum</name> <init>=
		<expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"MINVALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>datum</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"MAXVALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name><name>datum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>get_const_expr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
