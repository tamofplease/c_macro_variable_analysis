<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/utils/adt/network_spgist.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * network_spgist.c
 *	  SP-GiST support for network types.
 *
 * We split inet index entries first by address family (IPv4 or IPv6).
 * If the entries below a given inner tuple are all of the same family,
 * we identify their common prefix and split by the next bit of the address,
 * and by whether their masklens exceed the length of the common prefix.
 *
 * An inner tuple that has both IPv4 and IPv6 children has a null prefix
 * and exactly two nodes, the first being for IPv4 and the second for IPv6.
 *
 * Otherwise, the prefix is a CIDR value representing the common prefix,
 * and there are exactly four nodes.  Node numbers 0 and 1 are for addresses
 * with the same masklen as the prefix, while node numbers 2 and 3 are for
 * addresses with larger masklen.  (We do not allow a tuple to contain
 * entries with masklen smaller than its prefix's.)  Node numbers 0 and 1
 * are distinguished by the next bit of the address after the common prefix,
 * and likewise for node numbers 2 and 3.  If there are no more bits in
 * the address family, everything goes into node 0 (which will probably
 * lead to creating an allTheSame tuple).
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			src/backend/utils/adt/network_spgist.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inet.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>inet_spg_node_number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>inet</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>commonbits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>inet_spg_consistent_bitmap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>inet</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>,
						   <parameter><decl><type><name>ScanKey</name></type> <name>scankeys</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>leaf</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * The SP-GiST configuration function
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_spg_config</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* spgConfigIn *cfgin = (spgConfigIn *) PG_GETARG_POINTER(0); */</comment>
	<decl_stmt><decl><type><name>spgConfigOut</name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><operator>(</operator><name>spgConfigOut</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>prefixType</name></name> <operator>=</operator> <name>CIDROID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>labelType</name></name> <operator>=</operator> <name>VOIDOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>canReturnData</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>longValuesOK</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The SP-GiST choose function
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_spg_choose</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>spgChooseIn</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>spgChooseIn</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgChooseOut</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>spgChooseOut</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>inet</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>)</argument_list></call></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>commonbits</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're looking at a tuple that splits by address family, choose the
	 * appropriate subnode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>in</name><operator>-&gt;</operator><name>hasPrefix</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* allTheSame isn't possible for such a tuple */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>in</name><operator>-&gt;</operator><name>allTheSame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>resultType</name></name> <operator>=</operator> <name>spgMatchNode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>nodeN</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>ip_family</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGSQL_AF_INET</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>restDatum</name></name> <operator>=</operator> <call><name>InetPGetDatum</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else it must split by prefix */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name><name>in</name><operator>-&gt;</operator><name>allTheSame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>prefixDatum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We cannot put addresses from different families under the same inner
	 * node, so we have to split if the new value's family is different.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ip_family</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up 2-node tuple */</comment>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>resultType</name></name> <operator>=</operator> <name>spgSplitTuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixHasPrefix</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNNodes</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNodeLabels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Identify which node the existing data goes into */</comment>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>childNodeN</name></name> <operator>=</operator>
			<ternary><condition><expr><operator>(</operator><call><name>ip_family</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGSQL_AF_INET</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>postfixHasPrefix</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>postfixPrefixDatum</name></name> <operator>=</operator> <call><name>InetPGetDatum</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the new value does not match the existing prefix, we have to split.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ip_bits</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>commonbits</name> <operator>||</operator>
		<call><name>bitncmp</name><argument_list>(<argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Determine new prefix length for the split tuple */</comment>
		<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>bitncommon</name><argument_list>(<argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>Min</name><argument_list>(<argument><expr><call><name>ip_bits</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up 4-node tuple */</comment>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>resultType</name></name> <operator>=</operator> <name>spgSplitTuple</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixHasPrefix</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixPrefixDatum</name></name> <operator>=</operator>
			<call><name>InetPGetDatum</name><argument_list>(<argument><expr><call><name>cidr_set_masklen_internal</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNNodes</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>prefixNodeLabels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Identify which node the existing data goes into */</comment>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>childNodeN</name></name> <operator>=</operator>
			<call><name>inet_spg_node_number</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>postfixHasPrefix</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>splitTuple</name><operator>.</operator><name>postfixPrefixDatum</name></name> <operator>=</operator> <call><name>InetPGetDatum</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * All OK, choose the node to descend into.  (If this tuple is marked
	 * allTheSame, the core code will ignore our choice of nodeN; but we need
	 * not account for that case explicitly here.)
	 */</comment>
	<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>resultType</name></name> <operator>=</operator> <name>spgMatchNode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>nodeN</name></name> <operator>=</operator> <call><name>inet_spg_node_number</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>matchNode</name><operator>.</operator><name>restDatum</name></name> <operator>=</operator> <call><name>InetPGetDatum</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The GiST PickSplit method
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_spg_picksplit</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>spgPickSplitIn</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>spgPickSplitIn</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgPickSplitOut</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>spgPickSplitOut</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>inet</name>	   <modifier>*</modifier></type><name>prefix</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>commonbits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>differentFamilies</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Initialize the prefix with the first item */</comment>
	<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>datums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Examine remaining items to discover minimum common prefix length */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>differentFamilies</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ip_bits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>commonbits</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>bitncommon</name><argument_list>(<argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Don't need labels; allocate output arrays */</comment>
	<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nodeLabels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>mapTuplesToNodes</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>leafTupleDatums</name></name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>differentFamilies</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set up 2-node tuple */</comment>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>hasPrefix</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>mapTuplesToNodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<ternary><condition><expr><operator>(</operator><call><name>ip_family</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGSQL_AF_INET</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>leafTupleDatums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>InetPGetDatum</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Set up 4-node tuple */</comment>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>hasPrefix</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>prefixDatum</name></name> <operator>=</operator>
			<call><name>InetPGetDatum</name><argument_list>(<argument><expr><call><name>cidr_set_masklen_internal</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nTuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>mapTuplesToNodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>inet_spg_node_number</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>commonbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>leafTupleDatums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>InetPGetDatum</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The SP-GiST query consistency check for inner tuples
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_spg_inner_consistent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>spgInnerConsistentIn</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>spgInnerConsistentIn</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgInnerConsistentOut</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>spgInnerConsistentOut</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>which</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>in</name><operator>-&gt;</operator><name>hasPrefix</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>in</name><operator>-&gt;</operator><name>allTheSame</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Identify which child nodes need to be visited */</comment>
		<expr_stmt><expr><name>which</name> <operator>=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><name><name>in</name><operator>-&gt;</operator><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_strategy</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>inet</name>	   <modifier>*</modifier></type><name>argument</name> <init>= <expr><call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RTLessStrategyNumber</name></expr>:</case>
				<case>case <expr><name>RTLessEqualStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>ip_family</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGSQL_AF_INET</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTGreaterEqualStrategyNumber</name></expr>:</case>
				<case>case <expr><name>RTGreaterStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>ip_family</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGSQL_AF_INET6</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTNotEqualStrategyNumber</name></expr>:</case>
					<break>break;</break>

				<default>default:</default>
					<comment type="block">/* all other ops can only match addrs of same family */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>ip_family</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGSQL_AF_INET</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>which</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>in</name><operator>-&gt;</operator><name>allTheSame</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Identify which child nodes need to be visited */</comment>
		<expr_stmt><expr><name>which</name> <operator>=</operator> <call><name>inet_spg_consistent_bitmap</name><argument_list>(<argument><expr><call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>prefixDatum</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name><name>in</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name><name>in</name><operator>-&gt;</operator><name>scankeys</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Must visit all nodes; we assume there are less than 32 of 'em */</comment>
		<expr_stmt><expr><name>which</name> <operator>=</operator> <operator>~</operator><literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>which</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nodeNumbers</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>in</name><operator>-&gt;</operator><name>nNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>which</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>i</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nodeNumbers</name><index>[<expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>nNodes</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The SP-GiST query consistency check for leaf tuples
 */</comment>
<function><type><name>Datum</name></type>
<name>inet_spg_leaf_consistent</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>spgLeafConsistentIn</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>spgLeafConsistentIn</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgLeafConsistentOut</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>spgLeafConsistentOut</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>inet</name>	   <modifier>*</modifier></type><name>leaf</name> <init>= <expr><call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>leafDatum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* All tests are exact. */</comment>
	<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Leaf is what it is... */</comment>
	<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>leafValue</name></name> <operator>=</operator> <call><name>InetPGetDatum</name><argument_list>(<argument><expr><name>leaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use common code to apply the tests. */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>inet_spg_consistent_bitmap</name><argument_list>(<argument><expr><name>leaf</name></expr></argument>, <argument><expr><name><name>in</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name><name>in</name><operator>-&gt;</operator><name>scankeys</name></name></expr></argument>,
											  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate node number (within a 4-node, single-family inner index tuple)
 *
 * The value must have the same family as the node's prefix, and
 * commonbits is the mask length of the prefix.  We use even or odd
 * nodes according to the next address bit after the commonbits,
 * and low or high nodes according to whether the value's mask length
 * is larger than commonbits.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>inet_spg_node_number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>inet</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>commonbits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nodeN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&lt;</operator> <call><name>ip_maxbits</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>ip_addr</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call><index>[<expr><name>commonbits</name> <operator>/</operator> <literal type="number">8</literal></expr>]</index> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal> <operator>-</operator> <name>commonbits</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nodeN</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&lt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nodeN</name> <operator>|=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>nodeN</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate bitmap of node numbers that are consistent with the query
 *
 * This can be used either at a 4-way inner tuple, or at a leaf tuple.
 * In the latter case, we should return a boolean result (0 or 1)
 * not a bitmap.
 *
 * This definition is pretty odd, but the inner and leaf consistency checks
 * are mostly common and it seems best to keep them in one function.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>inet_spg_consistent_bitmap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>inet</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>scankeys</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>leaf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>commonbits</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize result to allow visiting all children */</comment>
	<if_stmt><if>if <condition>(<expr><name>leaf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>commonbits</name> <operator>=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>inet</name>	   <modifier>*</modifier></type><name>argument</name> <init>= <expr><call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_argument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name> <init>= <expr><name><name>scankeys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sk_strategy</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>order</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check 0: different families
		 *
		 * Matching families do not help any of the strategies.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ip_family</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RTLessStrategyNumber</name></expr>:</case>
				<case>case <expr><name>RTLessEqualStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>ip_family</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTGreaterEqualStrategyNumber</name></expr>:</case>
				<case>case <expr><name>RTGreaterStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>ip_family</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTNotEqualStrategyNumber</name></expr>:</case>
					<break>break;</break>

				<default>default:</default>
					<comment type="block">/* For all other cases, we can be sure there is no match */</comment>
					<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* Other checks make no sense with different families. */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check 1: network bit count
		 *
		 * Network bit count (ip_bits) helps to check leaves for sub network
		 * and sup network operators.  At non-leaf nodes, we know every child
		 * value has greater ip_bits, so we can avoid descending in some cases
		 * too.
		 *
		 * This check is less expensive than checking the address bits, so we
		 * are doing this before, but it has to be done after for the basic
		 * comparison strategies, because ip_bits only affect their results
		 * when the common network bits are the same.
		 */</comment>
		<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTSubStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&lt;=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>RTSubEqualStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&lt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>RTSuperStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>==</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>commonbits</name> <operator>&gt;=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>RTSuperEqualStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>==</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>commonbits</name> <operator>&gt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>RTEqualStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&lt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>commonbits</name> <operator>==</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check 2: common network bits
		 *
		 * Compare available common prefix bits to the query, but not beyond
		 * either the query's netmask or the minimum netmask among the
		 * represented values.  If these bits don't match the query, we can
		 * eliminate some cases.
		 */</comment>
		<expr_stmt><expr><name>order</name> <operator>=</operator> <call><name>bitncmp</name><argument_list>(<argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>commonbits</name></expr></argument>, <argument><expr><call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>order</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RTLessStrategyNumber</name></expr>:</case>
				<case>case <expr><name>RTLessEqualStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTGreaterEqualStrategyNumber</name></expr>:</case>
				<case>case <expr><name>RTGreaterStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTNotEqualStrategyNumber</name></expr>:</case>
					<break>break;</break>

				<default>default:</default>
					<comment type="block">/* For all other cases, we can be sure there is no match */</comment>
					<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Remaining checks make no sense when common bits don't match.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check 3: next network bit
		 *
		 * We can filter out branch 2 or 3 using the next network bit of the
		 * argument, if it is available.
		 *
		 * This check matters for the performance of the search. The results
		 * would be correct without it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>commonbits</name> <operator>&lt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nextbit</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>nextbit</name> <operator>=</operator> <call><name>ip_addr</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call><index>[<expr><name>commonbits</name> <operator>/</operator> <literal type="number">8</literal></expr>]</index> <operator>&amp;</operator>
				<operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal> <operator>-</operator> <name>commonbits</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RTLessStrategyNumber</name></expr>:</case>
				<case>case <expr><name>RTLessEqualStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nextbit</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTGreaterEqualStrategyNumber</name></expr>:</case>
				<case>case <expr><name>RTGreaterStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>nextbit</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTNotEqualStrategyNumber</name></expr>:</case>
					<break>break;</break>

				<default>default:</default>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nextbit</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Remaining checks are only for the basic comparison strategies. This
		 * test relies on the strategy number ordering defined in stratnum.h.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>strategy</name> <argument_list type="generic">&lt; <argument><expr><name>RTEqualStrategyNumber</name> <operator>||</operator>
			<name>strategy</name></expr></argument> &gt;</argument_list></name> <name>RTGreaterEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check 4: network bit count
		 *
		 * At this point, we know that the common network bits of the prefix
		 * and the argument are the same, so we can go forward and check the
		 * ip_bits.
		 */</comment>
		<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTLessStrategyNumber</name></expr>:</case>
			<case>case <expr><name>RTLessEqualStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>==</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>commonbits</name> <operator>&gt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>RTGreaterEqualStrategyNumber</name></expr>:</case>
			<case>case <expr><name>RTGreaterStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>&lt;</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Remaining checks don't make sense with different ip_bits. */</comment>
		<if_stmt><if>if <condition>(<expr><name>commonbits</name> <operator>!=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check 5: next host bit
		 *
		 * We can filter out branch 0 or 1 using the next host bit of the
		 * argument, if it is available.
		 *
		 * This check matters for the performance of the search. The results
		 * would be correct without it.  There is no point in running it for
		 * leafs as we have to check the whole address on the next step.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>leaf</name> <operator>&amp;&amp;</operator> <name>bitmap</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>commonbits</name> <operator>&lt;</operator> <call><name>ip_maxbits</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nextbit</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>nextbit</name> <operator>=</operator> <call><name>ip_addr</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call><index>[<expr><name>commonbits</name> <operator>/</operator> <literal type="number">8</literal></expr>]</index> <operator>&amp;</operator>
				<operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">7</literal> <operator>-</operator> <name>commonbits</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RTLessStrategyNumber</name></expr>:</case>
				<case>case <expr><name>RTLessEqualStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nextbit</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTGreaterEqualStrategyNumber</name></expr>:</case>
				<case>case <expr><name>RTGreaterStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>nextbit</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTNotEqualStrategyNumber</name></expr>:</case>
					<break>break;</break>

				<default>default:</default>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nextbit</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <literal type="number">1</literal> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check 6: whole address
		 *
		 * This is the last check for correctness of the basic comparison
		 * strategies.  It's only appropriate at leaf entries.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>leaf</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Redo ordering comparison using all address bits */</comment>
			<expr_stmt><expr><name>order</name> <operator>=</operator> <call><name>bitncmp</name><argument_list>(<argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>argument</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>ip_maxbits</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RTLessStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTLessEqualStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTEqualStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>order</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTGreaterEqualStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTGreaterStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>RTNotEqualStrategyNumber</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>order</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bitmap</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>bitmap</name></expr>;</return>
</block_content>}</block></function>
</unit>
