<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/spgist/spgxlog.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * spgxlog.c
 *	  WAL replay logic for SP-GiST
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			 src/backend/access/spgist/spgxlog.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bufmask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>opCtx</name></decl>;</decl_stmt>		<comment type="block">/* working memory for operations */</comment>


<comment type="block">/*
 * Prepare a dummy SpGistState, with just the minimum info needed for replay.
 *
 * At present, all we need is enough info to support spgFormDeadTuple(),
 * plus the isBuild flag.
 */</comment>
<function><type><name>void</name></type>
<name>fillFakeState</name><parameter_list>(<parameter><decl><type><name>SpGistState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>spgxlogState</name></type> <name>stateSrc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>myXid</name></name> <operator>=</operator> <name><name>stateSrc</name><operator>.</operator><name>myXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBuild</name></name> <operator>=</operator> <name><name>stateSrc</name><operator>.</operator><name>isBuild</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>deadTupleStorage</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>SGDTSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a leaf tuple, or replace an existing placeholder tuple.  This is used
 * to replay SpGistPageAddNewItem() operations.  If the offset points at an
 * existing tuple, it had better be a placeholder tuple.
 */</comment>
<function><type><name>void</name></type>
<name>addOrReplaceTuple</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>Item</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>dt</name> <init>= <expr><operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
														   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>!=</operator> <name>SPGIST_PLACEHOLDER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPGiST tuple to be replaced is not a placeholder"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nPlaceholder</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nPlaceholder</name><operator>--</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
			 <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgRedoCreateIndex</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SPGIST_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpGistInitMetapage</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SPGIST_ROOT_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>SPGIST_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SPGIST_NULL_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>SPGIST_LEAF</name> <operator>|</operator> <name>SPGIST_NULLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgRedoAddLeaf</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogAddLeaf</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogAddLeaf</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>leafTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistLeafTupleData</name></type> <name>leafTupleHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>spgxlogAddLeaf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>leafTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<comment type="block">/* the leaf tuple is unaligned, so make a copy to access its header */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leafTupleHdr</name></expr></argument>, <argument><expr><name>leafTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistLeafTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In normal operation we would have both current and parent pages locked
	 * simultaneously; but in WAL replay it should be safe to update the leaf
	 * page before updating the parent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>newPage</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
						 <argument><expr><name>SPGIST_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>storesNulls</name></name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* insert new tuple */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name> <operator>!=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnumHeadLeaf</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* normal cases, tuple was added by SpGistPageAddNewItem */</comment>
			<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>leafTuple</name></expr></argument>, <argument><expr><name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
							  <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* update head tuple's chain link if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumHeadLeaf</name></name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>head</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>head</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
													 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumHeadLeaf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>head</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>==</operator> <name><name>leafTupleHdr</name><operator>.</operator><name>nextOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* replacing a DEAD tuple */</comment>
			<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
							<argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>leafTuple</name></expr></argument>, <argument><expr><name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
							<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
					 <argument><expr><name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* update parent downlink if necessary */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blknoLeaf</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blknoLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
												   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
							  <argument><expr><name>blknoLeaf</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumLeaf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgRedoMoveLeafs</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogMoveLeafs</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogMoveLeafs</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDelete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toInsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nInsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blknoDst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blknoDst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fillFakeState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nInsert</name> <operator>=</operator> <ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>replaceDead</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>xldata</name><operator>-&gt;</operator><name>nMoves</name></name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>SizeOfSpgxlogMoveLeafs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toDelete</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nMoves</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toInsert</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nInsert</name></expr>;</expr_stmt>

	<comment type="block">/* now ptr points to the list of leaf tuples */</comment>

	<comment type="block">/*
	 * In normal operation we would have all three pages (source, dest, and
	 * parent) locked simultaneously; but in WAL replay it should be safe to
	 * update them one at a time, as long as we do it in the right order.
	 */</comment>

	<comment type="block">/* Insert tuples on the dest page (do first, so redirect is valid) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>newPage</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
						 <argument><expr><name>SPGIST_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>storesNulls</name></name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nInsert</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>leafTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SpGistLeafTupleData</name></type> <name>leafTupleHdr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * the tuples are not aligned, so must copy to access the size
			 * field.
			 */</comment>
			<expr_stmt><expr><name>leafTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leafTupleHdr</name></expr></argument>, <argument><expr><name>leafTuple</name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistLeafTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>leafTuple</name></expr></argument>,
							  <argument><expr><name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>toInsert</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Delete tuples from the source page, inserting a redirection pointer */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nMoves</name></name></expr></argument>,
								<argument><expr><ternary><condition><expr><name><name>state</name><operator>.</operator><name>isBuild</name></name></expr> ?</condition><then> <expr><name>SPGIST_PLACEHOLDER</name></expr> </then><else>: <expr><name>SPGIST_REDIRECT</name></expr></else></ternary></expr></argument>,
								<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
								<argument><expr><name>blknoDst</name></expr></argument>,
								<argument><expr><name><name>toInsert</name><index>[<expr><name>nInsert</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And update the parent downlink */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
											   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
						  <argument><expr><name>blknoDst</name></expr></argument>, <argument><expr><name><name>toInsert</name><index>[<expr><name>nInsert</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgRedoAddNode</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogAddNode</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogAddNode</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>innerTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistInnerTupleData</name></type> <name>innerTupleHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>spgxlogAddNode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>innerTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<comment type="block">/* the tuple is unaligned, so make a copy to access its header */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>innerTupleHdr</name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistInnerTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fillFakeState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* update in place */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>parentBlk</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>innerTuple</name></expr></argument>, <argument><expr><name><name>innerTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
							<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
					 <argument><expr><name><name>innerTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blknoNew</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blknoNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In normal operation we would have all three pages (source, dest,
		 * and parent) locked simultaneously; but in WAL replay it should be
		 * safe to update them one at a time, as long as we do it in the right
		 * order. We must insert the new tuple before replacing the old tuple
		 * with the redirect tuple.
		 */</comment>

		<comment type="block">/* Install new tuple first so redirect is valid */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>newPage</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* AddNode is not used for nulls pages */</comment>
			<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>innerTuple</name></expr></argument>,
							  <argument><expr><name><name>innerTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If parent is in this same page, update it now.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>parentBlk</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>parentTuple</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>parentTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
															 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>parentTuple</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
								  <argument><expr><name>blknoNew</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Delete old tuple, replacing it with redirect or placeholder tuple */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>dt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>isBuild</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dt</name> <operator>=</operator> <call><name>spgFormDeadTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
									  <argument><expr><name>InvalidBlockNumber</name></expr></argument>,
									  <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>dt</name> <operator>=</operator> <call><name>spgFormDeadTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>SPGIST_REDIRECT</name></expr></argument>,
									  <argument><expr><name>blknoNew</name></expr></argument>,
									  <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>dt</name></expr></argument>, <argument><expr><name><name>dt</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
							<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnum</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
					 <argument><expr><name><name>dt</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>isBuild</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nPlaceholder</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>nRedirection</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * If parent is in this same page, update it now.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>parentBlk</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>parentTuple</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>parentTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
															 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>parentTuple</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
								  <argument><expr><name>blknoNew</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Update parent downlink (if we didn't do it as part of the source or
		 * destination page update already).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>parentBlk</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>parentTuple</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>parentTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
															 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>parentTuple</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
								  <argument><expr><name>blknoNew</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumNew</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgRedoSplitTuple</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogSplitTuple</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogSplitTuple</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prefixTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistInnerTupleData</name></type> <name>prefixTupleHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>postfixTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistInnerTupleData</name></type> <name>postfixTupleHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>spgxlogSplitTuple</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>prefixTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<comment type="block">/* the prefix tuple is unaligned, so make a copy to access its header */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefixTupleHdr</name></expr></argument>, <argument><expr><name>prefixTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistInnerTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>prefixTupleHdr</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>postfixTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<comment type="block">/* postfix tuple is also unaligned */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>postfixTupleHdr</name></expr></argument>, <argument><expr><name>postfixTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistInnerTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In normal operation we would have both pages locked simultaneously; but
	 * in WAL replay it should be safe to update them one at a time, as long
	 * as we do it in the right order.
	 */</comment>

	<comment type="block">/* insert postfix tuple first to avoid dangling link */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>xldata</name><operator>-&gt;</operator><name>postfixBlkSame</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>newPage</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* SplitTuple is not used for nulls pages */</comment>
			<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>postfixTuple</name></expr></argument>,
							  <argument><expr><name><name>postfixTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumPostfix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* now handle the original page */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumPrefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>prefixTuple</name></expr></argument>, <argument><expr><name><name>prefixTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
						<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumPrefix</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offnumPrefix</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item of size %u to SPGiST index page"</literal></expr></argument>,
				 <argument><expr><name><name>prefixTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>postfixBlkSame</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>postfixTuple</name></expr></argument>,
							  <argument><expr><name><name>postfixTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
							  <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumPostfix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgRedoPickSplit</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogPickSplit</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogPickSplit</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>innerTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistInnerTupleData</name></type> <name>innerTupleHdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDelete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toInsert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>leafPageSelect</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>srcBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>destBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>innerBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>srcPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>destPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blknoInner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRedoAction</name></type> <name>action</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blknoInner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fillFakeState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>SizeOfSpgxlogPickSplit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toDelete</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nDelete</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toInsert</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nInsert</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>leafPageSelect</name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nInsert</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>innerTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
	<comment type="block">/* the inner tuple is unaligned, so make a copy to access its header */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>innerTupleHdr</name></expr></argument>, <argument><expr><name>innerTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistInnerTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>innerTupleHdr</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

	<comment type="block">/* now ptr points to the list of leaf tuples */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>isRootSplit</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* when splitting root, we touch it only in the guise of new inner */</comment>
		<expr_stmt><expr><name>srcBuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>srcPage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>initSrc</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* just re-init the source page */</comment>
		<expr_stmt><expr><name>srcBuffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>srcPage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>srcBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name>srcBuffer</name></expr></argument>,
						 <argument><expr><name>SPGIST_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>storesNulls</name></name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* don't update LSN etc till we're done with it */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Delete the specified tuples from source page.  (In case we're in
		 * Hot Standby, we need to hold lock on the page till we're done
		 * inserting leaf tuples and the new inner tuple, else the added
		 * redirect tuple will be a dangling link.)
		 */</comment>
		<expr_stmt><expr><name>srcPage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcBuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>srcPage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>srcBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We have it a bit easier here than in doPickSplit(), because we
			 * know the inner tuple's location already, so we can inject the
			 * correct redirection tuple now.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>.</operator><name>isBuild</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>srcPage</name></expr></argument>,
										<argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nDelete</name></name></expr></argument>,
										<argument><expr><name>SPGIST_REDIRECT</name></expr></argument>,
										<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
										<argument><expr><name>blknoInner</name></expr></argument>,
										<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumInner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>srcPage</name></expr></argument>,
										<argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nDelete</name></name></expr></argument>,
										<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
										<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
										<argument><expr><name>InvalidBlockNumber</name></expr></argument>,
										<argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* don't update LSN etc till we're done with it */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* try to access dest page if any */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>destBuffer</name> <operator>=</operator> <name>InvalidBuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>destPage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>initDest</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* just re-init the dest page */</comment>
		<expr_stmt><expr><name>destBuffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>destPage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>destBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name>destBuffer</name></expr></argument>,
						 <argument><expr><name>SPGIST_LEAF</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>storesNulls</name></name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* don't update LSN etc till we're done with it */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We could probably release the page lock immediately in the
		 * full-page-image case, but for safety let's hold it till later.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>destBuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>destPage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>destBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>destPage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* don't do any page updates */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* restore leaf tuples to src and/or dest page */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nInsert</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>leafTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SpGistLeafTupleData</name></type> <name>leafTupleHdr</name></decl>;</decl_stmt>

		<comment type="block">/* the tuples are not aligned, so must copy to access the size field. */</comment>
		<expr_stmt><expr><name>leafTuple</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leafTupleHdr</name></expr></argument>, <argument><expr><name>leafTuple</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SpGistLeafTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <ternary><condition><expr><name><name>leafPageSelect</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name>destPage</name></expr> </then><else>: <expr><name>srcPage</name></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* no need to touch this page */</comment>

		<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>leafTuple</name></expr></argument>, <argument><expr><name><name>leafTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
						  <argument><expr><name><name>toInsert</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Now update src and dest page LSNs if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>srcPage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>srcPage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>srcBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>srcBuffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>destPage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>destPage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>destBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>destBuffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* restore new inner tuple */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>initInner</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>innerBuffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpGistInitBuffer</name><argument_list>(<argument><expr><name>innerBuffer</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>xldata</name><operator>-&gt;</operator><name>storesNulls</name></name></expr> ?</condition><then> <expr><name>SPGIST_NULLS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <name>BLK_NEEDS_REDO</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>action</name> <operator>=</operator> <call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>innerBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>innerBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>addOrReplaceTuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>innerTuple</name></expr></argument>, <argument><expr><name><name>innerTupleHdr</name><operator>.</operator><name>size</name></name></expr></argument>,
						  <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumInner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if inner is also parent, update link while we're here */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>innerIsParent</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>parent</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>parent</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
													<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
							  <argument><expr><name>blknoInner</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumInner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>innerBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>innerBuffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>innerBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>innerBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now we can release the leaf-page locks.  It's okay to do this before
	 * updating the parent downlink.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>srcBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>srcBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>destBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>destBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* update parent downlink, unless we did it above */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogRecHasBlockRef</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>parentBuffer</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentBuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>parent</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>parentBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>parent</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
													<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumParent</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>spgUpdateNodeLink</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nodeI</name></name></expr></argument>,
							  <argument><expr><name>blknoInner</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>offnumInner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>parentBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>parentBuffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>parentBuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>parentBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>innerIsParent</name></name> <operator>||</operator> <name><name>xldata</name><operator>-&gt;</operator><name>isRootSplit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgRedoVacuumLeaf</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogVacuumLeaf</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogVacuumLeaf</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDead</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toPlaceholder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>moveSrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>moveDest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>chainSrc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>chainDest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fillFakeState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>SizeOfSpgxlogVacuumLeaf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toDead</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nDead</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>toPlaceholder</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nPlaceholder</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>moveSrc</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nMove</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>moveDest</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nMove</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>chainSrc</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nChain</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>chainDest</name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
								<argument><expr><name>toDead</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nDead</name></name></expr></argument>,
								<argument><expr><name>SPGIST_DEAD</name></expr></argument>, <argument><expr><name>SPGIST_DEAD</name></expr></argument>,
								<argument><expr><name>InvalidBlockNumber</name></expr></argument>,
								<argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
								<argument><expr><name>toPlaceholder</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nPlaceholder</name></name></expr></argument>,
								<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>, <argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
								<argument><expr><name>InvalidBlockNumber</name></expr></argument>,
								<argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* see comments in vacuumLeafPage() */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nMove</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>idSrc</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>moveSrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemId</name></type>		<name>idDest</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>moveDest</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemIdData</name></type>	<name>tmp</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>idSrc</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>idSrc</name> <operator>=</operator> <operator>*</operator><name>idDest</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>idDest</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
								<argument><expr><name>moveSrc</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nMove</name></name></expr></argument>,
								<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>, <argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
								<argument><expr><name>InvalidBlockNumber</name></expr></argument>,
								<argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nChain</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>lt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
											   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>chainSrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name><name>chainDest</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgRedoVacuumRoot</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogVacuumRoot</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogVacuumRoot</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDelete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>toDelete</name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offsets</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The tuple numbers are in order */</comment>
		<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>nDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgRedoVacuumRedirect</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogVacuumRedirect</name> <modifier>*</modifier></type><name>xldata</name> <init>= <expr><operator>(</operator><name>spgxlogVacuumRedirect</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>itemToPlaceholder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>itemToPlaceholder</name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>offsets</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If any redirection tuples are being removed, make sure there are no
	 * live Hot Standby transactions that might need to see them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>InHotStandby</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>newestRedirectXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RelFileNode</name></type> <name>node</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogRecGetBlockTag</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResolveRecoveryConflictWithSnapshot</name><argument_list>(<argument><expr><name><name>xldata</name><operator>-&gt;</operator><name>newestRedirectXid</name></name></expr></argument>,
												<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SpGistPageOpaque</name></type> <name>opaque</name> <init>= <expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Convert redirect pointers to plain placeholders */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nToPlaceholder</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>dt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>dt</name> <operator>=</operator> <operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
											   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>itemToPlaceholder</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_REDIRECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>=</operator> <name>SPGIST_PLACEHOLDER</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dt</name><operator>-&gt;</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>nRedirection</name></name> <operator>&gt;=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nToPlaceholder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>nRedirection</name></name> <operator>-=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nToPlaceholder</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name> <operator>+=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>nToPlaceholder</name></name></expr>;</expr_stmt>

		<comment type="block">/* Remove placeholder tuples at end of page */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>xldata</name><operator>-&gt;</operator><name>firstPlaceholder</name></name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>max</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>toDelete</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>toDelete</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>xldata</name><operator>-&gt;</operator><name>firstPlaceholder</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>toDelete</name><index>[<expr><name>i</name> <operator>-</operator> <name><name>xldata</name><operator>-&gt;</operator><name>firstPlaceholder</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>

			<expr_stmt><expr><name>i</name> <operator>=</operator> <name>max</name> <operator>-</operator> <name><name>xldata</name><operator>-&gt;</operator><name>firstPlaceholder</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name> <operator>&gt;=</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>

			<comment type="block">/* The array is sorted, so can use PageIndexMultiDelete */</comment>
			<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>toDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>spg_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>opCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_SPGIST_CREATE_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>spgRedoCreateIndex</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_SPGIST_ADD_LEAF</name></expr>:</case>
			<expr_stmt><expr><call><name>spgRedoAddLeaf</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_SPGIST_MOVE_LEAFS</name></expr>:</case>
			<expr_stmt><expr><call><name>spgRedoMoveLeafs</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_SPGIST_ADD_NODE</name></expr>:</case>
			<expr_stmt><expr><call><name>spgRedoAddNode</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_SPGIST_SPLIT_TUPLE</name></expr>:</case>
			<expr_stmt><expr><call><name>spgRedoSplitTuple</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_SPGIST_PICKSPLIT</name></expr>:</case>
			<expr_stmt><expr><call><name>spgRedoPickSplit</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_SPGIST_VACUUM_LEAF</name></expr>:</case>
			<expr_stmt><expr><call><name>spgRedoVacuumLeaf</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_SPGIST_VACUUM_ROOT</name></expr>:</case>
			<expr_stmt><expr><call><name>spgRedoVacuumRoot</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_SPGIST_VACUUM_REDIRECT</name></expr>:</case>
			<expr_stmt><expr><call><name>spgRedoVacuumRedirect</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"spg_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>opCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>spg_xlog_startup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>opCtx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"SP-GiST temporary context"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>spg_xlog_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>opCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opCtx</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Mask a SpGist page before performing consistency checks on it.
 */</comment>
<function><type><name>void</name></type>
<name>spg_mask</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pagedata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <name>pagedata</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>pagehdr</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>mask_page_lsn_and_checksum</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mask_page_hint_bits</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mask the unused space, but only if the page's pd_lower appears to have
	 * been set correctly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pagehdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&gt;=</operator> <name>SizeOfPageHeaderData</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>mask_unused_space</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
