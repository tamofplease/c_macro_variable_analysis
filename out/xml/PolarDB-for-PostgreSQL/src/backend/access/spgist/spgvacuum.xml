<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/spgist/spgvacuum.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * spgvacuum.c
 *	  vacuum for SP-GiST
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			src/backend/access/spgist/spgvacuum.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/spgxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/indexfsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR csn */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/* Entry in pending-list of TIDs we need to revisit */</comment>
<typedef>typedef <type><struct>struct <name>spgVacPendingItem</name>
<block>{
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tid</name></decl>;</decl_stmt>		<comment type="block">/* redirection target to visit */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>done</name></decl>;</decl_stmt>			<comment type="block">/* have we dealt with this? */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>spgVacPendingItem</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt> <comment type="block">/* list link */</comment>
}</block></struct></type> <name>spgVacPendingItem</name>;</typedef>

<comment type="block">/* Local state for vacuum operations */</comment>
<typedef>typedef <type><struct>struct <name>spgBulkDeleteState</name>
<block>{
	<comment type="block">/* Parameters passed in to spgvacuumscan */</comment>
	<decl_stmt><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>callback_state</name></decl>;</decl_stmt>

	<comment type="block">/* Additional working state */</comment>
	<decl_stmt><decl><type><name>SpGistState</name></type> <name>spgstate</name></decl>;</decl_stmt>		<comment type="block">/* for SPGiST operations that need one */</comment>
	<decl_stmt><decl><type><name>spgVacPendingItem</name> <modifier>*</modifier></type><name>pendingList</name></decl>;</decl_stmt> <comment type="block">/* TIDs we need to (re)visit */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>myXmin</name></decl>;</decl_stmt>		<comment type="block">/* for detecting newly-added redirects */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lastFilledBlock</name></decl>;</decl_stmt>	<comment type="block">/* last non-deletable block */</comment>
}</block></struct></type> <name>spgBulkDeleteState</name>;</typedef>


<comment type="block">/*
 * Add TID to pendingList, but only if not already present.
 *
 * Note that new items are always appended at the end of the list; this
 * ensures that scans of the list don't miss items added during the scan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgAddPendingTID</name><parameter_list>(<parameter><decl><type><name>spgBulkDeleteState</name> <modifier>*</modifier></type><name>bds</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>spgVacPendingItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgVacPendingItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>listLink</name></decl>;</decl_stmt>

	<comment type="block">/* search the list for pre-existing entry */</comment>
	<expr_stmt><expr><name>listLink</name> <operator>=</operator> <operator>&amp;</operator><name><name>bds</name><operator>-&gt;</operator><name>pendingList</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>listLink</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pitem</name> <operator>=</operator> <operator>*</operator><name>listLink</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ItemPointerEquals</name><argument_list>(<argument><expr><name>tid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pitem</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>				<comment type="block">/* already in list, do nothing */</comment>
		<expr_stmt><expr><name>listLink</name> <operator>=</operator> <operator>&amp;</operator><name><name>pitem</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<comment type="block">/* not there, so append new entry */</comment>
	<expr_stmt><expr><name>pitem</name> <operator>=</operator> <operator>(</operator><name>spgVacPendingItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>spgVacPendingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>tid</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>listLink</name> <operator>=</operator> <name>pitem</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clear pendingList
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgClearPendingList</name><parameter_list>(<parameter><decl><type><name>spgBulkDeleteState</name> <modifier>*</modifier></type><name>bds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>spgVacPendingItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgVacPendingItem</name> <modifier>*</modifier></type><name>nitem</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>pitem</name> <operator>=</operator> <name><name>bds</name><operator>-&gt;</operator><name>pendingList</name></name></expr>;</init> <condition><expr><name>pitem</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pitem</name> <operator>=</operator> <name>nitem</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>nitem</name> <operator>=</operator> <name><name>pitem</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<comment type="block">/* All items in list should have been dealt with */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>pendingList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Vacuum a regular (non-root) leaf page
 *
 * We must delete tuples that are targeted for deletion by the VACUUM,
 * but not move any tuples that are referenced by outside links; we assume
 * those are the ones that are heads of chains.
 *
 * If we find a REDIRECT that was made by a concurrently-running transaction,
 * we must add its target TID to pendingList.  (We don't try to visit the
 * target immediately, first because we don't want VACUUM locking more than
 * one buffer at a time, and second because the duplicate-filtering logic
 * in spgAddPendingTID is useful to ensure we can't get caught in an infinite
 * loop in the face of continuous concurrent insertions.)
 *
 * If forPending is true, we are examining the page as a consequence of
 * chasing a redirect link, not as part of the normal sequential scan.
 * We still vacuum the page normally, but we don't increment the stats
 * about live tuples; else we'd double-count those tuples, since the page
 * has been or will be visited in the sequential scan as well.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vacuumLeafPage</name><parameter_list>(<parameter><decl><type><name>spgBulkDeleteState</name> <modifier>*</modifier></type><name>bds</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>forPending</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogVacuumLeaf</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>toDead</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>toPlaceholder</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>moveSrc</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>moveDest</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>chainSrc</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>chainDest</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>predecessor</name><index>[<expr><name>MaxIndexTuplesPerPage</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>deletable</name><index>[<expr><name>MaxIndexTuplesPerPage</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nDeletable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>max</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>predecessor</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>predecessor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>deletable</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>deletable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nDeletable</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Scan page, identify tuples to delete, accumulate stats */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>lt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
										   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lt</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name><name>bds</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lt</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>, <argument><expr><name><name>bds</name><operator>-&gt;</operator><name>callback_state</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>tuples_removed</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>deletable</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nDeletable</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>forPending</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Form predecessor map, too */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* paranoia about corrupted chain links */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>&lt;</operator> <name>FirstOffsetNumber</name> <operator>||</operator>
					<name><name>lt</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>&gt;</operator> <name>max</name> <operator>||</operator>
					<name><name>predecessor</name><index>[<expr><name><name>lt</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>]</index></name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inconsistent tuple chain links in page %u of index \"%s\""</literal></expr></argument>,
						 <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>predecessor</name><index>[<expr><name><name>lt</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_REDIRECT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>dt</name> <init>= <expr><operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <name>lt</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dt</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dt</name><operator>-&gt;</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Add target TID to pending list if the redirection could have
			 * happened since VACUUM started.
			 *
			 * Note: we could make a tighter test by seeing if the xid is
			 * "running" according to the active snapshot; but tqual.c doesn't
			 * currently export a suitable API, and it's not entirely clear
			 * that a tighter test is worth the cycles anyway.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollowsOrEquals</name><argument_list>(<argument><expr><name><name>dt</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name><name>bds</name><operator>-&gt;</operator><name>myXmin</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>spgAddPendingTID</name><argument_list>(<argument><expr><name>bds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dt</name><operator>-&gt;</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>nDeletable</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing more to do */</comment>

	<comment type="block">/*----------
	 * Figure out exactly what we have to do.  We do this separately from
	 * actually modifying the page, mainly so that we have a representation
	 * that can be dumped into WAL and then the replay code can do exactly
	 * the same thing.  The output of this step consists of six arrays
	 * describing four kinds of operations, to be performed in this order:
	 *
	 * toDead[]: tuple numbers to be replaced with DEAD tuples
	 * toPlaceholder[]: tuple numbers to be replaced with PLACEHOLDER tuples
	 * moveSrc[]: tuple numbers that need to be relocated to another offset
	 * (replacing the tuple there) and then replaced with PLACEHOLDER tuples
	 * moveDest[]: new locations for moveSrc tuples
	 * chainSrc[]: tuple numbers whose chain links (nextOffset) need updates
	 * chainDest[]: new values of nextOffset for chainSrc members
	 *
	 * It's easiest to figure out what we have to do by processing tuple
	 * chains, so we iterate over all the tuples (not just the deletable
	 * ones!) to identify chain heads, then chase down each chain and make
	 * work item entries for deletable tuples within the chain.
	 *----------
	 */</comment>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nDead</name></name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>nPlaceholder</name></name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>nMove</name></name> <operator>=</operator> <name><name>xlrec</name><operator>.</operator><name>nChain</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>head</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>interveningDeletable</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>prevLive</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>head</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
											 <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>head</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>!=</operator> <name>SPGIST_LIVE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* can't be a chain member */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>predecessor</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* not a chain head */</comment>

		<comment type="block">/* initialize ... */</comment>
		<expr_stmt><expr><name>interveningDeletable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prevLive</name> <operator>=</operator> <ternary><condition><expr><name><name>deletable</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name>InvalidOffsetNumber</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/* scan down the chain ... */</comment>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>j</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>lt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
											   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>!=</operator> <name>SPGIST_LIVE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* all tuples in chain should be live */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>,
					 <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>deletable</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* This tuple should be replaced by a placeholder */</comment>
				<expr_stmt><expr><name><name>toPlaceholder</name><index>[<expr><name><name>xlrec</name><operator>.</operator><name>nPlaceholder</name></name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nPlaceholder</name></name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* previous live tuple's chain link will need an update */</comment>
				<expr_stmt><expr><name>interveningDeletable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>prevLive</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This is the first live tuple in the chain.  It has to move
				 * to the head position.
				 */</comment>
				<expr_stmt><expr><name><name>moveSrc</name><index>[<expr><name><name>xlrec</name><operator>.</operator><name>nMove</name></name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>moveDest</name><index>[<expr><name><name>xlrec</name><operator>.</operator><name>nMove</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nMove</name></name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* Chain updates will be applied after the move */</comment>
				<expr_stmt><expr><name>prevLive</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>interveningDeletable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Second or later live tuple.  Arrange to re-chain it to the
				 * previous live one, if there was a gap.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>interveningDeletable</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>chainSrc</name><index>[<expr><name><name>xlrec</name><operator>.</operator><name>nChain</name></name></expr>]</index></name> <operator>=</operator> <name>prevLive</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>chainDest</name><index>[<expr><name><name>xlrec</name><operator>.</operator><name>nChain</name></name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nChain</name></name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>prevLive</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>interveningDeletable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>nextOffset</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>prevLive</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* The chain is entirely removable, so we need a DEAD tuple */</comment>
			<expr_stmt><expr><name><name>toDead</name><index>[<expr><name><name>xlrec</name><operator>.</operator><name>nDead</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nDead</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>interveningDeletable</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* One or more deletions at end of chain, so close it off */</comment>
			<expr_stmt><expr><name><name>chainSrc</name><index>[<expr><name><name>xlrec</name><operator>.</operator><name>nChain</name></name></expr>]</index></name> <operator>=</operator> <name>prevLive</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chainDest</name><index>[<expr><name><name>xlrec</name><operator>.</operator><name>nChain</name></name></expr>]</index></name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nChain</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* sanity check ... */</comment>
	<if_stmt><if>if <condition>(<expr><name>nDeletable</name> <operator>!=</operator> <name><name>xlrec</name><operator>.</operator><name>nDead</name></name> <operator>+</operator> <name><name>xlrec</name><operator>.</operator><name>nPlaceholder</name></name> <operator>+</operator> <name><name>xlrec</name><operator>.</operator><name>nMove</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inconsistent counts of deletable tuples"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Do the updates */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bds</name><operator>-&gt;</operator><name>spgstate</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
							<argument><expr><name>toDead</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>nDead</name></name></expr></argument>,
							<argument><expr><name>SPGIST_DEAD</name></expr></argument>, <argument><expr><name>SPGIST_DEAD</name></expr></argument>,
							<argument><expr><name>InvalidBlockNumber</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bds</name><operator>-&gt;</operator><name>spgstate</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
							<argument><expr><name>toPlaceholder</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>nPlaceholder</name></name></expr></argument>,
							<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>, <argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
							<argument><expr><name>InvalidBlockNumber</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We implement the move step by swapping the item pointers of the source
	 * and target tuples, then replacing the newly-source tuples with
	 * placeholders.  This is perhaps unduly friendly with the page data
	 * representation, but it's fast and doesn't risk page overflow when a
	 * tuple to be relocated is large.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>.</operator><name>nMove</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>idSrc</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>moveSrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>idDest</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>moveDest</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemIdData</name></type>	<name>tmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>idSrc</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>idSrc</name> <operator>=</operator> <operator>*</operator><name>idDest</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>idDest</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>spgPageIndexMultiDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bds</name><operator>-&gt;</operator><name>spgstate</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
							<argument><expr><name>moveSrc</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>nMove</name></name></expr></argument>,
							<argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>, <argument><expr><name>SPGIST_PLACEHOLDER</name></expr></argument>,
							<argument><expr><name>InvalidBlockNumber</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xlrec</name><operator>.</operator><name>nChain</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>lt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
										   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>chainSrc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextOffset</name></name> <operator>=</operator> <name><name>chainDest</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>STORE_STATE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bds</name><operator>-&gt;</operator><name>spgstate</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfSpgxlogVacuumLeaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* sizeof(xlrec) should be a multiple of sizeof(OffsetNumber) */</comment>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>toDead</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xlrec</name><operator>.</operator><name>nDead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>toPlaceholder</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xlrec</name><operator>.</operator><name>nPlaceholder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>moveSrc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xlrec</name><operator>.</operator><name>nMove</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>moveDest</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xlrec</name><operator>.</operator><name>nMove</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>chainSrc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xlrec</name><operator>.</operator><name>nChain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>chainDest</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xlrec</name><operator>.</operator><name>nChain</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_SPGIST_ID</name></expr></argument>, <argument><expr><name>XLOG_SPGIST_VACUUM_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Vacuum a root page when it is also a leaf
 *
 * On the root, we just delete any dead leaf tuples; no fancy business
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vacuumLeafRoot</name><parameter_list>(<parameter><decl><type><name>spgBulkDeleteState</name> <modifier>*</modifier></type><name>bds</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogVacuumRoot</name></type> <name>xlrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>toDelete</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>max</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nDelete</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Scan page, identify tuples to delete, accumulate stats */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistLeafTuple</name></type> <name>lt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>(</operator><name>SpGistLeafTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
										   <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lt</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name><name>bds</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lt</name><operator>-&gt;</operator><name>heapPtr</name></name></expr></argument>, <argument><expr><name><name>bds</name><operator>-&gt;</operator><name>callback_state</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>tuples_removed</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>toDelete</name><index>[<expr><name><name>xlrec</name><operator>.</operator><name>nDelete</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nDelete</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* all tuples on root should be live */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>,
				 <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>xlrec</name><operator>.</operator><name>nDelete</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing more to do */</comment>

	<comment type="block">/* Do the update */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The tuple numbers are in order, so we can use PageIndexMultiDelete */</comment>
	<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>toDelete</name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>nDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Prepare WAL record */</comment>
		<expr_stmt><expr><call><name>STORE_STATE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bds</name><operator>-&gt;</operator><name>spgstate</name></name></expr></argument>, <argument><expr><name><name>xlrec</name><operator>.</operator><name>stateSrc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfSpgxlogVacuumRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* sizeof(xlrec) should be a multiple of sizeof(OffsetNumber) */</comment>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>toDelete</name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xlrec</name><operator>.</operator><name>nDelete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_SPGIST_ID</name></expr></argument>, <argument><expr><name>XLOG_SPGIST_VACUUM_ROOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clean up redirect and placeholder tuples on the given page
 *
 * Redirect tuples can be marked placeholder once they're old enough.
 * Placeholder tuples can be removed if it won't change the offsets of
 * non-placeholder ones.
 *
 * Unlike the routines above, this works on both leaf and inner pages.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vacuumRedirectAndPlaceholder</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpGistPageOpaque</name></type> <name>opaque</name> <init>= <expr><call><name>SpGistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>max</name> <init>= <expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>firstPlaceholder</name> <init>= <expr><name>InvalidOffsetNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasNonPlaceholder</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasUpdate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>itemToPlaceholder</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>itemnos</name><index>[<expr><name>MaxIndexTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgxlogVacuumRedirect</name></type> <name>xlrec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nToPlaceholder</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>newestRedirectXid</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan backwards to convert old redirection tuples to placeholder tuples,
	 * and identify location of last non-placeholder tuple while at it.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>max</name></expr>;</init>
		 <condition><expr><name>i</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator>
		 <operator>(</operator><name><name>opaque</name><operator>-&gt;</operator><name>nRedirection</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>hasNonPlaceholder</name><operator>)</operator></expr>;</condition>
		 <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SpGistDeadTuple</name></type> <name>dt</name></decl>;</decl_stmt>
		<comment type="block">/* POLAR csn */</comment>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>tmpRecentGlobalXmin</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dt</name> <operator>=</operator> <operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* POLAR csn: get newest global xmin */</comment>
		<expr_stmt><expr><name>tmpRecentGlobalXmin</name> <operator>=</operator> <call><name>GetRecentGlobalXmin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_REDIRECT</name> <operator>&amp;&amp;</operator>
			<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>dt</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>, <argument><expr><name>tmpRecentGlobalXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>=</operator> <name>SPGIST_PLACEHOLDER</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>nRedirection</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>nRedirection</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* remember newest XID among the removed redirects */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>newestRedirectXid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>xlrec</name><operator>.</operator><name>newestRedirectXid</name></name></expr></argument>, <argument><expr><name><name>dt</name><operator>-&gt;</operator><name>xid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>newestRedirectXid</name></name> <operator>=</operator> <name><name>dt</name><operator>-&gt;</operator><name>xid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dt</name><operator>-&gt;</operator><name>pointer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>itemToPlaceholder</name><index>[<expr><name><name>xlrec</name><operator>.</operator><name>nToPlaceholder</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>nToPlaceholder</name></name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>hasUpdate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>dt</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_PLACEHOLDER</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasNonPlaceholder</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>firstPlaceholder</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>hasNonPlaceholder</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Any placeholder tuples at the end of page can safely be removed.  We
	 * can't remove ones before the last non-placeholder, though, because we
	 * can't alter the offset numbers of non-placeholder tuples.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>firstPlaceholder</name> <operator>!=</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We do not store this array to rdata because it's easy to recreate.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>firstPlaceholder</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>itemnos</name><index>[<expr><name>i</name> <operator>-</operator> <name>firstPlaceholder</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>max</name> <operator>-</operator> <name>firstPlaceholder</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name> <operator>&gt;=</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>opaque</name><operator>-&gt;</operator><name>nPlaceholder</name></name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>

		<comment type="block">/* The array is surely sorted, so can use PageIndexMultiDelete */</comment>
		<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>itemnos</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>hasUpdate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>firstPlaceholder</name></name> <operator>=</operator> <name>firstPlaceholder</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasUpdate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasUpdate</name> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfSpgxlogVacuumRedirect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>itemToPlaceholder</name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>xlrec</name><operator>.</operator><name>nToPlaceholder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_SPGIST_ID</name></expr></argument>, <argument><expr><name>XLOG_SPGIST_VACUUM_REDIRECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process one page during a bulkdelete scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgvacuumpage</name><parameter_list>(<parameter><decl><type><name>spgBulkDeleteState</name> <modifier>*</modifier></type><name>bds</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>index</name> <init>= <expr><name><name>bds</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

	<comment type="block">/* call vacuum_delay_point while not holding any buffer lock */</comment>
	<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
								<argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name><name>bds</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We found an all-zero page, which could happen if the database
		 * crashed just after extending the file.  Recycle it.
		 */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>SpGistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>vacuumLeafRoot</name><argument_list>(<argument><expr><name>bds</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* no need for vacuumRedirectAndPlaceholder */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>vacuumLeafPage</name><argument_list>(<argument><expr><name>bds</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>vacuumRedirectAndPlaceholder</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* inner page */</comment>
		<expr_stmt><expr><call><name>vacuumRedirectAndPlaceholder</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The root pages must never be deleted, nor marked as available in FSM,
	 * because we don't want them ever returned by a search for a place to put
	 * a new tuple.  Otherwise, check for empty page, and make sure the FSM
	 * knows about it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RecordFreeIndexPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>pages_deleted</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpGistSetLastUsedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>lastFilledBlock</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process the pending-TID list between pages of the main scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgprocesspending</name><parameter_list>(<parameter><decl><type><name>spgBulkDeleteState</name> <modifier>*</modifier></type><name>bds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>index</name> <init>= <expr><name><name>bds</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgVacPendingItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>spgVacPendingItem</name> <modifier>*</modifier></type><name>nitem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>pitem</name> <operator>=</operator> <name><name>bds</name><operator>-&gt;</operator><name>pendingList</name></name></expr>;</init> <condition><expr><name>pitem</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pitem</name> <operator>=</operator> <name><name>pitem</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pitem</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore already-done items */</comment>

		<comment type="block">/* call vacuum_delay_point while not holding any buffer lock */</comment>
		<expr_stmt><expr><call><name>vacuum_delay_point</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* examine the referenced page */</comment>
		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pitem</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBufferExtended</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
									<argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name><name>bds</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SpGistPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Probably shouldn't happen, but ignore it */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>SpGistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>SpGistBlockIsRoot</name><argument_list>(<argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* this should definitely not happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"redirection leads to root page of index \"%s\""</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* deal with any deletable tuples */</comment>
			<expr_stmt><expr><call><name>vacuumLeafPage</name><argument_list>(<argument><expr><name>bds</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* might as well do this while we are here */</comment>
			<expr_stmt><expr><call><name>vacuumRedirectAndPlaceholder</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SpGistSetLastUsedPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We can mark as done not only this item, but any later ones
			 * pointing at the same page, since we vacuumed the whole page.
			 */</comment>
			<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>nitem</name> <operator>=</operator> <name><name>pitem</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>nitem</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>nitem</name> <operator>=</operator> <name><name>nitem</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nitem</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>nitem</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * On an inner page, visit the referenced inner tuple and add all
			 * its downlinks to the pending list.  We might have pending items
			 * for more than one inner tuple on the same page (in fact this is
			 * pretty likely given the way space allocation works), so get
			 * them all while we are here.
			 */</comment>
			<for>for <control>(<init><expr><name>nitem</name> <operator>=</operator> <name>pitem</name></expr>;</init> <condition><expr><name>nitem</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>nitem</name> <operator>=</operator> <name><name>nitem</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>nitem</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nitem</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>blkno</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>SpGistInnerTuple</name></type> <name>innerTuple</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nitem</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>innerTuple</name> <operator>=</operator> <operator>(</operator><name>SpGistInnerTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
																<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>innerTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_LIVE</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>SpGistNodeTuple</name></type> <name>node</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

						<macro><name>SGITITERATE</name><argument_list>(<argument>innerTuple</argument>, <argument>i</argument>, <argument>node</argument>)</argument_list></macro>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>spgAddPendingTID</name><argument_list>(<argument><expr><name>bds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>innerTuple</name><operator>-&gt;</operator><name>tupstate</name></name> <operator>==</operator> <name>SPGIST_REDIRECT</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* transfer attention to redirect point */</comment>
						<expr_stmt><expr><call><name>spgAddPendingTID</name><argument_list>(<argument><expr><name>bds</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>SpGistDeadTuple</name><operator>)</operator> <name>innerTuple</name><operator>)</operator><operator>-&gt;</operator><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SPGiST tuple state: %d"</literal></expr></argument>,
							 <argument><expr><name><name>innerTuple</name><operator>-&gt;</operator><name>tupstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<expr_stmt><expr><name><name>nitem</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>spgClearPendingList</name><argument_list>(<argument><expr><name>bds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform a bulkdelete scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>spgvacuumscan</name><parameter_list>(<parameter><decl><type><name>spgBulkDeleteState</name> <modifier>*</modifier></type><name>bds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>index</name> <init>= <expr><name><name>bds</name><operator>-&gt;</operator><name>info</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>num_pages</name></decl>,
				<decl><type ref="prev"/><name>blkno</name></decl>;</decl_stmt>

	<comment type="block">/* Finish setting up spgBulkDeleteState */</comment>
	<expr_stmt><expr><call><name>initSpGistState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bds</name><operator>-&gt;</operator><name>spgstate</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>pendingList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>myXmin</name></name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>xmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>lastFilledBlock</name></name> <operator>=</operator> <name>SPGIST_LAST_FIXED_BLKNO</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset counts that will be incremented during the scan; needed in case
	 * of multiple scans during a single VACUUM command
	 */</comment>
	<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>estimated_count</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>pages_deleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* We can skip locking for new or temp relations */</comment>
	<expr_stmt><expr><name>needLock</name> <operator>=</operator> <operator>!</operator><call><name>RELATION_IS_LOCAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The outer loop iterates over all index pages except the metapage, in
	 * physical order (we hope the kernel will cooperate in providing
	 * read-ahead for speed).  It is critical that we visit all leaf pages,
	 * including ones added after we start the scan, else we might fail to
	 * delete some deletable tuples.  See more extensive comments about this
	 * in btvacuumscan().
	 */</comment>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name>SPGIST_METAPAGE_BLKNO</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Get the current relation length */</comment>
		<if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>num_pages</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Quit if we've scanned the whole relation */</comment>
		<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>&gt;=</operator> <name>num_pages</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<comment type="block">/* Iterate over pages, then loop back to recheck length */</comment>
		<for>for <control>(<init>;</init> <condition><expr><name>blkno</name> <operator>&lt;</operator> <name>num_pages</name></expr>;</condition> <incr><expr><name>blkno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>spgvacuumpage</name><argument_list>(<argument><expr><name>bds</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* empty the pending-list after each page */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>bds</name><operator>-&gt;</operator><name>pendingList</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>spgprocesspending</name><argument_list>(<argument><expr><name>bds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/* Propagate local lastUsedPage cache to metablock */</comment>
	<expr_stmt><expr><call><name>SpGistUpdateMetaPage</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we found any empty pages (and recorded them in the FSM), then
	 * forcibly update the upper-level FSM pages to ensure that searchers can
	 * find them.  It's possible that the pages were also found during
	 * previous scans and so this is a waste of time, but it's cheap enough
	 * relative to scanning the index that it shouldn't matter much, and
	 * making sure that free pages are available sooner not later seems
	 * worthwhile.
	 *
	 * Note that if no empty pages exist, we don't bother vacuuming the FSM at
	 * all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>pages_deleted</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>IndexFreeSpaceMapVacuum</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Truncate index if possible
	 *
	 * XXX disabled because it's unsafe due to possible concurrent inserts.
	 * We'd have to rescan the pages to make sure they're still empty, and it
	 * doesn't seem worth it.  Note that btree doesn't do this either.
	 *
	 * Another reason not to truncate is that it could invalidate the cached
	 * pages-with-freespace pointers in the metapage and other backends'
	 * relation caches, that is leave them pointing to nonexistent pages.
	 * Adding RelationGetNumberOfBlocks calls to protect the places that use
	 * those pointers would be unduly expensive.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>num_pages</name> <operator>&gt;</operator> <name><name>bds</name><operator>-&gt;</operator><name>lastFilledBlock</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lastBlock</name> <init>= <expr><name>num_pages</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>num_pages</name> <operator>=</operator> <name><name>bds</name><operator>-&gt;</operator><name>lastFilledBlock</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationTruncate</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>num_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>pages_removed</name></name> <operator>+=</operator> <name>lastBlock</name> <operator>-</operator> <name><name>bds</name><operator>-&gt;</operator><name>lastFilledBlock</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>pages_deleted</name></name> <operator>-=</operator> <name>lastBlock</name> <operator>-</operator> <name><name>bds</name><operator>-&gt;</operator><name>lastFilledBlock</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Report final stats */</comment>
	<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>num_pages</name></name> <operator>=</operator> <name>num_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>pages_free</name></name> <operator>=</operator> <name><name>bds</name><operator>-&gt;</operator><name>stats</name><operator>-&gt;</operator><name>pages_deleted</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Bulk deletion of all index entries pointing to a set of heap tuples.
 * The set of target tuples is specified via a callback routine that tells
 * whether any given heap tuple (identified by ItemPointer) is being deleted.
 *
 * Result: a palloc'd struct containing statistical info for VACUUM displays.
 */</comment>
<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>spgbulkdelete</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>,
			  <parameter><decl><type><name>IndexBulkDeleteCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>spgBulkDeleteState</name></type> <name>bds</name></decl>;</decl_stmt>

	<comment type="block">/* allocate stats if first time through, else re-use existing struct */</comment>
	<if_stmt><if>if <condition>(<expr><name>stats</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>IndexBulkDeleteResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>stats</name></name> <operator>=</operator> <name>stats</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>callback_state</name></name> <operator>=</operator> <name>callback_state</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>spgvacuumscan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Dummy callback to delete no tuples during spgvacuumcleanup */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dummy_callback</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Post-VACUUM cleanup.
 *
 * Result: a palloc'd struct containing statistical info for VACUUM displays.
 */</comment>
<function><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type>
<name>spgvacuumcleanup</name><parameter_list>(<parameter><decl><type><name>IndexVacuumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>IndexBulkDeleteResult</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>spgBulkDeleteState</name></type> <name>bds</name></decl>;</decl_stmt>

	<comment type="block">/* No-op in ANALYZE ONLY mode */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>analyze_only</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>stats</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't need to scan the index if there was a preceding bulkdelete
	 * pass.  Otherwise, make a pass that won't delete any live tuples, but
	 * might still accomplish useful stuff with redirect/placeholder cleanup
	 * and/or FSM housekeeping, and in any case will provide stats.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stats</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>IndexBulkDeleteResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBulkDeleteResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>stats</name></name> <operator>=</operator> <name>stats</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>dummy_callback</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bds</name><operator>.</operator><name>callback_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>spgvacuumscan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It's quite possible for us to be fooled by concurrent tuple moves into
	 * double-counting some index tuples, so disbelieve any total that exceeds
	 * the underlying heap's count ... if we know that accurately.  Otherwise
	 * this might just make matters worse.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>info</name><operator>-&gt;</operator><name>estimated_count</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name> <operator>&gt;</operator> <name><name>info</name><operator>-&gt;</operator><name>num_heap_tuples</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>num_index_tuples</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>num_heap_tuples</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>
</unit>
