<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/gin/ginxlog.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ginxlog.c
 *	  WAL replay logic for inverted index.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			 src/backend/access/gin/ginxlog.c
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bufmask.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/ginxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlogutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>opCtx</name></decl>;</decl_stmt>		<comment type="block">/* working memory for operations */</comment>

<function><type><name>void</name></type>
<name>ginRedoClearIncompleteSplit</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>block_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>block_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>GIN_INCOMPLETE_SPLIT</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginRedoCreateIndex</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>RootBuffer</name></decl>,
				<decl><type ref="prev"/><name>MetaBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>MetaBuffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GIN_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GinInitMetabuffer</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>RootBuffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GIN_ROOT_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GinInitBuffer</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>, <argument><expr><name>GIN_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>RootBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>MetaBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginRedoCreatePTree</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ginxlogCreatePostingTree</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ginxlogCreatePostingTree</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GinInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_DATA</name> <operator>|</operator> <name>GIN_LEAF</name> <operator>|</operator> <name>GIN_COMPRESSED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogCreatePostingTree</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Place page data */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GinDataPageSetDataSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ginRedoInsertEntry</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isLeaf</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>rightblkno</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>rdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ginxlogInsertEntry</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ginxlogInsertEntry</name> <operator>*</operator><operator>)</operator> <name>rdata</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rightblkno</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* update link to right page after split */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinSetDownlink</name><argument_list>(<argument><expr><name>itup</name></expr></argument>, <argument><expr><name>rightblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>isDelete</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageIndexTupleDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelFileNode</name></type> <name>node</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ForkNumber</name></type>	<name>forknum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blknum</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>BufferGetTag</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>forknum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to index page in %u/%u/%u"</literal></expr></argument>,
			 <argument><expr><name><name>node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Redo recompression of posting list.  Doing all the changes in-place is not
 * always possible, because it might require more space than we've on the page.
 * Instead, once modification is required we copy unprocessed tail of the page
 * into separately allocated chunk of memory for further reading original
 * versions of segments.  Thanks to that we don't bother about moving page data
 * in-place.
 */</comment>
<function><type><name>void</name></type>
<name>ginRedoRecompress</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>ginxlogRecompressDataLeaf</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>actionno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>oldseg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>segmentend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>walbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>tailCopy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>writePtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>segptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the page is in pre-9.4 format, convert to new format first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GinPageIsCompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>uncompressed</name> <init>= <expr><operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>GinDataPageGetData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nuncompressed</name> <init>= <expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>npacked</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Empty leaf pages are deleted as part of vacuum, but leftmost and
		 * rightmost pages are never deleted.  So, pg_upgrade'd from pre-9.4
		 * instances might contain empty leaf pages, and we need to handle
		 * them correctly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nuncompressed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>plist</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>plist</name> <operator>=</operator> <call><name>ginCompressPostingList</name><argument_list>(<argument><expr><name>uncompressed</name></expr></argument>, <argument><expr><name>nuncompressed</name></expr></argument>,
										   <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>npacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>totalsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name>plist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npacked</name> <operator>==</operator> <name>nuncompressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>plist</name></expr></argument>, <argument><expr><name>totalsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>totalsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>GinDataPageSetDataSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>totalsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinPageSetCompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>oldseg</name> <operator>=</operator> <call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>writePtr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>oldseg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>segmentend</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>oldseg</name> <operator>+</operator> <call><name>GinDataLeafPageGetPostingListSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>segno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>walbuf</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>data</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogRecompressDataLeaf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>actionno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>actionno</name> <operator>&lt;</operator> <name><name>data</name><operator>-&gt;</operator><name>nactions</name></name></expr>;</condition> <incr><expr><name>actionno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>a_segno</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>walbuf</name><operator>++</operator><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>a_action</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>walbuf</name><operator>++</operator><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>newseg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>newsegsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>items</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16</name></type>		<name>nitems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>olditems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nolditems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>newitems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewitems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>segsize</name></decl>;</decl_stmt>

		<comment type="block">/* Extract all the information we need from the WAL record */</comment>
		<if_stmt><if>if <condition>(<expr><name>a_action</name> <operator>==</operator> <name>GIN_SEGMENT_INSERT</name> <operator>||</operator>
			<name>a_action</name> <operator>==</operator> <name>GIN_SEGMENT_REPLACE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newseg</name> <operator>=</operator> <operator>(</operator><name>GinPostingList</name> <operator>*</operator><operator>)</operator> <name>walbuf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newsegsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name>newseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>walbuf</name> <operator>+=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>newsegsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>a_action</name> <operator>==</operator> <name>GIN_SEGMENT_ADDITEMS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>, <argument><expr><name>walbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>walbuf</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>items</name> <operator>=</operator> <operator>(</operator><name>ItemPointerData</name> <operator>*</operator><operator>)</operator> <name>walbuf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>walbuf</name> <operator>+=</operator> <name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Skip to the segment that this action concerns */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segno</name> <operator>&lt;=</operator> <name>a_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>segno</name> <operator>&lt;</operator> <name>a_segno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Once modification is started and page tail is copied, we've
			 * to copy unmodified segments.
			 */</comment>
			<expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name>oldseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tailCopy</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>writePtr</name> <operator>+</operator> <name>segsize</name> <operator>&lt;</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>writePtr</name></expr></argument>, <argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>oldseg</name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>writePtr</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldseg</name> <operator>=</operator> <call><name>GinNextPostingListSegment</name><argument_list>(<argument><expr><name>oldseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>segno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * ADDITEMS action is handled like REPLACE, but the new segment to
		 * replace the old one is reconstructed using the old segment from
		 * disk and the new items from the WAL record.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>a_action</name> <operator>==</operator> <name>GIN_SEGMENT_ADDITEMS</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>npacked</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>olditems</name> <operator>=</operator> <call><name>ginPostingListDecode</name><argument_list>(<argument><expr><name>oldseg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nolditems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newitems</name> <operator>=</operator> <call><name>ginMergeItemPointers</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>,
											<argument><expr><name>olditems</name></expr></argument>, <argument><expr><name>nolditems</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>nnewitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nnewitems</name> <operator>==</operator> <name>nolditems</name> <operator>+</operator> <name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newseg</name> <operator>=</operator> <call><name>ginCompressPostingList</name><argument_list>(<argument><expr><name>newitems</name></expr></argument>, <argument><expr><name>nnewitems</name></expr></argument>,
											<argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>npacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npacked</name> <operator>==</operator> <name>nnewitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newsegsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name>newseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>a_action</name> <operator>=</operator> <name>GIN_SEGMENT_REPLACE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>segptr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>oldseg</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>segptr</name> <operator>!=</operator> <name>segmentend</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name>oldseg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Positioned after the last existing segment. Only INSERTs
			 * expected here.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>a_action</name> <operator>==</operator> <name>GIN_SEGMENT_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>segsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * We're about to start modification of the page.  So, copy tail of the
		 * page if it's not done already.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tailCopy</name> <operator>&amp;&amp;</operator> <name>segptr</name> <operator>!=</operator> <name>segmentend</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>tailSize</name> <init>= <expr><name>segmentend</name> <operator>-</operator> <name>segptr</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>tailCopy</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>tailSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tailCopy</name></expr></argument>, <argument><expr><name>segptr</name></expr></argument>, <argument><expr><name>tailSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>segptr</name> <operator>=</operator> <name>tailCopy</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldseg</name> <operator>=</operator> <operator>(</operator><name>GinPostingList</name> <operator>*</operator><operator>)</operator> <name>segptr</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>segmentend</name> <operator>=</operator> <name>segptr</name> <operator>+</operator> <name>tailSize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name>a_action</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>GIN_SEGMENT_DELETE</name></expr>:</case>
				<expr_stmt><expr><name>segptr</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>segno</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>GIN_SEGMENT_INSERT</name></expr>:</case>
				<comment type="block">/* copy the new segment in place */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>writePtr</name> <operator>+</operator> <name>newsegsize</name> <operator>&lt;=</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>writePtr</name></expr></argument>, <argument><expr><name>newseg</name></expr></argument>, <argument><expr><name>newsegsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>writePtr</name> <operator>+=</operator> <name>newsegsize</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>GIN_SEGMENT_REPLACE</name></expr>:</case>
				<comment type="block">/* copy the new version of segment in place */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>writePtr</name> <operator>+</operator> <name>newsegsize</name> <operator>&lt;=</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>writePtr</name></expr></argument>, <argument><expr><name>newseg</name></expr></argument>, <argument><expr><name>newsegsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>writePtr</name> <operator>+=</operator> <name>newsegsize</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>segptr</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>segno</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected GIN leaf action: %u"</literal></expr></argument>, <argument><expr><name>a_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><name>oldseg</name> <operator>=</operator> <operator>(</operator><name>GinPostingList</name> <operator>*</operator><operator>)</operator> <name>segptr</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Copy the rest of unmodified segments if any. */</comment>
	<expr_stmt><expr><name>segptr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>oldseg</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>segptr</name> <operator>!=</operator> <name>segmentend</name> <operator>&amp;&amp;</operator> <name>tailCopy</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>restSize</name> <init>= <expr><name>segmentend</name> <operator>-</operator> <name>segptr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>writePtr</name> <operator>+</operator> <name>restSize</name> <operator>&lt;=</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>writePtr</name></expr></argument>, <argument><expr><name>segptr</name></expr></argument>, <argument><expr><name>restSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>writePtr</name> <operator>+=</operator> <name>restSize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>totalsize</name> <operator>=</operator> <name>writePtr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinDataPageSetDataSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>totalsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ginRedoInsertData</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isLeaf</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>rightblkno</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>rdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isLeaf</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ginxlogRecompressDataLeaf</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ginxlogRecompressDataLeaf</name> <operator>*</operator><operator>)</operator> <name>rdata</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ginRedoRecompress</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ginxlogInsertDataInternal</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ginxlogInsertDataInternal</name> <operator>*</operator><operator>)</operator> <name>rdata</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PostingItem</name> <modifier>*</modifier></type><name>oldpitem</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* update link to right page after split */</comment>
		<expr_stmt><expr><name>oldpitem</name> <operator>=</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PostingItemSetBlockNumber</name><argument_list>(<argument><expr><name>oldpitem</name></expr></argument>, <argument><expr><name>rightblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>GinDataPageAddPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>newitem</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginRedoInsert</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ginxlogInsert</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ginxlogInsert</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>leftChildBlkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rightChildBlkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isLeaf</name> <init>= <expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GIN_INSERT_ISLEAF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * First clear incomplete-split flag on child page if this finishes a
	 * split.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isLeaf</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>payload</name> <init>= <expr><call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogInsert</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
		<expr_stmt><expr><name>leftChildBlkno</name> <operator>=</operator> <call><name>BlockIdGetBlockNumber</name><argument_list>(<argument><expr><operator>(</operator><name>BlockId</name><operator>)</operator> <name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>payload</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BlockIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>rightChildBlkno</name> <operator>=</operator> <call><name>BlockIdGetBlockNumber</name><argument_list>(<argument><expr><operator>(</operator><name>BlockId</name><operator>)</operator> <name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>payload</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BlockIdData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ginRedoClearIncompleteSplit</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>payload</name> <init>= <expr><call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* How to insert the payload is tree-type specific */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GIN_INSERT_ISDATA</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ginRedoInsertData</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>isLeaf</name></expr></argument>, <argument><expr><name>rightChildBlkno</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ginRedoInsertEntry</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>isLeaf</name></expr></argument>, <argument><expr><name>rightChildBlkno</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginRedoSplit</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ginxlogSplit</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ginxlogSplit</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>lbuffer</name></decl>,
				<decl><type ref="prev"/><name>rbuffer</name></decl>,
				<decl><type ref="prev"/><name>rootbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isLeaf</name> <init>= <expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GIN_INSERT_ISLEAF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isRoot</name> <init>= <expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GIN_SPLIT_ROOT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * First clear incomplete-split flag on child page if this finishes a
	 * split
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isLeaf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ginRedoClearIncompleteSplit</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * POLAR: The error message is triggered in XLogReadBufferForRedo function
	 * when fail to restore full-page image.
	 * Besides we will return BLK_DONE when page lsn is larger than current xlog
	 * record lsn.
	 */</comment>
	<expr_stmt><expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isRoot</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>rootbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * VACUUM_PAGE record contains simply a full image of the page, similar to
 * an XLOG_FPI record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginRedoVacuumPage</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLK_RESTORED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"replay of gin entry tree page vacuum did not restore the page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginRedoVacuumDataLeafPage</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ginxlogVacuumDataLeafPage</name> <modifier>*</modifier></type><name>xlrec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>xlrec</name> <operator>=</operator> <operator>(</operator><name>ginxlogVacuumDataLeafPage</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ginRedoRecompress</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>xlrec</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginRedoDeletePage</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ginxlogDeletePage</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ginxlogDeletePage</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>dbuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>pbuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>lbuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Lock left page first in order to prevent possible deadlock with
	 * ginStepRight().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lbuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>rightLink</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>dbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinPageSetDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * deleteXid field of ginxlogDeletePage was added during backpatching.
		 * But, non-backpatched instances will continue generate WAL without
		 * this field.  We should be able to correctly apply that.  We can
		 * distinguish new WAL records by size their data, because
		 * ginxlogDeletePage changes its size on both 32-bit and 64-bit
		 * platforms.
		 */</comment>
		<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogDeletePage</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator>
						 <sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogDeletePageOld</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						 <argument><expr><literal type="string">"ginxlogDeletePage size should be changed "</literal>
						 <literal type="string">"with addition of deleteXid field"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogDeletePage</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
			   <call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogDeletePageOld</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>XLogRecGetDataLen</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogDeletePage</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>GinPageSetDeleteXid</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>deleteXid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>dbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>dbuffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pbuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>pbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinPageDeletePostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>parentOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>pbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>pbuffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>lbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>pbuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>pbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>dbuffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>dbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginRedoUpdateMetapage</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ginxlogUpdateMeta</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ginxlogUpdateMeta</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Restore the metapage. This is essentially the same as a full-page
	 * image, so restore the metapage unconditionally without looking at the
	 * LSN, to avoid torn page hazards.
	 */</comment>
	<expr_stmt><expr><name>metabuffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GIN_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GinInitMetabuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>GinPageGetMeta</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * insert into tail page
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>tupsize</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>payload</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuples</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>totaltupsize</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>payload</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>totaltupsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuples</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name>payload</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PageIsEmpty</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>tupsize</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>tuples</name></expr></argument>, <argument><expr><name>tupsize</name></expr></argument>, <argument><expr><name>off</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to index page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>tuples</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuples</name><operator>)</operator> <operator>+</operator> <name>tupsize</name><operator>)</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>payload</name> <operator>+</operator> <name>totaltupsize</name> <operator>==</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Increase counter of heap tuples
			 */</comment>
			<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>prevTail</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * New tail
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>XLogReadBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BLK_NEEDS_REDO</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>newRightlink</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginRedoInsertListPage</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ginxlogInsertListPage</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ginxlogInsertListPage</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>l</name></decl>,
				<decl><type ref="prev"/><name>off</name> <init>= <expr><name>FirstOffsetNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>tupsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>payload</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>totaltupsize</name></decl>;</decl_stmt>

	<comment type="block">/* We always re-initialize the page. */</comment>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GinInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>rightlink</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>rightlink</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* tail of sublist */</comment>
		<expr_stmt><expr><call><name>GinPageSetFullRow</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>payload</name> <operator>=</operator> <call><name>XLogRecGetBlockData</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>totaltupsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuples</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name>payload</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>-&gt;</operator><name>ntuples</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>tupsize</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>tuples</name></expr></argument>, <argument><expr><name>tupsize</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add item to index page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tuples</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuples</name><operator>)</operator> <operator>+</operator> <name>tupsize</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuples</name> <operator>==</operator> <name>payload</name> <operator>+</operator> <name>totaltupsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginRedoDeleteListPages</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>lsn</name> <init>= <expr><name><name>record</name><operator>-&gt;</operator><name>EndRecPtr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ginxlogDeleteListPages</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ginxlogDeleteListPages</name> <operator>*</operator><operator>)</operator> <call><name>XLogRecGetData</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>metabuffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GIN_METAPAGE_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GinInitMetabuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>GinPageGetMeta</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>metadata</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinMetaPageData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In normal operation, shiftList() takes exclusive lock on all the
	 * pages-to-be-deleted simultaneously.  During replay, however, it should
	 * be all right to lock them one at a time.  This is dependent on the fact
	 * that we are deleting pages from the head of the list, and that readers
	 * share-lock the next page before releasing the one they are on. So we
	 * cannot get past a reader that is on, or due to visit, any page we are
	 * going to delete.  New incoming readers will block behind our metapage
	 * lock and then see a fully updated page list.
	 *
	 * No full-page images are taken of the deleted pages. Instead, they are
	 * re-initialized as empty, deleted pages. Their right-links don't need to
	 * be preserved, because no new readers can see the pages, as explained
	 * above.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>-&gt;</operator><name>ndeleted</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XLogInitBufferForRedo</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIN_DELETED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_redo_set_buffer_oldest_lsn</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>ReadRecPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>metabuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gin_redo</name><parameter_list>(<parameter><decl><type><name>XLogReaderState</name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>info</name> <init>= <expr><call><name>XLogRecGetInfo</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>XLR_INFO_MASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * GIN indexes do not require any conflict processing. NB: If we ever
	 * implement a similar optimization as we have in b-tree, and remove
	 * killed tuples outside VACUUM, we'll need to handle that here.
	 */</comment>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>opCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>info</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XLOG_GIN_CREATE_INDEX</name></expr>:</case>
			<expr_stmt><expr><call><name>ginRedoCreateIndex</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_GIN_CREATE_PTREE</name></expr>:</case>
			<expr_stmt><expr><call><name>ginRedoCreatePTree</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_GIN_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>ginRedoInsert</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_GIN_SPLIT</name></expr>:</case>
			<expr_stmt><expr><call><name>ginRedoSplit</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_GIN_VACUUM_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>ginRedoVacuumPage</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_GIN_VACUUM_DATA_LEAF_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>ginRedoVacuumDataLeafPage</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_GIN_DELETE_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>ginRedoDeletePage</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_GIN_UPDATE_META_PAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>ginRedoUpdateMetapage</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_GIN_INSERT_LISTPAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>ginRedoInsertListPage</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>XLOG_GIN_DELETE_LISTPAGE</name></expr>:</case>
			<expr_stmt><expr><call><name>ginRedoDeleteListPages</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"gin_redo: unknown op code %u"</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>opCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gin_xlog_startup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>opCtx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								  <argument><expr><literal type="string">"GIN recovery temporary context"</literal></expr></argument>,
								  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gin_xlog_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>opCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opCtx</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Mask a GIN page before running consistency checks on it.
 */</comment>
<function><type><name>void</name></type>
<name>gin_mask</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pagedata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><operator>(</operator><name>Page</name><operator>)</operator> <name>pagedata</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PageHeader</name></type>	<name>pagehdr</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>mask_page_lsn_and_checksum</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mask_page_hint_bits</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For a GIN_DELETED page, the page is initialized to empty.  Hence, mask
	 * the whole page content.  For other pages, mask the hole if pd_lower
	 * appears to have been set correctly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>opaque</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GIN_DELETED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>mask_page_content</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pagehdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&gt;</operator> <name>SizeOfPageHeaderData</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>mask_unused_space</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
