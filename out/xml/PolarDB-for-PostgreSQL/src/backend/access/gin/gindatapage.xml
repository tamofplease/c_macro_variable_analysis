<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/gin/gindatapage.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gindatapage.c
 *	  routines for handling GIN posting tree pages.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *			src/backend/access/gin/gindatapage.c
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/ginxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Min, Max and Target size of posting lists stored on leaf pages, in bytes.
 *
 * The code can deal with any size, but random access is more efficient when
 * a number of smaller lists are stored, rather than one big list. If a
 * posting list would become larger than Max size as a result of insertions,
 * it is split into two. If a posting list would be smaller than minimum
 * size, it is merged with the next posting list.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GinPostingListSegmentMaxSize</name></cpp:macro> <cpp:value>384</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GinPostingListSegmentTargetSize</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GinPostingListSegmentMinSize</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<comment type="block">/*
 * At least this many items fit in a GinPostingListSegmentMaxSize-bytes
 * long segment. This is used when estimating how much space is required
 * for N items, at minimum.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MinTuplesPerSegment</name></cpp:macro> <cpp:value>((GinPostingListSegmentMaxSize - 2) / 6)</cpp:value></cpp:define>

<comment type="block">/*
 * A working struct for manipulating a posting tree leaf page.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>dlist_head</name></type>	<name>segments</name></decl>;</decl_stmt>		<comment type="block">/* a list of leafSegmentInfos */</comment>

	<comment type="block">/*
	 * The following fields represent how the segments are split across pages,
	 * if a page split is required. Filled in by leafRepackItems.
	 */</comment>
	<decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>lastleft</name></decl>;</decl_stmt>		<comment type="block">/* last segment on left page */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>lsize</name></decl>;</decl_stmt>			<comment type="block">/* total size on left page */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>rsize</name></decl>;</decl_stmt>			<comment type="block">/* total size on right page */</comment>

	<decl_stmt><decl><type><name>bool</name></type>		<name>oldformat</name></decl>;</decl_stmt>		<comment type="block">/* page is in pre-9.4 format on disk */</comment>

	<comment type="block">/*
	 * If we need WAL data representing the reconstructed leaf page, it's
	 * stored here by computeLeafRecompressWALData.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>walinfo</name></decl>;</decl_stmt>		<comment type="block">/* buffer start */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>walinfolen</name></decl>;</decl_stmt>		<comment type="block">/* and length */</comment>
}</block></struct></type> <name>disassembledLeaf</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>node</name></decl>;</decl_stmt>			<comment type="block">/* linked list pointers */</comment>

	<comment type="block">/*-------------
	 * 'action' indicates the status of this in-memory segment, compared to
	 * what's on disk. It is one of the GIN_SEGMENT_* action codes:
	 *
	 * UNMODIFIED	no changes
	 * DELETE		the segment is to be removed. 'seg' and 'items' are
	 *				ignored
	 * INSERT		this is a completely new segment
	 * REPLACE		this replaces an existing segment with new content
	 * ADDITEMS		like REPLACE, but no items have been removed, and we track
	 *				in detail what items have been added to this segment, in
	 *				'modifieditems'
	 *-------------
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>action</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>modifieditems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>nmodifieditems</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The following fields represent the items in this segment. If 'items' is
	 * not NULL, it contains a palloc'd array of the itemsin this segment. If
	 * 'seg' is not NULL, it contains the items in an already-compressed
	 * format. It can point to an on-disk page (!modified), or a palloc'd
	 * segment in memory. If both are set, they must represent the same items.
	 */</comment>
	<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>seg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>			<comment type="block">/* # of items in 'items', if items != NULL */</comment>
}</block></struct></type> <name>leafSegmentInfo</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>ItemPointer</name></type> <name>dataLeafPageGetUncompressed</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nitems</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dataSplitPageInternal</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>origbuf</name></decl></parameter>,
					  <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertdata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
					  <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newlpage</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newrpage</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>disassembledLeaf</name> <modifier>*</modifier></type><name>disassembleLeaf</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>leafRepackItems</name><parameter_list>(<parameter><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>remaining</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>addItemsToLeaf</name><parameter_list>(<parameter><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>newItems</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>nNewItems</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>computeLeafRecompressWALData</name><parameter_list>(<parameter><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dataPlaceToPageLeafRecompress</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dataPlaceToPageLeafSplit</name><parameter_list>(<parameter><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl></parameter>,
						 <parameter><decl><type><name>ItemPointerData</name></type> <name>lbound</name></decl></parameter>, <parameter><decl><type><name>ItemPointerData</name></type> <name>rbound</name></decl></parameter>,
						 <parameter><decl><type><name>Page</name></type> <name>lpage</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>rpage</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Read TIDs from leaf data page to single uncompressed array. The TIDs are
 * returned in ascending order.
 *
 * advancePast is a hint, indicating that the caller is only interested in
 * TIDs &gt; advancePast. To return all items, use ItemPointerSetMin.
 *
 * Note: This function can still return items smaller than advancePast that
 * are in the same posting list as the items of interest, so the caller must
 * still check all the returned items. But passing it allows this function to
 * skip whole posting lists.
 */</comment>
<function><type><name>ItemPointer</name></type>
<name>GinDataLeafPageGetItems</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nitems</name></decl></parameter>, <parameter><decl><type><name>ItemPointerData</name></type> <name>advancePast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsCompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>seg</name> <init>= <expr><call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>len</name> <init>= <expr><call><name>GinDataLeafPageGetPostingListSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Pointer</name></type>		<name>endptr</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Pointer</name><operator>)</operator> <name>seg</name><operator>)</operator> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

		<comment type="block">/* Skip to the segment containing advancePast+1 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>GinNextPostingListSegment</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>next</name> <operator>&lt;</operator> <name>endptr</name> <operator>&amp;&amp;</operator>
				   <call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>next</name><operator>-&gt;</operator><name>first</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>advancePast</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>seg</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>GinNextPostingListSegment</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <name>endptr</name> <operator>-</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>seg</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ginPostingListDecodeAllSegments</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>nitems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>tmp</name> <init>= <expr><call><name>dataLeafPageGetUncompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>nitems</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>nitems</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Places all TIDs from leaf data page to bitmap.
 */</comment>
<function><type><name>int</name></type>
<name>GinDataLeafPageGetItemsToTbm</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>uncompressed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsCompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>segment</name> <init>= <expr><call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>len</name> <init>= <expr><call><name>GinDataLeafPageGetPostingListSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ginPostingListDecodeAllSegmentsToTbm</name><argument_list>(<argument><expr><name>segment</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>uncompressed</name> <operator>=</operator> <call><name>dataLeafPageGetUncompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tbm_add_tuples</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>uncompressed</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>nitems</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get pointer to the uncompressed array of items on a pre-9.4 format
 * uncompressed leaf page. The number of items in the array is returned in
 * *nitems.
 */</comment>
<function><type><specifier>static</specifier> <name>ItemPointer</name></type>
<name>dataLeafPageGetUncompressed</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nitems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>items</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsCompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In the old pre-9.4 page format, the whole page content is used for
	 * uncompressed items, and the number of items is stored in 'maxoff'
	 */</comment>
	<expr_stmt><expr><name>items</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>GinDataPageGetData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nitems</name> <operator>=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name></expr>;</expr_stmt>

	<return>return <expr><name>items</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if we should follow the right link to find the item we're searching
 * for.
 *
 * Compares inserting item pointer with the right bound of the current page.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dataIsMoveRight</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>iptr</name> <init>= <expr><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsDeleted</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><ternary><condition><expr><operator>(</operator><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btree</name><operator>-&gt;</operator><name>itemptr</name></name></expr></argument>, <argument><expr><name>iptr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find correct PostingItem in non-leaf page. It is assumed that this is
 * the correct page, and the searched value SHOULD be on the page.
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>dataLocateItem</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>low</name></decl>,
				<decl><type ref="prev"/><name>high</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PostingItem</name> <modifier>*</modifier></type><name>pitem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>btree</name><operator>-&gt;</operator><name>fullScan</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>predictNumber</name></name> <operator>*=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name></expr>;</expr_stmt>
		<return>return <expr><call><name><name>btree</name><operator>-&gt;</operator><name>getLeftMostChild</name></name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>low</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>high</name> <operator>=</operator> <call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>high</name> <operator>&gt;=</operator> <name>low</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>high</name><operator>++</operator></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>high</name> <operator>&gt;</operator> <name>low</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>mid</name> <init>= <expr><name>low</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>mid</name> <operator>==</operator> <name>maxoff</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Right infinity, page already correctly chosen with a help of
			 * dataIsMoveRight
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btree</name><operator>-&gt;</operator><name>itemptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pitem</name><operator>-&gt;</operator><name>key</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
			<return>return <expr><call><name>PostingItemGetBlockNumber</name><argument_list>(<argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>high</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator> <name>high</name> <operator>&lt;=</operator> <name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name>high</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PostingItemGetBlockNumber</name><argument_list>(<argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find link to blkno on non-leaf page, returns offset of PostingItem
 */</comment>
<function><type><specifier>static</specifier> <name>OffsetNumber</name></type>
<name>dataFindChildPtr</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>storedOff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name> <init>= <expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PostingItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if page isn't changed, we return storedOff */</comment>
	<if_stmt><if>if <condition>(<expr><name>storedOff</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator> <name>storedOff</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>storedOff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PostingItemGetBlockNumber</name><argument_list>(<argument><expr><name>pitem</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>storedOff</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * we hope, that needed pointer goes to right. It's true if there
		 * wasn't a deletion
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>storedOff</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PostingItemGetBlockNumber</name><argument_list>(<argument><expr><name>pitem</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <name>storedOff</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* last chance */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PostingItemGetBlockNumber</name><argument_list>(<argument><expr><name>pitem</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>InvalidOffsetNumber</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return blkno of leftmost child
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>dataGetLeftMostPage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PostingItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>PostingItemGetBlockNumber</name><argument_list>(<argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add PostingItem to a non-leaf page.
 */</comment>
<function><type><name>void</name></type>
<name>GinDataPageAddPostingItem</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>PostingItem</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name> <init>= <expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PostingItemGetBlockNumber</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>maxoff</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <name>maxoff</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					<argument><expr><name>ptr</name></expr></argument>,
					<argument><expr><operator>(</operator><name>maxoff</name> <operator>-</operator> <name>offset</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>maxoff</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>=</operator> <name>maxoff</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also set pd_lower to the end of the posting items, to follow the
	 * "standard" page layout, so that we can squeeze out the unused space
	 * from full-page images.
	 */</comment>
	<expr_stmt><expr><call><name>GinDataPageSetDataSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>maxoff</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete posting item from non-leaf page
 */</comment>
<function><type><name>void</name></type>
<name>GinPageDeletePostingItem</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name> <init>= <expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <name>FirstOffsetNumber</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;=</operator> <name>maxoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <name>maxoff</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>maxoff</name> <operator>-</operator> <name>offset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>maxoff</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>=</operator> <name>maxoff</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GinDataPageSetDataSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>maxoff</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare to insert data on a leaf data page.
 *
 * If it will fit, return GPTP_INSERT after doing whatever setup is needed
 * before we enter the insertion critical section.  *ptp_workspace can be
 * set to pass information along to the execPlaceToPage function.
 *
 * If it won't fit, perform a page split and return two temporary page
 * images into *newlpage and *newrpage, with result GPTP_SPLIT.
 *
 * In neither case should the given page buffer be modified here.
 */</comment>
<function><type><specifier>static</specifier> <name>GinPlaceToPageRC</name></type>
<name>dataBeginPlaceToPageLeaf</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
						 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertdata</name></decl></parameter>,
						 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptp_workspace</name></decl></parameter>,
						 <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newlpage</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newrpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinBtreeDataLeafInsertData</name> <modifier>*</modifier></type><name>items</name> <init>= <expr><name>insertdata</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>newItems</name> <init>= <expr><operator>&amp;</operator><name><name>items</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>items</name><operator>-&gt;</operator><name>curitem</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxitems</name> <init>= <expr><name><name>items</name><operator>-&gt;</operator><name>nitem</name></name> <operator>-</operator> <name><name>items</name><operator>-&gt;</operator><name>curitem</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>rbound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>lbound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needsplit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>append</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>freespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>lastleftinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>maxOldItem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>remaining</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rbound</name> <operator>=</operator> <operator>*</operator><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Count how many of the new items belong to this page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newItems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rbound</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This needs to go to some other location in the tree. (The
				 * caller should've chosen the insert location so that at
				 * least the first item goes here.)
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>maxitems</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Disassemble the data on the page */</comment>
	<expr_stmt><expr><name>leaf</name> <operator>=</operator> <call><name>disassembleLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Are we appending to the end of the page? IOW, are all the new items
	 * larger than any of the existing items.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lastleftinfo</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
									   <argument><expr><call><name>dlist_tail_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lastleftinfo</name><operator>-&gt;</operator><name>items</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lastleftinfo</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <call><name>ginPostingListDecode</name><argument_list>(<argument><expr><name><name>lastleftinfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name><name>lastleftinfo</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>maxOldItem</name> <operator>=</operator> <name><name>lastleftinfo</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>lastleftinfo</name><operator>-&gt;</operator><name>nitems</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newItems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxOldItem</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>append</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>append</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ItemPointerSetMin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>maxOldItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>append</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If we're appending to the end of the page, we will append as many items
	 * as we can fit (after splitting), and stop when the pages becomes full.
	 * Otherwise we have to limit the number of new items to insert, because
	 * once we start packing we can't just stop when we run out of space,
	 * because we must make sure that all the old items still fit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsCompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>freespace</name> <operator>=</operator> <call><name>GinDataLeafPageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>freespace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>append</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Even when appending, trying to append more items than will fit is
		 * not completely free, because we will merge the new items and old
		 * items into an array below. In the best case, every new item fits in
		 * a single byte, and we can use all the free space on the old page as
		 * well as the new page. For simplicity, ignore segment overhead etc.
		 */</comment>
		<expr_stmt><expr><name>maxitems</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>maxitems</name></expr></argument>, <argument><expr><name>freespace</name> <operator>+</operator> <name>GinDataPageMaxDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Calculate a conservative estimate of how many new items we can fit
		 * on the two pages after splitting.
		 *
		 * We can use any remaining free space on the old page to store full
		 * segments, as well as the new page. Each full-sized segment can hold
		 * at least MinTuplesPerSegment items
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>nnewsegments</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nnewsegments</name> <operator>=</operator> <name>freespace</name> <operator>/</operator> <name>GinPostingListSegmentMaxSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nnewsegments</name> <operator>+=</operator> <name>GinDataPageMaxDataSize</name> <operator>/</operator> <name>GinPostingListSegmentMaxSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxitems</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>maxitems</name></expr></argument>, <argument><expr><name>nnewsegments</name> <operator>*</operator> <name>MinTuplesPerSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Add the new items to the segment list */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>addItemsToLeaf</name><argument_list>(<argument><expr><name>leaf</name></expr></argument>, <argument><expr><name>newItems</name></expr></argument>, <argument><expr><name>maxitems</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* all items were duplicates, we have nothing to do */</comment>
		<expr_stmt><expr><name><name>items</name><operator>-&gt;</operator><name>curitem</name></name> <operator>+=</operator> <name>maxitems</name></expr>;</expr_stmt>

		<return>return <expr><name>GPTP_NO_WORK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Pack the items back to compressed segments, ready for writing to disk.
	 */</comment>
	<expr_stmt><expr><name>needsplit</name> <operator>=</operator> <call><name>leafRepackItems</name><argument_list>(<argument><expr><name>leaf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Did all the new items fit?
	 *
	 * If we're appending, it's OK if they didn't. But as a sanity check,
	 * verify that all the old items fit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remaining</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>append</name> <operator>||</operator> <call><name>ItemPointerCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>maxOldItem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remaining</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not split GIN page; all old items didn't fit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Count how many of the new items did fit. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newItems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>remaining</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not split GIN page; no new items fit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>maxitems</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needsplit</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Great, all the items fit on a single page.  If needed, prepare data
		 * for a WAL record describing the changes we'll make.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>computeLeafRecompressWALData</name><argument_list>(<argument><expr><name>leaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We're ready to enter the critical section, but
		 * dataExecPlaceToPageLeaf will need access to the "leaf" data.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>ptp_workspace</name> <operator>=</operator> <name>leaf</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>append</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"appended %d new items to block %u; %d bytes (%d to go)"</literal></expr></argument>,
				 <argument><expr><name>maxitems</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name></expr></argument>,
				 <argument><expr><name><name>items</name><operator>-&gt;</operator><name>nitem</name></name> <operator>-</operator> <name><name>items</name><operator>-&gt;</operator><name>curitem</name></name> <operator>-</operator> <name>maxitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"inserted %d new items to block %u; %d bytes (%d to go)"</literal></expr></argument>,
				 <argument><expr><name>maxitems</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name></expr></argument>,
				 <argument><expr><name><name>items</name><operator>-&gt;</operator><name>nitem</name></name> <operator>-</operator> <name><name>items</name><operator>-&gt;</operator><name>curitem</name></name> <operator>-</operator> <name>maxitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Have to split.
		 *
		 * leafRepackItems already divided the segments between the left and
		 * the right page. It filled the left page as full as possible, and
		 * put the rest to the right page. When building a new index, that's
		 * good, because the table is scanned from beginning to end and there
		 * won't be any more insertions to the left page during the build.
		 * This packs the index as tight as possible. But otherwise, split
		 * 50/50, by moving segments from the left page to the right page
		 * until they're balanced.
		 *
		 * As a further heuristic, when appending items to the end of the
		 * page, try to make the left page 75% full, on the assumption that
		 * subsequent insertions will probably also go to the end. This packs
		 * the index somewhat tighter when appending to a table, which is very
		 * common.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>btree</name><operator>-&gt;</operator><name>isBuild</name></name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><call><name>dlist_has_prev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>lastleft</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>lastleftinfo</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>lastleft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* ignore deleted segments */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>lastleftinfo</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>GIN_SEGMENT_DELETE</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name><name>lastleftinfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Note that we check that the right page doesn't become
					 * more full than the left page even when appending. It's
					 * possible that we added enough items to make both pages
					 * more than 75% full.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name> <operator>-</operator> <name>segsize</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name><name>leaf</name><operator>-&gt;</operator><name>rsize</name></name> <operator>+</operator> <name>segsize</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>append</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name> <operator>-</operator> <name>segsize</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name>BLCKSZ</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator> <operator>/</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name> <operator>-=</operator> <name>segsize</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>rsize</name></name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>lastleft</name></name> <operator>=</operator> <call><name>dlist_prev_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>lastleft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name> <operator>&lt;=</operator> <name>GinDataPageMaxDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>rsize</name></name> <operator>&lt;=</operator> <name>GinDataPageMaxDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fetch the max item in the left page's last segment; it becomes the
		 * right bound of the page.
		 */</comment>
		<expr_stmt><expr><name>lastleftinfo</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>lastleft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lastleftinfo</name><operator>-&gt;</operator><name>items</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lastleftinfo</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <call><name>ginPostingListDecode</name><argument_list>(<argument><expr><name><name>lastleftinfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name><name>lastleftinfo</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>lbound</name> <operator>=</operator> <name><name>lastleftinfo</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>lastleftinfo</name><operator>-&gt;</operator><name>nitems</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now allocate a couple of temporary page images, and fill them.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>newlpage</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>newrpage</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>dataPlaceToPageLeafSplit</name><argument_list>(<argument><expr><name>leaf</name></expr></argument>, <argument><expr><name>lbound</name></expr></argument>, <argument><expr><name>rbound</name></expr></argument>,
								 <argument><expr><operator>*</operator><name>newlpage</name></expr></argument>, <argument><expr><operator>*</operator><name>newrpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator>
			   <call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><operator>*</operator><name>newlpage</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><operator>*</operator><name>newrpage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>append</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"appended %d items to block %u; split %d/%d (%d to go)"</literal></expr></argument>,
				 <argument><expr><name>maxitems</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>leaf</name><operator>-&gt;</operator><name>rsize</name></name></expr></argument>,
				 <argument><expr><name><name>items</name><operator>-&gt;</operator><name>nitem</name></name> <operator>-</operator> <name><name>items</name><operator>-&gt;</operator><name>curitem</name></name> <operator>-</operator> <name>maxitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"inserted %d items to block %u; split %d/%d (%d to go)"</literal></expr></argument>,
				 <argument><expr><name>maxitems</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>leaf</name><operator>-&gt;</operator><name>rsize</name></name></expr></argument>,
				 <argument><expr><name><name>items</name><operator>-&gt;</operator><name>nitem</name></name> <operator>-</operator> <name><name>items</name><operator>-&gt;</operator><name>curitem</name></name> <operator>-</operator> <name>maxitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>items</name><operator>-&gt;</operator><name>curitem</name></name> <operator>+=</operator> <name>maxitems</name></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><name>needsplit</name></expr> ?</condition><then> <expr><name>GPTP_SPLIT</name></expr> </then><else>: <expr><name>GPTP_INSERT</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform data insertion after beginPlaceToPage has decided it will fit.
 *
 * This is invoked within a critical section, and XLOG record creation (if
 * needed) is already started.  The target buffer is registered in slot 0.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dataExecPlaceToPageLeaf</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
						<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptp_workspace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name> <init>= <expr><operator>(</operator><name>disassembledLeaf</name> <operator>*</operator><operator>)</operator> <name>ptp_workspace</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Apply changes to page */</comment>
	<expr_stmt><expr><call><name>dataPlaceToPageLeafRecompress</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>leaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If needed, register WAL data built by computeLeafRecompressWALData */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>walinfo</name></name></expr></argument>, <argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>walinfolen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Vacuum a posting tree leaf page.
 */</comment>
<function><type><name>void</name></type>
<name>ginVacuumPostingTreeLeaf</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexrel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>GinVacuumState</name> <modifier>*</modifier></type><name>gvs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>removedsomething</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>leaf</name> <operator>=</operator> <call><name>disassembleLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Vacuum each segment. */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;leaf-&gt;segments</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>seginfo</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>oldsegsize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>cleaned</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ncleaned</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <call><name>ginPostingListDecode</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldsegsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldsegsize</name> <operator>=</operator> <name>GinDataPageMaxDataSize</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>cleaned</name> <operator>=</operator> <call><name>ginVacuumItemPointers</name><argument_list>(<argument><expr><name>gvs</name></expr></argument>,
										<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name></expr></argument>,
										<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>ncleaned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cleaned</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ncleaned</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>npacked</name></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <call><name>ginCompressPostingList</name><argument_list>(<argument><expr><name>cleaned</name></expr></argument>,
													  <argument><expr><name>ncleaned</name></expr></argument>,
													  <argument><expr><name>oldsegsize</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>npacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Removing an item never increases the size of the segment */</comment>
				<if_stmt><if>if <condition>(<expr><name>npacked</name> <operator>!=</operator> <name>ncleaned</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not fit vacuumed posting list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_REPLACE</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_DELETE</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <name>ncleaned</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>removedsomething</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we removed any items, reconstruct the page from the pieces.
	 *
	 * We don't try to re-encode the segments here, even though some of them
	 * might be really small now that we've removed some items from them. It
	 * seems like a waste of effort, as there isn't really any benefit from
	 * larger segments per se; larger segments only help to pack more items in
	 * the same space. We might as well delay doing that until the next
	 * insertion, which will need to re-encode at least part of the page
	 * anyway.
	 *
	 * Also note if the page was in uncompressed, pre-9.4 format before, it is
	 * now represented as one huge segment that contains all the items. It
	 * might make sense to split that, to speed up random access, but we don't
	 * bother. You'll have to REINDEX anyway if you want the full gain of the
	 * new tighter index format.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>removedsomething</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>modified</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Make sure we have a palloc'd copy of all segments, after the first
		 * segment that is modified. (dataPlaceToPageLeafRecompress requires
		 * this).
		 */</comment>
		<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;leaf-&gt;segments</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>seginfo</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
													   <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>GIN_SEGMENT_UNMODIFIED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>modified</name> <operator>&amp;&amp;</operator> <name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>GIN_SEGMENT_DELETE</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>segsize</name> <init>= <expr><call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><operator>(</operator><name>GinPostingList</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>computeLeafRecompressWALData</name><argument_list>(<argument><expr><name>leaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Apply changes to page */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>dataPlaceToPageLeafRecompress</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>leaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>walinfo</name></name></expr></argument>, <argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>walinfolen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_GIN_ID</name></expr></argument>, <argument><expr><name>XLOG_GIN_VACUUM_DATA_LEAF_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a ginxlogRecompressDataLeaf record representing the changes
 * in *leaf.  (Because this requires a palloc, we have to do it before
 * we enter the critical section that actually updates the page.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>computeLeafRecompressWALData</name><parameter_list>(<parameter><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmodified</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>walbufbegin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>walbufend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ginxlogRecompressDataLeaf</name> <modifier>*</modifier></type><name>recompress_xlog</name></decl>;</decl_stmt>

	<comment type="block">/* Count the modified segments */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;leaf-&gt;segments</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>seginfo</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
												   <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>GIN_SEGMENT_UNMODIFIED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nmodified</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>walbufbegin</name> <operator>=</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogRecompressDataLeaf</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
			   <name>BLCKSZ</name> <operator>+</operator>			<comment type="block">/* max size needed to hold the segment data */</comment>
			   <name>nmodified</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>	<comment type="block">/* (segno + action) per action */</comment>
		)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>walbufend</name> <operator>=</operator> <name>walbufbegin</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>recompress_xlog</name> <operator>=</operator> <operator>(</operator><name>ginxlogRecompressDataLeaf</name> <operator>*</operator><operator>)</operator> <name>walbufend</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>walbufend</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogRecompressDataLeaf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>recompress_xlog</name><operator>-&gt;</operator><name>nactions</name></name> <operator>=</operator> <name>nmodified</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>segno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;leaf-&gt;segments</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>seginfo</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
												   <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>segsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>datalen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>action</name> <init>= <expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>GIN_SEGMENT_UNMODIFIED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>segno</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>!=</operator> <name>GIN_SEGMENT_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If storing the uncompressed list of added item pointers would take
		 * more space than storing the compressed segment as is, do that
		 * instead.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>GIN_SEGMENT_ADDITEMS</name> <operator>&amp;&amp;</operator>
			<name><name>seginfo</name><operator>-&gt;</operator><name>nmodifieditems</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>segsize</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>action</name> <operator>=</operator> <name>GIN_SEGMENT_REPLACE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>walbufend</name><operator>++</operator><operator>)</operator><operator>)</operator> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>walbufend</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>action</name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>action</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>GIN_SEGMENT_DELETE</name></expr>:</case>
				<expr_stmt><expr><name>datalen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>GIN_SEGMENT_ADDITEMS</name></expr>:</case>
				<expr_stmt><expr><name>datalen</name> <operator>=</operator> <name><name>seginfo</name><operator>-&gt;</operator><name>nmodifieditems</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>walbufend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seginfo</name><operator>-&gt;</operator><name>nmodifieditems</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>walbufend</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>modifieditems</name></name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>datalen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>GIN_SEGMENT_INSERT</name></expr>:</case>
			<case>case <expr><name>GIN_SEGMENT_REPLACE</name></expr>:</case>
				<expr_stmt><expr><name>datalen</name> <operator>=</operator> <call><name>SHORTALIGN</name><argument_list>(<argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>walbufend</name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected GIN leaf action %d"</literal></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><name>walbufend</name> <operator>+=</operator> <name>datalen</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>action</name> <operator>!=</operator> <name>GIN_SEGMENT_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>segno</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Pass back the constructed info via *leaf */</comment>
	<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>walinfo</name></name> <operator>=</operator> <name>walbufbegin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>walinfolen</name></name> <operator>=</operator> <name>walbufend</name> <operator>-</operator> <name>walbufbegin</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assemble a disassembled posting tree leaf page back to a buffer.
 *
 * This just updates the target buffer; WAL stuff is caller's responsibility.
 *
 * NOTE: The segment pointers must not point directly to the same buffer,
 * except for segments that have not been modified and whose preceding
 * segments have not been modified either.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dataPlaceToPageLeafRecompress</name><parameter_list>(<parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>modified</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segsize</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the page was in pre-9.4 format before, convert the header, and force
	 * all segments to be copied to the page whether they were modified or
	 * not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GinPageIsCompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>oldformat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinPageSetCompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>=</operator> <name>InvalidOffsetNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;leaf-&gt;segments</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>seginfo</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>GIN_SEGMENT_UNMODIFIED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>GIN_SEGMENT_DELETE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>modified</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newsize</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newsize</name> <operator>&lt;=</operator> <name>GinDataPageMaxDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinDataPageSetDataSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Like dataPlaceToPageLeafRecompress, but writes the disassembled leaf
 * segments to two pages instead of one.
 *
 * This is different from the non-split cases in that this does not modify
 * the original page directly, but writes to temporary in-memory copies of
 * the new left and right pages.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dataPlaceToPageLeafSplit</name><parameter_list>(<parameter><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl></parameter>,
						 <parameter><decl><type><name>ItemPointerData</name></type> <name>lbound</name></decl></parameter>, <parameter><decl><type><name>ItemPointerData</name></type> <name>rbound</name></decl></parameter>,
						 <parameter><decl><type><name>Page</name></type> <name>lpage</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>rpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>firstright</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>seginfo</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize temporary pages to hold the new left and right pages */</comment>
	<expr_stmt><expr><call><name>GinInitPage</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>GIN_DATA</name> <operator>|</operator> <name>GIN_LEAF</name> <operator>|</operator> <name>GIN_COMPRESSED</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinInitPage</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><name>GIN_DATA</name> <operator>|</operator> <name>GIN_LEAF</name> <operator>|</operator> <name>GIN_COMPRESSED</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the segments that go to the left page.
	 *
	 * XXX: We should skip copying the unmodified part of the left page, like
	 * we do when recompressing.
	 */</comment>
	<expr_stmt><expr><name>lsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstright</name> <operator>=</operator> <call><name>dlist_next_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>lastleft</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>node</name> <operator>=</operator> <call><name>dlist_head_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>node</name> <operator>!=</operator> <name>firstright</name></expr>;</condition>
		 <incr><expr><name>node</name> <operator>=</operator> <call><name>dlist_next_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>seginfo</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>GIN_SEGMENT_DELETE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lsize</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lsize</name> <operator>==</operator> <name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinDataPageSetDataSize</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>lsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>lbound</name></expr>;</expr_stmt>

	<comment type="block">/* Copy the segments that go to the right page */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>node</name> <operator>=</operator> <name>firstright</name></expr>;</init>
		 <condition>;</condition>
		 <incr><expr><name>node</name> <operator>=</operator> <call><name>dlist_next_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>seginfo</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>GIN_SEGMENT_DELETE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rsize</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_has_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rsize</name> <operator>==</operator> <name><name>leaf</name><operator>-&gt;</operator><name>rsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinDataPageSetDataSize</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>rbound</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare to insert data on an internal data page.
 *
 * If it will fit, return GPTP_INSERT after doing whatever setup is needed
 * before we enter the insertion critical section.  *ptp_workspace can be
 * set to pass information along to the execPlaceToPage function.
 *
 * If it won't fit, perform a page split and return two temporary page
 * images into *newlpage and *newrpage, with result GPTP_SPLIT.
 *
 * In neither case should the given page buffer be modified here.
 *
 * Note: on insertion to an internal node, in addition to inserting the given
 * item, the downlink of the existing item at stack-&gt;off will be updated to
 * point to updateblkno.
 */</comment>
<function><type><specifier>static</specifier> <name>GinPlaceToPageRC</name></type>
<name>dataBeginPlaceToPageInternal</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertdata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
							 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptp_workspace</name></decl></parameter>,
							 <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newlpage</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newrpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If it doesn't fit, deal with split case */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GinNonLeafDataPageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dataSplitPageInternal</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>insertdata</name></expr></argument>, <argument><expr><name>updateblkno</name></expr></argument>,
							  <argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>newrpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>GPTP_SPLIT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Else, we're ready to proceed with insertion */</comment>
	<return>return <expr><name>GPTP_INSERT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform data insertion after beginPlaceToPage has decided it will fit.
 *
 * This is invoked within a critical section, and XLOG record creation (if
 * needed) is already started.  The target buffer is registered in slot 0.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dataExecPlaceToPageInternal</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
							<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertdata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
							<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptp_workspace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PostingItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>

	<comment type="block">/* Update existing downlink to point to next page (on internal page) */</comment>
	<expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PostingItemSetBlockNumber</name><argument_list>(<argument><expr><name>pitem</name></expr></argument>, <argument><expr><name>updateblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add new item */</comment>
	<expr_stmt><expr><name>pitem</name> <operator>=</operator> <operator>(</operator><name>PostingItem</name> <operator>*</operator><operator>)</operator> <name>insertdata</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinDataPageAddPostingItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This must be static, because it has to survive until XLogInsert,
		 * and we can't palloc here.  Ugly, but the XLogInsert infrastructure
		 * isn't reentrant anyway.
		 */</comment>
		<decl_stmt><decl><type><specifier>static</specifier> <name>ginxlogInsertDataInternal</name></type> <name>data</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>newitem</name></name> <operator>=</operator> <operator>*</operator><name>pitem</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>data</name></expr></argument>,
							<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogInsertDataInternal</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare to insert data on a posting-tree data page.
 *
 * If it will fit, return GPTP_INSERT after doing whatever setup is needed
 * before we enter the insertion critical section.  *ptp_workspace can be
 * set to pass information along to the execPlaceToPage function.
 *
 * If it won't fit, perform a page split and return two temporary page
 * images into *newlpage and *newrpage, with result GPTP_SPLIT.
 *
 * In neither case should the given page buffer be modified here.
 *
 * Note: on insertion to an internal node, in addition to inserting the given
 * item, the downlink of the existing item at stack-&gt;off will be updated to
 * point to updateblkno.
 *
 * Calls relevant function for internal or leaf page because they are handled
 * very differently.
 */</comment>
<function><type><specifier>static</specifier> <name>GinPlaceToPageRC</name></type>
<name>dataBeginPlaceToPage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertdata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptp_workspace</name></decl></parameter>,
					 <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newlpage</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newrpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GinPageIsData</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>dataBeginPlaceToPageLeaf</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>insertdata</name></expr></argument>,
										<argument><expr><name>ptp_workspace</name></expr></argument>,
										<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>newrpage</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>dataBeginPlaceToPageInternal</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>,
											<argument><expr><name>insertdata</name></expr></argument>, <argument><expr><name>updateblkno</name></expr></argument>,
											<argument><expr><name>ptp_workspace</name></expr></argument>,
											<argument><expr><name>newlpage</name></expr></argument>, <argument><expr><name>newrpage</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform data insertion after beginPlaceToPage has decided it will fit.
 *
 * This is invoked within a critical section, and XLOG record creation (if
 * needed) is already started.  The target buffer is registered in slot 0.
 *
 * Calls relevant function for internal or leaf page because they are handled
 * very differently.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dataExecPlaceToPage</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
					<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertdata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
					<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptp_workspace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dataExecPlaceToPageLeaf</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>insertdata</name></expr></argument>,
								<argument><expr><name>ptp_workspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dataExecPlaceToPageInternal</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>insertdata</name></expr></argument>,
									<argument><expr><name>updateblkno</name></expr></argument>, <argument><expr><name>ptp_workspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Split internal page and insert new data.
 *
 * Returns new temp pages to *newlpage and *newrpage.
 * The original buffer is left untouched.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dataSplitPageInternal</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>origbuf</name></decl></parameter>,
					  <parameter><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
					  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>insertdata</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>updateblkno</name></decl></parameter>,
					  <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newlpage</name></decl></parameter>, <parameter><decl><type><name>Page</name> <modifier>*</modifier></type><name>newrpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Page</name></type>		<name>oldpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>origbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>off</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name> <init>= <expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nleftitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nrightitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>pageSize</name> <init>= <expr><call><name>PageGetPageSize</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>oldbound</name> <init>= <expr><operator>*</operator><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>bound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>rpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>separator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PostingItem</name></type> <name><name>allitems</name><index>[<expr><operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>lpage</name> <operator>=</operator> <call><name>PageGetTempPage</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rpage</name> <operator>=</operator> <call><name>PageGetTempPage</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinInitPage</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinInitPage</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></argument>, <argument><expr><name>pageSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First construct a new list of PostingItems, which includes all the old
	 * items, and the new item.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>allitems</name></expr></argument>, <argument><expr><call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><operator>(</operator><name>off</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>allitems</name><index>[<expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>PostingItem</name> <operator>*</operator><operator>)</operator> <name>insertdata</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>allitems</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><operator>(</operator><name>nitems</name> <operator>-</operator> <operator>(</operator><name>off</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nitems</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Update existing downlink to point to next page */</comment>
	<expr_stmt><expr><call><name>PostingItemSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>allitems</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>, <argument><expr><name>updateblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When creating a new index, fit as many tuples as possible on the left
	 * page, on the assumption that the table is scanned from beginning to
	 * end. This packs the index as tight as possible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>btree</name><operator>-&gt;</operator><name>isBuild</name></name> <operator>&amp;&amp;</operator> <call><name>GinPageRightMost</name><argument_list>(<argument><expr><name>oldpage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>separator</name> <operator>=</operator> <call><name>GinNonLeafDataPageGetFreeSpace</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>separator</name> <operator>=</operator> <name>nitems</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>nleftitems</name> <operator>=</operator> <name>separator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nrightitems</name> <operator>=</operator> <name>nitems</name> <operator>-</operator> <name>separator</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>allitems</name></expr></argument>,
		   <argument><expr><name>nleftitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>=</operator> <name>nleftitems</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><operator>&amp;</operator><name><name>allitems</name><index>[<expr><name>separator</name></expr>]</index></name></expr></argument>,
		   <argument><expr><name>nrightitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>maxoff</name> <operator>=</operator> <name>nrightitems</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also set pd_lower for both pages, like GinDataPageAddPostingItem does.
	 */</comment>
	<expr_stmt><expr><call><name>GinDataPageSetDataSize</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>nleftitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinDataPageSetDataSize</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>, <argument><expr><name>nrightitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set up right bound for left page */</comment>
	<expr_stmt><expr><name>bound</name> <operator>=</operator> <call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>bound</name> <operator>=</operator> <call><name>GinDataPageGetPostingItem</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>, <argument><expr><name>nleftitems</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>key</name></expr>;</expr_stmt>

	<comment type="block">/* set up right bound for right page */</comment>
	<expr_stmt><expr><operator>*</operator><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>oldbound</name></expr>;</expr_stmt>

	<comment type="block">/* return temp pages to caller */</comment>
	<expr_stmt><expr><operator>*</operator><name>newlpage</name> <operator>=</operator> <name>lpage</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>newrpage</name> <operator>=</operator> <name>rpage</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct insertion payload for inserting the downlink for given buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>dataPrepareDownlink</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>lbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PostingItem</name> <modifier>*</modifier></type><name>pitem</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PostingItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>lpage</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PostingItemSetBlockNumber</name><argument_list>(<argument><expr><name>pitem</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>lbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <operator>*</operator><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pitem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fills new root by right bound values from child.
 * Also called from ginxlog, should not use btree
 */</comment>
<function><type><name>void</name></type>
<name>ginDataFillRoot</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>root</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>lblkno</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>lpage</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>rblkno</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>rpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PostingItem</name></type> <name>li</name></decl>,
				<decl><type ref="prev"/><name>ri</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>li</name><operator>.</operator><name>key</name></name> <operator>=</operator> <operator>*</operator><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><name>lpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PostingItemSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>li</name></expr></argument>, <argument><expr><name>lblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinDataPageAddPostingItem</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>li</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ri</name><operator>.</operator><name>key</name></name> <operator>=</operator> <operator>*</operator><call><name>GinDataPageGetRightBound</name><argument_list>(<argument><expr><name>rpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PostingItemSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>, <argument><expr><name>rblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinDataPageAddPostingItem</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*** Functions to work with disassembled leaf pages ***/</comment>

<comment type="block">/*
 * Disassemble page into a disassembledLeaf struct.
 */</comment>
<function><type><specifier>static</specifier> <name>disassembledLeaf</name> <modifier>*</modifier></type>
<name>disassembleLeaf</name><parameter_list>(<parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>seg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>segbegin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>segend</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>leaf</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>disassembledLeaf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GinPageIsCompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Create a leafSegment entry for each segment.
		 */</comment>
		<expr_stmt><expr><name>seg</name> <operator>=</operator> <call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>segbegin</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <name>seg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>segend</name> <operator>=</operator> <name>segbegin</name> <operator>+</operator> <call><name>GinDataLeafPageGetPostingListSize</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>seg</name> <operator>&lt;</operator> <name>segend</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>seginfo</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_UNMODIFIED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>seg</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seginfo</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>seg</name> <operator>=</operator> <call><name>GinNextPostingListSegment</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>oldformat</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * A pre-9.4 format uncompressed page is represented by a single
		 * segment, with an array of items.  The corner case is uncompressed
		 * page containing no items, which is represented as no segments.
		 */</comment>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>uncompressed</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nuncompressed</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>seginfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>uncompressed</name> <operator>=</operator> <call><name>dataLeafPageGetUncompressed</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nuncompressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nuncompressed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>seginfo</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_REPLACE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nuncompressed</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name></expr></argument>, <argument><expr><name>uncompressed</name></expr></argument>, <argument><expr><name>nuncompressed</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <name>nuncompressed</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>seginfo</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>oldformat</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>leaf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Distribute newItems to the segments.
 *
 * Any segments that acquire new items are decoded, and the new items are
 * merged with the old items.
 *
 * Returns true if any new items were added. False means they were all
 * duplicates of existing items on the page.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>addItemsToLeaf</name><parameter_list>(<parameter><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>newItems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nNewItems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>nextnew</name> <init>= <expr><name>newItems</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newleft</name> <init>= <expr><name>nNewItems</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>modified</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>newseg</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the page is completely empty, just construct one new segment to hold
	 * all the new items.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newseg</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newseg</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newseg</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <name>newItems</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newseg</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <name>nNewItems</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newseg</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_INSERT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newseg</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;leaf-&gt;segments</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><operator>(</operator><name>leafSegmentInfo</name> <operator>*</operator><operator>)</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nthis</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>tmpitems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntmpitems</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * How many of the new items fall into this segment?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_has_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nthis</name> <operator>=</operator> <name>newleft</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>next_first</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>next</name> <operator>=</operator> <operator>(</operator><name>leafSegmentInfo</name> <operator>*</operator><operator>)</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
													   <argument><expr><call><name>dlist_next_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>next</name><operator>-&gt;</operator><name>items</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>next_first</name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>seg</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>next_first</name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>seg</name><operator>-&gt;</operator><name>first</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>nthis</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>nthis</name> <operator>&lt;</operator> <name>newleft</name> <operator>&amp;&amp;</operator> <call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nextnew</name><index>[<expr><name>nthis</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_first</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nthis</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nthis</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Merge the new items with the existing items. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cur</name><operator>-&gt;</operator><name>items</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <call><name>ginPostingListDecode</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Fast path for the important special case that we're appending to
		 * the end of the page: don't let the last segment on the page grow
		 * larger than the target, create a new segment before that happens.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_has_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>ginCompareItemPointers</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>items</name><index>[<expr><name><name>cur</name><operator>-&gt;</operator><name>nitems</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nextnew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>cur</name><operator>-&gt;</operator><name>seg</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>GinPostingListSegmentTargetSize</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newseg</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newseg</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newseg</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <name>nextnew</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newseg</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <name>nthis</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newseg</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_INSERT</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newseg</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>tmpitems</name> <operator>=</operator> <call><name>ginMergeItemPointers</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>items</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>,
										<argument><expr><name>nextnew</name></expr></argument>, <argument><expr><name>nthis</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>ntmpitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ntmpitems</name> <operator>!=</operator> <name><name>cur</name><operator>-&gt;</operator><name>nitems</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there are no duplicates, track the added items so that we
			 * can emit a compact ADDITEMS WAL record later on. (it doesn't
			 * seem worth re-checking which items were duplicates, if there
			 * were any)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ntmpitems</name> <operator>==</operator> <name>nthis</name> <operator>+</operator> <name><name>cur</name><operator>-&gt;</operator><name>nitems</name></name> <operator>&amp;&amp;</operator>
				<name><name>cur</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>GIN_SEGMENT_UNMODIFIED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_ADDITEMS</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>modifieditems</name></name> <operator>=</operator> <name>nextnew</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>nmodifieditems</name></name> <operator>=</operator> <name>nthis</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_REPLACE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <name>tmpitems</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <name>ntmpitems</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>nextnew</name> <operator>+=</operator> <name>nthis</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newleft</name> <operator>-=</operator> <name>nthis</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newleft</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>modified</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recompresses all segments that have been modified.
 *
 * If not all the items fit on two pages (ie. after split), we store as
 * many items as fit, and set *remaining to the first item that didn't fit.
 * If all items fit, *remaining is set to invalid.
 *
 * Returns true if the page has to be split.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>leafRepackItems</name><parameter_list>(<parameter><decl><type><name>disassembledLeaf</name> <modifier>*</modifier></type><name>leaf</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>remaining</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pgused</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needsplit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>nextseg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>npacked</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>modified</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>cur_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>next_node</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * cannot use dlist_foreach_modify here because we insert adjacent items
	 * while iterating.
	 */</comment>
	<for>for <control>(<init><expr><name>cur_node</name> <operator>=</operator> <call><name>dlist_head_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>cur_node</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>cur_node</name> <operator>=</operator> <name>next_node</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>seginfo</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
												   <argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>dlist_has_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>next_node</name> <operator>=</operator> <call><name>dlist_next_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>next_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Compress the posting list, if necessary */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>GIN_SEGMENT_DELETE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name> <operator>&gt;</operator> <name>GinPostingListSegmentMaxSize</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>npacked</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* no chance that it would fit. */</comment>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <call><name>ginCompressPostingList</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name></expr></argument>,
														  <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>,
														  <argument><expr><name>GinPostingListSegmentMaxSize</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>npacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>npacked</name> <operator>!=</operator> <name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Too large. Compress again to the target size, and
					 * create a new segment to represent the remaining items.
					 * The new segment is inserted after this one, so it will
					 * be processed in the next iteration of this loop.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <call><name>ginCompressPostingList</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name></expr></argument>,
														  <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>,
														  <argument><expr><name>GinPostingListSegmentTargetSize</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>npacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>GIN_SEGMENT_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_REPLACE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>nextseg</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>nextseg</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_INSERT</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>nextseg</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>nextseg</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>seginfo</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>npacked</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>nextseg</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name> <operator>-</operator> <name>npacked</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>next_node</name> <operator>=</operator> <operator>&amp;</operator><name><name>nextseg</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>dlist_insert_after</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>, <argument><expr><name>next_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If the segment is very small, merge it with the next segment.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>GinPostingListSegmentMinSize</name> <operator>&amp;&amp;</operator> <name>next_node</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>nmerged</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>nextseg</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>next_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <call><name>ginPostingListDecode</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>nextseg</name><operator>-&gt;</operator><name>items</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>nextseg</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <call><name>ginPostingListDecode</name><argument_list>(<argument><expr><name><name>nextseg</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name><name>nextseg</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>nextseg</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator>
					<call><name>ginMergeItemPointers</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>,
										 <argument><expr><name><name>nextseg</name><operator>-&gt;</operator><name>items</name></name></expr></argument>, <argument><expr><name><name>nextseg</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>nmerged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nmerged</name> <operator>==</operator> <name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name> <operator>+</operator> <name><name>nextseg</name><operator>-&gt;</operator><name>nitems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nextseg</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <name>nmerged</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nextseg</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>nextseg</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_REPLACE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nextseg</name><operator>-&gt;</operator><name>modifieditems</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nextseg</name><operator>-&gt;</operator><name>nmodifieditems</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>GIN_SEGMENT_INSERT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>GIN_SEGMENT_DELETE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>nitems</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>GIN_SEGMENT_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * OK, we now have a compressed version of this segment ready for
		 * copying to the page. Did we exceed the size that fits on one page?
		 */</comment>
		<expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pgused</name> <operator>+</operator> <name>segsize</name> <operator>&gt;</operator> <name>GinDataPageMaxDataSize</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needsplit</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* switch to right page */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pgused</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>lastleft</name></name> <operator>=</operator> <call><name>dlist_prev_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>needsplit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name> <operator>=</operator> <name>pgused</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pgused</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Filled both pages. The last segment we constructed did not
				 * fit.
				 */</comment>
				<expr_stmt><expr><operator>*</operator><name>remaining</name> <operator>=</operator> <name><name>seginfo</name><operator>-&gt;</operator><name>seg</name><operator>-&gt;</operator><name>first</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * remove all segments that did not fit from the list.
				 */</comment>
				<while>while <condition>(<expr><call><name>dlist_has_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><call><name>dlist_next_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>leaf</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>, <argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
				<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name>cur_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>pgused</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needsplit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name> <operator>=</operator> <name>pgused</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>rsize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>leaf</name><operator>-&gt;</operator><name>rsize</name></name> <operator>=</operator> <name>pgused</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>lsize</name></name> <operator>&lt;=</operator> <name>GinDataPageMaxDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>leaf</name><operator>-&gt;</operator><name>rsize</name></name> <operator>&lt;=</operator> <name>GinDataPageMaxDataSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make a palloc'd copy of every segment after the first modified one,
	 * because as we start copying items to the original page, we might
	 * overwrite an existing segment.
	 */</comment>
	<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;leaf-&gt;segments</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>leafSegmentInfo</name> <modifier>*</modifier></type><name>seginfo</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>leafSegmentInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
												   <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modified</name> <operator>&amp;&amp;</operator> <name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>GIN_SEGMENT_UNMODIFIED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>modified</name> <operator>&amp;&amp;</operator> <name><name>seginfo</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>GIN_SEGMENT_UNMODIFIED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>seginfo</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>needsplit</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*** Functions that are exported to the rest of the GIN code ***/</comment>

<comment type="block">/*
 * Creates new posting tree containing the given TIDs. Returns the page
 * number of the root of the new posting tree.
 *
 * items[] must be in sorted order with no duplicates.
 */</comment>
<function><type><name>BlockNumber</name></type>
<name>createPostingTree</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>nitems</name></decl></parameter>,
				  <parameter><decl><type><name>GinStatsData</name> <modifier>*</modifier></type><name>buildStats</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>entrybuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>tmppage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name></type>		<name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nrootitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rootsize</name></decl>;</decl_stmt>

	<comment type="block">/* Construct the new root page in memory first. */</comment>
	<expr_stmt><expr><name>tmppage</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinInitPage</name><argument_list>(<argument><expr><name>tmppage</name></expr></argument>, <argument><expr><name>GIN_DATA</name> <operator>|</operator> <name>GIN_LEAF</name> <operator>|</operator> <name>GIN_COMPRESSED</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GinPageGetOpaque</name><argument_list>(<argument><expr><name>tmppage</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rightlink</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Write as many of the items to the root page as fit. In segments of max
	 * GinPostingListSegmentMaxSize bytes each.
	 */</comment>
	<expr_stmt><expr><name>nrootitems</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rootsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>Pointer</name><operator>)</operator> <call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>tmppage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>nrootitems</name> <operator>&lt;</operator> <name>nitems</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GinPostingList</name> <modifier>*</modifier></type><name>segment</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>npacked</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>segsize</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>segment</name> <operator>=</operator> <call><name>ginCompressPostingList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>nrootitems</name></expr>]</index></name></expr></argument>,
										 <argument><expr><name>nitems</name> <operator>-</operator> <name>nrootitems</name></expr></argument>,
										 <argument><expr><name>GinPostingListSegmentMaxSize</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>npacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>SizeOfGinPostingList</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rootsize</name> <operator>+</operator> <name>segsize</name> <operator>&gt;</operator> <name>GinDataPageMaxDataSize</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>segment</name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rootsize</name> <operator>+=</operator> <name>segsize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nrootitems</name> <operator>+=</operator> <name>npacked</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>GinDataPageSetDataSize</name><argument_list>(<argument><expr><name>tmppage</name></expr></argument>, <argument><expr><name>rootsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * All set. Get a new physical page, and copy the in-memory page to it.
	 */</comment>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>GinNewBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy any predicate locks from the entry tree leaf (containing posting
	 * list) to the posting tree.
	 */</comment>
	<expr_stmt><expr><call><name>PredicateLockPageSplit</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>entrybuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PageRestoreTempPage</name><argument_list>(<argument><expr><name>tmppage</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ginxlogCreatePostingTree</name></type> <name>data</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>data</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>rootsize</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ginxlogCreatePostingTree</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>GinDataLeafPageGetPostingList</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>rootsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_GIN_ID</name></expr></argument>, <argument><expr><name>XLOG_GIN_CREATE_PTREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* During index build, count the newly-added data page */</comment>
	<if_stmt><if>if <condition>(<expr><name>buildStats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>buildStats</name><operator>-&gt;</operator><name>nDataPages</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"created GIN posting tree with %d items"</literal></expr></argument>, <argument><expr><name>nrootitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add any remaining TIDs to the newly-created posting tree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&gt;</operator> <name>nrootitems</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ginInsertItemPointers</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>,
							  <argument><expr><name>items</name> <operator>+</operator> <name>nrootitems</name></expr></argument>,
							  <argument><expr><name>nitems</name> <operator>-</operator> <name>nrootitems</name></expr></argument>,
							  <argument><expr><name>buildStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>blkno</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ginPrepareDataScan</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>rootBlkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GinBtreeData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>rootBlkno</name></name> <operator>=</operator> <name>rootBlkno</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>findChildPage</name></name> <operator>=</operator> <name>dataLocateItem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>getLeftMostChild</name></name> <operator>=</operator> <name>dataGetLeftMostPage</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>isMoveRight</name></name> <operator>=</operator> <name>dataIsMoveRight</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>findItem</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>findChildPtr</name></name> <operator>=</operator> <name>dataFindChildPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>beginPlaceToPage</name></name> <operator>=</operator> <name>dataBeginPlaceToPage</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>execPlaceToPage</name></name> <operator>=</operator> <name>dataExecPlaceToPage</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>fillRoot</name></name> <operator>=</operator> <name>ginDataFillRoot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>prepareDownlink</name></name> <operator>=</operator> <name>dataPrepareDownlink</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>isData</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>fullScan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>isBuild</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Inserts array of item pointers, may execute several tree scan (very rare)
 */</comment>
<function><type><name>void</name></type>
<name>ginInsertItemPointers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>rootBlkno</name></decl></parameter>,
					  <parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>nitem</name></decl></parameter>,
					  <parameter><decl><type><name>GinStatsData</name> <modifier>*</modifier></type><name>buildStats</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinBtreeData</name></type> <name>btree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinBtreeDataLeafInsertData</name></type> <name>insertdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ginPrepareDataScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btree</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>rootBlkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btree</name><operator>.</operator><name>isBuild</name></name> <operator>=</operator> <operator>(</operator><name>buildStats</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertdata</name><operator>.</operator><name>items</name></name> <operator>=</operator> <name>items</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertdata</name><operator>.</operator><name>nitem</name></name> <operator>=</operator> <name>nitem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>insertdata</name><operator>.</operator><name>curitem</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>insertdata</name><operator>.</operator><name>curitem</name></name> <operator>&lt;</operator> <name><name>insertdata</name><operator>.</operator><name>nitem</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* search for the leaf page where the first item should go to */</comment>
		<expr_stmt><expr><name><name>btree</name><operator>.</operator><name>itemptr</name></name> <operator>=</operator> <name><name>insertdata</name><operator>.</operator><name>items</name><index>[<expr><name><name>insertdata</name><operator>.</operator><name>curitem</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>ginFindLeafPage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btree</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ginInsertValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btree</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>insertdata</name></expr></argument>, <argument><expr><name>buildStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Starts a new scan on a posting tree.
 */</comment>
<function><type><name>GinBtreeStack</name> <modifier>*</modifier></type>
<name>ginScanBeginPostingTree</name><parameter_list>(<parameter><decl><type><name>GinBtree</name></type> <name>btree</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>rootBlkno</name></decl></parameter>,
						<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GinBtreeStack</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ginPrepareDataScan</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>rootBlkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>btree</name><operator>-&gt;</operator><name>fullScan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>ginFindLeafPage</name><argument_list>(<argument><expr><name>btree</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stack</name></expr>;</return>
</block_content>}</block></function>
</unit>
