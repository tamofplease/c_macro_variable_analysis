<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/hash/hashinsert.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * hashinsert.c
 *	  Item insertion in hash tables for Postgres.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/access/hash/hashinsert.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buf_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_hash_vacuum_one_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
					  <parameter><decl><type><name>RelFileNode</name></type> <name>hnode</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 *	_hash_doinsert() -- Handle insertion of a single index tuple.
 *
 *		This routine is called by the public interface routines, hashbuild
 *		and hashinsert.  By here, itup is completely filled in.
 */</comment>
<function><type><name>void</name></type>
<name>_hash_doinsert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buf</name> <init>= <expr><name>InvalidBuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>bucket_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>metabuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>usedmetap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>metapage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>pageopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>itemsz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>do_expand</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bucket</name></type>		<name>bucket</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the hash key for the item (it's stored in the index tuple itself).
	 */</comment>
	<expr_stmt><expr><name>hashkey</name> <operator>=</operator> <call><name>_hash_get_indextuple_hashkey</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* compute item size too */</comment>
	<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemsz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* be safe, PageAddItem will do this but we
								 * need to be consistent */</comment>

<label><name>restart_insert</name>:</label>

	<comment type="block">/*
	 * Read the metapage.  We don't lock it yet; HashMaxItemSize() will
	 * examine pd_pagesize_version, but that can't change so we can examine it
	 * without a lock.
	 */</comment>
	<expr_stmt><expr><name>metabuf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>HASH_METAPAGE</name></expr></argument>, <argument><expr><name>HASH_NOLOCK</name></expr></argument>, <argument><expr><name>LH_META_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>metapage</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check whether the item can fit on a hash page at all. (Eventually, we
	 * ought to try to apply TOAST methods if not.)  Note that at this point,
	 * itemsz doesn't include the ItemId.
	 *
	 * XXX this is useless code if we are only storing hash keys.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>itemsz</name> <operator>&gt;</operator> <call><name>HashMaxItemSize</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row size %zu exceeds hash maximum %zu"</literal></expr></argument>,
						<argument><expr><name>itemsz</name></expr></argument>, <argument><expr><call><name>HashMaxItemSize</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Values larger than a buffer page cannot be indexed."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Lock the primary bucket page for the target bucket. */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_hash_getbucketbuf_from_hashkey</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>hashkey</name></expr></argument>, <argument><expr><name>HASH_WRITE</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>usedmetap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>usedmetap</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CheckForSerializableConflictIn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* remember the primary bucket buffer to release the pin on it at end. */</comment>
	<expr_stmt><expr><name>bucket_buf</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pageopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bucket</name> <operator>=</operator> <name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this bucket is in the process of being split, try to finish the
	 * split before inserting, because that might create room for the
	 * insertion to proceed without allocating an additional overflow page.
	 * It's only interesting to finish the split if we're trying to insert
	 * into the bucket from which we're removing tuples (the "old" bucket),
	 * not if we're trying to insert into the bucket into which tuples are
	 * being moved (the "new" bucket).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>H_BUCKET_BEING_SPLIT</name><argument_list>(<argument><expr><name>pageopaque</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsBufferCleanupOK</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* release the lock on bucket buffer, before completing the split. */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>_hash_finish_split</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>,
						   <argument><expr><name><name>usedmetap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name></expr></argument>,
						   <argument><expr><name><name>usedmetap</name><operator>-&gt;</operator><name>hashm_highmask</name></name></expr></argument>,
						   <argument><expr><name><name>usedmetap</name><operator>-&gt;</operator><name>hashm_lowmask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* release the pin on old and meta buffer.  retry for insert. */</comment>
		<expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>restart_insert</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Do the insertion */</comment>
	<while>while <condition>(<expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>itemsz</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nextblkno</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check if current page has any DEAD tuples. If yes, delete these
		 * tuples and see if we can get a space for the new item to be
		 * inserted before moving to the next page in the bucket chain.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>H_HAS_DEAD_TUPLES</name><argument_list>(<argument><expr><name>pageopaque</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>

			<if_stmt><if>if <condition>(<expr><call><name>IsBufferCleanupOK</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>_hash_vacuum_one_page</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>heapRel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>itemsz</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* OK, now we have enough space */</comment>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * no space on this page; check for an overflow page
		 */</comment>
		<expr_stmt><expr><name>nextblkno</name> <operator>=</operator> <name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_nextblkno</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name>nextblkno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ovfl page exists; go get it.  if it doesn't have room, we'll
			 * find out next pass through the loop test above.  we always
			 * release both the lock and pin if this is an overflow page, but
			 * only the lock if this is the primary bucket page, since the pin
			 * on the primary bucket must be retained throughout the scan.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>bucket_buf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_hash_getbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>nextblkno</name></expr></argument>, <argument><expr><name>HASH_WRITE</name></expr></argument>, <argument><expr><name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * we're at the end of the bucket chain and we haven't found a
			 * page with enough room.  allocate a new overflow page.
			 */</comment>

			<comment type="block">/* release our write lock without modifying buffer */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* chain to a new overflow page */</comment>
			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>_hash_addovflpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>buf</name> <operator>==</operator> <name>bucket_buf</name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* should fit now, given test above */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PageGetFreeSpace</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>itemsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>pageopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>&amp;</operator> <name>LH_PAGE_TYPE</name><operator>)</operator> <operator>==</operator> <name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_bucket</name></name> <operator>==</operator> <name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Write-lock the metapage so we can increment the tuple count. After
	 * incrementing it, check to see if it's time for a split.
	 */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do the update.  No ereport(ERROR) until changes are logged */</comment>
	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* found page with enough space, so add the item here */</comment>
	<expr_stmt><expr><name>itup_off</name> <operator>=</operator> <call><name>_hash_pgaddtup</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>itemsz</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* metapage operations */</comment>
	<expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ntuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Make sure this stays in sync with _hash_expandtable() */</comment>
	<expr_stmt><expr><name>do_expand</name> <operator>=</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_ntuples</name></name> <operator>&gt;</operator>
		<operator>(</operator><name>double</name><operator>)</operator> <name><name>metap</name><operator>-&gt;</operator><name>hashm_ffactor</name></name> <operator>*</operator> <operator>(</operator><name><name>metap</name><operator>-&gt;</operator><name>hashm_maxbucket</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>xl_hash_insert</name></type> <name>xlrec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>offnum</name></name> <operator>=</operator> <name>itup_off</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHashInsert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBufData</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HASH_ID</name></expr></argument>, <argument><expr><name>XLOG_HASH_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* drop lock on metapage, but keep pin */</comment>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release the modified page and ensure to release the pin on primary
	 * page.
	 */</comment>
	<expr_stmt><expr><call><name>_hash_relbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>bucket_buf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>bucket_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Attempt to split if a split is needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>do_expand</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_hash_expandtable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Finally drop our pin on the metapage */</comment>
	<expr_stmt><expr><call><name>_hash_dropbuf</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	_hash_pgaddtup() -- add a tuple to a particular page in the index.
 *
 * This routine adds the tuple to the page as requested; it does not write out
 * the page.  It is an error to call pgaddtup() without pin and write lock on
 * the target buffer.
 *
 * Returns the offset number at which the tuple was inserted.  This function
 * is responsible for preserving the condition that tuples in a hash index
 * page are sorted by hashkey value.
 */</comment>
<function><type><name>OffsetNumber</name></type>
<name>_hash_pgaddtup</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>itemsize</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashkey</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>_hash_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>LH_BUCKET_PAGE</name> <operator>|</operator> <name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find where to insert the tuple (preserving page's hashkey ordering) */</comment>
	<expr_stmt><expr><name>hashkey</name> <operator>=</operator> <call><name>_hash_get_indextuple_hashkey</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itup_off</name> <operator>=</operator> <call><name>_hash_binsearch</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>hashkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name>itup</name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>, <argument><expr><name>itup_off</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call>
		<operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add index item to \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>itup_off</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	_hash_pgaddmultitup() -- add a tuple vector to a particular page in the
 *							 index.
 *
 * This routine has same requirements for locking and tuple ordering as
 * _hash_pgaddtup().
 *
 * Returns the offset number array at which the tuples were inserted.
 */</comment>
<function><type><name>void</name></type>
<name>_hash_pgaddmultitup</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itups</name></decl></parameter>,
					<parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>itup_offsets</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>nitups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>itup_off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>_hash_checkpage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>LH_BUCKET_PAGE</name> <operator>|</operator> <name>LH_OVERFLOW_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>itemsize</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>itemsize</name> <operator>=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name><name>itups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itemsize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>itemsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Find where to insert the tuple (preserving page's hashkey ordering) */</comment>
		<expr_stmt><expr><name>hashkey</name> <operator>=</operator> <call><name>_hash_get_indextuple_hashkey</name><argument_list>(<argument><expr><name><name>itups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>itup_off</name> <operator>=</operator> <call><name>_hash_binsearch</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>hashkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>itup_offsets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>itup_off</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PageAddItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>Item</name><operator>)</operator> <name><name>itups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>itemsize</name></expr></argument>, <argument><expr><name>itup_off</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call>
			<operator>==</operator> <name>InvalidOffsetNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to add index item to \"%s\""</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * _hash_vacuum_one_page - vacuum just one index page.
 *
 * Try to remove LP_DEAD items from the given page. We must acquire cleanup
 * lock on the page being modified before calling this function.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_hash_vacuum_one_page</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>metabuf</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buf</name></decl></parameter>,
					  <parameter><decl><type><name>RelFileNode</name></type> <name>hnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>deletable</name><index>[<expr><name>MaxOffsetNumber</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndeletable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>,
				<decl><type ref="prev"/><name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashPageOpaque</name></type> <name>pageopaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HashMetaPage</name></type> <name>metap</name></decl>;</decl_stmt>

	<comment type="block">/* Scan each tuple in page to see if it is marked as LP_DEAD */</comment>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>offnum</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init>
		 <condition><expr><name>offnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition>
		 <incr><expr><name>offnum</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>itemId</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>itemId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>deletable</name><index>[<expr><name>ndeletable</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>ndeletable</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Write-lock the meta page so that we can decrement tuple count.
		 */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* No ereport(ERROR) until changes are logged */</comment>
		<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PageIndexMultiDelete</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>deletable</name></expr></argument>, <argument><expr><name>ndeletable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Mark the page as not containing any LP_DEAD items. This is not
		 * certainly true (there might be some that have recently been marked,
		 * but weren't included in our target-item list), but it will almost
		 * always be true and it doesn't seem worth an additional page scan to
		 * check it. Remember that LH_PAGE_HAS_DEAD_TUPLES is only a hint
		 * anyway.
		 */</comment>
		<expr_stmt><expr><name>pageopaque</name> <operator>=</operator> <operator>(</operator><name>HashPageOpaque</name><operator>)</operator> <call><name>PageGetSpecialPointer</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pageopaque</name><operator>-&gt;</operator><name>hasho_flag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LH_PAGE_HAS_DEAD_TUPLES</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>metap</name> <operator>=</operator> <call><name>HashPageGetMeta</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>metap</name><operator>-&gt;</operator><name>hashm_ntuples</name></name> <operator>-=</operator> <name>ndeletable</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* XLOG stuff */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>xl_hash_vacuum_one_page</name></type> <name>xlrec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>hnode</name></name> <operator>=</operator> <name>hnode</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>xlrec</name><operator>.</operator><name>ntuples</name></name> <operator>=</operator> <name>ndeletable</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xlrec</name></expr></argument>, <argument><expr><name>SizeOfHashVacuumOnePage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We need the target-offsets array whether or not we store the
			 * whole buffer, to allow us to find the latestRemovedXid on a
			 * standby server.
			 */</comment>
			<expr_stmt><expr><call><name>XLogRegisterData</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>deletable</name></expr></argument>,
							 <argument><expr><name>ndeletable</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>REGBUF_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_HASH_ID</name></expr></argument>, <argument><expr><name>XLOG_HASH_VACUUM_ONE_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Releasing write lock on meta page as we have updated the tuple
		 * count.
		 */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>metabuf</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
