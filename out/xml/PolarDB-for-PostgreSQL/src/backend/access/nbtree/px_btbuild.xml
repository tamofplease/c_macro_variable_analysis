<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/nbtree/px_btbuild.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * px_btbuild.c
 *		Build a btree from sorted using PolarDB Parallel Execution.
 *
 * Copyright (c) 2020, Alibaba Group Holding Limited
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *		src/backend/access/nbtree/px_btbuild.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>IndexTuple</name></type> <name>index_form_tuple_noalloc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>free</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>used</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PxWorkerstate</name> <modifier>*</modifier></type> <name>_bt_start_pxworker</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_produce_pxworker</name><parameter_list>(<parameter><decl><type><name>PxWorkerstate</name> <modifier>*</modifier></type><name>px</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_finish_pxworker</name><parameter_list>(<parameter><decl><type><name>PxWorkerstate</name> <modifier>*</modifier></type><name>px</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_begin_pxworker</name><parameter_list>(<parameter><decl><type><name>BTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, 
								<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isconcurrent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_px_init_buffer</name><parameter_list>(<parameter><decl><type><name>PxIndexTupleBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_leafbuild_pxleader</name><parameter_list>(<parameter><decl><type><name>PxLeaderstate</name> <modifier>*</modifier></type><name>px</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_finish_pxleader</name><parameter_list>(<parameter><decl><type><name>PxLeaderstate</name> <modifier>*</modifier></type><name>pxleader</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IndexBuildResult</name> <modifier>*</modifier></type><name>pxbuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IndexTuple</name></type> <name>_bt_consume_pxleader</name><parameter_list>(<parameter><decl><type><name>PxLeaderstate</name> <modifier>*</modifier></type><name>pxleader</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_px_alloc_page_buffer</name><parameter_list>(<parameter><decl><type><name>PxIndexPageBuffer</name> <modifier>*</modifier><modifier>*</modifier></type><name>px_index_buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_px_blwritepage</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_px_flush_blpage</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_bt_px_bulkwrite</name><parameter_list>(<parameter><decl><type><name>SMgrRelationData</name> <modifier>*</modifier></type><name>rd_smgr</name></decl></parameter>, <parameter><decl><type><name>PxIndexPageBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>px_bulk_write_page_valid</name><parameter_list>(<parameter><decl><type><name>PxIndexPageBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>IndexTuple</name></type>
<name>index_form_tuple_noalloc</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
				 <parameter><decl><type><name>Size</name></type> <name>free</name></decl></parameter>,
				 <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>used</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>				<comment type="block">/* tuple pointer */</comment>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>			<comment type="block">/* return tuple */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>,
				<decl><type ref="prev"/><name>data_size</name></decl>,
				<decl><type ref="prev"/><name>hoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>infomask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>tupmask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numberOfAttributes</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TOAST_INDEX_HACK</name></cpp:ifdef>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>untoasted_values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>untoasted_free</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>numberOfAttributes</name> <operator>&gt;</operator> <name>INDEX_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of index columns (%d) exceeds limit (%d)"</literal></expr></argument>,
						<argument><expr><name>numberOfAttributes</name></expr></argument>, <argument><expr><name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TOAST_INDEX_HACK</name></cpp:ifdef>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>untoasted_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Do nothing if value is NULL or not of varlena type */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If value is stored EXTERNAL, must fetch it so we are not depending
		 * on outside storage.  This should be improved someday.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>VARATT_IS_EXTERNAL</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
				<call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>heap_tuple_fetch_attr</name><argument_list>(<argument><expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator>
													  <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>untoasted_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If value is above size target, and is of a compressible datatype,
		 * try to compress it in-line.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>VARSIZE</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>TOAST_INDEX_TARGET</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>==</operator> <literal type="char">'m'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>cvalue</name> <init>= <expr><call><name>toast_compress_datum</name><argument_list>(<argument><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>cvalue</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* successful compression */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>untoasted_free</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>untoasted_values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cvalue</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>untoasted_free</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfAttributes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>hasnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>infomask</name> <operator>|=</operator> <name>INDEX_NULL_MASK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hoff</name> <operator>=</operator> <call><name>IndexInfoFindDataOffset</name><argument_list>(<argument><expr><name>infomask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TOAST_INDEX_HACK</name></cpp:ifdef>
	<expr_stmt><expr><name>data_size</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
									   <argument><expr><name>untoasted_values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>data_size</name> <operator>=</operator> <call><name>heap_compute_data_size</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
									   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <name>hoff</name> <operator>+</operator> <name>data_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* be conservative */</comment>

	<expr_stmt><expr><operator>*</operator><name>used</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>free</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <name>tp</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_fill_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TOAST_INDEX_HACK</name></cpp:ifdef>
					<argument><expr><name>untoasted_values</name></expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<argument><expr><name>values</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<argument><expr><name>isnull</name></expr></argument>,
					<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tp</name> <operator>+</operator> <name>hoff</name></expr></argument>,
					<argument><expr><name>data_size</name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>tupmask</name></expr></argument>,
					<argument><expr><operator>(</operator><ternary><condition><expr><name>hasnull</name></expr> ?</condition><then> <expr><operator>(</operator><name>bits8</name> <operator>*</operator><operator>)</operator> <name>tp</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We do this because heap_fill_tuple wants to initialize a "tupmask"
	 * which is used for HeapTuples, but we want an indextuple infomask. The
	 * only relevant info is the "has variable attributes" field. We have
	 * already set the hasnull bit above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupmask</name> <operator>&amp;</operator> <name>HEAP_HASVARWIDTH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>infomask</name> <operator>|=</operator> <name>INDEX_VAR_MASK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also assert we got rid of external attributes */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TOAST_INDEX_HACK</name></cpp:ifdef>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>tupmask</name> <operator>&amp;</operator> <name>HEAP_HASEXTERNAL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Here we make sure that the size will fit in the field reserved for it
	 * in t_info.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size</name> <operator>&amp;</operator> <name>INDEX_SIZE_MASK</name><operator>)</operator> <operator>!=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index row requires %zu bytes, maximum size is %zu"</literal></expr></argument>,
						<argument><expr><name>size</name></expr></argument>, <argument><expr><operator>(</operator><name>Size</name><operator>)</operator> <name>INDEX_SIZE_MASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>infomask</name> <operator>|=</operator> <name>size</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * initialize metadata
	 */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_info</name></name> <operator>=</operator> <name>infomask</name></expr>;</expr_stmt>
	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>pxbuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexBuildResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BTBuildState</name></type> <name>buildstate</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * check if pxbuild can be used.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PX index build does not support expr index now"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We expect to be called exactly once for any index relation. If that's
	 * not the case, big trouble's what we have.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_check_nblocks_consistent</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index \"%s\" already contains data"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>isunique</name></name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>havedead</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>heap</name></name> <operator>=</operator> <name>heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>spool</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>spool2</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>indtuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>btleader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>pxleader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_info_debug</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"btbuild px with %d workers"</literal></expr></argument>,  <argument><expr><call><name>getPxWorkerCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>_bt_begin_pxworker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buildstate</name></expr></argument>, <argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_leafbuild_pxleader</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>pxleader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_finish_pxleader</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>pxleader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>IndexBuildResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBuildResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>heap_tuples</name></name> <operator>=</operator> <name><name>buildstate</name><operator>.</operator><name>pxleader</name><operator>-&gt;</operator><name>processed</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>index_tuples</name></name> <operator>=</operator> <name><name>buildstate</name><operator>.</operator><name>indtuples</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_px_btbuild_update_pg_class</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_px_bt_build_main</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl></parameter>, <parameter><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sharedquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxShared</name>   <modifier>*</modifier></type><name>shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>heapLockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>indexLockmode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>bufferusage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxWorkerstate</name> <modifier>*</modifier></type><name>pxstate</name></decl>;</decl_stmt>

	<comment type="block">/* Set debug_query_string for individual workers first */</comment>
	<expr_stmt><expr><name>sharedquery</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PX_KEY_QUERY_TEXT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>sharedquery</name></expr>;</expr_stmt>

	<comment type="block">/* Report the query string from leader */</comment>
	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up nbtree shared state */</comment>
	<expr_stmt><expr><name>shared</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PX_KEY_BTREE_SHARED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open relations using lock modes known to be obtained by index.c */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>isconcurrent</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>heapLockmode</name> <operator>=</operator> <name>ShareLock</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexLockmode</name> <operator>=</operator> <name>AccessExclusiveLock</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>heapLockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexLockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Open relations within worker */</comment>
	<expr_stmt><expr><name>heapRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>heaprelid</name></name></expr></argument>, <argument><expr><name>heapLockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>, <argument><expr><name>indexLockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pxstate</name> <operator>=</operator> <call><name>_bt_start_pxworker</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pxstate</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <name>shared</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bt_produce_pxworker</name><argument_list>(<argument><expr><name>pxstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_bt_finish_pxworker</name><argument_list>(<argument><expr><name>pxstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Prepare to track buffer usage during parallel execution */</comment>
	<expr_stmt><expr><call><name>InstrStartParallelQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report buffer usage during parallel execution */</comment>
	<expr_stmt><expr><name>bufferusage</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PX_KEY_BUFFER_USAGE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InstrEndParallelQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufferusage</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BTREE_BUILD_STATS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>log_btree_build_stats</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"BTREE BUILD (Worker Partial Spool) STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* BTREE_BUILD_STATS */</comment>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>indexLockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>heapLockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PxWorkerstate</name> <modifier>*</modifier></type>
<name>_bt_start_pxworker</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>old_enable_px</name> <init>= <expr><name>polar_enable_px</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>old_px_plancache</name> <init>= <expr><name>px_enable_plan_cache</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>old_px_index</name> <init>= <expr><name>px_optimizer_enable_indexscan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>old_px_indexonly</name> <init>= <expr><name>px_optimizer_enable_indexonlyscan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>old_px_check_workers</name> <init>= <expr><name>px_enable_check_workers</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>old_px_tx</name> <init>= <expr><name>px_enable_transaction</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>old_px_replay_wait</name> <init>= <expr><name>px_enable_replay_wait</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PxWorkerstate</name> <modifier>*</modifier></type><name>px</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PxWorkerstate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>px</name><operator>-&gt;</operator><name>fetch_end</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>px</name><operator>-&gt;</operator><name>sql</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* generate sql */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> 	<name>attrs</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>		<comment type="block">/* attrs in SELECT clause */</comment>
		<decl_stmt><decl><type><name>StringInfo</name></type>	<name>sortattrs</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>	<comment type="block">/* attrs in ORDER BY clause */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdes</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> 		<name>natts</name> <init>= <expr><name><name>tupdes</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKey</name></type> 	<name>scankey</name> <init>= <expr><call><name>_bt_mkscankey_nodata</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>natts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>scankey</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><literal type="string">", %s"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sortattrs</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>scankey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_DESC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sortattrs</name></expr></argument>, <argument><expr><literal type="string">"desc "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>scankey</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_BT_NULLS_FIRST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sortattrs</name></expr></argument>, <argument><expr><literal type="string">"nulls first "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sortattrs</name></expr></argument>, <argument><expr><literal type="string">"nulls last "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>natts</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sortattrs</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>px</name><operator>-&gt;</operator><name>sql</name></name></expr></argument>, <argument><expr><literal type="string">"select _root_ctid %s from %s order by %s"</literal></expr></argument>,
			<argument><expr><name><name>attrs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sortattrs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"sql: %s"</literal></expr></argument>, <argument><expr><name><name>px</name><operator>-&gt;</operator><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>px</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <name>heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>px</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>px</name><operator>-&gt;</operator><name>tv1</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* invoke SPI */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>polar_enable_px</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_optimizer_enable_indexscan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_optimizer_enable_indexonlyscan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_enable_check_workers</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_enable_plan_cache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_enable_transaction</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_enable_replay_wait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>px</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <call><name>SPI_prepare_px</name><argument_list>(<argument><expr><name><name>px</name><operator>-&gt;</operator><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare(\"%s\") failed"</literal></expr></argument>, <argument><expr><name><name>px</name><operator>-&gt;</operator><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>px</name><operator>-&gt;</operator><name>portal</name></name> <operator>=</operator> <call><name>SPI_cursor_open</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>px</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open(\"%s\") failed"</literal></expr></argument>, <argument><expr><name><name>px</name><operator>-&gt;</operator><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<block>{<block_content>
		<expr_stmt><expr><name>polar_enable_px</name> <operator>=</operator> <name>old_enable_px</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_optimizer_enable_indexscan</name> <operator>=</operator> <name>old_px_index</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_optimizer_enable_indexonlyscan</name> <operator>=</operator> <name>old_px_indexonly</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_enable_check_workers</name> <operator>=</operator> <name>old_px_check_workers</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_enable_plan_cache</name> <operator>=</operator> <name>old_px_plancache</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_enable_transaction</name> <operator>=</operator> <name>old_px_tx</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_enable_replay_wait</name> <operator>=</operator> <name>old_px_replay_wait</name></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>px</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_fetch_all_index_buffer</name><parameter_list>(<parameter><decl><type><name>PxWorkerstate</name> <modifier>*</modifier></type><name>pxworker</name></decl></parameter>, <parameter><decl><type><name>PxIndexTupleBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>begin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>begin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SPI_processed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>	   <name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>	   <name><name>nulls</name><index>[<expr><name>INDEX_MAX_KEYS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>  <name>ituple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>ip</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>used</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name> <init>= <expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ip</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ituple</name> <operator>=</operator> <call><name>index_form_tuple_noalloc</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>values</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										<argument><expr><name>nulls</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										<argument><expr><call><name>POLAR_GET_PX_ITUPLE_MEM</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>buffer</name><operator>-&gt;</operator><name>ioffset</name></name></expr></argument>,
										<argument><expr><name>px_btbuild_mem_size</name> <operator>-</operator> <name><name>buffer</name><operator>-&gt;</operator><name>ioffset</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ituple</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pxworker</name><operator>-&gt;</operator><name>last_produce</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pxworker</name><operator>-&gt;</operator><name>fetch_end</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"btbuild px worker, put index tuple, buffer %d, offset %d, citd (%u, %u)"</literal></expr></argument>, 
		<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>ioffset</name></name></expr></argument>,
		<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ituple</name><operator>-&gt;</operator><name>t_tid</name></name> <operator>=</operator> <operator>*</operator><name>ip</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>addr</name><index>[<expr><name><name>buffer</name><operator>-&gt;</operator><name>icount</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>ioffset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>ioffset</name></name> <operator>+=</operator> <name>used</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pxworker</name><operator>-&gt;</operator><name>processed</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR PX: create a parallel context for px btbuild.
 * PxShared is a varlen structure. It contains px_btbuild_queue_size PxIndexTupleBuffer and
 * each PxIndexTupleBuffer contains px_btbuild_mem_size size of mem.
 * So the structure of PxShared is defined as::
 * +--------------------------------------------------------------------------+
 * | heaprelid indexrelid isunique ... done                                   |
 * +--------------------------------------------------------------------------+
 * | PxIndexTupleBuffer1 PxIndexTupleBuffer1-&gt;ituple PxIndexTupleBuffer1-&gt;mem |
 * +--------------------------------------------------------------------------+
 * | PxIndexTupleBuffer2 PxIndexTupleBuffer2-&gt;ituple PxIndexTupleBuffer2-&gt;mem |
 * +--------------------------------------------------------------------------+
 * |			         ...                                                  |
 * +--------------------------------------------------------------------------+
 * | PxIndexTupleBuffern PxIndexTupleBuffern-&gt;ituple PxIndexTupleBuffern-&gt;mem |
 * +--------------------------------------------------------------------------+
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_begin_pxworker</name><parameter_list>(<parameter><decl><type><name>BTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isconcurrent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>pxbtshared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> 		<name>itbuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>batchsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> 		<name>memsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxShared</name>   <modifier>*</modifier></type><name>shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferUsage</name> <modifier>*</modifier></type><name>bufferusage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxLeaderstate</name> <modifier>*</modifier></type><name>pxleader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sharedquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>querylen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>pxleader</name></name> <operator>=</operator> <name>pxleader</name> <operator>=</operator> <operator>(</operator><name>PxLeaderstate</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PxLeaderstate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pxleader</name><operator>-&gt;</operator><name>tv1</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Enter parallel mode, and create context for px parallel build of btree
	 * index
	 */</comment>
	<expr_stmt><expr><call><name>EnterParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pcxt</name> <operator>=</operator> <call><name>CreateParallelContext</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>, <argument><expr><literal type="string">"polar_px_bt_build_main"</literal></expr></argument>,
								 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Prepare for scan of the base relation.  In a normal index build, we use
	 * SnapshotAny because we must retrieve all tuples and do our own time
	 * qual checks (because we have to index RECENTLY_DEAD tuples).  In a
	 * concurrent build, we take a regular MVCC snapshot and index whatever's
	 * live according to that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isconcurrent</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name>SnapshotAny</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Estimate size for our own PARALLEL_KEY_BTREE_SHARED workspace, and
	 * PARALLEL_KEY_TUPLESORT tuplesort workspace
	 */</comment>
	<expr_stmt><expr><name>pxbtshared</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PxShared</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* calculate the size of PxIndexTupleBuffer for PxShared */</comment>
	<expr_stmt><expr><name>itbuffer</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PxIndexTupleBuffer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>px_btbuild_queue_size</name></expr>;</expr_stmt>

	<comment type="block">/* calculate the size of addr for PxIndexTupleBuffer */</comment>
	<expr_stmt><expr><name>batchsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>px_btbuild_batch_size</name> <operator>*</operator> <name>px_btbuild_queue_size</name></expr>;</expr_stmt>

	<comment type="block">/* calculate the size of mem for PxIndexTupleBuffer */</comment>
	<expr_stmt><expr><name>memsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>px_btbuild_mem_size</name> <operator>*</operator> <name>px_btbuild_queue_size</name> <operator>*</operator> <operator>(</operator><name>INDEX_MAX_KEYS</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>pxbtshared</name> <operator>+=</operator> <name>itbuffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pxbtshared</name> <operator>+=</operator> <name>batchsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pxbtshared</name> <operator>+=</operator> <name>memsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>pxbtshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finally, estimate PARALLEL_KEY_QUERY_TEXT space */</comment>
	<expr_stmt><expr><name>querylen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>querylen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Everyone's had a chance to ask for space, so now create the DSM */</comment>
	<expr_stmt><expr><call><name>InitializeParallelDSM</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If no DSM segment was available, back out (do serial build) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>DestroyParallelContext</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExitParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"btbuild alloc px parallel worker dsm failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Store shared build state, for which we reserved space */</comment>
	<expr_stmt><expr><name>shared</name> <operator>=</operator> <operator>(</operator><name>PxShared</name><operator>*</operator><operator>)</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>pxbtshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Initialize immutable state */</comment>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>heaprelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>indexrelid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>isconcurrent</name></name> <operator>=</operator> <name>isconcurrent</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ConditionVariableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Initialize mutable state */</comment>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>bfilled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>bc</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>bp</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PX_KEY_BTREE_SHARED</name></expr></argument>, <argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Store query string for workers */</comment>
	<expr_stmt><expr><name>sharedquery</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>querylen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>sharedquery</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>, <argument><expr><name>querylen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PX_KEY_QUERY_TEXT</name></expr></argument>, <argument><expr><name>sharedquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate space for each worker's BufferUsage; no need to initialize */</comment>
	<expr_stmt><expr><name>bufferusage</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
								   <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PX_KEY_BUFFER_USAGE</name></expr></argument>, <argument><expr><name>bufferusage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Launch workers, saving status for leader/caller */</comment>
	<expr_stmt><expr><call><name>LaunchParallelWorkers</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If no workers were successfully launched, back out (do serial build) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"btbuild launch px parallel worker failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Save leader state now that it's clear build will be parallel */</comment>
	<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>heap</name></name> <operator>=</operator> <name>heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <name>shared</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>bufferidx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>pcxt</name></name> <operator>=</operator> <name>pcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>bufferusage</name></name> <operator>=</operator> <name>bufferusage</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>waittimes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Caller needs to wait for all launched workers when we return.  Make
	 * sure that the failure-to-start case will not hang forever.
	 */</comment>
	<expr_stmt><expr><call><name>WaitForParallelWorkersToAttach</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_produce_pxworker</name><parameter_list>(<parameter><decl><type><name>PxWorkerstate</name> <modifier>*</modifier></type><name>pxworker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxShared</name>   <modifier>*</modifier></type><name>shared</name> <init>= <expr><name><name>pxworker</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxIndexTupleBuffer</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pxworker</name><operator>-&gt;</operator><name>tv2</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* get free buffer */</comment>
		<block>{<block_content>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>bfilled</name></name> <operator>&lt;</operator> <name>px_btbuild_queue_size</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type> <name>bpnext</name> <init>= <expr><call><name>PxQueueNext</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>bp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>bp</name></name> <operator>=</operator> <name>bpnext</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>POLAR_GET_PX_ITUPLE</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>bpnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"btbuild px worker get buffer ok %d"</literal></expr></argument>, <argument><expr><name>bpnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pxworker</name><operator>-&gt;</operator><name>waittimes</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"btbuild px worker get buffer waitting %lu"</literal></expr></argument>, <argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>waittimes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>,
									<argument><expr><name>WAIT_EVENT_PARALLEL_CREATE_INDEX_SCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_px_init_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/**
		 *  fetch tuple from qc, fill into buffer
		 * 	after fetch, these tuples must be fill into buffer
		 */</comment>
		<block>{<block_content>
			<comment type="block">/* fetch tuples from the last produce location at location pxworker-&gt;last_produce */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pxworker</name><operator>-&gt;</operator><name>fetch_end</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>polar_fetch_all_index_buffer</name><argument_list>(<argument><expr><name>pxworker</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>last_produce</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>produce_buffer</name>;</goto></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * already fetched all the tuples from the last produce location,
			 * reset the location and fetch new tuples.
			 */</comment>
			<expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>portal</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>px_btbuild_batch_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pxworker</name><operator>-&gt;</operator><name>fetch_end</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ConditionVariableSignal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pxworker</name><operator>-&gt;</operator><name>tv4</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* fetch from the new tuples at location 0 */</comment>
			<expr_stmt><expr><name><name>pxworker</name><operator>-&gt;</operator><name>last_produce</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pxworker</name><operator>-&gt;</operator><name>fetch_end</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>polar_fetch_all_index_buffer</name><argument_list>(<argument><expr><name>pxworker</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>produce_buffer</name>;</goto></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<label><name>produce_buffer</name>:</label>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>bfilled</name></name> <operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ConditionVariableSignal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>processbuffers</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pxworker</name><operator>-&gt;</operator><name>tv3</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>pxworker</name><operator>-&gt;</operator><name>processbuffers</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_finish_pxworker</name><parameter_list>(<parameter><decl><type><name>PxWorkerstate</name> <modifier>*</modifier></type><name>pxworker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>px_info_debug</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"btbiuld px worker finish,  open cursor: %ldms, first fetch: %ldms, total fetch: %ldms, total processd: %lu, total buffers: %lu, total waittimes: %lu"</literal></expr></argument>, 
			<argument><expr><call><name>TvDiff</name><argument_list>(<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>tv2</name></name></expr></argument>, <argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>tv1</name></name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>TvDiff</name><argument_list>(<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>tv3</name></name></expr></argument>, <argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>tv2</name></name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>TvDiff</name><argument_list>(<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>tv4</name></name></expr></argument>, <argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>tv2</name></name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>processed</name></name></expr></argument>, 
			<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>processbuffers</name></name></expr></argument>,
			<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>waittimes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>portal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_freeplan</name><argument_list>(<argument><expr><name><name>pxworker</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IndexTuple</name></type>
<name>_bt_consume_pxleader</name><parameter_list>(<parameter><decl><type><name>PxLeaderstate</name> <modifier>*</modifier></type><name>pxleader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxShared</name> <modifier>*</modifier></type><name>shared</name> <init>= <expr><name><name>pxleader</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxIndexTupleBuffer</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name><name>pxleader</name><operator>-&gt;</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* get on indextuple */</comment>
		<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>idx</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>icount</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type> <name>offset</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>addr</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>idx</name></name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexTuple</name></type> <name>itup</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator><operator>(</operator><call><name>POLAR_GET_PX_ITUPLE_MEM</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>offset</name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"btbuild px leader, get index tuple, buffer %d, offset %lu, citd (%u, %u)"</literal></expr></argument>, 
					<argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>bufferidx</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, 
					<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if<condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>processed</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pxleader</name><operator>-&gt;</operator><name>tv2</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>processed</name></name><operator>++</operator></expr>;</expr_stmt>
			<return>return <expr><name>itup</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* notify producer */</comment>
		<if_stmt><if>if <condition>(<expr><name>b</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>bfilled</name></name> <operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ConditionVariableSignal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>processbuffers</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"btbuild px leader, consumed one buffer notify px worker, idx:%d, icount:%d"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>icount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* get another buffer */</comment>
		<block>{<block_content>
			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>bfilled</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type> <name>bcnext</name> <init>= <expr><call><name>PxQueueNext</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>bc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>bc</name></name> <operator>=</operator> <name>bcnext</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"btbuild px leader get buffer %d"</literal></expr></argument>, <argument><expr><name>bcnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>b</name> <operator>=</operator> <call><name>POLAR_GET_PX_ITUPLE</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>bcnext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>bufferidx</name></name> <operator>=</operator> <name>bcnext</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pxleader</name><operator>-&gt;</operator><name>waittimes</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"btbuild px leader get buffer waitting %lu"</literal></expr></argument>, <argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>waittimes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>cv</name></name></expr></argument>,
									<argument><expr><name>WAIT_EVENT_PARALLEL_CREATE_INDEX_SCAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_leafbuild_pxleader</name><parameter_list>(<parameter><decl><type><name>PxLeaderstate</name> <modifier>*</modifier></type><name>pxleader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BTWriteState</name></type> <name>wstate</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>pxleader</name></name> <operator>=</operator> <name>pxleader</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>heap</name></name> <operator>=</operator> <name><name>pxleader</name><operator>-&gt;</operator><name>heap</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name><name>pxleader</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to log index creation in WAL iff WAL archiving/streaming is
	 * enabled UNLESS the index isn't WAL-logged anyway.
	 */</comment>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_use_wal</name></name> <operator>=</operator> <call><name>XLogIsNeeded</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name><name>wstate</name><operator>.</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reserve the metapage */</comment>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_pages_alloced</name></name> <operator>=</operator> <name>BTREE_METAPAGE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_pages_written</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_zeropage</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* until needed */</comment>

	<comment type="block">/* POALR: bulk extend index file */</comment>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>polar_index_create_bulk_extend_size_copy</name></name> <operator>=</operator> <name>polar_index_create_bulk_extend_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>px_index_buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_bt_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * POLAR: Manually free memory of `wstate.btws_zeropage' beforehand,
	 * instead of automatically freeing memory via memcontext.
	 *
	 * `wstate' is a local variable of function _bt_leafbuild(),
	 * which would be destructed when _bt_leafbuild() finished.
	 * So it's safe to manually free memory of `wstate.btws_zeropage' here.
	 *
	 * Why this is needed? Avoid OOM.
	 * For example, polar_index_create_bulk_extend_size = 512, `wstate.btws_zeropage' will be 4MB.
	 * The OOM case is truncating a partitioning table with huge number of sub-partitioning.
	 * Huge number of indexes would be reindexed in one transaction.
	 * Every index has its own `wstate.btws_zeropage' memory in the only one transaction,
	 * If we don't manually free memory of `wstate.btws_zeropage' here,
	 * huge number of `wstate.btws_zeropage's would leed to OOM.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wstate</name><operator>.</operator><name>btws_zeropage</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>wstate</name><operator>.</operator><name>btws_zeropage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wstate</name><operator>.</operator><name>btws_zeropage</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR: end */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_px_init_buffer</name><parameter_list>(<parameter><decl><type><name>PxIndexTupleBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>icount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>ioffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_finish_pxleader</name><parameter_list>(<parameter><decl><type><name>PxLeaderstate</name> <modifier>*</modifier></type><name>pxleader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pxleader</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bfilled</name></name> <operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"btbuild px leader, bfilled faild: %d"</literal></expr></argument>, <argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bfilled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pxleader</name><operator>-&gt;</operator><name>tv3</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>px_info_debug</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"btbuild px leader finish, first indextuple time: %ld, total build leaf time: %ld, total process: %lu, total buffers: %lu, total waittimes: %lu"</literal></expr></argument>, 
			<argument><expr><call><name>TvDiff</name><argument_list>(<argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>tv2</name></name></expr></argument>, <argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>tv1</name></name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>TvDiff</name><argument_list>(<argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>tv3</name></name></expr></argument>, <argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>tv2</name></name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>processed</name></name></expr></argument>, <argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>processbuffers</name></name></expr></argument>, <argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>waittimes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Shutdown worker processes */</comment>
	<expr_stmt><expr><call><name>WaitForParallelWorkersToFinish</name><argument_list>(<argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Next, accumulate buffer usage.  (This must wait for the workers to
	 * finish, or we might get incomplete data.)
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pxleader</name><operator>-&gt;</operator><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InstrAccumParallelQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pxleader</name><operator>-&gt;</operator><name>bufferusage</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Free last reference to MVCC snapshot, if one was used */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>DestroyParallelContext</name><argument_list>(<argument><expr><name><name>pxleader</name><operator>-&gt;</operator><name>pcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExitParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The same as _bt_blwritepage. But in this function, we use px_index_buffer
 * for page bulk write.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_px_blwritepage</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>, <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_bt_px_alloc_page_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wstate</name><operator>-&gt;</operator><name>px_index_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure rd_smgr is open (could have been closed by relcache flush!) */</comment>
	<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XLOG stuff */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>wstate</name><operator>-&gt;</operator><name>btws_use_wal</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We use the heap NEWPAGE record type for this */</comment>
		<expr_stmt><expr><call><name>log_newpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>wstate</name><operator>-&gt;</operator><name>px_index_buffer</name><operator>-&gt;</operator><name>item_len</name></name> <operator>==</operator> <name>polar_bt_write_page_buffer_size</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_bt_px_flush_blpage</name><argument_list>(<argument><expr><name>wstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PageEncryptInplace</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>wstate</name><operator>-&gt;</operator><name>px_index_buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name><name>wstate</name><operator>-&gt;</operator><name>px_index_buffer</name><operator>-&gt;</operator><name>item_len</name></name></expr>]</index></name><operator>.</operator><name>page</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>px_index_buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name><name>wstate</name><operator>-&gt;</operator><name>px_index_buffer</name><operator>-&gt;</operator><name>item_len</name></name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>blkno</name> <operator>&gt;</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_written</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_written</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>px_index_buffer</name><operator>-&gt;</operator><name>item_len</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>wstate</name><operator>-&gt;</operator><name>px_index_buffer</name><operator>-&gt;</operator><name>current_written_blkno</name></name> <operator>=</operator> <name><name>wstate</name><operator>-&gt;</operator><name>btws_pages_written</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>px_index_buffer_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno_a</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PxIndexBufferItem</name> <operator>*</operator><operator>)</operator><name>a</name><operator>)</operator><operator>-&gt;</operator><name>blkno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno_b</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>PxIndexBufferItem</name> <operator>*</operator><operator>)</operator><name>b</name><operator>)</operator><operator>-&gt;</operator><name>blkno</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>blkno_a</name> <operator>==</operator> <name>blkno_b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>blkno_a</name> <operator>&gt;</operator> <name>blkno_b</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check the write pages are valid. */</comment>
<macro><name>pg_attribute_unused</name><argument_list>()</argument_list></macro>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>px_bulk_write_page_valid</name><parameter_list>(<parameter><decl><type><name>PxIndexPageBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>page_write_start</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name>page</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>start</name> <operator>+</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>page</name><operator>)</operator> <operator>!=</operator> <name>page_write_start</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>page_write_start</name> <operator>+=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Use smgrbulkwrite to write buffer from start location to end location.
 * The caller should guarantee the buffer from start to end is continuous and without
 * empty pages.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_px_bulkwrite</name><parameter_list>(<parameter><decl><type><name>SMgrRelationData</name> <modifier>*</modifier></type><name>rd_smgr</name></decl></parameter>, <parameter><decl><type><name>PxIndexPageBuffer</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>page_write</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name>page</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>px_bulk_write_page_valid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_smgrbulkwrite</name><argument_list>(<argument><expr><name>rd_smgr</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>page_write</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: There are two locations when we use px flush btree leaf pages.
 * last_written_blkno: Last block number that we have written on the disk.
 * current_written_blkno: Current block number that we have written on the buffer_addr.
 * For all the buffer in buffer_addr, if the blkno is smaller than last_written_blkno, means
 * that this block has been written on the disk, might be a zero page. So we should just
 * overwrite it with the real content page. If the blkno is bigger than last_written_blkno,
 * means that this block has not been written on the disk, so we should just extend this page.
 * The differences between px index page overwrite and px index page extend is that, overwrite
 * page must be a valid page with real content. But extend page might be a hole, so we should
 * extend it as a zero page. This is the same process as _bt_blwritepage.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_px_flush_blpage</name><parameter_list>(<parameter><decl><type><name>BTWriteState</name> <modifier>*</modifier></type><name>wstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno_start</name></decl>, <decl><type ref="prev"/><name>blkno_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>max_blocknum_count</name></decl>, <decl><type ref="prev"/><name>total_blocknum_count</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxIndexPageBuffer</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name><name>wstate</name><operator>-&gt;</operator><name>px_index_buffer</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SMgrRelationData</name> <modifier>*</modifier></type><name>rd_smgr</name> <init>= <expr><name><name>wstate</name><operator>-&gt;</operator><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extend_buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>item_len</name></name> <operator>&lt;=</operator> <name>polar_bt_write_page_buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sort it order by block number */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>item_len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PxIndexBufferItem</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>px_index_buffer_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For block number smaller than last_writtten_blkno, we make continuous blocks bulk write together.
	 * It misses the final buffers bulk write.
	 */</comment>
	<while>while <condition>(<expr><name>end</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>buffer</name><operator>-&gt;</operator><name>item_len</name></name> <operator>&amp;&amp;</operator> <name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>&lt;</operator> <name><name>buffer</name><operator>-&gt;</operator><name>last_written_blkno</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>!=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>end</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>_bt_px_bulkwrite</name><argument_list>(<argument><expr><name>rd_smgr</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>start</name> <operator>=</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Deal with the final buffers bulk write.
	 * Two situations should be considered:
	 * 1. last_written_blkno has not been inited, so 'start' is the first block, it is the first
	 * time to call _bt_px_flush_blpage, all the buffers are bigger than last_written_blkno.
	 * 'start' is default set to 0, 'end' is set to buffer-&gt;item_len - 1, bulk write will be replaced by
	 * extend batch.
	 * 2. last_written_blkno has been inited
	 * 2.1 'start' is smaller than last_written_blkno, 'end' is smaller than last_written_blkno and
	 * 'end + 1' is bigger than last_written_blkno, we should deal with the final buffers bulk write
	 * from 'start' to 'end'
	 * 2.2 'start' is bigger than last_written_blkno, 'start' is default set to 0, 'end' is set to
	 * buffer-&gt;item_len - 1, bulk write will be replaced by extend batch.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>&lt;</operator> <name><name>buffer</name><operator>-&gt;</operator><name>last_written_blkno</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>_bt_px_bulkwrite</name><argument_list>(<argument><expr><name>rd_smgr</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> <operator>+=</operator> <name>count</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>item_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Record the start block number, if last_written_blkno has not been inited, it is 0, else
	 * it is last_written_blkno + 1
	 */</comment>
	<expr_stmt><expr><name>blkno_start</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>buffer</name><operator>-&gt;</operator><name>last_written_blkno</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name><name>buffer</name><operator>-&gt;</operator><name>last_written_blkno</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>blkno_end</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>end</name></expr>]</index></name><operator>.</operator><name>blkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_blocknum_count</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>blkno_end</name> <operator>-</operator> <name>blkno_start</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>total_blocknum_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We must guarantee extend batch size is not over the max block number in this page */</comment>
		<expr_stmt><expr><name>max_blocknum_count</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>total_blocknum_count</name></expr></argument>,
								<argument><expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name> <operator>-</operator> <operator>(</operator><name>blkno_start</name><operator>)</operator> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>RELSEG_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>extend_buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>max_blocknum_count</name> <operator>*</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>start</name> <operator>&lt;=</operator> <name>end</name> <operator>&amp;&amp;</operator> <name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>&lt;</operator> <name>blkno_start</name> <operator>+</operator> <name>max_blocknum_count</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name>blkno</name> <operator>-</operator> <name>blkno_start</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>extend_buffer</name> <operator>+</operator> <name>offset</name> <operator>*</operator> <name>BLCKSZ</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>start</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>smgrextendbatch</name><argument_list>(<argument><expr><name>rd_smgr</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno_start</name></expr></argument>, <argument><expr><name>max_blocknum_count</name></expr></argument>, <argument><expr><name>extend_buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>extend_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>extend_buffer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>total_blocknum_count</name> <operator>-=</operator> <name>max_blocknum_count</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blkno_start</name> <operator>+=</operator> <name>max_blocknum_count</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>item_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>last_written_blkno</name></name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>current_written_blkno</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_bt_px_alloc_page_buffer</name><parameter_list>(<parameter><decl><type><name>PxIndexPageBuffer</name> <modifier>*</modifier><modifier>*</modifier></type><name>px_index_buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>px_index_buffer_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>page_size_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxIndexPageBuffer</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>px_index_buffer</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>px_index_buffer_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PxIndexPageBuffer</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
							<name>polar_bt_write_page_buffer_size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PxIndexBufferItem</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_index_buffer_size</name> <operator>=</operator> <call><name>PXBUILD_MAXALIGN</name><argument_list>(<argument><expr><name>px_index_buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_index_buffer_size</name> <operator>+=</operator> <name>polar_bt_write_page_buffer_size</name> <operator>*</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_index_buffer_size</name> <operator>=</operator> <call><name>PXBUILD_MAXALIGN</name><argument_list>(<argument><expr><name>px_index_buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>posix_memalign</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>px_index_buffer</name></expr></argument>, <argument><expr><name>PXBUILD_MAXIMUM_ALIGNOF</name></expr></argument>, <argument><expr><name>px_index_buffer_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory, posix_memalign alloc px_index_buffer failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name>px_index_buffer</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name>PXBUILD_MAXIMUM_ALIGNOF</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>PxIndexPageBuffer</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>px_index_buffer</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>px_index_buffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page_size_start</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>px_index_buffer</name><operator>)</operator> <operator>+</operator>
						<call><name>PXBUILD_MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PxIndexPageBuffer</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
						<name>polar_bt_write_page_buffer_size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PxIndexBufferItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>polar_bt_write_page_buffer_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>item</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>page</name> <operator>=</operator> <name>page_size_start</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>page_size_start</name> <operator>+=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_px_enable_btbuild_precheck</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_enable_btbuild</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"px_build"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsInTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PX index build does not support in transaction block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment>
</unit>
