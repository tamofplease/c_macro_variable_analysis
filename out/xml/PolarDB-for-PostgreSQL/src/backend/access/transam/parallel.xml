<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/transam/parallel.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parallel.c
 *	  Infrastructure for launching parallel workers
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/access/transam/parallel.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/session.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execParallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqmq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/combocid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/* POLAR px */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/px_btbuild.h"</cpp:file></cpp:include>

<comment type="block">/*
 * We don't want to waste a lot of memory on an error queue which, most of
 * the time, will process only a handful of small messages.  However, it is
 * desirable to make it large enough that a typical ErrorResponse can be sent
 * without blocking.  That way, a worker that errors out can write the whole
 * message into the queue and terminate without waiting for the user backend.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_ERROR_QUEUE_SIZE</name></cpp:macro>			<cpp:value>16384</cpp:value></cpp:define>

<comment type="block">/* Magic number for parallel context TOC. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_MAGIC</name></cpp:macro>						<cpp:value>0x50477c7c</cpp:value></cpp:define>

<comment type="block">/*
 * Magic numbers for per-context parallel state sharing.  Higher-level code
 * should use smaller values, leaving these very large ones for use by this
 * module.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_FIXED</name></cpp:macro>					<cpp:value>UINT64CONST(0xFFFFFFFFFFFF0001)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_ERROR_QUEUE</name></cpp:macro>			<cpp:value>UINT64CONST(0xFFFFFFFFFFFF0002)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_LIBRARY</name></cpp:macro>				<cpp:value>UINT64CONST(0xFFFFFFFFFFFF0003)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_GUC</name></cpp:macro>					<cpp:value>UINT64CONST(0xFFFFFFFFFFFF0004)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_COMBO_CID</name></cpp:macro>				<cpp:value>UINT64CONST(0xFFFFFFFFFFFF0005)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_TRANSACTION_SNAPSHOT</name></cpp:macro>	<cpp:value>UINT64CONST(0xFFFFFFFFFFFF0006)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_ACTIVE_SNAPSHOT</name></cpp:macro>		<cpp:value>UINT64CONST(0xFFFFFFFFFFFF0007)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_TRANSACTION_STATE</name></cpp:macro>		<cpp:value>UINT64CONST(0xFFFFFFFFFFFF0008)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_ENTRYPOINT</name></cpp:macro>				<cpp:value>UINT64CONST(0xFFFFFFFFFFFF0009)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_SESSION_DSM</name></cpp:macro>			<cpp:value>UINT64CONST(0xFFFFFFFFFFFF000A)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_KEY_REINDEX_STATE</name></cpp:macro>			<cpp:value>UINT64CONST(0xFFFFFFFFFFFF000B)</cpp:value></cpp:define>

<comment type="block">/* Fixed-size parallel state. */</comment>
<typedef>typedef <type><struct>struct <name>FixedParallelState</name>
<block>{
	<comment type="block">/* Fixed-size state that workers must restore. */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>database_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>authenticated_user_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>current_user_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>outer_user_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>temp_namespace_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>temp_toast_namespace_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sec_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_superuser</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>parallel_master_pgproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>parallel_master_pid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>parallel_master_backend_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>xact_ts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>stmt_ts</name></decl>;</decl_stmt>

	<comment type="block">/* Mutex protects remaining fields. */</comment>
	<decl_stmt><decl><type><name>slock_t</name></type>		<name>mutex</name></decl>;</decl_stmt>

	<comment type="block">/* Maximum XactLastRecEnd of any worker. */</comment>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>last_xlog_end</name></decl>;</decl_stmt>
}</block></struct></type> <name>FixedParallelState</name>;</typedef>

<comment type="block">/*
 * Our parallel worker number.  We initialize this to -1, meaning that we are
 * not a parallel worker.  In parallel workers, it will be set to a value &gt;= 0
 * and &lt; the number of workers before any user code is invoked; each parallel
 * worker will get a different parallel worker number.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>ParallelWorkerNumber</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Is there a parallel message pending which we need to receive? */</comment>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>ParallelMessagePending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Are we initializing a parallel worker? */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>InitializingParallelWorker</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Pointer to our fixed parallel state. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>FixedParallelState</name> <modifier>*</modifier></type><name>MyFixedParallelState</name></decl>;</decl_stmt>

<comment type="block">/* List of active parallel contexts. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type> <name>pcxt_list</name> <init>= <expr><call><name>DLIST_STATIC_INIT</name><argument_list>(<argument><expr><name>pcxt_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/* Backend-local copy of data from FixedParallelState. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>ParallelMasterPid</name></decl>;</decl_stmt>

<comment type="block">/*
 * List of internal parallel worker entry points.  We need this for
 * reasons explained in LookupParallelWorkerFunction(), below.
 */</comment>
<struct><specifier>static</specifier> <specifier>const</specifier> struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fn_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>parallel_worker_main_type</name></type> <name>fn_addr</name></decl>;</decl_stmt>
}</block>			<decl><name><name>InternalParallelWorkers</name><index>[]</index></name> <init>=

<expr><block>{
	<expr><block>{
		<expr><literal type="string">"ParallelQueryMain"</literal></expr>, <expr><name>ParallelQueryMain</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><literal type="string">"_bt_parallel_build_main"</literal></expr>, <expr><name>_bt_parallel_build_main</name></expr>
	}</block></expr>,
	<comment type="block">/* POLAR px */</comment>
	<expr><block>{
		<expr><literal type="string">"polar_px_bt_build_main"</literal></expr>, <expr><name>polar_px_bt_build_main</name></expr>
	}</block></expr>,
	<comment type="block">/* POLAR End*/</comment>
}</block></expr></init></decl>;</struct>

<comment type="block">/* Private functions. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>HandleParallelMessage</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>msg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WaitForParallelWorkersToExit</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>parallel_worker_main_type</name></type> <name>LookupParallelWorkerFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libraryname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ParallelWorkerShutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Establish a new parallel context.  This should be done after entering
 * parallel mode, and (unless there is an error) the context should be
 * destroyed before exiting the current subtransaction.
 */</comment>
<function><type><name>ParallelContext</name> <modifier>*</modifier></type>
<name>CreateParallelContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>library_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>function_name</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>nworkers</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>serializable_okay</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>

	<comment type="block">/* It is unsafe to create a parallel context if not in parallel mode. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Number of workers should be non-negative. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nworkers</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If dynamic shared memory is not available, we won't be able to use
	 * background workers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dynamic_shared_memory_type</name> <operator>==</operator> <name>DSM_IMPL_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nworkers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we are running under serializable isolation, we can't use parallel
	 * workers, at least not until somebody enhances that mechanism to be
	 * parallel-aware.  Utility statement callers may ask us to ignore this
	 * restriction because they're always able to safely ignore the fact that
	 * SIREAD locks do not work with parallelism.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>serializable_okay</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nworkers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* We might be running in a short-lived memory context. */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize a new ParallelContext. */</comment>
	<expr_stmt><expr><name>pcxt</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>subid</name></name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>library_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>library_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>function_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>function_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>error_context_stack</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_initialize_estimator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcxt_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore previous memory context. */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pcxt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Establish the dynamic shared memory segment for a parallel context and
 * copy state and other bookkeeping information that will be needed by
 * parallel workers into it.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeParallelDSM</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>library_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>guc_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>combocidlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>tsnaplen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>asnaplen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>tstatelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>reindexlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>segsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FixedParallelState</name> <modifier>*</modifier></type><name>fps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsm_handle</name></type>	<name>session_dsm_handle</name> <init>= <expr><name>DSM_HANDLE_INVALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>transaction_snapshot</name> <init>= <expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>active_snapshot</name> <init>= <expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We might be running in a very short-lived memory context. */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allow space to store the fixed-size parallel state. */</comment>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FixedParallelState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Normally, the user will have requested at least one worker process, but
	 * if by chance they have not, we can skip a bunch of things here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get (or create) the per-session DSM segment's handle. */</comment>
		<expr_stmt><expr><name>session_dsm_handle</name> <operator>=</operator> <call><name>GetSessionDsmHandle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we weren't able to create a per-session DSM segment, then we can
		 * continue but we can't safely launch any workers because their
		 * record typmods would be incompatible so they couldn't exchange
		 * tuples.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>session_dsm_handle</name> <operator>==</operator> <name>DSM_HANDLE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Estimate space for various kinds of state sharing. */</comment>
		<expr_stmt><expr><name>library_len</name> <operator>=</operator> <call><name>EstimateLibraryStateSpace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>library_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>guc_len</name> <operator>=</operator> <call><name>EstimateGUCStateSpace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>guc_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>combocidlen</name> <operator>=</operator> <call><name>EstimateComboCIDStateSpace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>combocidlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tsnaplen</name> <operator>=</operator> <call><name>EstimateSnapshotSpace</name><argument_list>(<argument><expr><name>transaction_snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>tsnaplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>asnaplen</name> <operator>=</operator> <call><name>EstimateSnapshotSpace</name><argument_list>(<argument><expr><name>active_snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>asnaplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tstatelen</name> <operator>=</operator> <call><name>EstimateTransactionStateSpace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>tstatelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsm_handle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reindexlen</name> <operator>=</operator> <call><name>EstimateReindexStateSpace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><name>reindexlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If you add more chunks here, you probably need to add keys. */</comment>
		<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Estimate space need for error queues. */</comment>
		<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><call><name>BUFFERALIGN</name><argument_list>(<argument><expr><name>PARALLEL_ERROR_QUEUE_SIZE</name></expr></argument>)</argument_list></call> <operator>==</operator>
						 <name>PARALLEL_ERROR_QUEUE_SIZE</name></expr></argument>,
						 <argument><expr><literal type="string">"parallel error queue size not buffer-aligned"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>,
							   <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>PARALLEL_ERROR_QUEUE_SIZE</name></expr></argument>,
										<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Estimate how much we'll need for the entrypoint info. */</comment>
		<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>library_name</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
							   <call><name>strlen</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>function_name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Create DSM and initialize with new table of contents.  But if the user
	 * didn't request any workers, then don't bother creating a dynamic shared
	 * memory segment; instead, just use backend-private memory.
	 *
	 * Also, if we can't create a dynamic shared memory segment because the
	 * maximum number of segments have already been created, then fall back to
	 * backend-private memory, and plan not to use any workers.  We hope this
	 * won't happen very often, but it's better to abandon the use of
	 * parallelism than to fail outright.
	 */</comment>
	<expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>shm_toc_estimate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>estimator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <call><name>dsm_create</name><argument_list>(<argument><expr><name>segsize</name></expr></argument>, <argument><expr><name>DSM_CREATE_NULL_IF_MAXSEGMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name> <operator>=</operator> <call><name>shm_toc_create</name><argument_list>(<argument><expr><name>PARALLEL_MAGIC</name></expr></argument>,
								   <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>private_memory</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name> <operator>=</operator> <call><name>shm_toc_create</name><argument_list>(<argument><expr><name>PARALLEL_MAGIC</name></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>private_memory</name></name></expr></argument>,
								   <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Initialize fixed-size state in shared memory. */</comment>
	<expr_stmt><expr><name>fps</name> <operator>=</operator> <operator>(</operator><name>FixedParallelState</name> <operator>*</operator><operator>)</operator>
		<call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FixedParallelState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>database_id</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>authenticated_user_id</name></name> <operator>=</operator> <call><name>GetAuthenticatedUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>outer_user_id</name></name> <operator>=</operator> <call><name>GetCurrentRoleId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>is_superuser</name></name> <operator>=</operator> <name>session_auth_is_superuser</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fps</name><operator>-&gt;</operator><name>current_user_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fps</name><operator>-&gt;</operator><name>sec_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GetTempNamespaceState</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fps</name><operator>-&gt;</operator><name>temp_namespace_id</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>fps</name><operator>-&gt;</operator><name>temp_toast_namespace_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>parallel_master_pgproc</name></name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>parallel_master_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>parallel_master_backend_id</name></name> <operator>=</operator> <name>MyBackendId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>xact_ts</name></name> <operator>=</operator> <call><name>GetCurrentTransactionStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>stmt_ts</name></name> <operator>=</operator> <call><name>GetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fps</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>last_xlog_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_FIXED</name></expr></argument>, <argument><expr><name>fps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can skip the rest of this if we're not budgeting for any workers. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>libraryspace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>gucspace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>combocidspace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tsnapspace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>asnapspace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tstatespace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>reindexspace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>error_queue_space</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>session_dsm_handle_space</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>entrypointstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>lnamelen</name></decl>;</decl_stmt>

		<comment type="block">/* Serialize shared libraries we have loaded. */</comment>
		<expr_stmt><expr><name>libraryspace</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>library_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SerializeLibraryState</name><argument_list>(<argument><expr><name>library_len</name></expr></argument>, <argument><expr><name>libraryspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_LIBRARY</name></expr></argument>, <argument><expr><name>libraryspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Serialize GUC settings. */</comment>
		<expr_stmt><expr><name>gucspace</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>guc_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SerializeGUCState</name><argument_list>(<argument><expr><name>guc_len</name></expr></argument>, <argument><expr><name>gucspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_GUC</name></expr></argument>, <argument><expr><name>gucspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Serialize combo CID state. */</comment>
		<expr_stmt><expr><name>combocidspace</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>combocidlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SerializeComboCIDState</name><argument_list>(<argument><expr><name>combocidlen</name></expr></argument>, <argument><expr><name>combocidspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_COMBO_CID</name></expr></argument>, <argument><expr><name>combocidspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Serialize transaction snapshot and active snapshot. */</comment>
		<expr_stmt><expr><name>tsnapspace</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>tsnaplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SerializeSnapshot</name><argument_list>(<argument><expr><name>transaction_snapshot</name></expr></argument>, <argument><expr><name>tsnapspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TRANSACTION_SNAPSHOT</name></expr></argument>,
					   <argument><expr><name>tsnapspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>asnapspace</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>asnaplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SerializeSnapshot</name><argument_list>(<argument><expr><name>active_snapshot</name></expr></argument>, <argument><expr><name>asnapspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_ACTIVE_SNAPSHOT</name></expr></argument>, <argument><expr><name>asnapspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Provide the handle for per-session segment. */</comment>
		<expr_stmt><expr><name>session_dsm_handle_space</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
													<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dsm_handle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>dsm_handle</name> <operator>*</operator><operator>)</operator> <name>session_dsm_handle_space</name> <operator>=</operator> <name>session_dsm_handle</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_SESSION_DSM</name></expr></argument>,
					   <argument><expr><name>session_dsm_handle_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Serialize transaction state. */</comment>
		<expr_stmt><expr><name>tstatespace</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>tstatelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SerializeTransactionState</name><argument_list>(<argument><expr><name>tstatelen</name></expr></argument>, <argument><expr><name>tstatespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TRANSACTION_STATE</name></expr></argument>, <argument><expr><name>tstatespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Serialize reindex state. */</comment>
		<expr_stmt><expr><name>reindexspace</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>reindexlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SerializeReindexState</name><argument_list>(<argument><expr><name>reindexlen</name></expr></argument>, <argument><expr><name>reindexspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_REINDEX_STATE</name></expr></argument>, <argument><expr><name>reindexspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Allocate space for worker information. */</comment>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelWorkerInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Establish error queues in dynamic shared memory.
		 *
		 * These queues should be used only for transmitting ErrorResponse,
		 * NoticeResponse, and NotifyResponse protocol messages.  Tuple data
		 * should be transmitted via separate (possibly larger?) queues.
		 */</comment>
		<expr_stmt><expr><name>error_queue_space</name> <operator>=</operator>
			<call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>,
							 <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>PARALLEL_ERROR_QUEUE_SIZE</name></expr></argument>,
									  <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>start</name> <operator>=</operator> <name>error_queue_space</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>PARALLEL_ERROR_QUEUE_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_mq_create</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>PARALLEL_ERROR_QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shm_mq_set_receiver</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name> <operator>=</operator> <call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_ERROR_QUEUE</name></expr></argument>, <argument><expr><name>error_queue_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Serialize entrypoint information.  It's unsafe to pass function
		 * pointers across processes, as the function pointer may be different
		 * in each process in EXEC_BACKEND builds, so we always pass library
		 * and function name.  (We use library name "postgres" for functions
		 * in the core backend.)
		 */</comment>
		<expr_stmt><expr><name>lnamelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>library_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>entrypointstate</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>lnamelen</name> <operator>+</operator>
										   <call><name>strlen</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>function_name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>entrypointstate</name></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>library_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>entrypointstate</name> <operator>+</operator> <name>lnamelen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>function_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_ENTRYPOINT</name></expr></argument>, <argument><expr><name>entrypointstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Restore previous memory context. */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reinitialize the dynamic shared memory segment for a parallel context such
 * that we could launch workers for it again.
 */</comment>
<function><type><name>void</name></type>
<name>ReinitializeParallelDSM</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FixedParallelState</name> <modifier>*</modifier></type><name>fps</name></decl>;</decl_stmt>

	<comment type="block">/* Wait for any old workers to exit. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WaitForParallelWorkersToFinish</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WaitForParallelWorkersToExit</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nknown_attached_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Reset a few bits of fixed parallel state to a clean state. */</comment>
	<expr_stmt><expr><name>fps</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_FIXED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>last_xlog_end</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Recreate error queues (if they exist). */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>error_queue_space</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>error_queue_space</name> <operator>=</operator>
			<call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_ERROR_QUEUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>start</name> <operator>=</operator> <name>error_queue_space</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>PARALLEL_ERROR_QUEUE_SIZE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_mq_create</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>PARALLEL_ERROR_QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shm_mq_set_receiver</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name> <operator>=</operator> <call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Launch parallel workers.
 */</comment>
<function><type><name>void</name></type>
<name>LaunchParallelWorkers</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackgroundWorker</name></type> <name>worker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>any_registrations_failed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Skip this if we have no workers. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* We need to be a lock group leader. */</comment>
	<expr_stmt><expr><call><name>BecomeLockGroupLeader</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we do have workers, we'd better have a DSM segment. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We might be running in a short-lived memory context. */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Configure a worker. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>worker</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_name</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><literal type="string">"parallel worker for PID %d"</literal></expr></argument>,
			 <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_type</name></name></expr></argument>, <argument><expr><name>BGW_MAXLEN</name></expr></argument>, <argument><expr><literal type="string">"parallel worker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_flags</name></name> <operator>=</operator>
		<name>BGWORKER_SHMEM_ACCESS</name> <operator>|</operator> <name>BGWORKER_BACKEND_DATABASE_CONNECTION</name>
		<operator>|</operator> <name>BGWORKER_CLASS_PARALLEL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_start_time</name></name> <operator>=</operator> <name>BgWorkerStart_ConsistentState</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_restart_time</name></name> <operator>=</operator> <name>BGW_NEVER_RESTART</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_library_name</name></name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_function_name</name></name></expr></argument>, <argument><expr><literal type="string">"ParallelWorkerMain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_main_arg</name></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>worker</name><operator>.</operator><name>bgw_notify_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start workers.
	 *
	 * The caller must be able to tolerate ending up with fewer workers than
	 * expected, so there is no need to throw an error here if registration
	 * fails.  It wouldn't help much anyway, because registering the worker in
	 * no way guarantees that it will start up and initialize successfully.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>worker</name><operator>.</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>any_registrations_failed</name> <operator>&amp;&amp;</operator>
			<call><name>RegisterDynamicBackgroundWorker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>shm_mq_set_handle</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name></expr></argument>,
							  <argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If we weren't able to register the worker, then we've bumped up
			 * against the max_worker_processes limit, and future
			 * registrations will probably fail too, so arrange to skip them.
			 * But we still have to execute this code for the remaining slots
			 * to make sure that we forget about the error queues we budgeted
			 * for those workers.  Otherwise, we'll wait for them to start,
			 * but they never will.
			 */</comment>
			<expr_stmt><expr><name>any_registrations_failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now that nworkers_launched has taken its final value, we can initialize
	 * known_attached_workers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name></name> <operator>=</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nknown_attached_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Restore previous memory context. */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for all workers to attach to their error queues, and throw an error if
 * any worker fails to do this.
 *
 * Callers can assume that if this function returns successfully, then the
 * number of workers given by pcxt-&gt;nworkers_launched have initialized and
 * attached to their error queues.  Whether or not these workers are guaranteed
 * to still be running depends on what code the caller asked them to run;
 * this function does not guarantee that they have not exited.  However, it
 * does guarantee that any workers which exited must have done so cleanly and
 * after successfully performing the work with which they were tasked.
 *
 * If this function is not called, then some of the workers that were launched
 * may not have been started due to a fork() failure, or may have exited during
 * early startup prior to attaching to the error queue, so nworkers_launched
 * cannot be viewed as completely reliable.  It will never be less than the
 * number of workers which actually started, but it might be more.  Any workers
 * that failed to start will still be discovered by
 * WaitForParallelWorkersToFinish and an error will be thrown at that time,
 * provided that function is eventually reached.
 *
 * In general, the leader process should do as much work as possible before
 * calling this function.  fork() failures and other early-startup failures
 * are very uncommon, and having the leader sit idle when it could be doing
 * useful work is undesirable.  However, if the leader needs to wait for
 * all of its workers or for a specific worker, it may want to call this
 * function before doing so.  If not, it must make some other provision for
 * the failure-to-start case, lest it wait forever.  On the other hand, a
 * leader which never waits for a worker that might not be started yet, or
 * at least never does so prior to WaitForParallelWorkersToFinish(), need not
 * call this function at all.
 */</comment>
<function><type><name>void</name></type>
<name>WaitForParallelWorkersToAttach</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Skip this if we have no launched workers. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * This will process any parallel messages that are pending and it may
		 * also throw an error propagated from a worker.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If error_mqh is NULL, then the worker has already exited
			 * cleanly.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>++</operator><name><name>pcxt</name><operator>-&gt;</operator><name>nknown_attached_workers</name></name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_STARTED</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Has the worker attached to the error queue? */</comment>
				<expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_mq_get_queue</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>shm_mq_get_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Yes, so it is known to be attached. */</comment>
					<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><operator>++</operator><name><name>pcxt</name><operator>-&gt;</operator><name>nknown_attached_workers</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_STOPPED</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If the worker stopped without attaching to the error queue,
				 * throw an error.
				 */</comment>
				<expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_mq_get_queue</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>shm_mq_get_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parallel worker failed to initialize"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"More details may be available in the server log."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>++</operator><name><name>pcxt</name><operator>-&gt;</operator><name>nknown_attached_workers</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Worker not yet started, so we must wait.  The postmaster
				 * will notify us if the worker's state changes.  Our latch
				 * might also get set for some other reason, but if so we'll
				 * just end up waiting for the same worker again.
				 */</comment>
				<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
							   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
							   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_BGWORKER_STARTUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* emergency bailout if postmaster has died */</comment>
				<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* If all workers are known to have started, we're done. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>nknown_attached_workers</name></name> <operator>&gt;=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nknown_attached_workers</name></name> <operator>==</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for all workers to finish computing.
 *
 * Even if the parallel operation seems to have completed successfully, it's
 * important to call this function afterwards.  We must not miss any errors
 * the workers may have thrown during the parallel operation, or any that they
 * may yet throw while shutting down.
 *
 * Also, we want to update our notion of XactLastRecEnd based on worker
 * feedback.
 */</comment>
<function><type><name>void</name></type>
<name>WaitForParallelWorkersToFinish</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>anyone_alive</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nfinished</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * This will process any parallel messages that are pending, which may
		 * change the outcome of the loop that follows.  It may also throw an
		 * error propagated from a worker.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/*
			 * If error_mqh is NULL, then the worker has already exited
			 * cleanly.  If we have received a message through error_mqh from
			 * the worker, we know it started up cleanly, and therefore we're
			 * certain to be notified when it exits.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name>nfinished</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>anyone_alive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>anyone_alive</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If all workers are known to have finished, we're done. */</comment>
			<if_stmt><if>if <condition>(<expr><name>nfinished</name> <operator>&gt;=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nfinished</name> <operator>==</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We didn't detect any living workers, but not all workers are
			 * known to have exited cleanly.  Either not all workers have
			 * launched yet, or maybe some of them failed to start or
			 * terminated abnormally.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>pid_t</name></type>		<name>pid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If the worker is BGWH_NOT_YET_STARTED or BGWH_STARTED, we
				 * should just keep waiting.  If it is BGWH_STOPPED, then
				 * further investigation is needed.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
					<name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
					<call><name>GetBackgroundWorkerPid</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BGWH_STOPPED</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Check whether the worker ended up stopped without ever
				 * attaching to the error queue.  If so, the postmaster was
				 * unable to fork the worker or it exited without initializing
				 * properly.  We must throw an error, since the caller may
				 * have been expecting the worker to do some work before
				 * exiting.
				 */</comment>
				<expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_mq_get_queue</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>shm_mq_get_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parallel worker failed to initialize"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"More details may be available in the server log."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * The worker is stopped, but is attached to the error queue.
				 * Unless there's a bug somewhere, this will only happen when
				 * the worker writes messages and terminates after the
				 * CHECK_FOR_INTERRUPTS() near the top of this function and
				 * before the call to GetBackgroundWorkerPid().  In that case,
				 * or latch should have been set as well and the right things
				 * will happen on the next pass through the loop.
				 */</comment>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
				  <argument><expr><name>WAIT_EVENT_PARALLEL_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FixedParallelState</name> <modifier>*</modifier></type><name>fps</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>fps</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>, <argument><expr><name>PARALLEL_KEY_FIXED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fps</name><operator>-&gt;</operator><name>last_xlog_end</name></name> <operator>&gt;</operator> <name>XactLastRecEnd</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>XactLastRecEnd</name> <operator>=</operator> <name><name>fps</name><operator>-&gt;</operator><name>last_xlog_end</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for all workers to exit.
 *
 * This function ensures that workers have been completely shutdown.  The
 * difference between WaitForParallelWorkersToFinish and this function is
 * that former just ensures that last message sent by worker backend is
 * received by master backend whereas this ensures the complete shutdown.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitForParallelWorkersToExit</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Wait until the workers actually die. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BgwHandleStatus</name></type> <name>status</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>WaitForBackgroundWorkerShutdown</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the postmaster kicked the bucket, we have no chance of cleaning
		 * up safely -- we won't be able to tell when our workers are actually
		 * dead.  This doesn't necessitate a PANIC since they will all abort
		 * eventually, but we can't safely continue this session.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>BGWH_POSTMASTER_DIED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ADMIN_SHUTDOWN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"postmaster exited during a parallel transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Release memory. */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Destroy a parallel context.
 *
 * If expecting a clean exit, you should use WaitForParallelWorkersToFinish()
 * first, before calling this function.  When this function is invoked, any
 * remaining workers are forcibly killed; the dynamic shared memory segment
 * is unmapped; and we then wait (uninterruptibly) for the workers to exit.
 */</comment>
<function><type><name>void</name></type>
<name>DestroyParallelContext</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Be careful about order of operations here!  We remove the parallel
	 * context from the list before we do anything else; otherwise, if an
	 * error occurs during a subsequent step, we might try to nuke it again
	 * from AtEOXact_Parallel or AtEOSubXact_Parallel.
	 */</comment>
	<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcxt</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Kill each worker in turn, and forget their error queues. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>TerminateBackgroundWorker</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bgwhandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have allocated a shared memory segment, detach it.  This will
	 * implicitly detach the error queues, and any other shared memory queues,
	 * stored there.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this parallel context is actually in backend-private memory rather
	 * than shared memory, free that memory instead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>private_memory</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>private_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>private_memory</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can't finish transaction commit or abort until all of the workers
	 * have exited.  This means, in particular, that we can't respond to
	 * interrupts at this stage.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WaitForParallelWorkersToExit</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Free the worker array itself. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Free memory. */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>library_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>function_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Are there any parallel contexts currently active?
 */</comment>
<function><type><name>bool</name></type>
<name>ParallelContextActive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcxt_list</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle receipt of an interrupt indicating a parallel worker message.
 *
 * Note: this is called within a signal handler!  All we can do is set
 * a flag that will cause the next CHECK_FOR_INTERRUPTS() to invoke
 * HandleParallelMessages().
 */</comment>
<function><type><name>void</name></type>
<name>HandleParallelMessageInterrupt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ParallelMessagePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle any queued protocol messages received from parallel workers.
 */</comment>
<function><type><name>void</name></type>
<name>HandleParallelMessages</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>hpm_context</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is invoked from ProcessInterrupts(), and since some of the
	 * functions it calls contain CHECK_FOR_INTERRUPTS(), there is a potential
	 * for recursive calls if more signals are received while this runs.  It's
	 * unclear that recursive entry would be safe, and it doesn't seem useful
	 * even if it is safe, so let's block interrupts until done.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Moreover, CurrentMemoryContext might be pointing almost anywhere.  We
	 * don't want to risk leaking data into long-lived contexts, so let's do
	 * our work here in a private context that we can reset on each use.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hpm_context</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* first time through? */</comment>
		<expr_stmt><expr><name>hpm_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
											<argument><expr><literal type="string">"HandleParallelMessages"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>hpm_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>hpm_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK to process messages.  Reset the flag saying there are more to do. */</comment>
	<expr_stmt><expr><name>ParallelMessagePending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;pcxt_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pcxt</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>ParallelContext</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>nworkers_launched</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/*
			 * Read as many messages as we can from each worker, but stop when
			 * either (1) the worker's error queue goes away, which can happen
			 * if we receive a Terminate message from the worker; or (2) no
			 * more messages can be read from the worker without blocking.
			 */</comment>
			<while>while <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>shm_mq_result</name></type> <name>res</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Size</name></type>		<name>nbytes</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>shm_mq_receive</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>SHM_MQ_WOULD_BLOCK</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>SHM_MQ_SUCCESS</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>StringInfoData</name></type> <name>msg</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>HandleParallelMessage</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>msg</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lost connection to parallel worker"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></while>
		</block_content>}</block></for>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Might as well clear the context on our way out */</comment>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>hpm_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle a single protocol message received from a single parallel worker.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleParallelMessage</name><parameter_list>(<parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>msgtype</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>known_attached_workers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>nknown_attached_workers</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>msgtype</name> <operator>=</operator> <call><name>pq_getmsgbyte</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>msgtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'K'</literal></expr>:</case>				<comment type="block">/* BackendKeyData */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int32</name></type>		<name>pid</name> <init>= <expr><call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* discard cancel key */</comment>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_getmsgend</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pid</name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><literal type="char">'E'</literal></expr>:</case>				<comment type="block">/* ErrorResponse */</comment>
		<case>case <expr><literal type="char">'N'</literal></expr>:</case>				<comment type="block">/* NoticeResponse */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ErrorData</name></type>	<name>edata</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ErrorContextCallback</name> <modifier>*</modifier></type><name>save_error_context_stack</name></decl>;</decl_stmt>

				<comment type="block">/* Parse ErrorResponse or NoticeResponse. */</comment>
				<expr_stmt><expr><call><name>pq_parse_errornotice</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Death of a worker isn't enough justification for suicide. */</comment>
				<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>elevel</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>edata</name><operator>.</operator><name>elevel</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If desired, add a context line to show that this is a
				 * message propagated from a parallel worker.  Otherwise, it
				 * can sometimes be confusing to understand what actually
				 * happened.  (We don't do this in FORCE_PARALLEL_REGRESS mode
				 * because it causes test-result instability depending on
				 * whether a parallel worker is actually used or not.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>force_parallel_mode</name> <operator>!=</operator> <name>FORCE_PARALLEL_REGRESS</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>.</operator><name>context</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>context</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s\n%s"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>.</operator><name>context</name></name></expr></argument>,
												 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"parallel worker"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>context</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"parallel worker"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Context beyond that should use the error context callbacks
				 * that were in effect when the ParallelContext was created,
				 * not the current ones.
				 */</comment>
				<expr_stmt><expr><name>save_error_context_stack</name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>pcxt</name><operator>-&gt;</operator><name>error_context_stack</name></name></expr>;</expr_stmt>

				<comment type="block">/* Rethrow error or print notice. */</comment>
				<expr_stmt><expr><call><name>ThrowErrorData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Not an error, so restore previous context stack. */</comment>
				<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>save_error_context_stack</name></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><literal type="char">'A'</literal></expr>:</case>				<comment type="block">/* NotifyResponse */</comment>
			<block>{<block_content>
				<comment type="block">/* Propagate NotifyResponse. */</comment>
				<decl_stmt><decl><type><name>int32</name></type>		<name>pid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>channel</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>payload</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>channel</name> <operator>=</operator> <call><name>pq_getmsgrawstring</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>payload</name> <operator>=</operator> <call><name>pq_getmsgrawstring</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>NotifyMyFrontEnd</name><argument_list>(<argument><expr><name>channel</name></expr></argument>, <argument><expr><name>payload</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><literal type="char">'X'</literal></expr>:</case>				<comment type="block">/* Terminate, indicating clean exit */</comment>
			<block>{<block_content>
				<expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pcxt</name><operator>-&gt;</operator><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>error_mqh</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized message type received from parallel worker: %c (message length %d bytes)"</literal></expr></argument>,
					 <argument><expr><name>msgtype</name></expr></argument>, <argument><expr><name><name>msg</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * End-of-subtransaction cleanup for parallel contexts.
 *
 * Currently, it's forbidden to enter or leave a subtransaction while
 * parallel mode is in effect, so we could just blow away everything.  But
 * we may want to relax that restriction in the future, so this code
 * contemplates that there may be multiple subtransaction IDs in pcxt_list.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOSubXact_Parallel</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcxt_list</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pcxt</name> <operator>=</operator> <call><name>dlist_head_element</name><argument_list>(<argument><expr><name>ParallelContext</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcxt_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pcxt</name><operator>-&gt;</operator><name>subid</name></name> <operator>!=</operator> <name>mySubId</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"leaked parallel context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>DestroyParallelContext</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * End-of-transaction cleanup for parallel contexts.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_Parallel</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcxt_list</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pcxt</name> <operator>=</operator> <call><name>dlist_head_element</name><argument_list>(<argument><expr><name>ParallelContext</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcxt_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"leaked parallel context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>DestroyParallelContext</name><argument_list>(<argument><expr><name>pcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Main entrypoint for parallel workers.
 */</comment>
<function><type><name>void</name></type>
<name>ParallelWorkerMain</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>main_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_toc</name>    <modifier>*</modifier></type><name>toc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FixedParallelState</name> <modifier>*</modifier></type><name>fps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>error_queue_space</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>libraryspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>entrypointstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>library_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>function_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>parallel_worker_main_type</name></type> <name>entrypt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>gucspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>combocidspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tsnapspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>asnapspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tstatespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>reindexspace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>msgbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>session_dsm_handle_space</name></decl>;</decl_stmt>

	<comment type="block">/* Set flag to indicate that we're initializing a parallel worker. */</comment>
	<expr_stmt><expr><name>InitializingParallelWorker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Establish signal handlers. */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine and set our parallel worker number. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ParallelWorkerNumber</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name><name>MyBgworkerEntry</name><operator>-&gt;</operator><name>bgw_extra</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up a memory context and resource owner. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"parallel toplevel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentMemoryContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
												 <argument><expr><literal type="string">"Parallel worker"</literal></expr></argument>,
												 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that we have a resource owner, we can attach to the dynamic shared
	 * memory segment and read the table of contents.
	 */</comment>
	<expr_stmt><expr><name>seg</name> <operator>=</operator> <call><name>dsm_attach</name><argument_list>(<argument><expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name>main_arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>seg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not map dynamic shared memory segment"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>toc</name> <operator>=</operator> <call><name>shm_toc_attach</name><argument_list>(<argument><expr><name>PARALLEL_MAGIC</name></expr></argument>, <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>toc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid magic number in dynamic shared memory segment"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Look up fixed parallel state. */</comment>
	<expr_stmt><expr><name>fps</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_FIXED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyFixedParallelState</name> <operator>=</operator> <name>fps</name></expr>;</expr_stmt>

	<comment type="block">/* Arrange to signal the leader if we exit. */</comment>
	<expr_stmt><expr><name>ParallelMasterPid</name> <operator>=</operator> <name><name>fps</name><operator>-&gt;</operator><name>parallel_master_pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ParallelMasterBackendId</name> <operator>=</operator> <name><name>fps</name><operator>-&gt;</operator><name>parallel_master_backend_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>ParallelWorkerShutdown</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we can find and attach to the error queue provided for us.  That's
	 * good, because until we do that, any errors that happen here will not be
	 * reported back to the process that requested that this worker be
	 * launched.
	 */</comment>
	<expr_stmt><expr><name>error_queue_space</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_ERROR_QUEUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mq</name> <operator>=</operator> <operator>(</operator><name>shm_mq</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>error_queue_space</name> <operator>+</operator>
					 <name>ParallelWorkerNumber</name> <operator>*</operator> <name>PARALLEL_ERROR_QUEUE_SIZE</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_mq_set_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mqh</name> <operator>=</operator> <call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_redirect_to_shm_mq</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>mqh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_set_parallel_master</name><argument_list>(<argument><expr><name><name>fps</name><operator>-&gt;</operator><name>parallel_master_pid</name></name></expr></argument>,
						   <argument><expr><name><name>fps</name><operator>-&gt;</operator><name>parallel_master_backend_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send a BackendKeyData message to the process that initiated parallelism
	 * so that it has access to our PID before it receives any other messages
	 * from us.  Our cancel key is sent, too, since that's the way the
	 * protocol message is defined, but it won't actually be used for anything
	 * in this case.
	 */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><literal type="char">'K'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>MyCancelKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Hooray! Primary initialization is complete.  Now, we need to set up our
	 * backend-local state to match the original backend.
	 */</comment>

	<comment type="block">/*
	 * Join locking group.  We must do this before anything that could try to
	 * acquire a heavyweight lock, because any heavyweight locks acquired to
	 * this point could block either directly against the parallel group
	 * leader or against some process which in turn waits for a lock that
	 * conflicts with the parallel group leader, causing an undetected
	 * deadlock.  (If we can't join the lock group, the leader has gone away,
	 * so just exit quietly.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BecomeLockGroupMember</name><argument_list>(<argument><expr><name><name>fps</name><operator>-&gt;</operator><name>parallel_master_pgproc</name></name></expr></argument>,
							   <argument><expr><name><name>fps</name><operator>-&gt;</operator><name>parallel_master_pid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Restore transaction and statement start-time timestamps.  This must
	 * happen before anything that would start a transaction, else asserts in
	 * xact.c will fire.
	 */</comment>
	<expr_stmt><expr><call><name>SetParallelStartTimestamps</name><argument_list>(<argument><expr><name><name>fps</name><operator>-&gt;</operator><name>xact_ts</name></name></expr></argument>, <argument><expr><name><name>fps</name><operator>-&gt;</operator><name>stmt_ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Identify the entry point to be called.  In theory this could result in
	 * loading an additional library, though most likely the entry point is in
	 * the core backend or in a library we just loaded.
	 */</comment>
	<expr_stmt><expr><name>entrypointstate</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_ENTRYPOINT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>library_name</name> <operator>=</operator> <name>entrypointstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>function_name</name> <operator>=</operator> <name>entrypointstate</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>library_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>entrypt</name> <operator>=</operator> <call><name>LookupParallelWorkerFunction</name><argument_list>(<argument><expr><name>library_name</name></expr></argument>, <argument><expr><name>function_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore database connection. */</comment>
	<expr_stmt><expr><call><name>BackgroundWorkerInitializeConnectionByOid</name><argument_list>(<argument><expr><name><name>fps</name><operator>-&gt;</operator><name>database_id</name></name></expr></argument>,
											  <argument><expr><name><name>fps</name><operator>-&gt;</operator><name>authenticated_user_id</name></name></expr></argument>,
											  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set the client encoding to the database encoding, since that is what
	 * the leader will expect.
	 */</comment>
	<expr_stmt><expr><call><name>SetClientEncoding</name><argument_list>(<argument><expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Load libraries that were loaded by original backend.  We want to do
	 * this before restoring GUCs, because the libraries might define custom
	 * variables.
	 */</comment>
	<expr_stmt><expr><name>libraryspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_LIBRARY</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RestoreLibraryState</name><argument_list>(<argument><expr><name>libraryspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore GUC values from launching backend. */</comment>
	<expr_stmt><expr><name>gucspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_GUC</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RestoreGUCState</name><argument_list>(<argument><expr><name>gucspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Crank up a transaction state appropriate to a parallel worker. */</comment>
	<expr_stmt><expr><name>tstatespace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TRANSACTION_STATE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartParallelWorkerTransaction</name><argument_list>(<argument><expr><name>tstatespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore combo CID state. */</comment>
	<expr_stmt><expr><name>combocidspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_COMBO_CID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RestoreComboCIDState</name><argument_list>(<argument><expr><name>combocidspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Attach to the per-session DSM segment and contained objects. */</comment>
	<expr_stmt><expr><name>session_dsm_handle_space</name> <operator>=</operator>
		<call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_SESSION_DSM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AttachSession</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>dsm_handle</name> <operator>*</operator><operator>)</operator> <name>session_dsm_handle_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore transaction snapshot. */</comment>
	<expr_stmt><expr><name>tsnapspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_TRANSACTION_SNAPSHOT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RestoreTransactionSnapshot</name><argument_list>(<argument><expr><call><name>RestoreSnapshot</name><argument_list>(<argument><expr><name>tsnapspace</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name><name>fps</name><operator>-&gt;</operator><name>parallel_master_pgproc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore active snapshot. */</comment>
	<expr_stmt><expr><name>asnapspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_ACTIVE_SNAPSHOT</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>RestoreSnapshot</name><argument_list>(<argument><expr><name>asnapspace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We've changed which tuples we can see, and must therefore invalidate
	 * system caches.
	 */</comment>
	<expr_stmt><expr><call><name>InvalidateSystemCaches</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Restore current role id.  Skip verifying whether session user is
	 * allowed to become this role and blindly restore the leader's state for
	 * current role.
	 */</comment>
	<expr_stmt><expr><call><name>SetCurrentRoleId</name><argument_list>(<argument><expr><name><name>fps</name><operator>-&gt;</operator><name>outer_user_id</name></name></expr></argument>, <argument><expr><name><name>fps</name><operator>-&gt;</operator><name>is_superuser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore user ID and security context. */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>fps</name><operator>-&gt;</operator><name>current_user_id</name></name></expr></argument>, <argument><expr><name><name>fps</name><operator>-&gt;</operator><name>sec_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore temp-namespace state to ensure search path matches leader's. */</comment>
	<expr_stmt><expr><call><name>SetTempNamespaceState</name><argument_list>(<argument><expr><name><name>fps</name><operator>-&gt;</operator><name>temp_namespace_id</name></name></expr></argument>,
						  <argument><expr><name><name>fps</name><operator>-&gt;</operator><name>temp_toast_namespace_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore reindex state. */</comment>
	<expr_stmt><expr><name>reindexspace</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_KEY_REINDEX_STATE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RestoreReindexState</name><argument_list>(<argument><expr><name>reindexspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We've initialized all of our state now; nothing should change
	 * hereafter.
	 */</comment>
	<expr_stmt><expr><name>InitializingParallelWorker</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnterParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Time to do the real work: invoke the caller-supplied code.
	 */</comment>
	<expr_stmt><expr><call><name>entrypt</name><argument_list>(<argument><expr><name>seg</name></expr></argument>, <argument><expr><name>toc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must exit parallel mode to pop active snapshot. */</comment>
	<expr_stmt><expr><call><name>ExitParallelMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must pop active snapshot so resowner.c doesn't complain. */</comment>
	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shut down the parallel-worker transaction. */</comment>
	<expr_stmt><expr><call><name>EndParallelWorkerTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Detach from the per-session DSM segment. */</comment>
	<expr_stmt><expr><call><name>DetachSession</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report success. */</comment>
	<expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'X'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update shared memory with the ending location of the last WAL record we
 * wrote, if it's greater than the value already stored there.
 */</comment>
<function><type><name>void</name></type>
<name>ParallelWorkerReportLastRecEnd</name><parameter_list>(<parameter><decl><type><name>XLogRecPtr</name></type> <name>last_xlog_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FixedParallelState</name> <modifier>*</modifier></type><name>fps</name> <init>= <expr><name>MyFixedParallelState</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fps</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fps</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fps</name><operator>-&gt;</operator><name>last_xlog_end</name></name> <operator>&lt;</operator> <name>last_xlog_end</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fps</name><operator>-&gt;</operator><name>last_xlog_end</name></name> <operator>=</operator> <name>last_xlog_end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fps</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make sure the leader tries to read from our error queue one more time.
 * This guards against the case where we exit uncleanly without sending an
 * ErrorResponse to the leader, for example because some code calls proc_exit
 * directly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParallelWorkerShutdown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SendProcSignal</name><argument_list>(<argument><expr><name>ParallelMasterPid</name></expr></argument>,
				   <argument><expr><name>PROCSIG_PARALLEL_MESSAGE</name></expr></argument>,
				   <argument><expr><name>ParallelMasterBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Look up (and possibly load) a parallel worker entry point function.
 *
 * For functions contained in the core code, we use library name "postgres"
 * and consult the InternalParallelWorkers array.  External functions are
 * looked up, and loaded if necessary, using load_external_function().
 *
 * The point of this is to pass function names as strings across process
 * boundaries.  We can't pass actual function addresses because of the
 * possibility that the function has been loaded at a different address
 * in a different process.  This is obviously a hazard for functions in
 * loadable libraries, but it can happen even for functions in the core code
 * on platforms using EXEC_BACKEND (e.g., Windows).
 *
 * At some point it might be worthwhile to get rid of InternalParallelWorkers[]
 * in favor of applying load_external_function() for core functions too;
 * but that raises portability issues that are not worth addressing now.
 */</comment>
<function><type><specifier>static</specifier> <name>parallel_worker_main_type</name></type>
<name>LookupParallelWorkerFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libraryname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the function is to be loaded from postgres itself, search the
	 * InternalParallelWorkers array.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>libraryname</name></expr></argument>, <argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>InternalParallelWorkers</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>InternalParallelWorkers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_name</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>InternalParallelWorkers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fn_addr</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* We can only reach this by programming error. */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"internal function \"%s\" not found"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Otherwise load from external library. */</comment>
	<return>return <expr><operator>(</operator><name>parallel_worker_main_type</name><operator>)</operator>
		<call><name>load_external_function</name><argument_list>(<argument><expr><name>libraryname</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
