<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/transam/slru.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * slru.c
 *		Simple LRU buffering for transaction status logfiles
 *
 * We use a simple least-recently-used scheme to manage a pool of page
 * buffers.  Under ordinary circumstances we expect that write
 * traffic will occur mostly to the latest page (and to the just-prior
 * page, soon after a page transition).  Read traffic will probably touch
 * a larger span of pages, but in any case a fairly small number of page
 * buffers should be sufficient.  So, we just search the buffers using plain
 * linear search; there's no need for a hashtable or anything fancy.
 * The management algorithm is straight LRU except that we will never swap
 * out the latest page (since we know it's going to be hit again eventually).
 *
 * We use a control LWLock to protect the shared data structures, plus
 * per-buffer LWLocks that synchronize I/O for each buffer.  The control lock
 * must be held to examine or modify any shared state.  A process that is
 * reading in or writing out a page buffer does not hold the control lock,
 * only the per-buffer lock for the buffer it is working on.
 *
 * "Holding the control lock" means exclusive lock in all cases except for
 * SimpleLruReadPage_ReadOnly(); see comments for SlruRecentlyUsed() for
 * the implications of that.
 *
 * When initiating I/O on a buffer, we acquire the per-buffer lock exclusively
 * before releasing the control lock.  The per-buffer lock is released after
 * completing the I/O, re-acquiring the control lock, and updating the shared
 * state.  (Deadlock is not possible here, because we never try to initiate
 * I/O when someone else is already doing I/O on the same buffer.)
 * To wait for I/O to complete, release the control lock, acquire the
 * per-buffer lock in shared mode, immediately release the per-buffer lock,
 * reacquire the control lock, and then recheck state (since arbitrary things
 * could have happened while we didn't have the lock).
 *
 * As with the regular buffer manager, it is possible for another process
 * to re-dirty a page that is currently being written out.  This is handled
 * by re-setting the page's page_dirty flag.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/backend/access/transam/slru.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/slru.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_fd.h"</cpp:file></cpp:include>

<comment type="block">/*
 * During SimpleLruFlush(), we will usually not need to write/fsync more
 * than one or two physical files, but we may need to write several pages
 * per file.  We can consolidate the I/O requests by leaving files open
 * until control returns to SimpleLruFlush().  This data structure remembers
 * which files are open.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FLUSH_BUFFERS</name></cpp:macro>	<cpp:value>16</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>SlruFlushData</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>num_files</name></decl>;</decl_stmt>		<comment type="block">/* # files actually open */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>fd</name><index>[<expr><name>MAX_FLUSH_BUFFERS</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* their FD's */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>segno</name><index>[<expr><name>MAX_FLUSH_BUFFERS</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* their log seg#s */</comment>
}</block></struct></type> <name>SlruFlushData</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>SlruFlushData</name></name> <modifier>*</modifier></type><name>SlruFlush</name>;</typedef>

<comment type="block">/*
 * Macro to mark a buffer slot "most recently used".  Note multiple evaluation
 * of arguments!
 *
 * The reason for the if-test is that there are often many consecutive
 * accesses to the same page (particularly the latest page).  By suppressing
 * useless increments of cur_lru_count, we reduce the probability that old
 * pages' counts will "wrap around" and make them appear recently used.
 *
 * We allow this code to be executed concurrently by multiple processes within
 * SimpleLruReadPage_ReadOnly().  As long as int reads and writes are atomic,
 * this should not cause any completely-bogus values to enter the computation.
 * However, it is possible for either cur_lru_count or individual
 * page_lru_count entries to be "reset" to lower values than they should have,
 * in case a process is delayed while it executes this macro.  With care in
 * SlruSelectLRUPage(), this does little harm, and in any case the absolute
 * worst possible consequence is a nonoptimal choice of page to evict.  The
 * gain from allowing concurrent reads of SLRU pages seems worth it.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlruRecentlyUsed</name><parameter_list>(<parameter><type><name>shared</name></type></parameter>, <parameter><type><name>slotno</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>do { \
		int		new_lru_count = (shared)-&gt;cur_lru_count; \
		if (new_lru_count != (shared)-&gt;page_lru_count[slotno]) { \
			(shared)-&gt;cur_lru_count = ++new_lru_count; \
			(shared)-&gt;page_lru_count[slotno] = new_lru_count; \
		} \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Saved info for SlruReportIOError */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>SLRU_OPEN_FAILED</name></decl>,
	<decl><name>SLRU_SEEK_FAILED</name></decl>,
	<decl><name>SLRU_READ_FAILED</name></decl>,
	<decl><name>SLRU_WRITE_FAILED</name></decl>,
	<decl><name>SLRU_FSYNC_FAILED</name></decl>,
	<decl><name>SLRU_CLOSE_FAILED</name></decl>,
	<decl><name>SLRU_CACHE_READ_FAILED</name></decl>,
	<decl><name>SLRU_CACHE_WRITE_FAILED</name></decl>,
	<decl><name>SLRU_CACHE_SYNC_FAILED</name></decl>
}</block></enum></type> <name>SlruErrorCause</name>;</typedef>

<comment type="block">/* POLAR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>POLAR_SLRU_FILE_IN_SHARED_STORAGE</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>(polar_enable_shared_storage_mode &amp;&amp; ctl-&gt;shared-&gt;polar_file_in_shared_storage)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>polar_slru_stat</name> <modifier>*</modifier></type><name><name>polar_slru_stats</name><index>[<expr><name>POLAR_SLRU_STATS_NUM</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n_polar_slru_stats</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SlruErrorCause</name></type> <name>slru_errcause</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>slru_errno</name></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SimpleLruZeroLSNs</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SimpleLruWaitIO</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SlruInternalWritePage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>SlruFlush</name></type> <name>fdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>update</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SlruPhysicalReadPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SlruPhysicalWritePage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>,
					  <parameter><decl><type><name>SlruFlush</name></type> <name>fdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>update</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SlruReportIOError</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>SlruSelectLRUPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SlruScanDirCbDeleteCutoff</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SlruInternalDeleteSegment</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_slru_file_name_by_seg</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>seg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_slru_file_name_by_name</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_slru_file_dir</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_slru_local_cache_read_page</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>polar_slru_local_cache_write_page</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlruFileName</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>			<cpp:value>polar_slru_file_name_by_seg(a,b,c)</cpp:value></cpp:define>

<comment type="block">/* POLAR: hash table */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SlruHashSlots</name><parameter_list>(<parameter><type><name>nslots</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(nslots * 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VICTIM_WINDOW</name></cpp:macro>				<cpp:value>128</cpp:value></cpp:define>      <comment type="block">/* victim slot window */</comment>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>polar_slru_set_page_status</name><parameter_list>(<parameter><decl><type><name>SlruShared</name></type> <name>shared</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>SlruPageStatus</name></type> <name>pagestatus</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_slru_hash_init</name><parameter_list>(<parameter><decl><type><name>SlruShared</name></type> <name>shared</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nslots</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialization of shared memory
 */</comment>

<function><type><specifier>static</specifier> <name>Size</name></type>
<name>SimpleLruPureShmemSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nslots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlsns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sz</name></decl>;</decl_stmt>

	<comment type="block">/* we assume nslots isn't so large as to risk overflow */</comment>
	<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SlruSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_buffer[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SlruPageStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_status[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_dirty[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_number[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* page_lru_count[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LWLockPadded</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* buffer_locks[] */</comment>
	<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>POLAR_SUCCESSOR_LIST_SIZE</name><argument_list>(<argument><expr><name>nslots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* polar_free_list */</comment>

	<if_stmt><if>if <condition>(<expr><name>nlsns</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sz</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <name>nlsns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* group_lsn[] */</comment>

	<comment type="block">/* POLAR: extra alignment padding for SLRU data I/O buffers */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_buffer_alignment</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>POLAR_BUFFER_EXTEND_SIZE</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><call><name>BUFFERALIGN</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>BLCKSZ</name> <operator>*</operator> <name>nslots</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Size</name></type>
<name>SimpleLruShmemSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nslots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlsns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>sz</name> <init>= <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>SimpleLruPureShmemSize</name><argument_list>(<argument><expr><name>nslots</name></expr></argument>, <argument><expr><name>nlsns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* POLAR: Add size for hash table */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>nslots</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_slru_hash_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>sz</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: polar_remote_file slru file can put into remote file system 
 */</comment>
<function><type><name>void</name></type>
<name>SimpleLruInit</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nslots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlsns</name></decl></parameter>,
			  <parameter><decl><type><name>LWLock</name> <modifier>*</modifier></type><name>ctllock</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subdir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tranche_id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>polar_shared_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>shared</name> <operator>=</operator> <operator>(</operator><name>SlruShared</name><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
										  <argument><expr><call><name>SimpleLruPureShmemSize</name><argument_list>(<argument><expr><name>nslots</name></expr></argument>, <argument><expr><name>nlsns</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Initialize locks and shared memory area */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>offset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> 		<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SlruSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_file_in_shared_storage</name></name> <operator>=</operator> <name>polar_shared_file</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name> <operator>=</operator> <name>ctllock</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name> <operator>=</operator> <name>nslots</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name> <operator>=</operator> <name>nlsns</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>cur_lru_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* shared-&gt;latest_page_number will be set later */</comment>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>shared</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SlruSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name></name> <operator>=</operator> <operator>(</operator><name>SlruPageStatus</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SlruPageStatus</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize LWLocks */</comment>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name></name> <operator>=</operator> <operator>(</operator><name>LWLockPadded</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LWLockPadded</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* POLAR: Init free list */</comment>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_free_list</name></name> <operator>=</operator> <call><name>polar_successor_list_init</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>, <argument><expr><name>nslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>POLAR_SUCCESSOR_LIST_SIZE</name><argument_list>(<argument><expr><name>nslots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nlsns</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>group_lsn</name></name> <operator>=</operator> <operator>(</operator><name>XLogRecPtr</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <name>nlsns</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>SLRU_MAX_NAME_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>lwlock_tranche_name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>SLRU_MAX_NAME_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name> <operator>=</operator> <name>tranche_id</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>BUFFERALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* POLAR: align buffer for SLRU data I/O buffers */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_buffer_alignment</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>POLAR_BUFFER_ALIGN</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name>nslots</name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>,
							 <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
			<comment type="block">/* POLAR: set page status */</comment>
			<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* POLAR: for slru stat */</comment>
		<comment type="block">/* polar_slru_stat */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_slru_stat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>stat</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>lwlock_tranche_name</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>stat</name><operator>.</operator><name>n_slots</name></name> <operator>=</operator> <operator>(</operator><name>uint</name><operator>)</operator><name>nslots</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>stat</name><operator>.</operator><name>n_page_status_stat</name><index>[<expr><name>SLRU_PAGE_EMPTY</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint</name><operator>)</operator><name>nslots</name></expr>;</expr_stmt>

		<comment type="block">/* push into polar_slru_stats */</comment>
		<if_stmt><if>if <condition>(<expr><name>n_polar_slru_stats</name> <operator>&lt;</operator> <name>POLAR_SLRU_STATS_NUM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>polar_slru_stats</name><index>[<expr><name>n_polar_slru_stats</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>n_polar_slru_stats</name> <operator>&gt;=</operator> <name>POLAR_SLRU_STATS_NUM</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>POLAR_SLRU_STATS_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"slru exceed max number %d, slru stat[%d] type[%s]"</literal></expr></argument>,
						<argument><expr><name>POLAR_SLRU_STATS_NUM</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>polar_slru_stats</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exceed max number of POLAR_SLRU_STATS_NUM"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* POLAR: end */</comment>

		<comment type="block">/* POLAR: victim pivot init */</comment>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>victim_pivot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* Should fit to estimated shmem size */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>shared</name> <operator>&lt;=</operator> <call><name>SimpleLruPureShmemSize</name><argument_list>(<argument><expr><name>nslots</name></expr></argument>, <argument><expr><name>nlsns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* POLAR: Init shared hash table */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_slru_hash_init</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>nslots</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* POLAR: Disable polar local file cache */</comment>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * POLAR: This flag is true when do online promote and allow this slru to write data to shared storage.
		 * The default value is false
		 */</comment>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_ro_promoting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Register SLRU tranche in the main tranches array */</comment>
	<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>lwlock_tranche_id</name></name></expr></argument>,
						  <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>lwlock_tranche_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the unshared control struct, including directory path. We
	 * assume caller set PagePrecedes.
	 */</comment>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <name>shared</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>do_fsync</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>		<comment type="block">/* default behavior */</comment>
	<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>subdir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize (or reinitialize) a page to zeroes.
 *
 * The page is not actually written, just set up in shared memory.
 * The slot number of the new page is returned.
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><name>int</name></type>
<name>SimpleLruZeroPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR: slru stat */</comment>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_zero_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Find a suitable buffer slot for the page */</comment>
	<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SlruSelectLRUPage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name> <operator>||</operator>
		   <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator> <operator>||</operator>
		   <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name> <operator>&amp;&amp;</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>,
					<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"slru hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Mark the slot as containing this page */</comment>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_slru_hash_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>polar_slru_hash_entry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>,
				<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pageno</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the buffer to zeroes */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set the LSNs for this new page to zero */</comment>
	<expr_stmt><expr><call><name>SimpleLruZeroLSNs</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assume this page is now the latest active page */</comment>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>

	<return>return <expr><name>slotno</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Zero all the LSNs we store for this slru page.
 *
 * This should be called each time we create a new page, and each time we read
 * in a page from disk into an existing buffer.  (Such an old page cannot
 * have any interesting LSNs, since we'd have flushed them before writing
 * the page in the first place.)
 *
 * This assumes that InvalidXLogRecPtr is bitwise-all-0.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SimpleLruZeroLSNs</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>group_lsn</name><index>[<expr><name>slotno</name> <operator>*</operator> <name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XLogRecPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for any active I/O on a page slot to finish.  (This does not
 * guarantee that new I/O hasn't been started before we return, though.
 * In fact the slot might not even contain the same page anymore.)
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SimpleLruWaitIO</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR: slru stat */</comment>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>wait_reading</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>wait_writing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>wait_reading</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_wait_reading_count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>wait_writing</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_wait_writing_count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* POLAR: end */</comment>

	<comment type="block">/* See notes at top of file */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: slru stat */</comment>
	<if_stmt><if>if <condition>(<expr><name>wait_reading</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_wait_reading_count</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>wait_writing</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_wait_writing_count</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* POLAR: end */</comment>

	<comment type="block">/*
	 * If the slot is still in an io-in-progress state, then either someone
	 * already started a new I/O on the slot, or a previous I/O failed and
	 * neglected to reset the page state.  That shouldn't happen, really, but
	 * it seems worth a few extra cycles to check and recover from it. We can
	 * cheaply test for failure by seeing if the buffer lock is still held (we
	 * assume that transaction abort would release the lock).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name> <operator>||</operator>
		<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>LWLockConditionalAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* indeed, the I/O must have failed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>,
								<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"slru hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>polar_successor_list_push</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_free_list</name></name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else				<comment type="block">/* write_in_progress */</comment>
			<block>{<block_content>
				<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find a page in a shared buffer, reading it in if necessary.
 * The page number must correspond to an already-initialized page.
 *
 * If write_ok is true then it is OK to return a page that is in
 * WRITE_IN_PROGRESS state; it is the caller's responsibility to be sure
 * that modification of the page is safe.  If write_ok is false then we
 * will not return the page until it is not undergoing active I/O.
 *
 * The passed-in xid is used only for error reporting, and may be
 * InvalidTransactionId if no specific xid is associated with the action.
 *
 * Return value is the shared-buffer slot number now holding the page.
 * The buffer's LRU access info is updated.
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><name>int</name></type>
<name>SimpleLruReadPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>write_ok</name></decl></parameter>,
				  <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR: slru stat */</comment>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_read_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Outer loop handles restart if we must wait for someone else's I/O */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>

		<comment type="block">/* See if page already is in memory; if not, pick victim slot */</comment>
		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SlruSelectLRUPage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Did we find the page in memory? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
			<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If page is still being read in, we must wait for I/O.  Likewise
			 * if the page is being written and the caller said that's not OK.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name> <operator>||</operator>
				<operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><name>write_ok</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Now we must recheck state from the top */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Otherwise, it's ready to use */</comment>
			<expr_stmt><expr><call><name>SlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>slotno</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We found no match; assert we selected a freeable slot */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name> <operator>||</operator>
			   <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name> <operator>&amp;&amp;</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Polar: victim page replace, delete it first */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>,
						<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>,
						<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"slru hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Mark the slot read-busy */</comment>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_READ_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>polar_slru_hash_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>polar_slru_hash_entry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pageno</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Acquire per-buffer lock (cannot deadlock, see notes at top) */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Release control lock while doing I/O */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do the read */</comment>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>SlruPhysicalReadPage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set the LSNs for this newly read-in page to zero */</comment>
		<expr_stmt><expr><call><name>SimpleLruZeroLSNs</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Re-acquire control lock and update page state */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
			   <name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name> <operator>&amp;&amp;</operator>
			   <operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>,
							<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>,
							<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"slru hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>polar_successor_list_push</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_free_list</name></name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><ternary><condition><expr><name>ok</name></expr> ?</condition><then> <expr><name>SLRU_PAGE_VALID</name></expr> </then><else>: <expr><name>SLRU_PAGE_EMPTY</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now it's okay to ereport if we failed */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Release control lock before elog */</comment>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<expr_stmt><expr><call><name>SlruReportIOError</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>SlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>slotno</name></expr>;</return>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Find a page in a shared buffer, reading it in if necessary.
 * The page number must correspond to an already-initialized page.
 * The caller must intend only read-only access to the page.
 *
 * The passed-in xid is used only for error reporting, and may be
 * InvalidTransactionId if no specific xid is associated with the action.
 *
 * Return value is the shared-buffer slot number now holding the page.
 * The buffer's LRU access info is updated.
 *
 * Control lock must NOT be held at entry, but will be held at exit.
 * It is unspecified whether the lock will be shared or exclusive.
 */</comment>
<function><type><name>int</name></type>
<name>SimpleLruReadPage_ReadOnly</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR: slru stat */</comment>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Try to find the page while holding only shared lock */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: not accurate in SharedLock, but it doesn't matter */</comment>
	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_read_only_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* See if page is already in a buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_slru_hash_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pageno</name></expr></argument>,
				<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name> <operator>&amp;&amp;</operator>
			<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else 
	<block>{<block_content>
		<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
				<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name> <operator>&amp;&amp;</operator>
				<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* See comments for SlruRecentlyUsed macro */</comment>
				<expr_stmt><expr><call><name>SlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>slotno</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>


	<comment type="block">/* No luck, so switch to normal exclusive lock and do regular read */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_read_upgrade_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR for csnlog */</comment>

<comment type="block">/*
 * Same as SimpleLruReadPage_ReadOnly, but the shared lock must be held by the caller
 * and will try best be held at exit.
 */</comment>
<function><type><name>int</name></type>
<name>SimpleLruReadPage_ReadOnly_Locked</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>slotno</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR: slru stat */</comment>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR slru hash search */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>share_lock_retry_times</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
	<comment type="block">/* POLAR end */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR: not accurate in SharedLock, but it doesn't matter */</comment>
	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_read_only_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* See if page is already in a buffer */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>polar_slru_hash_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pageno</name></expr></argument>,
					<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name> <operator>&amp;&amp;</operator>
				<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else 
		<block>{<block_content>
			<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
					<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name> <operator>&amp;&amp;</operator>
					<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* See comments for SlruRecentlyUsed macro */</comment>
					<expr_stmt><expr><call><name>SlruRecentlyUsed</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>slotno</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* No luck, so switch to normal exclusive lock and do regular read */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_read_upgrade_count</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>SimpleLruReadPage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In worst case, we maybe fall in dead loop for trying to get share lock.
		 * So we set a deadline retry time and return with exclusive lock held.
		 * Performance maybe degrade because of this, so we log the event for 
		 * later diagnostics.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>share_lock_retry_times</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>slotno</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content> 
			<expr_stmt><expr><name>share_lock_retry_times</name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* POLAR: not accurate in SharedLock, but it doesn't matter */</comment>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_read_only_count</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 * Write a page from a shared buffer, if necessary.
 * Does nothing if the specified slot is not dirty.
 *
 * NOTE: only one write attempt is made here.  Hence, it is possible that
 * the page is still dirty at exit (if someone else re-dirtied it during
 * the write).  However, we *do* attempt a fresh write even if the page
 * is already being written; this is for checkpoints.
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SlruInternalWritePage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>SlruFlush</name></type> <name>fdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>update</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name> <init>= <expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR: stat */</comment>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_write_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* If a write is in progress, wait for it to finish */</comment>
	<while>while <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name> <operator>&amp;&amp;</operator>
		   <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Do nothing if page is not dirty, or if buffer no longer contains the
	 * same page we were called for.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>||</operator>
		<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_VALID</name> <operator>||</operator>
		<name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>pageno</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Mark the slot write-busy, and clear the dirtybit.  After this point, a
	 * transaction status update on this page will mark it dirty again.
	 */</comment>
	<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Acquire per-buffer lock (cannot deadlock, see notes at top) */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release control lock while doing I/O */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do the write */</comment>
	<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>SlruPhysicalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>fdata</name></expr></argument>, <argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we failed, and we're in a flush, better close the files */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name> <operator>&amp;&amp;</operator> <name>fdata</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name><name>fdata</name><operator>-&gt;</operator><name>fd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Re-acquire control lock and update page state */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
		   <name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we failed to write, mark the page dirty again */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>buffer_locks</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now it's okay to ereport if we failed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SlruReportIOError</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wrapper of SlruInternalWritePage, for external callers.
 * fdata is always passed a NULL here.
 */</comment>
<function><type><name>void</name></type>
<name>SimpleLruWritePage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SlruInternalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return whether the given page exists on disk.
 *
 * A false return means that either the file does not exist, or that it's not
 * large enough to contain the given page.
 */</comment>
<function><type><name>bool</name></type>
<name>SimpleLruDoesPhysicalPageExist</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>endpos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SlruFileName</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_open_transient_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* expected: file doesn't exist */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* report error normally */</comment>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_OPEN_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SlruReportIOError</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>endpos</name> <operator>=</operator> <call><name>polar_lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_SEEK_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SlruReportIOError</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>endpos</name> <operator>&gt;=</operator> <operator>(</operator><name>off_t</name><operator>)</operator> <operator>(</operator><name>offset</name> <operator>+</operator> <name>BLCKSZ</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Physical read of a (previously existing) page into a buffer slot
 *
 * On failure, we cannot just ereport(ERROR) since caller has put state in
 * shared memory that must be undone.  So, we return false and save enough
 * info in static variables to let SlruReportIOError make the report.
 *
 * For now, assume it's not worth keeping a file pointer open across
 * read/write operations.  We could cache one virtual file pointer ...
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SlruPhysicalReadPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR: slru stat */</comment>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_storage_read_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* POLAR: If local file cache is enabled, we read data from cache */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>polar_slru_local_cache_read_page</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SlruFileName</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a crash-and-restart situation, it's possible for us to receive
	 * commands to set the commit status of transactions whose bits are in
	 * already-truncated segments of the commit log (see notes in
	 * SlruPhysicalWritePage).  Hence, if we are InRecovery, allow the case
	 * where the file doesn't exist, and return zeroes instead.
	 */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_open_transient_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name> <operator>||</operator> <operator>!</operator><name>InRecovery</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_OPEN_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"file \"%s\" doesn't exist, reading as zeroes"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SLRU_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>polar_pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * POLAR: In a csn upgrade situation, it's possible for us to set the csn 
		 * of transactions whose bytes are not exists. Hence, if we are 
		 * InRecovery, allow the case, and return zeroes instead.
		 */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>InRecovery</name> <operator>&amp;&amp;</operator> <call><name>polar_fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fst</name><operator>.</operator><name>st_size</name></name> <operator>&lt;=</operator> <name>offset</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"read beyond the end of file \"%s\", reading as zeroes"</literal></expr></argument>,
									<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_READ_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_CLOSE_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Physical write of a page from a buffer slot
 *
 * On failure, we cannot just ereport(ERROR) since caller has put state in
 * shared memory that must be undone.  So, we return false and save enough
 * info in static variables to let SlruReportIOError make the report.
 *
 * For now, assume it's not worth keeping a file pointer open across
 * independent read/write operations.  We do batch operations during
 * SimpleLruFlush, though.
 *
 * fdata is NULL for a standalone write, pointer to open-file info during
 * SimpleLruFlush.
 *
 * POLAR: If we know this segment is an append-only file and set update to be true, then
 * the file will be opend without O_CREAT flag. If O_CREAT flag is set then pfs acquires 
 * a write lock, otherwise it acquires a read lock.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SlruPhysicalWritePage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>SlruFlush</name></type> <name>fdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>update</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * POLAR: Don't write page to shared storage if it's in replica mode.
	 * We allow to write shared storage if replica is doing online promote and set flag
	 * polar_ro_promoting to be true.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>POLAR_SLRU_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>polar_ro_promoting</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SlruFileName</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"polardb replica skip write file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* POLAR: slru stat */</comment>
	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_storage_write_count</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Honor the write-WAL-before-data rule, if appropriate, so that we do not
	 * write out data before associated WAL records.  This is the same action
	 * performed during FlushBuffer() in the main buffer manager.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>group_lsn</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We must determine the largest async-commit LSN for the page. This
		 * is a bit tedious, but since this entire function is a slow path
		 * anyway, it seems better to do this here than to maintain a per-page
		 * LSN variable (which'd need an extra comparison in the
		 * transaction-commit path).
		 */</comment>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>max_lsn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>lsnindex</name></decl>,
					<decl><type ref="prev"/><name>lsnoff</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lsnindex</name> <operator>=</operator> <name>slotno</name> <operator>*</operator> <name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>max_lsn</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>group_lsn</name><index>[<expr><name>lsnindex</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>lsnoff</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lsnoff</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>lsn_groups_per_page</name></name></expr>;</condition> <incr><expr><name>lsnoff</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>this_lsn</name> <init>= <expr><name><name>shared</name><operator>-&gt;</operator><name>group_lsn</name><index>[<expr><name>lsnindex</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>max_lsn</name> <operator>&lt;</operator> <name>this_lsn</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>max_lsn</name> <operator>=</operator> <name>this_lsn</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name>max_lsn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * As noted above, elog(ERROR) is not acceptable here, so if
			 * XLogFlush were to fail, we must PANIC.  This isn't much of a
			 * restriction because XLogFlush is just about all critical
			 * section anyway, but let's make sure.
			 */</comment>
			<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>XLogFlush</name><argument_list>(<argument><expr><name>max_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* POLAR: If local file cache is enabled, we write data to cache */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>polar_slru_local_cache_write_page</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * During a Flush, we may already have the desired file open.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fdata</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fdata</name><operator>-&gt;</operator><name>segno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>segno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fd</name> <operator>=</operator> <name><name>fdata</name><operator>-&gt;</operator><name>fd</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the file doesn't already exist, we should create it.  It is
		 * possible for this to need to happen when writing a page that's not
		 * first in its segment; we assume the OS can cope with that. (Note:
		 * it might seem that it'd be okay to create files only when
		 * SimpleLruZeroPage is called for the first page of a segment.
		 * However, if after a crash and restart the REDO logic elects to
		 * replay the log from a checkpoint before the latest one, then it's
		 * possible that we will get commands to set transaction status of
		 * transactions that have already been truncated from the commit log.
		 * Easiest way to deal with that is to accept references to
		 * nonexistent files here and in SlruPhysicalReadPage.)
		 *
		 * Note: it is possible for more than one backend to be executing this
		 * code simultaneously for different pages of the same file. Hence,
		 * don't use O_EXCL or O_TRUNC or anything like that.
		 */</comment>

		<comment type="block">/*
		 * POLAR: We reuse this slru code for other usage.If we know this is an append-only
		 * file then we will set O_CREAT flag only when offset is zero.
		 * This is an optimization for pfs lock. When O_CREAT is set pfs will use write lock,
		 * and otherwise it uses read lock
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>update</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>O_CREAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>SlruFileName</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>polar_open_transient_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_OPEN_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>fdata</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name> <operator>&lt;</operator> <name>MAX_FLUSH_BUFFERS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fdata</name><operator>-&gt;</operator><name>fd</name><index>[<expr><name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name></expr>]</index></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fdata</name><operator>-&gt;</operator><name>segno</name><index>[<expr><name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name></expr>]</index></name> <operator>=</operator> <name>segno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fdata</name><operator>-&gt;</operator><name>num_files</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * In the unlikely event that we exceed MAX_FLUSH_BUFFERS,
				 * fall back to treating it as a standalone write.
				 */</comment>
				<expr_stmt><expr><name>fdata</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SLRU_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>polar_pwrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_WRITE_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fdata</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If not part of Flush, need to fsync now.  We assume this happens
	 * infrequently enough that it's not a performance issue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fdata</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SLRU_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>do_fsync</name></name> <operator>&amp;&amp;</operator> <call><name>polar_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_FSYNC_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_CLOSE_FAILED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Issue the error message after failure of SlruPhysicalReadPage or
 * SlruPhysicalWritePage.  Call this after cleaning up shared-memory state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SlruReportIOError</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SlruFileName</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>slru_errno</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>slru_errcause</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SLRU_OPEN_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not open file \"%s\": %m."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_SEEK_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not seek in file \"%s\" to offset %u: %m."</literal></expr></argument>,
							   <argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_READ_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not read from file \"%s\" at offset %u: %m."</literal></expr></argument>,
							   <argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_WRITE_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not write to file \"%s\" at offset %u: %m."</literal></expr></argument>,
							   <argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_FSYNC_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><call><name>data_sync_elevel</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not fsync file \"%s\": %m."</literal></expr></argument>,
							   <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_CLOSE_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not access status of transaction %u"</literal></expr></argument>, <argument><expr><name>xid</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Could not close file \"%s\": %m."</literal></expr></argument>,
							   <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_CACHE_READ_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to read page=%d from %s local file cache, offset=%d"</literal></expr></argument>,
					<argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_CACHE_WRITE_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to write page=%d from %s local file cache, offset=%d"</literal></expr></argument>,
					<argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLRU_CACHE_SYNC_FAILED</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to sync local file cache"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* can't get here, we trust */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized SimpleLru error cause: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>slru_errcause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Select the slot to re-use when we need a free slot.
 *
 * The target page number is passed because we need to consider the
 * possibility that some other process reads in the target page while
 * we are doing I/O to free a slot.  Hence, check or recheck to see if
 * any slot already holds the target page, and return that slot if so.
 * Thus, the returned slot is *either* a slot already holding the pageno
 * (could be any state except EMPTY), *or* a freeable slot (state EMPTY
 * or CLEAN).
 *
 * Control lock must be held at entry, and will be held at exit.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>SlruSelectLRUPage</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Outer loop handles restart after I/O */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cur_count</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bestvalidslot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_valid_delta</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_valid_page_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* keep compiler quiet */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>bestinvalidslot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_invalid_delta</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>best_invalid_page_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>

		<comment type="block">/* See if page already has a buffer assigned */</comment>
		<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>polar_slru_hash_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>polar_slru_hash_entry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>pageno</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>POLAR_SUCCESSOR_LIST_EMPTY</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_free_list</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>slotno</name> <operator>=</operator> <call><name>polar_successor_list_pop</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_free_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>slotno</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name> <operator>&amp;&amp;</operator>
					<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>slotno</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If we find any EMPTY slot, just select that one. Else choose a
		 * victim page to replace.  We normally take the least recently used
		 * valid page, but we will never take the slot containing
		 * latest_page_number, even if it appears least recently used.  We
		 * will select a slot that is already I/O busy only if there is no
		 * other choice: a read-busy slot will not be least recently used once
		 * the read finishes, and waiting for an I/O on a write-busy slot is
		 * inferior to just picking some other slot.  Testing shows the slot
		 * we pick instead will often be clean, allowing us to begin a read at
		 * once.
		 *
		 * Normally the page_lru_count values will all be different and so
		 * there will be a well-defined LRU page.  But since we allow
		 * concurrent execution of SlruRecentlyUsed() within
		 * SimpleLruReadPage_ReadOnly(), it is possible that multiple pages
		 * acquire the same lru_count values.  In that case we break ties by
		 * choosing the furthest-back page.
		 *
		 * Notice that this next line forcibly advances cur_lru_count to a
		 * value that is certainly beyond any value that will be in the
		 * page_lru_count array after the loop finishes.  This ensures that
		 * the next execution of SlruRecentlyUsed will mark the page newly
		 * used, even if it's for a page that has the current counter value.
		 * That gets us back on the path to having good data when there are
		 * multiple pages with the same lru_count.
		 */</comment>
		<expr_stmt><expr><name>cur_count</name> <operator>=</operator> <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>cur_lru_count</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>victim_pivot</name></name></expr>;</init> 
				<condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>victim_pivot</name></name> <operator>+</operator> <name>VICTIM_WINDOW</name> <operator>&amp;&amp;</operator> <name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition>
				<incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>this_delta</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>this_page_number</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>slotno</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>this_delta</name> <operator>=</operator> <name>cur_count</name> <operator>-</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>this_delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Clean up in case shared updates have caused cur_count
				 * increments to get "lost".  We back off the page counts,
				 * rather than trying to increase cur_count, to avoid any
				 * question of infinite loops or failure in the presence of
				 * wrapped-around counts.
				 */</comment>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>cur_count</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>this_delta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>this_page_number</name> <operator>=</operator> <name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>this_page_number</name> <operator>==</operator> <name><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>this_delta</name> <operator>&gt;</operator> <name>best_valid_delta</name> <operator>||</operator>
					<operator>(</operator><name>this_delta</name> <operator>==</operator> <name>best_valid_delta</name> <operator>&amp;&amp;</operator>
					 <call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name>this_page_number</name></expr></argument>,
									   <argument><expr><name>best_valid_page_number</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>bestvalidslot</name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_valid_delta</name> <operator>=</operator> <name>this_delta</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_valid_page_number</name> <operator>=</operator> <name>this_page_number</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>this_delta</name> <operator>&gt;</operator> <name>best_invalid_delta</name> <operator>||</operator>
					<operator>(</operator><name>this_delta</name> <operator>==</operator> <name>best_invalid_delta</name> <operator>&amp;&amp;</operator>
					 <call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name>this_page_number</name></expr></argument>,
									   <argument><expr><name>best_invalid_page_number</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>bestinvalidslot</name> <operator>=</operator> <name>slotno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_invalid_delta</name> <operator>=</operator> <name>this_delta</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>best_invalid_page_number</name> <operator>=</operator> <name>this_page_number</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>victim_pivot</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>slotno</name> <operator>==</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>slotno</name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/* POLAR: slru stat */</comment>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_victim_count</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * If all pages (except possibly the latest one) are I/O busy, we'll
		 * have to wait for an I/O to complete and then retry.  In that
		 * unhappy case, we choose to wait for the I/O on the least recently
		 * used slot, on the assumption that it was likely initiated first of
		 * all the I/Os in progress and may therefore finish first.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>best_valid_delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>bestinvalidslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the selected page is clean, we're set.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>bestvalidslot</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>bestvalidslot</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* POLAR: slru stat */</comment>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_victim_write_count</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Write the page.
		 */</comment>
		<expr_stmt><expr><call><name>SlruInternalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>bestvalidslot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<comment type="block">/*
		 * Now loop back and try again.  This is the easiest way of dealing
		 * with corner cases such as the victim page being re-dirtied while we
		 * wrote it.
		 */</comment>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Flush dirty pages to disk during checkpoint or database shutdown
 */</comment>
<function><type><name>void</name></type>
<name>SimpleLruFlush</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_redirtied</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlruFlushData</name></type> <name>fdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pageno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR: stat */</comment>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_flush_count</name></name><operator>++</operator></expr>;</expr_stmt>
	<comment type="block">/* POLAR: end */</comment>

	<comment type="block">/*
	 * Find and write dirty pages
	 */</comment>
	<expr_stmt><expr><name><name>fdata</name><operator>.</operator><name>num_files</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SlruInternalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fdata</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In some places (e.g. checkpoints), we cannot assert that the slot
		 * is clean now, since another process might have re-dirtied it
		 * already.  That's okay.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allow_redirtied</name> <operator>||</operator>
			   <name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name> <operator>||</operator>
			   <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now fsync and close any files that were open
	 */</comment>
	<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_cache_io_error</name></type> <name>io_error</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>polar_local_cache_flush_all</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_local_cache_report_error</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_CACHE_SYNC_FAILED</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fdata</name><operator>.</operator><name>num_files</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgstat_report_wait_start</name><argument_list>(<argument><expr><name>WAIT_EVENT_SLRU_FLUSH_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>POLAR_SLRU_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"polardb replica skip fsync file fd %d"</literal></expr></argument>, <argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>ctl</name><operator>-&gt;</operator><name>do_fsync</name></name> <operator>&amp;&amp;</operator> <call><name>polar_fsync</name><argument_list>(<argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_FSYNC_FAILED</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pageno</name> <operator>=</operator> <name><name>fdata</name><operator>.</operator><name>segno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name><name>fdata</name><operator>.</operator><name>fd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_CLOSE_FAILED</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>slru_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pageno</name> <operator>=</operator> <name><name>fdata</name><operator>.</operator><name>segno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SlruReportIOError</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove all segments before the one holding the passed page number
 */</comment>
<function><type><name>void</name></type>
<name>SimpleLruTruncate</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cutoffPage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<comment type="block">/* POLAR: stat */</comment>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_slru_truncate_count</name></name><operator>++</operator></expr>;</expr_stmt>
	<comment type="block">/* POLAR: end */</comment>

	<comment type="block">/*
	 * The cutoff point is the start of the segment containing cutoffPage.
	 */</comment>
	<expr_stmt><expr><name>cutoffPage</name> <operator>-=</operator> <name>cutoffPage</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan shared memory and remove any pages preceding the cutoff page, to
	 * ensure we won't rewrite them later.  (Since this is normally called in
	 * or just after a checkpoint, any dirty pages should have been flushed
	 * already ... we're just being extra careful here.)
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>restart</name>:</label><empty_stmt>;</empty_stmt>

	<comment type="block">/*
	 * While we are holding the lock, make an important safety check: the
	 * planned cutoff point must be &lt;= the current endpoint page. Otherwise we
	 * have already wrapped around, and proceeding with the truncation would
	 * risk removing the current segment.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>latest_page_number</name></name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not truncate directory \"%s\": apparent wraparound"</literal></expr></argument>,
						<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If page is clean, just change state to EMPTY (expected case).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>,
							<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>,
							<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"slru hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>polar_successor_list_push</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_free_list</name></name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Hmm, we have (or may have) I/O operations acting on the page, so
		 * we've got to wait for them to finish and then start again. This is
		 * the same logic as in SlruSelectLRUPage.  (XXX if page is dirty,
		 * wouldn't it be OK to just discard it without writing it?  For now,
		 * keep the logic the same as it was.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SlruInternalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<goto>goto <name>restart</name>;</goto>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we can remove the old segment(s) */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>SlruScanDirectory</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>SlruScanDirCbDeleteCutoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete an individual SLRU segment, identified by the filename.
 *
 * NB: This does not touch the SLRU buffers themselves, callers have to ensure
 * they either can't yet contain anything, or have already been cleaned out.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SlruInternalDeleteSegment</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>polar_cache_io_error</name></type> <name>io_error</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_local_cache_remove</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name></expr></argument>, <argument><expr><call><name>strtol</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>polar_local_cache_report_error</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>POLAR_SLRU_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"polardb replica skip unlink file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_slru_file_name_by_name</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete an individual SLRU segment, identified by the segment number.
 */</comment>
<function><type><name>void</name></type>
<name>SlruDeleteSegment</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>did_write</name></decl>;</decl_stmt>

	<comment type="block">/* Clean out any possibly existing references to the segment. */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>restart</name>:</label>
	<expr_stmt><expr><name>did_write</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>pagesegno</name> <init>= <expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* not the segment we're looking for */</comment>
		<if_stmt><if>if <condition>(<expr><name>pagesegno</name> <operator>!=</operator> <name>segno</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* If page is clean, just change state to EMPTY (expected case). */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>,
							<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>,
							<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"slru hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>polar_successor_list_push</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_free_list</name></name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Same logic as SimpleLruTruncate() */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SlruInternalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>did_write</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Be extra careful and re-check. The IO functions release the control
	 * lock, so new pages could have been read in.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>did_write</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>restart</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>POLAR_SLRU_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"polardb replica skip unlink file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SlruFileName</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing file \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>polar_unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SlruScanDirectory callback
 *		This callback reports true if there's any segment prior to the one
 *		containing the page passed as "data".
 */</comment>
<function><type><name>bool</name></type>
<name>SlruScanDirCbReportPresence</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cutoffPage</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>cutoffPage</name> <operator>-=</operator> <name>cutoffPage</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name>segpage</name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* found one; don't iterate any more */</comment>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep going */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * SlruScanDirectory callback.
 *		This callback deletes segments prior to the one passed in as "data".
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SlruScanDirCbDeleteCutoff</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cutoffPage</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name><name>ctl</name><operator>-&gt;</operator><name>PagePrecedes</name></name><argument_list>(<argument><expr><name>segpage</name></expr></argument>, <argument><expr><name>cutoffPage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SlruInternalDeleteSegment</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep going */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * SlruScanDirectory callback.
 *		This callback deletes all segments.
 */</comment>
<function><type><name>bool</name></type>
<name>SlruScanDirCbDeleteAll</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segpage</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SlruInternalDeleteSegment</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* keep going */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Scan the SimpleLRU directory and apply a callback to each file found in it.
 *
 * If the callback returns true, the scan is stopped.  The last return value
 * from the callback is returned.
 *
 * The callback receives the following arguments: 1. the SlruCtl struct for the
 * slru being truncated; 2. the filename being considered; 3. the page number
 * for the first page of that file; 4. a pointer to the opaque data given to us
 * by the caller.
 *
 * Note that the ordering in which the directory is scanned is not guaranteed.
 *
 * Note that no locking is applied.
 */</comment>
<function><type><name>bool</name></type>
<name>SlruScanDirectory</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>SlruScanCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DIR</name>		   <modifier>*</modifier></type><name>cldir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>clde</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cldir</name> <operator>=</operator> <call><name>polar_allocate_dir</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name><operator>-&gt;</operator><name>dir_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_slru_file_dir</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cldir</name> <operator>=</operator> <call><name>polar_allocate_dir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>clde</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>cldir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>len</name> <operator>==</operator> <literal type="number">5</literal> <operator>||</operator> <name>len</name> <operator>==</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>strspn</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"0123456789ABCDEF"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>segno</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>segpage</name> <operator>=</operator> <name>segno</name> <operator>*</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"SlruScanDirectory invoking callback on %s/%s"</literal></expr></argument>,
				 <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>callback</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name><name>clde</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>segpage</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>retval</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>cldir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Extend from SlruFileName
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_slru_file_name_by_seg</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>seg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_SLRU_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%04X"</literal></expr></argument>, <argument><expr><name>polar_datadir</name></expr></argument>, <argument><expr><operator>(</operator><name>ctl</name><operator>)</operator><operator>-&gt;</operator><name>Dir</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%04X"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ctl</name><operator>)</operator><operator>-&gt;</operator><name>Dir</name></expr></argument>, <argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_slru_file_dir</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_SLRU_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>polar_datadir</name></expr></argument>, <argument><expr><operator>(</operator><name>ctl</name><operator>)</operator><operator>-&gt;</operator><name>Dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ctl</name><operator>)</operator><operator>-&gt;</operator><name>Dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_slru_file_name_by_name</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>POLAR_SLRU_FILE_IN_SHARED_STORAGE</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/%s"</literal></expr></argument>, <argument><expr><name>polar_datadir</name></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>Dir</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For primary, some slru files, such as pg_xact, pg_commit_ts and pg_multixact,
 * are on the shared storage, for replica, all slru files are on the local storage.
 */</comment>
<function><type><name>bool</name></type>
<name>polar_slru_file_in_shared_storage</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>in_shared_storage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>polar_in_replica_mode</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>polar_enable_shared_storage_mode</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>in_shared_storage</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Scan SimpleLru and force to invalid specific page
 */</comment>
<function><type><name>void</name></type>
<name>polar_slru_invalid_page</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>polar_enable_slru_hash_index</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>polar_slru_hash_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>pageno</name></expr></argument>,
					<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>slotno</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>slotno</name></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name> <operator>||</operator>
						<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* POLAR: Now we must recheck from the top */</comment>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name> <operator>||</operator>
				   <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>!=</operator> <name>SLRU_PAGE_EMPTY</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>,
								<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"slru hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>polar_successor_list_push</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_free_list</name></name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else 
	<block>{<block_content>
		<for>for <control>(<init><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>slotno</name> <operator>&lt;</operator> <name><name>shared</name><operator>-&gt;</operator><name>num_slots</name></name></expr>;</condition> <incr><expr><name>slotno</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_number</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>pageno</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_READ_IN_PROGRESS</name> <operator>||</operator>
						<name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_WRITE_IN_PROGRESS</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>SimpleLruWaitIO</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>slotno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<comment type="block">/* POLAR: Now we must recheck from the top */</comment>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_EMPTY</name> <operator>||</operator>
				   <operator>(</operator><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>==</operator> <name>SLRU_PAGE_VALID</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>polar_slru_set_page_status</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>SLRU_PAGE_EMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_dirty</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_lru_count</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>ControlLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: Wrapper of SlruInternalWritePage, for external callers to append data to segment file.
 * fdata is always passed a NULL here.
 * If we know the segment file does not exists then set update to be false, otherwise set to be true.
 */</comment>
<function><type><name>void</name></type>
<name>polar_slru_append_page</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>update</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SlruInternalWritePage</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>slotno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR:Check whether page exists in file
 */</comment>
<function><type><name>bool</name></type>
<name>polar_slru_page_physical_exists</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>fst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SlruFileName</name><argument_list>(<argument><expr><name>ctl</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>polar_stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fst</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>fst</name><operator>.</operator><name>st_size</name></name> <operator>&gt;=</operator> <operator>(</operator><name>offset</name> <operator>+</operator> <name>BLCKSZ</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>polar_slru_set_page_status</name><parameter_list>(<parameter><decl><type><name>SlruShared</name></type> <name>shared</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>, <parameter><decl><type><name>SlruPageStatus</name></type> <name>pagestatus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_slru_stat</name> <modifier>*</modifier></type><name>stat</name> <init>= <expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>stat</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SlruPageStatus</name></type> <name>oldstatus</name> <init>= <expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldstatus</name> <operator>!=</operator> <name>pagestatus</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_page_status_stat</name><index>[<expr><name>oldstatus</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>n_page_status_stat</name><index>[<expr><name>pagestatus</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>page_status</name><index>[<expr><name>slotno</name></expr>]</index></name> <operator>=</operator> <name>pagestatus</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_slru_hash_init</name><parameter_list>(<parameter><decl><type><name>SlruShared</name></type> <name>shared</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nslots</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLAR_SLRU_HASH_NAME</name></cpp:macro> <cpp:value>" slru hash index"</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>HASHCTL</name></type> 	<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hash_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>name_size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>POLAR_SLRU_HASH_NAME</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>hash_name</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>name_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>polar_slru_hash_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>hash_name</name></expr></argument>, <argument><expr><name>name_size</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>POLAR_SLRU_HASH_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_hash_index</name></name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><name>hash_name</name></expr></argument>,
			<argument><expr><name>nslots</name></expr></argument>, <argument><expr><name>nslots</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
			<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hash_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_slru_reg_local_cache</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>polar_local_cache</name></type> <name>cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type> <name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name> <operator>=</operator> <name>cache</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_slru_local_cache_read_page</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_cache_io_error</name></type> <name>io_error</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_local_cache_read</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
			   <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/*
		 * if we are InRecovery, allow the case where the file doesn't exist and where 
		 * the page beyond the end of the file. (see notes in SlruPhysicalWritePage).  
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>POLAR_SEGMENT_NOT_EXISTS</name><argument_list>(<argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> 
			 <operator>!</operator><call><name>POLAR_SEGMENT_BEYOND_END</name><argument_list>(<argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> 
			<operator>!</operator><name>InRecovery</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>polar_local_cache_report_error</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_CACHE_READ_FAILED</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>polar_local_cache_report_error</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>polar_slru_local_cache_write_page</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pageno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slotno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type>	<name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segno</name> <init>= <expr><name>pageno</name> <operator>/</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rpageno</name> <init>= <expr><name>pageno</name> <operator>%</operator> <name>SLRU_PAGES_PER_SEGMENT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>offset</name> <init>= <expr><name>rpageno</name> <operator>*</operator> <name>BLCKSZ</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_cache_io_error</name></type> <name>io_error</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_local_cache_write</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name></expr></argument>, <argument><expr><name>segno</name></expr></argument>,
			   <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>shared</name><operator>-&gt;</operator><name>page_buffer</name><index>[<expr><name>slotno</name></expr>]</index></name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_local_cache_report_error</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>slru_errcause</name> <operator>=</operator> <name>SLRU_CACHE_WRITE_FAILED</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_slru_stats_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>polar_slru_stats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>polar_slru_stat</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>POLAR_SLRU_STATS_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n_polar_slru_stats</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>polar_slru_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>polar_slru_stats_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR: promote slru if local cache exists, copy data from local storage to shared storage */</comment>
<function><type><name>void</name></type>
<name>polar_slru_promote</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>polar_local_cache</name></type> <name>cache</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>io_permission</name> <init>= <expr><name>POLAR_CACHE_LOCAL_FILE_READ</name> <operator>|</operator> <name>POLAR_CACHE_LOCAL_FILE_WRITE</name> <operator>|</operator>
							<name>POLAR_CACHE_SHARED_FILE_READ</name> <operator>|</operator> <name>POLAR_CACHE_SHARED_FILE_WRITE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>polar_cache_io_error</name></type> <name>io_error</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cache</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"There's no local cache, so we can not promote"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>polar_local_cache_set_io_permission</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>io_permission</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_local_cache_report_error</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>io_error</name></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>polar_file_in_shared_storage</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR: remove slru local cache file */</comment>
<function><type><name>void</name></type>
<name>polar_slru_remove_local_cache_file</name><parameter_list>(<parameter><decl><type><name>SlruCtl</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SlruShared</name></type> <name>shared</name> <init>= <expr><name><name>ctl</name><operator>-&gt;</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shared</name> <operator>&amp;&amp;</operator> <name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>polar_local_cache_move_trash</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>polar_cache</name><operator>-&gt;</operator><name>dir_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
</unit>
