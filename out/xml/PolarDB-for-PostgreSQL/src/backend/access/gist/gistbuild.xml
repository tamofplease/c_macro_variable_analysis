<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/gist/gistbuild.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gistbuild.c
 *	  build algorithm for GiST indexes implementation.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/access/gist/gistbuild.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gistxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xloginsert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<comment type="block">/* Step of index tuples for check whether to switch to buffering build mode */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFFERING_MODE_SWITCH_CHECK_STEP</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<comment type="block">/*
 * Number of tuples to process in the slow way before switching to buffering
 * mode, when buffering is explicitly turned on. Also, the number of tuples
 * to process between readjusting the buffer size parameter, while in
 * buffering mode.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFFERING_MODE_TUPLE_SIZE_STATS_TARGET</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>GIST_BUFFERING_DISABLED</name></decl>,	<comment type="block">/* in regular build mode and aren't going to
								 * switch */</comment>
	<decl><name>GIST_BUFFERING_AUTO</name></decl>,		<comment type="block">/* in regular build mode, but will switch to
								 * buffering build mode if the index grows too
								 * big */</comment>
	<decl><name>GIST_BUFFERING_STATS</name></decl>,		<comment type="block">/* gathering statistics of index tuple size
								 * before switching to the buffering build
								 * mode */</comment>
	<decl><name>GIST_BUFFERING_ACTIVE</name></decl>		<comment type="block">/* in buffering build mode */</comment>
}</block></enum></type> <name>GistBufferingMode</name>;</typedef>

<comment type="block">/* Working state for gistbuild and its callback */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heaprel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTSTATE</name>  <modifier>*</modifier></type><name>giststate</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int64</name></type>		<name>indtuples</name></decl>;</decl_stmt>		<comment type="block">/* number of tuples indexed */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>indtuplesSize</name></decl>;</decl_stmt>	<comment type="block">/* total size of all indexed tuples */</comment>

	<decl_stmt><decl><type><name>Size</name></type>		<name>freespace</name></decl>;</decl_stmt>		<comment type="block">/* amount of free space to leave on pages */</comment>

	<comment type="block">/*
	 * Extra data structures used during a buffering build. 'gfbb' contains
	 * information related to managing the build buffers. 'parentMap' is a
	 * lookup table of the parent of each internal page.
	 */</comment>
	<decl_stmt><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>parentMap</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>GistBufferingMode</name></type> <name>bufferingMode</name></decl>;</decl_stmt>
}</block></struct></type> <name>GISTBuildState</name>;</typedef>

<comment type="block">/* prototypes for private functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistInitBuffering</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>calculatePagesPerBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelStep</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistBuildCallback</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
				  <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>tupleIsAlive</name></decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistBufferingBuildInsert</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>,
						 <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gistProcessItup</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
				<parameter><decl><type><name>BlockNumber</name></type> <name>startblkno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startlevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BlockNumber</name></type> <name>gistbufferinginserttuples</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>,
						  <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
						  <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntup</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>oldoffnum</name></decl></parameter>,
						  <parameter><decl><type><name>BlockNumber</name></type> <name>parentblk</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>downlinkoffnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Buffer</name></type> <name>gistBufferingFindCorrectParent</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>,
							   <parameter><decl><type><name>BlockNumber</name></type> <name>childblkno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
							   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>parentblk</name></decl></parameter>,
							   <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>downlinkoffnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistProcessEmptyingQueue</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistEmptyAllBuffers</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>gistGetMaxLevel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistInitParentMap</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistMemorizeParent</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>child</name></decl></parameter>,
				   <parameter><decl><type><name>BlockNumber</name></type> <name>parent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gistMemorizeAllDownlinks</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>parent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BlockNumber</name></type> <name>gistGetParent</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>child</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Main entry point to GiST index build. Initially calls insert over and over,
 * but switches to more efficient buffering build algorithm after a certain
 * number of tuples (unless buffering mode is disabled).
 */</comment>
<function><type><name>IndexBuildResult</name> <modifier>*</modifier></type>
<name>gistbuild</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexBuildResult</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTBuildState</name></type> <name>buildstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fillfactor</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>indexrel</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>heaprel</name></name> <operator>=</operator> <name>heap</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>rd_options</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get buffering mode from the options string */</comment>
		<decl_stmt><decl><type><name>GiSTOptions</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><operator>(</operator><name>GiSTOptions</name> <operator>*</operator><operator>)</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_options</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufferingMode</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>options</name> <operator>+</operator> <name><name>options</name><operator>-&gt;</operator><name>bufferingModeOffset</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>bufferingMode</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>bufferingMode</name></name> <operator>=</operator> <name>GIST_BUFFERING_STATS</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>bufferingMode</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>bufferingMode</name></name> <operator>=</operator> <name>GIST_BUFFERING_DISABLED</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>bufferingMode</name></name> <operator>=</operator> <name>GIST_BUFFERING_AUTO</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>fillfactor</name> <operator>=</operator> <name><name>options</name><operator>-&gt;</operator><name>fillfactor</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * By default, switch to buffering mode when the index grows too large
		 * to fit in cache.
		 */</comment>
		<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>bufferingMode</name></name> <operator>=</operator> <name>GIST_BUFFERING_AUTO</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fillfactor</name> <operator>=</operator> <name>GIST_DEFAULT_FILLFACTOR</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* Calculate target amount of free space to leave on pages */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>freespace</name></name> <operator>=</operator> <name>BLCKSZ</name> <operator>*</operator> <operator>(</operator><literal type="number">100</literal> <operator>-</operator> <name>fillfactor</name><operator>)</operator> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * We expect to be called exactly once for any index relation. If that's
	 * not the case, big trouble's what we have.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_check_nblocks_consistent</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index \"%s\" already contains data"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* no locking is needed */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>giststate</name></name> <operator>=</operator> <call><name>initGISTstate</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a temporary memory context that is reset once for each tuple
	 * processed.  (Note: we don't bother to make this a child of the
	 * giststate's scanCxt, so we have to delete it separately at the end.)
	 */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name> <operator>=</operator> <call><name>createTempGistContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize the root page */</comment>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>gistNewBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GIST_ROOT_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GISTInitBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>F_LEAF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MarkBufferDirty</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RelationNeedsWAL</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>XLogBeginInsert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>XLogRegisterBuffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REGBUF_WILL_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>XLogInsert</name><argument_list>(<argument><expr><name>RM_GIST_ID</name></expr></argument>, <argument><expr><name>XLOG_GIST_CREATE_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>recptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PageSetLSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><call><name>gistGetFakeLSN</name><argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build the index */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>indtuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>.</operator><name>indtuplesSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the heap scan.
	 */</comment>
	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <call><name>IndexBuildHeapScan</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								   <argument><expr><name>gistBuildCallback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buildstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If buffering was used, flush out all the tuples that are still in the
	 * buffers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buildstate</name><operator>.</operator><name>bufferingMode</name></name> <operator>==</operator> <name>GIST_BUFFERING_ACTIVE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"all tuples processed, emptying buffers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gistEmptyAllBuffers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buildstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gistFreeBuildBuffers</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>gfbb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* okay, all heap tuples are indexed */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>freeGISTstate</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>.</operator><name>giststate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return statistics
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>IndexBuildResult</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexBuildResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>heap_tuples</name></name> <operator>=</operator> <name>reltuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>index_tuples</name></name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>buildstate</name><operator>.</operator><name>indtuples</name></name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validator for "buffering" reloption on GiST indexes. Allows "on", "off"
 * and "auto" values.
 */</comment>
<function><type><name>void</name></type>
<name>gistValidateBufferingOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		 <call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		 <call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"auto"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for \"buffering\" option"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Valid values are \"on\", \"off\", and \"auto\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to switch to buffering mode.
 *
 * If there is not enough memory for buffering build, sets bufferingMode
 * to GIST_BUFFERING_DISABLED, so that we don't bother to try the switch
 * anymore. Otherwise initializes the build buffers, and sets bufferingMode to
 * GIST_BUFFERING_ACTIVE.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistInitBuffering</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>index</name> <init>= <expr><name><name>buildstate</name><operator>-&gt;</operator><name>indexrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pagesPerBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>pageFreeSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>itupAvgSize</name></decl>,
				<decl><type ref="prev"/><name>itupMinSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>avgIndexTuplesPerPage</name></decl>,
				<decl><type ref="prev"/><name>maxIndexTuplesPerPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>levelStep</name></decl>;</decl_stmt>

	<comment type="block">/* Calc space of index page which is available for index tuples */</comment>
	<expr_stmt><expr><name>pageFreeSpace</name> <operator>=</operator> <name>BLCKSZ</name> <operator>-</operator> <name>SizeOfPageHeaderData</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GISTPageOpaqueData</name></expr></argument>)</argument_list></sizeof>
		<operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof>
		<operator>-</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>freespace</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate average size of already inserted index tuples using gathered
	 * statistics.
	 */</comment>
	<expr_stmt><expr><name>itupAvgSize</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>indtuplesSize</name></name> <operator>/</operator>
		<operator>(</operator><name>double</name><operator>)</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate minimal possible size of index tuple by index metadata.
	 * Minimal possible size of varlena is VARHDRSZ.
	 *
	 * XXX: that's not actually true, as a short varlen can be just 2 bytes.
	 * And we should take padding into account here.
	 */</comment>
	<expr_stmt><expr><name>itupMinSize</name> <operator>=</operator> <operator>(</operator><name>Size</name><operator>)</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTupleData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>itupMinSize</name> <operator>+=</operator> <name>VARHDRSZ</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>itupMinSize</name> <operator>+=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Calculate average and maximal number of index tuples which fit to page */</comment>
	<expr_stmt><expr><name>avgIndexTuplesPerPage</name> <operator>=</operator> <name>pageFreeSpace</name> <operator>/</operator> <name>itupAvgSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxIndexTuplesPerPage</name> <operator>=</operator> <name>pageFreeSpace</name> <operator>/</operator> <name>itupMinSize</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to calculate two parameters for the buffering algorithm:
	 * levelStep and pagesPerBuffer.
	 *
	 * levelStep determines the size of subtree that we operate on, while
	 * emptying a buffer. A higher value is better, as you need fewer buffer
	 * emptying steps to build the index. However, if you set it too high, the
	 * subtree doesn't fit in cache anymore, and you quickly lose the benefit
	 * of the buffers.
	 *
	 * In Arge et al's paper, levelStep is chosen as logB(M/4B), where B is
	 * the number of tuples on page (ie. fanout), and M is the amount of
	 * internal memory available. Curiously, they doesn't explain *why* that
	 * setting is optimal. We calculate it by taking the highest levelStep so
	 * that a subtree still fits in cache. For a small B, our way of
	 * calculating levelStep is very close to Arge et al's formula. For a
	 * large B, our formula gives a value that is 2x higher.
	 *
	 * The average size (in pages) of a subtree of depth n can be calculated
	 * as a geometric series:
	 *
	 * B^0 + B^1 + B^2 + ... + B^n = (1 - B^(n + 1)) / (1 - B)
	 *
	 * where B is the average number of index tuples on page. The subtree is
	 * cached in the shared buffer cache and the OS cache, so we choose
	 * levelStep so that the subtree size is comfortably smaller than
	 * effective_cache_size, with a safety factor of 4.
	 *
	 * The estimate on the average number of index tuples on page is based on
	 * average tuple sizes observed before switching to buffered build, so the
	 * real subtree size can be somewhat larger. Also, it would selfish to
	 * gobble the whole cache for our index build. The safety factor of 4
	 * should account for those effects.
	 *
	 * The other limiting factor for setting levelStep is that while
	 * processing a subtree, we need to hold one page for each buffer at the
	 * next lower buffered level. The max. number of buffers needed for that
	 * is maxIndexTuplesPerPage^levelStep. This is very conservative, but
	 * hopefully maintenance_work_mem is set high enough that you're
	 * constrained by effective_cache_size rather than maintenance_work_mem.
	 *
	 * XXX: the buffer hash table consumes a fair amount of memory too per
	 * buffer, but that is not currently taken into account. That scales on
	 * the total number of buffers used, ie. the index size and on levelStep.
	 * Note that a higher levelStep *reduces* the amount of memory needed for
	 * the hash table.
	 */</comment>
	<expr_stmt><expr><name>levelStep</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>subtreesize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>maxlowestlevelpages</name></decl>;</decl_stmt>

		<comment type="block">/* size of an average subtree at this levelStep (in pages). */</comment>
		<expr_stmt><expr><name>subtreesize</name> <operator>=</operator>
			<operator>(</operator><literal type="number">1</literal> <operator>-</operator> <call><name>pow</name><argument_list>(<argument><expr><name>avgIndexTuplesPerPage</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>levelStep</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator>
			<operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>avgIndexTuplesPerPage</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* max number of pages at the lowest level of a subtree */</comment>
		<expr_stmt><expr><name>maxlowestlevelpages</name> <operator>=</operator> <call><name>pow</name><argument_list>(<argument><expr><name>maxIndexTuplesPerPage</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>levelStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* subtree must fit in cache (with safety factor of 4) */</comment>
		<if_stmt><if>if <condition>(<expr><name>subtreesize</name> <operator>&gt;</operator> <name>effective_cache_size</name> <operator>/</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* each node in the lowest level of a subtree has one page in memory */</comment>
		<if_stmt><if>if <condition>(<expr><name>maxlowestlevelpages</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>maintenance_work_mem</name> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Good, we can handle this levelStep. See if we can go one higher. */</comment>
		<expr_stmt><expr><name>levelStep</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We just reached an unacceptable value of levelStep in previous loop.
	 * So, decrease levelStep to get last acceptable value.
	 */</comment>
	<expr_stmt><expr><name>levelStep</name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there's not enough cache or maintenance_work_mem, fall back to plain
	 * inserts.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>levelStep</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"failed to switch to buffered GiST build"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>bufferingMode</name></name> <operator>=</operator> <name>GIST_BUFFERING_DISABLED</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The second parameter to set is pagesPerBuffer, which determines the
	 * size of each buffer. We adjust pagesPerBuffer also during the build,
	 * which is why this calculation is in a separate function.
	 */</comment>
	<expr_stmt><expr><name>pagesPerBuffer</name> <operator>=</operator> <call><name>calculatePagesPerBuffer</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name>levelStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize GISTBuildBuffers with these parameters */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>gfbb</name></name> <operator>=</operator> <call><name>gistInitBuildBuffers</name><argument_list>(<argument><expr><name>pagesPerBuffer</name></expr></argument>, <argument><expr><name>levelStep</name></expr></argument>,
											<argument><expr><call><name>gistGetMaxLevel</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gistInitParentMap</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>bufferingMode</name></name> <operator>=</operator> <name>GIST_BUFFERING_ACTIVE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"switched to buffered GiST build; level step = %d, pagesPerBuffer = %d"</literal></expr></argument>,
		 <argument><expr><name>levelStep</name></expr></argument>, <argument><expr><name>pagesPerBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate pagesPerBuffer parameter for the buffering algorithm.
 *
 * Buffer size is chosen so that assuming that tuples are distributed
 * randomly, emptying half a buffer fills on average one page in every buffer
 * at the next lower level.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>calculatePagesPerBuffer</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>levelStep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>pagesPerBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>avgIndexTuplesPerPage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>itupAvgSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>pageFreeSpace</name></decl>;</decl_stmt>

	<comment type="block">/* Calc space of index page which is available for index tuples */</comment>
	<expr_stmt><expr><name>pageFreeSpace</name> <operator>=</operator> <name>BLCKSZ</name> <operator>-</operator> <name>SizeOfPageHeaderData</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GISTPageOpaqueData</name></expr></argument>)</argument_list></sizeof>
		<operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemIdData</name></expr></argument>)</argument_list></sizeof>
		<operator>-</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>freespace</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate average size of already inserted index tuples using gathered
	 * statistics.
	 */</comment>
	<expr_stmt><expr><name>itupAvgSize</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>indtuplesSize</name></name> <operator>/</operator>
		<operator>(</operator><name>double</name><operator>)</operator> <name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>avgIndexTuplesPerPage</name> <operator>=</operator> <name>pageFreeSpace</name> <operator>/</operator> <name>itupAvgSize</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recalculate required size of buffers.
	 */</comment>
	<expr_stmt><expr><name>pagesPerBuffer</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>pow</name><argument_list>(<argument><expr><name>avgIndexTuplesPerPage</name></expr></argument>, <argument><expr><name>levelStep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>pagesPerBuffer</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Per-tuple callback from IndexBuildHeapScan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistBuildCallback</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>,
				  <parameter><decl><type><name>HeapTuple</name></type> <name>htup</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>tupleIsAlive</name></decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name> <init>= <expr><operator>(</operator><name>GISTBuildState</name> <operator>*</operator><operator>)</operator> <name>state</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* form an index tuple and point it at the heap tuple */</comment>
	<expr_stmt><expr><name>itup</name> <operator>=</operator> <call><name>gistFormTuple</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>giststate</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name> <operator>=</operator> <name><name>htup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>buildstate</name><operator>-&gt;</operator><name>bufferingMode</name></name> <operator>==</operator> <name>GIST_BUFFERING_ACTIVE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We have buffers, so use them. */</comment>
		<expr_stmt><expr><call><name>gistBufferingBuildInsert</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * There's no buffers (yet). Since we already have the index relation
		 * locked, we call gistdoinsert directly.
		 */</comment>
		<expr_stmt><expr><call><name>gistdoinsert</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>freespace</name></name></expr></argument>,
					 <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>giststate</name></name></expr></argument>, <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>heaprel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Update tuple count and total size. */</comment>
	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indtuplesSize</name></name> <operator>+=</operator> <call><name>IndexTupleSize</name><argument_list>(<argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>buildstate</name><operator>-&gt;</operator><name>bufferingMode</name></name> <operator>==</operator> <name>GIST_BUFFERING_ACTIVE</name> <operator>&amp;&amp;</operator>
		<name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name> <operator>%</operator> <name>BUFFERING_MODE_TUPLE_SIZE_STATS_TARGET</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Adjust the target buffer size now */</comment>
		<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>gfbb</name><operator>-&gt;</operator><name>pagesPerBuffer</name></name> <operator>=</operator>
			<call><name>calculatePagesPerBuffer</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>gfbb</name><operator>-&gt;</operator><name>levelStep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In 'auto' mode, check if the index has grown too large to fit in cache,
	 * and switch to buffering mode if it has.
	 *
	 * To avoid excessive calls to smgrnblocks(), only check this every
	 * BUFFERING_MODE_SWITCH_CHECK_STEP index tuples
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>buildstate</name><operator>-&gt;</operator><name>bufferingMode</name></name> <operator>==</operator> <name>GIST_BUFFERING_AUTO</name> <operator>&amp;&amp;</operator>
		 <name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name> <operator>%</operator> <name>BUFFERING_MODE_SWITCH_CHECK_STEP</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		 <name>effective_cache_size</name> <operator>&lt;</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name><name>buildstate</name><operator>-&gt;</operator><name>bufferingMode</name></name> <operator>==</operator> <name>GIST_BUFFERING_STATS</name> <operator>&amp;&amp;</operator>
		 <name><name>buildstate</name><operator>-&gt;</operator><name>indtuples</name></name> <operator>&gt;=</operator> <name>BUFFERING_MODE_TUPLE_SIZE_STATS_TARGET</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Index doesn't fit in effective cache anymore. Try to switch to
		 * buffering build mode.
		 */</comment>
		<expr_stmt><expr><call><name>gistInitBuffering</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert function for buffering index build.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistBufferingBuildInsert</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Insert the tuple to buffers. */</comment>
	<expr_stmt><expr><call><name>gistProcessItup</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>gfbb</name><operator>-&gt;</operator><name>rootlevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we filled up (half of a) buffer, process buffer emptying. */</comment>
	<expr_stmt><expr><call><name>gistProcessEmptyingQueue</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process an index tuple. Runs the tuple down the tree until we reach a leaf
 * page or node buffer, and inserts the tuple there. Returns true if we have
 * to stop buffer emptying process (because one of child buffers can't take
 * index tuples anymore).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gistProcessItup</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>IndexTuple</name></type> <name>itup</name></decl></parameter>,
				<parameter><decl><type><name>BlockNumber</name></type> <name>startblkno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startlevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTSTATE</name>  <modifier>*</modifier></type><name>giststate</name> <init>= <expr><name><name>buildstate</name><operator>-&gt;</operator><name>giststate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name> <init>= <expr><name><name>buildstate</name><operator>-&gt;</operator><name>gfbb</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexrel</name> <init>= <expr><name><name>buildstate</name><operator>-&gt;</operator><name>indexrel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>childblkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>downlinkoffnum</name> <init>= <expr><name>InvalidOffsetNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>parentblkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop until we reach a leaf page (level == 0) or a level with buffers
	 * (not including the level we start at, because we would otherwise make
	 * no progress).
	 */</comment>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name>startblkno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>level</name> <operator>=</operator> <name>startlevel</name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name></decl>,
					<decl><type ref="prev"/><name>newtup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>childoffnum</name></decl>;</decl_stmt>

		<comment type="block">/* Have we reached a level with buffers? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>LEVEL_HAS_BUFFERS</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><name>gfbb</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>level</name> <operator>!=</operator> <name>startlevel</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Have we reached a leaf page? */</comment>
		<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Nope. Descend down to the next level then. Choose a child to
		 * descend down to.
		 */</comment>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>childoffnum</name> <operator>=</operator> <call><name>gistchoose</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>iid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>childoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idxtuple</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>childblkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxtuple</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>gistMemorizeParent</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name>childblkno</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check that the key representing the target child node is consistent
		 * with the key we're inserting. Update it if it's not.
		 */</comment>
		<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>gistgetadjusted</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>idxtuple</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newtup</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>gistbufferinginserttuples</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>,
											  <argument><expr><name>buffer</name></expr></argument>,
											  <argument><expr><name>level</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>newtup</name></expr></argument>,
											  <argument><expr><literal type="number">1</literal></expr></argument>,
											  <argument><expr><name>childoffnum</name></expr></argument>,
											  <argument><expr><name>InvalidBlockNumber</name></expr></argument>,
											  <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* gistbufferinginserttuples() released the buffer */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Descend to the child */</comment>
		<expr_stmt><expr><name>parentblkno</name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name>childblkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>downlinkoffnum</name> <operator>=</operator> <name>childoffnum</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>LEVEL_HAS_BUFFERS</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><name>gfbb</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We've reached level with buffers. Place the index tuple to the
		 * buffer, and add the buffer to the emptying queue if it overflows.
		 */</comment>
		<decl_stmt><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>childNodeBuffer</name></decl>;</decl_stmt>

		<comment type="block">/* Find the buffer or create a new one */</comment>
		<expr_stmt><expr><name>childNodeBuffer</name> <operator>=</operator> <call><name>gistGetNodeBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add index tuple to it */</comment>
		<expr_stmt><expr><call><name>gistPushItupToNodeBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name>childNodeBuffer</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BUFFER_OVERFLOWED</name><argument_list>(<argument><expr><name>childNodeBuffer</name></expr></argument>, <argument><expr><name>gfbb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We've reached a leaf page. Place the tuple here.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gistbufferinginserttuples</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>level</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>itup</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>,
								  <argument><expr><name>parentblkno</name></expr></argument>, <argument><expr><name>downlinkoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* gistbufferinginserttuples() released the buffer */</comment>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert tuples to a given page.
 *
 * This is analogous with gistinserttuples() in the regular insertion code.
 *
 * Returns the block number of the page where the (first) new or updated tuple
 * was inserted. Usually that's the original page, but might be a sibling page
 * if the original page was split.
 *
 * Caller should hold a lock on 'buffer' on entry. This function will unlock
 * and unpin it.
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>gistbufferinginserttuples</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
						  <parameter><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>itup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntup</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>oldoffnum</name></decl></parameter>,
						  <parameter><decl><type><name>BlockNumber</name></type> <name>parentblk</name></decl></parameter>, <parameter><decl><type><name>OffsetNumber</name></type> <name>downlinkoffnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name> <init>= <expr><name><name>buildstate</name><operator>-&gt;</operator><name>gfbb</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>splitinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_split</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>placed_to_blk</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>is_split</name> <operator>=</operator> <call><name>gistplacetopage</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indexrel</name></name></expr></argument>,
							   <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>freespace</name></name></expr></argument>,
							   <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>giststate</name></name></expr></argument>,
							   <argument><expr><name>buffer</name></expr></argument>,
							   <argument><expr><name>itup</name></expr></argument>, <argument><expr><name>ntup</name></expr></argument>, <argument><expr><name>oldoffnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>placed_to_blk</name></expr></argument>,
							   <argument><expr><name>InvalidBuffer</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>splitinfo</name></expr></argument>,
							   <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>heaprel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is a root split, update the root path item kept in memory. This
	 * ensures that all path stacks are always complete, including all parent
	 * nodes up to the root. That simplifies the algorithm to re-find correct
	 * parent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_split</name> <operator>&amp;&amp;</operator> <call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GIST_ROOT_BLKNO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>level</name> <operator>==</operator> <name><name>gfbb</name><operator>-&gt;</operator><name>rootlevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>rootlevel</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"splitting GiST root page, now %d levels deep"</literal></expr></argument>, <argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>rootlevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * All the downlinks on the old root page are now on one of the child
		 * pages. Visit all the new child pages to memorize the parents of the
		 * grandchildren.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>gfbb</name><operator>-&gt;</operator><name>rootlevel</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>off</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BlockNumber</name></type> <name>childblkno</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxtuple</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Buffer</name></type>		<name>childbuf</name> <init>= <expr><call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indexrel</name></name></expr></argument>, <argument><expr><name>childblkno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>, <argument><expr><name>GIST_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>gistMemorizeAllDownlinks</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>childbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Also remember that the parent of the new child page is the
				 * root block.
				 */</comment>
				<expr_stmt><expr><call><name>gistMemorizeParent</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name>childblkno</name></expr></argument>, <argument><expr><name>GIST_ROOT_BLKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>splitinfo</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Insert the downlinks to the parent. This is analogous with
		 * gistfinishsplit() in the regular insertion code, but the locking is
		 * simpler, and we have to maintain the buffers on internal nodes and
		 * the parent map.
		 */</comment>
		<decl_stmt><decl><type><name>IndexTuple</name> <modifier>*</modifier></type><name>downlinks</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndownlinks</name></decl>,
					<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>parentBuffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* Parent may have changed since we memorized this path. */</comment>
		<expr_stmt><expr><name>parentBuffer</name> <operator>=</operator>
			<call><name>gistBufferingFindCorrectParent</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>,
										   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>level</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>parentblk</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>downlinkoffnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there's a buffer associated with this page, that needs to be
		 * split too. gistRelocateBuildBuffersOnSplit() will also adjust the
		 * downlinks in 'splitinfo', to make sure they're consistent not only
		 * with the tuples already on the pages, but also the tuples in the
		 * buffers that will eventually be inserted to them.
		 */</comment>
		<expr_stmt><expr><call><name>gistRelocateBuildBuffersOnSplit</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>,
										<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>giststate</name></name></expr></argument>,
										<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indexrel</name></name></expr></argument>,
										<argument><expr><name>level</name></expr></argument>,
										<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>splitinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create an array of all the downlink tuples */</comment>
		<expr_stmt><expr><name>ndownlinks</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>splitinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>downlinks</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexTuple</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndownlinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>splitinfo</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GISTPageSplitInfo</name> <modifier>*</modifier></type><name>splitinfo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Remember the parent of each new child page in our parent map.
			 * This assumes that the downlinks fit on the parent page. If the
			 * parent page is split, too, when we recurse up to insert the
			 * downlinks, the recursive gistbufferinginserttuples() call will
			 * update the map again.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>gistMemorizeParent</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>,
								   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name><name>splitinfo</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>parentBuffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Also update the parent map for all the downlinks that got moved
			 * to a different page. (actually this also loops through the
			 * downlinks that stayed on the original page, but it does no
			 * harm).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>gistMemorizeAllDownlinks</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name><name>splitinfo</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Since there's no concurrent access, we can release the lower
			 * level buffers immediately. This includes the original page.
			 */</comment>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name><name>splitinfo</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>downlinks</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>splitinfo</name><operator>-&gt;</operator><name>downlink</name></name></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Insert them into parent. */</comment>
		<expr_stmt><expr><call><name>gistbufferinginserttuples</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name>parentBuffer</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><name>downlinks</name></expr></argument>, <argument><expr><name>ndownlinks</name></expr></argument>, <argument><expr><name>downlinkoffnum</name></expr></argument>,
								  <argument><expr><name>InvalidBlockNumber</name></expr></argument>, <argument><expr><name>InvalidOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>splitinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* we don't need this anymore */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>placed_to_blk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the downlink pointing to a child page.
 *
 * 'childblkno' indicates the child page to find the parent for. 'level' is
 * the level of the child. On entry, *parentblkno and *downlinkoffnum can
 * point to a location where the downlink used to be - we will check that
 * location first, and save some cycles if it hasn't moved. The function
 * returns a buffer containing the downlink, exclusively-locked, and
 * *parentblkno and *downlinkoffnum are set to the real location of the
 * downlink.
 *
 * If the child page is a leaf (level == 0), the caller must supply a correct
 * parentblkno. Otherwise we use the parent map hash table to find the parent
 * block.
 *
 * This function serves the same purpose as gistFindCorrectParent() during
 * normal index inserts, but this is simpler because we don't need to deal
 * with concurrent inserts.
 */</comment>
<function><type><specifier>static</specifier> <name>Buffer</name></type>
<name>gistBufferingFindCorrectParent</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>,
							   <parameter><decl><type><name>BlockNumber</name></type> <name>childblkno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>,
							   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>parentblkno</name></decl></parameter>,
							   <parameter><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>downlinkoffnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>gistGetParent</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name>childblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For a leaf page, the caller must supply a correct parent block
		 * number.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>parentblkno</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no parent buffer provided of child %d"</literal></expr></argument>, <argument><expr><name>childblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <operator>*</operator><name>parentblkno</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indexrel</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gistcheckpage</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>indexrel</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if it was not moved */</comment>
	<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <operator>*</operator><name>parentblkno</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>parentblkno</name> <operator>!=</operator> <name>InvalidBlockNumber</name> <operator>&amp;&amp;</operator>
		<operator>*</operator><name>downlinkoffnum</name> <operator>!=</operator> <name>InvalidOffsetNumber</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>downlinkoffnum</name> <operator>&lt;=</operator> <name>maxoff</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>*</operator><name>downlinkoffnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxtuple</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>childblkno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Still there */</comment>
			<return>return <expr><name>buffer</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Downlink was not at the offset where it used to be. Scan the page to
	 * find it. During normal gist insertions, it might've moved to another
	 * page, to the right, but during a buffering build, we keep track of the
	 * parent of each page in the lookup table so we should always know what
	 * page it's on.
	 */</comment>
	<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>off</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>off</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxtuple</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>childblkno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* yes!!, found it */</comment>
			<expr_stmt><expr><operator>*</operator><name>downlinkoffnum</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
			<return>return <expr><name>buffer</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to re-find parent for block %u"</literal></expr></argument>, <argument><expr><name>childblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>InvalidBuffer</name></expr>;</return>		<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Process buffers emptying stack. Emptying of one buffer can cause emptying
 * of other buffers. This function iterates until this cascading emptying
 * process finished, e.g. until buffers emptying stack is empty.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistProcessEmptyingQueue</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name> <init>= <expr><name><name>buildstate</name><operator>-&gt;</operator><name>gfbb</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Iterate while we have elements in buffers emptying stack. */</comment>
	<while>while <condition>(<expr><name><name>gfbb</name><operator>-&gt;</operator><name>bufferEmptyingQueue</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>emptyingNodeBuffer</name></decl>;</decl_stmt>

		<comment type="block">/* Get node buffer from emptying stack. */</comment>
		<expr_stmt><expr><name>emptyingNodeBuffer</name> <operator>=</operator> <operator>(</operator><name>GISTNodeBuffer</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>bufferEmptyingQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>bufferEmptyingQueue</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>bufferEmptyingQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>emptyingNodeBuffer</name><operator>-&gt;</operator><name>queuedForEmptying</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We are going to load last pages of buffers where emptying will be
		 * to. So let's unload any previously loaded buffers.
		 */</comment>
		<expr_stmt><expr><call><name>gistUnloadNodeBuffers</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Pop tuples from the buffer and run them down to the buffers at
		 * lower level, or leaf pages. We continue until one of the lower
		 * level buffers fills up, or this buffer runs empty.
		 *
		 * In Arge et al's paper, the buffer emptying is stopped after
		 * processing 1/2 node buffer worth of tuples, to avoid overfilling
		 * any of the lower level buffers. However, it's more efficient to
		 * keep going until one of the lower level buffers actually fills up,
		 * so that's what we do. This doesn't need to be exact, if a buffer
		 * overfills by a few tuples, there's no harm done.
		 */</comment>
		<while>while <condition>(<expr><name>true</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

			<comment type="block">/* Get next index tuple from the buffer */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gistPopItupFromNodeBuffer</name><argument_list>(<argument><expr><name>gfbb</name></expr></argument>, <argument><expr><name>emptyingNodeBuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>itup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Run it down to the underlying node buffer or leaf page.
			 *
			 * Note: it's possible that the buffer we're emptying splits as a
			 * result of this call. If that happens, our emptyingNodeBuffer
			 * points to the left half of the split. After split, it's very
			 * likely that the new left buffer is no longer over the half-full
			 * threshold, but we might as well keep flushing tuples from it
			 * until we fill a lower-level buffer.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>gistProcessItup</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name>itup</name></expr></argument>, <argument><expr><name><name>emptyingNodeBuffer</name><operator>-&gt;</operator><name>nodeBlocknum</name></name></expr></argument>, <argument><expr><name><name>emptyingNodeBuffer</name><operator>-&gt;</operator><name>level</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * A lower level buffer filled up. Stop emptying this buffer,
				 * to avoid overflowing the lower level buffer.
				 */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Free all the memory allocated during index tuple processing */</comment>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Empty all node buffers, from top to bottom. This is done at the end of
 * index build to flush all remaining tuples to the index.
 *
 * Note: This destroys the buffersOnLevels lists, so the buffers should not
 * be inserted to after this call.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistEmptyAllBuffers</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTBuildBuffers</name> <modifier>*</modifier></type><name>gfbb</name> <init>= <expr><name><name>buildstate</name><operator>-&gt;</operator><name>gfbb</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldCtx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Iterate through the levels from top to bottom.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevelsLen</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Empty all buffers on this level. Note that new buffers can pop up
		 * in the list during the processing, as a result of page splits, so a
		 * simple walk through the list won't work. We remove buffers from the
		 * list when we see them empty; a buffer can't become non-empty once
		 * it's been fully emptied.
		 */</comment>
		<while>while <condition>(<expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GISTNodeBuffer</name> <modifier>*</modifier></type><name>nodeBuffer</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>nodeBuffer</name> <operator>=</operator> <operator>(</operator><name>GISTNodeBuffer</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>blocksCount</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Add this buffer to the emptying queue, and proceed to empty
				 * the queue.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nodeBuffer</name><operator>-&gt;</operator><name>queuedForEmptying</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>nodeBuffer</name><operator>-&gt;</operator><name>queuedForEmptying</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>bufferEmptyingQueue</name></name> <operator>=</operator>
						<call><name>lcons</name><argument_list>(<argument><expr><name>nodeBuffer</name></expr></argument>, <argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>bufferEmptyingQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>gistProcessEmptyingQueue</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
					<call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>gfbb</name><operator>-&gt;</operator><name>buffersOnLevels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"emptied all buffers at level %d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the depth of the GiST index.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gistGetMaxLevel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxLevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Traverse down the tree, starting from the root, until we hit the leaf
	 * level.
	 */</comment>
	<expr_stmt><expr><name>maxLevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <name>GIST_ROOT_BLKNO</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>itup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * There's no concurrent access during index build, so locking is just
		 * pro forma.
		 */</comment>
		<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>(</operator><name>Page</name><operator>)</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We hit the bottom, so we're done. */</comment>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Pick the first downlink on the page, and follow it. It doesn't
		 * matter which downlink we choose, the tree has the same depth
		 * everywhere, so we just pick the first one.
		 */</comment>
		<expr_stmt><expr><name>itup</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>,
										<argument><expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>itup</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We're going down on the tree. It means that there is yet one more
		 * level in the tree.
		 */</comment>
		<expr_stmt><expr><name>maxLevel</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>maxLevel</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Routines for managing the parent map.
 *
 * Whenever a page is split, we need to insert the downlinks into the parent.
 * We need to somehow find the parent page to do that. In normal insertions,
 * we keep a stack of nodes visited when we descend the tree. However, in
 * buffering build, we can start descending the tree from any internal node,
 * when we empty a buffer by cascading tuples to its children. So we don't
 * have a full stack up to the root available at that time.
 *
 * So instead, we maintain a hash table to track the parent of every internal
 * page. We don't need to track the parents of leaf nodes, however. Whenever
 * we insert to a leaf, we've just descended down from its parent, so we know
 * its immediate parent already. This helps a lot to limit the memory used
 * by this hash table.
 *
 * Whenever an internal node is split, the parent map needs to be updated.
 * the parent of the new child page needs to be recorded, and also the
 * entries for all page whose downlinks are moved to a new page at the split
 * needs to be updated.
 *
 * We also update the parent map whenever we descend the tree. That might seem
 * unnecessary, because we maintain the map whenever a downlink is moved or
 * created, but it is needed because we switch to buffering mode after
 * creating a tree with regular index inserts. Any pages created before
 * switching to buffering mode will not be present in the parent map initially,
 * but will be added there the first time we visit them.
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>childblkno</name></decl>;</decl_stmt>		<comment type="block">/* hash key */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>parentblkno</name></decl>;</decl_stmt>
}</block></struct></type> <name>ParentMapEntry</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistInitParentMap</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hashCtl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>hashCtl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BlockNumber</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashCtl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParentMapEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashCtl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buildstate</name><operator>-&gt;</operator><name>parentMap</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"gistbuild parent map"</literal></expr></argument>,
										<argument><expr><literal type="number">1024</literal></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>hashCtl</name></expr></argument>,
										<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistMemorizeParent</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>child</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParentMapEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>ParentMapEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>parentMap</name></name></expr></argument>,
										   <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>child</name></expr></argument>,
										   <argument><expr><name>HASH_ENTER</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>parentblkno</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Scan all downlinks on a page, and memorize their parent.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistMemorizeAllDownlinks</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>parentbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>parentblkno</name> <init>= <expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>parentbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>parentbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>off</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>off</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>idxtuple</name> <init>= <expr><operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>childblkno</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>idxtuple</name><operator>-&gt;</operator><name>t_tid</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>gistMemorizeParent</name><argument_list>(<argument><expr><name>buildstate</name></expr></argument>, <argument><expr><name>childblkno</name></expr></argument>, <argument><expr><name>parentblkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>gistGetParent</name><parameter_list>(<parameter><decl><type><name>GISTBuildState</name> <modifier>*</modifier></type><name>buildstate</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>child</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParentMapEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* Find node buffer in hash table */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>ParentMapEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>buildstate</name><operator>-&gt;</operator><name>parentMap</name></name></expr></argument>,
										   <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>child</name></expr></argument>,
										   <argument><expr><name>HASH_FIND</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find parent of block %d in lookup table"</literal></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>parentblkno</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
