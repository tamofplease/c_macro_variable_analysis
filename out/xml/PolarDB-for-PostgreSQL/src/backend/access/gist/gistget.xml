<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/access/gist/gistget.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gistget.c
 *	  fetch tuples from a GiST scan.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/access/gist/gistget.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gist_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/pairingheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>


<comment type="block">/*
 * gistkillitems() -- set LP_DEAD state for items an indexscan caller has
 * told us were killed.
 *
 * We re-read page here, so it's important to check page LSN. If the page
 * has been modified since the last read (as determined by LSN), we cannot
 * flag any entries because it is possible that the old entry was vacuumed
 * away and the TID was re-used by a completely different heap tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistkillitems</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GISTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>killedsomething</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>curBlkno</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>curPageLSN</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>killedItems</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>curBlkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BufferIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gistcheckpage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If page LSN differs it means that the page was modified since the last
	 * read. killedItems could be not valid so LP_DEAD hints applying is not
	 * safe.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufferGetLSNAtomic</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>so</name><operator>-&gt;</operator><name>curPageLSN</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* reset counter */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark all killedItems as dead. We need no additional recheck, because,
	 * if page was modified, pageLSN must have changed.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>offnum</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>killedItems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iid</name> <operator>=</operator> <call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ItemIdMarkDead</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>killedsomething</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>killedsomething</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GistMarkPageHasGarbage</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MarkBufferDirtyHint</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Always reset the scan state, so we don't look for same items on other
	 * pages.
	 */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * gistindex_keytest() -- does this index tuple satisfy the scan key(s)?
 *
 * The index tuple might represent either a heap tuple or a lower index page,
 * depending on whether the containing page is a leaf page or not.
 *
 * On success return for a heap tuple, *recheck_p is set to indicate whether
 * the quals need to be rechecked.  We recheck if any of the consistent()
 * functions request it.  recheck is not interesting when examining a non-leaf
 * entry, since we must visit the lower index page if there's any doubt.
 * Similarly, *recheck_distances_p is set to indicate whether the distances
 * need to be rechecked, and it is also ignored for non-leaf entries.
 *
 * If we are doing an ordered scan, so-&gt;distances[] is filled with distance
 * data from the distance() functions before returning success.
 *
 * We must decompress the key in the IndexTuple before passing it to the
 * sk_funcs (which actually are the opclass Consistent or Distance methods).
 *
 * Note that this function is always invoked in a short-lived memory context,
 * so we don't need to worry about cleaning up allocated memory, either here
 * or in the implementation of any Consistent or Distance methods.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gistindex_keytest</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>,
				  <parameter><decl><type><name>IndexTuple</name></type> <name>tuple</name></decl></parameter>,
				  <parameter><decl><type><name>Page</name></type> <name>page</name></decl></parameter>,
				  <parameter><decl><type><name>OffsetNumber</name></type> <name>offset</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>recheck_p</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>recheck_distances_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GISTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTSTATE</name>  <modifier>*</modifier></type><name>giststate</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>giststate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKey</name></type>		<name>key</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>keyData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keySize</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfKeys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexOrderByDistance</name> <modifier>*</modifier></type><name>distance_p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>r</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
    
	<expr_stmt><expr><operator>*</operator><name>recheck_p</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>recheck_distances_p</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a leftover invalid tuple from pre-9.1, treat it as a match with
	 * minimum possible distances.  This means we'll always follow it to the
	 * referenced page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GistTupleIsInvalid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid GiST tuple found on leaf page"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <operator>-</operator><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check whether it matches according to the Consistent functions */</comment>
	<while>while <condition>(<expr><name>keySize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>,
							  <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * On non-leaf page we can't conclude that child hasn't NULL
			 * values because of assumption in GiST: union (VAL, NULL) is VAL.
			 * But if on non-leaf page key IS NULL, then all children are
			 * NULL.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_SEARCHNOTNULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>test</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>recheck</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GISTENTRY</name></type>	<name>de</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>gistdentryinit</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>,
						   <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Call the Consistent function to evaluate the test.  The
			 * arguments are the index datum (as a GISTENTRY*), the comparison
			 * datum, the comparison operator's strategy number and subtype
			 * from pg_amop, and the recheck flag.
			 *
			 * (Presently there's no need to pass the subtype since it'll
			 * always be zero, but might as well pass it for possible future
			 * use.)
			 *
			 * We initialize the recheck flag to true (the safest assumption)
			 * in case the Consistent function forgets to set it.
			 */</comment>
			<expr_stmt><expr><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>FunctionCall5Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>,
									<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
									<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>,
									<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>recheck</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>		
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>    
            
			<expr_stmt><expr><operator>*</operator><name>recheck_p</name> <operator>|=</operator> <name>recheck</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>key</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>keySize</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* OK, it passes --- now let's compute the distances */</comment>
	<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>orderByData</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>distance_p</name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>distances</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>keySize</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>keySize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>index_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name></expr></argument>,
							  <argument><expr><name><name>giststate</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>sk_flags</name></name> <operator>&amp;</operator> <name>SK_ISNULL</name><operator>)</operator> <operator>||</operator> <name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Assume distance computes as null */</comment>
			<expr_stmt><expr><name><name>distance_p</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>distance_p</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>dist</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>recheck</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>GISTENTRY</name></type>	<name>de</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>gistdentryinit</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_attno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>,
						   <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
						   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Call the Distance function to evaluate the distance.  The
			 * arguments are the index datum (as a GISTENTRY*), the comparison
			 * datum, the ordering operator's strategy number and subtype from
			 * pg_amop, and the recheck flag.
			 *
			 * (Presently there's no need to pass the subtype since it'll
			 * always be zero, but might as well pass it for possible future
			 * use.)
			 *
			 * If the function sets the recheck flag, the returned distance is
			 * a lower bound on the true distance and needs to be rechecked.
			 * We initialize the flag to 'false'.  This flag was added in
			 * version 9.5; distance functions written before that won't know
			 * about the flag, but are expected to never be lossy.
			 */</comment>
			<expr_stmt><expr><name>recheck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>FunctionCall5Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>sk_func</name></name></expr></argument>,
									 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_collation</name></name></expr></argument>,
									 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_argument</name></name></expr></argument>,
									 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_strategy</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>sk_subtype</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>recheck</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>recheck_distances_p</name> <operator>|=</operator> <name>recheck</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>distance_p</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>distance_p</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>key</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>distance_p</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>keySize</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Scan all items on the GiST index page identified by *pageItem, and insert
 * them into the queue (or directly to output areas)
 *
 * scan: index scan we are executing
 * pageItem: search queue item identifying an index page to scan
 * myDistances: distances array associated with pageItem, or NULL at the root
 * tbm: if not NULL, gistgetbitmap's output bitmap
 * ntids: if not NULL, gistgetbitmap's output tuple counter
 *
 * If tbm/ntids aren't NULL, we are doing an amgetbitmap scan, and heap
 * tuples should be reported directly into the bitmap.  If they are NULL,
 * we're doing a plain or ordered indexscan.  For a plain indexscan, heap
 * tuple TIDs are returned into so-&gt;pageData[].  For an ordered indexscan,
 * heap tuple TIDs are pushed into individual search queue items.  In an
 * index-only scan, reconstructed index tuples are returned along with the
 * TIDs.
 *
 * If we detect that the index page has split since we saw its downlink
 * in the parent, we push its new right sibling onto the queue so the
 * sibling will be processed next.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gistScanPage</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>GISTSearchItem</name> <modifier>*</modifier></type><name>pageItem</name></decl></parameter>,
			 <parameter><decl><type><name>IndexOrderByDistance</name> <modifier>*</modifier></type><name>myDistances</name></decl></parameter>, <parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>ntids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GISTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTSTATE</name>  <modifier>*</modifier></type><name>giststate</name> <init>= <expr><name><name>so</name><operator>-&gt;</operator><name>giststate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>r</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Buffer</name></type>		<name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type>		<name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTPageOpaque</name></type> <name>opaque</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>maxoff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GISTSearchItemIsHeap</name><argument_list>(<argument><expr><operator>*</operator><name>pageItem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name><name>pageItem</name><operator>-&gt;</operator><name>blkno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GIST_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PredicateLockPage</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gistcheckpage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TestForOldSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_snapshot</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>opaque</name> <operator>=</operator> <call><name>GistPageGetOpaque</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check if we need to follow the rightlink. We need to follow it if the
	 * page was concurrently split since we visited the parent (in which case
	 * parentlsn &lt; nsn), or if the system crashed after a page split but
	 * before the downlink was inserted into the parent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>XLogRecPtrIsInvalid</name><argument_list>(<argument><expr><name><name>pageItem</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>parentlsn</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>GistFollowRight</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <name><name>pageItem</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>parentlsn</name></name> <operator>&lt;</operator> <call><name>GistPageGetNSN</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>opaque</name><operator>-&gt;</operator><name>rightlink</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr> <comment type="block">/* sanity check */</comment> )</condition>
	<block>{<block_content>
		<comment type="block">/* There was a page split, follow right link to add pages */</comment>
		<decl_stmt><decl><type><name>GISTSearchItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

		<comment type="block">/* This can't happen when starting at the root */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>myDistances</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>queueCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create new GISTSearchItem for the right sibling index page */</comment>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>SizeOfGISTSearchItem</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name><name>opaque</name><operator>-&gt;</operator><name>rightlink</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>parentlsn</name></name> <operator>=</operator> <name><name>pageItem</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>parentlsn</name></name></expr>;</expr_stmt>

		<comment type="block">/* Insert it into the queue using same distances as for this page */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>distances</name></name></expr></argument>, <argument><expr><name>myDistances</name></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>distances</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>phNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>nPageData</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* might point into pageDataCxt */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>pageDataCxt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>pageDataCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We save the LSN of the page as we read it, so that we know whether it
	 * safe to apply LP_DEAD hints to the page later. This allows us to drop
	 * the pin for MVCC scans, which allows vacuum to avoid blocking.
	 */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>curPageLSN</name></name> <operator>=</operator> <call><name>BufferGetLSNAtomic</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * check all tuples on page
	 */</comment>
	<expr_stmt><expr><name>maxoff</name> <operator>=</operator> <call><name>PageGetMaxOffsetNumber</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstOffsetNumber</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxoff</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name>OffsetNumberNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemId</name></type>		<name>iid</name> <init>= <expr><call><name>PageGetItemId</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexTuple</name></type>	<name>it</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>match</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>recheck</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>recheck_distances</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the scan specifies not to return killed tuples, then we treat a
		 * killed tuple as not passing the qual.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>ignore_killed_tuples</name></name> <operator>&amp;&amp;</operator> <call><name>ItemIdIsDead</name><argument_list>(<argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>it</name> <operator>=</operator> <operator>(</operator><name>IndexTuple</name><operator>)</operator> <call><name>PageGetItem</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>iid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Must call gistindex_keytest in tempCxt, and clean up any leftover
		 * junk afterward.
		 */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>gistindex_keytest</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>it</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>recheck</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recheck_distances</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>giststate</name><operator>-&gt;</operator><name>tempCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Ignore tuple if it doesn't match */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>tbm</name> <operator>&amp;&amp;</operator> <call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * getbitmap scan, so just push heap tuple TIDs into the bitmap
			 * without worrying about ordering
			 */</comment>
			<expr_stmt><expr><call><name>tbm_add_tuples</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>recheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>ntids</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Non-ordered scan, so report tuples in so-&gt;pageData[]
			 */</comment>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>pageData</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPageData</name></name></expr>]</index></name><operator>.</operator><name>heapPtr</name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>pageData</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPageData</name></name></expr>]</index></name><operator>.</operator><name>recheck</name> <operator>=</operator> <name>recheck</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>pageData</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPageData</name></name></expr>]</index></name><operator>.</operator><name>offnum</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * In an index-only scan, also fetch the data from the tuple.  The
			 * reconstructed tuples are stored in pageDataCxt.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>pageDataCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>pageData</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>nPageData</name></name></expr>]</index></name><operator>.</operator><name>recontup</name> <operator>=</operator>
					<call><name>gistFetchTuple</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>nPageData</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Must push item into search queue.  We get here for any lower
			 * index page, and also for heap tuples if doing an ordered
			 * search.
			 */</comment>
			<decl_stmt><decl><type><name>GISTSearchItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nOrderBys</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>queueCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Create new GISTSearchItem for this item */</comment>
			<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>SizeOfGISTSearchItem</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>GistPageIsLeaf</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Creating heap-tuple GISTSearchItem */</comment>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>heap</name><operator>.</operator><name>heapPtr</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>t_tid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>heap</name><operator>.</operator><name>recheck</name></name> <operator>=</operator> <name>recheck</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>heap</name><operator>.</operator><name>recheckDistances</name></name> <operator>=</operator> <name>recheck_distances</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * In an index-only scan, also fetch the data from the tuple.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>heap</name><operator>.</operator><name>recontup</name></name> <operator>=</operator> <call><name>gistFetchTuple</name><argument_list>(<argument><expr><name>giststate</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Creating index-page GISTSearchItem */</comment>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>blkno</name></name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>t_tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * LSN of current page is lsn of parent page for child. We
				 * only have a shared lock, so we need to get the LSN
				 * atomically.
				 */</comment>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>parentlsn</name></name> <operator>=</operator> <call><name>BufferGetLSNAtomic</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Insert it into the queue using new distance data */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>distances</name></name></expr></argument>, <argument><expr><name><name>so</name><operator>-&gt;</operator><name>distances</name></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>distances</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nOrderBys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pairingheap_add</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>phNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Extract next item (in order) from search queue
 *
 * Returns a GISTSearchItem or NULL.  Caller must pfree item when done with it.
 */</comment>
<function><type><specifier>static</specifier> <name>GISTSearchItem</name> <modifier>*</modifier></type>
<name>getNextGISTSearchItem</name><parameter_list>(<parameter><decl><type><name>GISTScanOpaque</name></type> <name>so</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTSearchItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pairingheap_is_empty</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>GISTSearchItem</name> <operator>*</operator><operator>)</operator> <call><name>pairingheap_remove_first</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Done when both heaps are empty */</comment>
		<expr_stmt><expr><name>item</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Return item; caller is responsible to pfree it */</comment>
	<return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch next heap tuple in an ordered search
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>getNextNearest</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GISTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* free previously returned tuple */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>GISTSearchItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>getNextGISTSearchItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GISTSearchItemIsHeap</name><argument_list>(<argument><expr><operator>*</operator><name>item</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* found a heap item at currently minimal distance */</comment>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>heap</name><operator>.</operator><name>heapPtr</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_recheck</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>heap</name><operator>.</operator><name>recheck</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_recheckorderby</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>heap</name><operator>.</operator><name>recheckDistances</name></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>orderByTypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>FLOAT8OID</name></expr>)</condition>
				<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_FLOAT8_BYVAL</name></cpp:ifndef>
					<comment type="block">/* must free any old value to avoid memory leakage */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbynulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbyvals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbyvals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbynulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>orderByTypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>FLOAT4OID</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* convert distance function's result to ORDER BY type */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_FLOAT4_BYVAL</name></cpp:ifndef>
					<comment type="block">/* must free any old value to avoid memory leakage */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbynulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbyvals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbyvals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbynulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>distances</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * If the ordering operator's return value is anything
					 * else, we don't know how to convert the float8 bound
					 * calculated by the distance function to that.  The
					 * executor won't actually need the order by values we
					 * return here, if there are no lossy results, so only
					 * insist on converting if the *recheck flag is set.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_recheckorderby</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GiST operator family's FOR ORDER BY operator must return float8 or float4 if the distance function is lossy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_orderbynulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/* in an index-only scan, also return the reconstructed tuple. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>heap</name><operator>.</operator><name>recontup</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* visit an index page, extract its items into queue */</comment>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>gistScanPage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>distances</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition>;</do>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * gistgettuple() -- Get the next tuple in the scan
 */</comment>
<function><type><name>bool</name></type>
<name>gistgettuple</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GISTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>!=</operator> <name>ForwardScanDirection</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GiST only supports forward scan direction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>firstCall</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Begin the scan by processing the root page */</comment>
		<decl_stmt><decl><type><name>GISTSearchItem</name></type> <name>fakeItem</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pgstat_count_index_scan</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>firstCall</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>nPageData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>pageDataCxt</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>pageDataCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>fakeItem</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name>GIST_ROOT_BLKNO</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fakeItem</name><operator>.</operator><name>data</name><operator>.</operator><name>parentlsn</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GistNSN</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>gistScanPage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fakeItem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>numberOfOrderBys</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must fetch tuples in strict distance order */</comment>
		<return>return <expr><call><name>getNextNearest</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Fetch tuples index-page-at-a-time */</comment>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name> <operator>&lt;</operator> <name><name>so</name><operator>-&gt;</operator><name>nPageData</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>kill_prior_tuple</name></name> <operator>&amp;&amp;</operator> <name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>

					<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>killedItems</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name> <init>=
						<expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>giststate</name><operator>-&gt;</operator><name>scanCxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>killedItems</name></name> <operator>=</operator>
							<operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MaxIndexTuplesPerPage</name>
													<operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>&lt;</operator> <name>MaxIndexTuplesPerPage</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>killedItems</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator>
							<name><name>so</name><operator>-&gt;</operator><name>pageData</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* continuing to return tuples from a leaf page */</comment>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_ctup</name><operator>.</operator><name>t_self</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>pageData</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name></expr>]</index></name><operator>.</operator><name>heapPtr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_recheck</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>pageData</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name></expr>]</index></name><operator>.</operator><name>recheck</name></expr>;</expr_stmt>

				<comment type="block">/* in an index-only scan, also return the reconstructed tuple */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>xs_want_itup</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>pageData</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name></expr>]</index></name><operator>.</operator><name>recontup</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name><operator>++</operator></expr>;</expr_stmt>

				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Check the last returned tuple and add it to killitems if
			 * necessary
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>kill_prior_tuple</name></name>
				<operator>&amp;&amp;</operator> <name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
				<operator>&amp;&amp;</operator> <name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name> <operator>==</operator> <name><name>so</name><operator>-&gt;</operator><name>nPageData</name></name></expr>)</condition>
			<block>{<block_content>

				<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>killedItems</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name> <init>=
					<expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>giststate</name><operator>-&gt;</operator><name>scanCxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>killedItems</name></name> <operator>=</operator>
						<operator>(</operator><name>OffsetNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MaxIndexTuplesPerPage</name>
												<operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>&lt;</operator> <name>MaxIndexTuplesPerPage</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>killedItems</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator>
						<name><name>so</name><operator>-&gt;</operator><name>pageData</name><index>[<expr><name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>offnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* find and process the next index page */</comment>
			<do>do
			<block>{<block_content>
				<decl_stmt><decl><type><name>GISTSearchItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>curBlkno</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>so</name><operator>-&gt;</operator><name>numKilled</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>gistkillitems</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>getNextGISTSearchItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* save current item BlockNumber for next gistkillitems() call */</comment>
				<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>curBlkno</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>blkno</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * While scanning a leaf page, ItemPointers of matching heap
				 * tuples are stored in so-&gt;pageData.  If there are any on
				 * this page, we fall out of the inner "do" and loop around to
				 * return them.
				 */</comment>
				<expr_stmt><expr><call><name>gistScanPage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>distances</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>nPageData</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * gistgetbitmap() -- Get a bitmap of all heap tuple locations
 */</comment>
<function><type><name>int64</name></type>
<name>gistgetbitmap</name><parameter_list>(<parameter><decl><type><name>IndexScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GISTScanOpaque</name></type> <name>so</name> <init>= <expr><operator>(</operator><name>GISTScanOpaque</name><operator>)</operator> <name><name>scan</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>ntids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GISTSearchItem</name></type> <name>fakeItem</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>so</name><operator>-&gt;</operator><name>qual_ok</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_count_index_scan</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>indexRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Begin the scan by processing the root page */</comment>
	<expr_stmt><expr><name><name>so</name><operator>-&gt;</operator><name>curPageData</name></name> <operator>=</operator> <name><name>so</name><operator>-&gt;</operator><name>nPageData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>xs_hitup</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>so</name><operator>-&gt;</operator><name>pageDataCxt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>so</name><operator>-&gt;</operator><name>pageDataCxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>fakeItem</name><operator>.</operator><name>blkno</name></name> <operator>=</operator> <name>GIST_ROOT_BLKNO</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fakeItem</name><operator>.</operator><name>data</name><operator>.</operator><name>parentlsn</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GistNSN</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gistScanPage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fakeItem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * While scanning a leaf page, ItemPointers of matching heap tuples will
	 * be stored directly into tbm, so we don't need to deal with them here.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GISTSearchItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>getNextGISTSearchItem</name><argument_list>(<argument><expr><name>so</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>gistScanPage</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>distances</name></name></expr></argument>, <argument><expr><name>tbm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>ntids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Can we do index-only scans on the given index column?
 *
 * Opclasses that implement a fetch function support index-only scans.
 * Opclasses without compression functions also support index-only scans.
 */</comment>
<function><type><name>bool</name></type>
<name>gistcanreturn</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>index_getprocid</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>GIST_FETCH_PROC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>index_getprocid</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><name>GIST_COMPRESS_PROC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
